#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CARendering

#include "Basic.hpp"

#include "ProceduralMeshComponent_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "CARendering_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class CARendering.CAMeshBlock
// 0x0060 (0x0090 - 0x0030)
class UCAMeshBlock final : public UObject
{
public:
	TArray<struct FVector>                        M_positions;                                       // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        M_normals;                                         // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      M_uv0s;                                            // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_indices;                                         // 0x0060(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FProcMeshTangent>               M_tangents;                                        // 0x0070(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FColor>                         M_vertex_colours;                                  // 0x0080(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Reset();

	int32 GetIndexCount() const;
	int32 GetVertexCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAMeshBlock">();
	}
	static class UCAMeshBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAMeshBlock>();
	}
};
static_assert(alignof(UCAMeshBlock) == 0x000008, "Wrong alignment on UCAMeshBlock");
static_assert(sizeof(UCAMeshBlock) == 0x000090, "Wrong size on UCAMeshBlock");
static_assert(offsetof(UCAMeshBlock, M_positions) == 0x000030, "Member 'UCAMeshBlock::M_positions' has a wrong offset!");
static_assert(offsetof(UCAMeshBlock, M_normals) == 0x000040, "Member 'UCAMeshBlock::M_normals' has a wrong offset!");
static_assert(offsetof(UCAMeshBlock, M_uv0s) == 0x000050, "Member 'UCAMeshBlock::M_uv0s' has a wrong offset!");
static_assert(offsetof(UCAMeshBlock, M_indices) == 0x000060, "Member 'UCAMeshBlock::M_indices' has a wrong offset!");
static_assert(offsetof(UCAMeshBlock, M_tangents) == 0x000070, "Member 'UCAMeshBlock::M_tangents' has a wrong offset!");
static_assert(offsetof(UCAMeshBlock, M_vertex_colours) == 0x000080, "Member 'UCAMeshBlock::M_vertex_colours' has a wrong offset!");

// Class CARendering.CAOutlineSettings
// 0x0068 (0x00A0 - 0x0038)
class UCAOutlineSettings final : public UDataAsset
{
public:
	TMap<ECAOutlineColor, struct FColor>          M_color_map;                                       // 0x0038(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         M_min_width;                                       // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_width;                                       // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_width_distance;                              // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0xC];                                       // 0x0094(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAOutlineSettings">();
	}
	static class UCAOutlineSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAOutlineSettings>();
	}
};
static_assert(alignof(UCAOutlineSettings) == 0x000008, "Wrong alignment on UCAOutlineSettings");
static_assert(sizeof(UCAOutlineSettings) == 0x0000A0, "Wrong size on UCAOutlineSettings");
static_assert(offsetof(UCAOutlineSettings, M_color_map) == 0x000038, "Member 'UCAOutlineSettings::M_color_map' has a wrong offset!");
static_assert(offsetof(UCAOutlineSettings, M_min_width) == 0x000088, "Member 'UCAOutlineSettings::M_min_width' has a wrong offset!");
static_assert(offsetof(UCAOutlineSettings, M_max_width) == 0x00008C, "Member 'UCAOutlineSettings::M_max_width' has a wrong offset!");
static_assert(offsetof(UCAOutlineSettings, M_min_width_distance) == 0x000090, "Member 'UCAOutlineSettings::M_min_width_distance' has a wrong offset!");

// Class CARendering.CARenderingLibrary
// 0x0000 (0x0030 - 0x0030)
class UCARenderingLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AppendMeshBlock(const class UCAMeshBlock* Src_mesh_block, class UCAMeshBlock* Dst_mesh_block, const struct FVector& Translation);
	static void ApplyLightmapType(class UStaticMeshComponent* Mesh_component, ELightmapType Lightmap_type);
	static void ApplyOverridenLightmapDensity(class UStaticMeshComponent* Mesh_component, int32 Lightmap_resolution);
	static class UTexture2D* CACreateRuntimeTexture(int32 Width, int32 Height, EPixelFormat Format, bool Use_mips);
	static float CalculateAreaFromStaticMesh(class UStaticMesh* Mesh);
	static void ClearHighlightingOutline(class UPrimitiveComponent* Primitive);
	static class UStaticMesh* ExportMeshBlockToStaticMesh(const class FString& User_package_name, class FName Mesh_name, const TArray<class UCAMeshBlock*>& Mesh_blocks, const TArray<class UMaterialInterface*>& Materials);
	static class UStaticMesh* ExportProceduralMeshComponentToStaticMesh(const class FString& User_package_name, class FName Mesh_name, class UProceduralMeshComponent* Procedural_mesh_component, const TArray<class UMaterialInterface*>& Materials);
	static class UCAMeshBlock* ExtractMeshBlockFromStaticMesh(class UStaticMesh* Mesh, int32 Lod_index, int32 Section_index);
	static class UCAMeshBlock* ExtractMeshBlockFromStaticMeshByMaterial(class UStaticMesh* Mesh, int32 Lod_index, int32 Material_index);
	static class UCAMeshBlock* ExtractMeshBlockFromStaticMeshByMaterialTransformed(class UStaticMesh* Mesh, int32 Lod_index, int32 Material_index, const struct FTransform& Transform);
	static class UCAMeshBlock* ExtractMeshBlockFromStaticMeshTransformed(class UStaticMesh* Mesh, int32 Lod_index, int32 Section_index, const struct FTransform& Transform);
	static void SetHighlightingOutlineRenderingEnabled(bool Enabled);
	static void SetRenderHighlightingOutline(bool Enabled, class UPrimitiveComponent* Primitive, ECAOutlineMode Mode, ECAOutlineColor Color);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CARenderingLibrary">();
	}
	static class UCARenderingLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCARenderingLibrary>();
	}
};
static_assert(alignof(UCARenderingLibrary) == 0x000008, "Wrong alignment on UCARenderingLibrary");
static_assert(sizeof(UCARenderingLibrary) == 0x000030, "Wrong size on UCARenderingLibrary");

}

