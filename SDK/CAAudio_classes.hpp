#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CAAudio

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "CAAudio_structs.hpp"
#include "Engine_classes.hpp"
#include "PhysicsCore_structs.hpp"


namespace SDK
{

// Class CAAudio.CAAudioAmbientComponent
// 0x0030 (0x0280 - 0x0250)
class UCAAudioAmbientComponent final : public USceneComponent
{
public:
	struct FCAAudioEventType                      Event;                                             // 0x0248(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Ambient_group;                                     // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          begin_on;                                          // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_multiemitter;                                  // 0x0261(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable_portalling;                                 // 0x0262(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_263[0x1D];                                     // 0x0263(0x001D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartAmbientComponent();
	void StopAmbientComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAAudioAmbientComponent">();
	}
	static class UCAAudioAmbientComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAAudioAmbientComponent>();
	}
};
static_assert(alignof(UCAAudioAmbientComponent) == 0x000010, "Wrong alignment on UCAAudioAmbientComponent");
static_assert(sizeof(UCAAudioAmbientComponent) == 0x000280, "Wrong size on UCAAudioAmbientComponent");
static_assert(offsetof(UCAAudioAmbientComponent, Event) == 0x000248, "Member 'UCAAudioAmbientComponent::Event' has a wrong offset!");
static_assert(offsetof(UCAAudioAmbientComponent, Ambient_group) == 0x000250, "Member 'UCAAudioAmbientComponent::Ambient_group' has a wrong offset!");
static_assert(offsetof(UCAAudioAmbientComponent, begin_on) == 0x000260, "Member 'UCAAudioAmbientComponent::begin_on' has a wrong offset!");
static_assert(offsetof(UCAAudioAmbientComponent, Use_multiemitter) == 0x000261, "Member 'UCAAudioAmbientComponent::Use_multiemitter' has a wrong offset!");
static_assert(offsetof(UCAAudioAmbientComponent, Enable_portalling) == 0x000262, "Member 'UCAAudioAmbientComponent::Enable_portalling' has a wrong offset!");

// Class CAAudio.CAAudioAmbientObject
// 0x0008 (0x0260 - 0x0258)
class ACAAudioAmbientObject final : public AActor
{
public:
	class UCAAudioAmbientComponent*               Ambient_component;                                 // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAAudioAmbientObject">();
	}
	static class ACAAudioAmbientObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACAAudioAmbientObject>();
	}
};
static_assert(alignof(ACAAudioAmbientObject) == 0x000008, "Wrong alignment on ACAAudioAmbientObject");
static_assert(sizeof(ACAAudioAmbientObject) == 0x000260, "Wrong size on ACAAudioAmbientObject");
static_assert(offsetof(ACAAudioAmbientObject, Ambient_component) == 0x000258, "Member 'ACAAudioAmbientObject::Ambient_component' has a wrong offset!");

// Class CAAudio.AnimNotify_CAAudioEvent
// 0x0010 (0x0050 - 0x0040)
class UAnimNotify_CAAudioEvent final : public UAnimNotify
{
public:
	struct FCAAudioEventType                      Event;                                             // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	ECAAudioAnimNotify_Perspective                ActorPerspective;                                  // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistance;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_CAAudioEvent">();
	}
	static class UAnimNotify_CAAudioEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_CAAudioEvent>();
	}
};
static_assert(alignof(UAnimNotify_CAAudioEvent) == 0x000008, "Wrong alignment on UAnimNotify_CAAudioEvent");
static_assert(sizeof(UAnimNotify_CAAudioEvent) == 0x000050, "Wrong size on UAnimNotify_CAAudioEvent");
static_assert(offsetof(UAnimNotify_CAAudioEvent, Event) == 0x000040, "Member 'UAnimNotify_CAAudioEvent::Event' has a wrong offset!");
static_assert(offsetof(UAnimNotify_CAAudioEvent, ActorPerspective) == 0x000044, "Member 'UAnimNotify_CAAudioEvent::ActorPerspective' has a wrong offset!");
static_assert(offsetof(UAnimNotify_CAAudioEvent, MaxDistance) == 0x000048, "Member 'UAnimNotify_CAAudioEvent::MaxDistance' has a wrong offset!");

// Class CAAudio.CAAudioBank
// 0x0008 (0x0038 - 0x0030)
class UCAAudioBank final : public UObject
{
public:
	bool                                          M_auto_load;                                       // 0x0030(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_async_load;                                      // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_unload_on_destroy;                               // 0x0032(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Load(ECAAudioBankScope Scope);
	void UnLoad();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAAudioBank">();
	}
	static class UCAAudioBank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAAudioBank>();
	}
};
static_assert(alignof(UCAAudioBank) == 0x000008, "Wrong alignment on UCAAudioBank");
static_assert(sizeof(UCAAudioBank) == 0x000038, "Wrong size on UCAAudioBank");
static_assert(offsetof(UCAAudioBank, M_auto_load) == 0x000030, "Member 'UCAAudioBank::M_auto_load' has a wrong offset!");
static_assert(offsetof(UCAAudioBank, M_async_load) == 0x000031, "Member 'UCAAudioBank::M_async_load' has a wrong offset!");
static_assert(offsetof(UCAAudioBank, M_unload_on_destroy) == 0x000032, "Member 'UCAAudioBank::M_unload_on_destroy' has a wrong offset!");

// Class CAAudio.CAAudioBankLoader
// 0x0010 (0x0268 - 0x0258)
class ACAAudioBankLoader final : public AActor
{
public:
	TArray<TSoftObjectPtr<class UCAAudioBank>>    M_banks;                                           // 0x0258(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAAudioBankLoader">();
	}
	static class ACAAudioBankLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACAAudioBankLoader>();
	}
};
static_assert(alignof(ACAAudioBankLoader) == 0x000008, "Wrong alignment on ACAAudioBankLoader");
static_assert(sizeof(ACAAudioBankLoader) == 0x000268, "Wrong size on ACAAudioBankLoader");
static_assert(offsetof(ACAAudioBankLoader, M_banks) == 0x000258, "Member 'ACAAudioBankLoader::M_banks' has a wrong offset!");

// Class CAAudio.CAAudioBeamComponent
// 0x0030 (0x0280 - 0x0250)
class UCAAudioBeamComponent final : public USceneComponent
{
public:
	struct FCAAudioEventType                      M_event;                                           // 0x0248(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_threshold;                                       // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_listener;                                    // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x2F];                                     // 0x0251(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetRTPC(const struct FCAAudioRTPCNameType& Rtpc_name, const float Value, const float Change_duration, const float Threshold);
	void SetSwitch(const struct FCAAudioSwitchNameType& Switch_name, const struct FCAAudioSwitchValueType& Switch_value);
	void Start(const struct FVector& Start_0, const struct FVector& End);
	void Stop(int32 Fade_out_ms);
	void UpdateBeamPosition(const struct FVector& Start, const struct FVector& End);
	void UpdateSourcePosition(const struct FVector& Source);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAAudioBeamComponent">();
	}
	static class UCAAudioBeamComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAAudioBeamComponent>();
	}
};
static_assert(alignof(UCAAudioBeamComponent) == 0x000010, "Wrong alignment on UCAAudioBeamComponent");
static_assert(sizeof(UCAAudioBeamComponent) == 0x000280, "Wrong size on UCAAudioBeamComponent");
static_assert(offsetof(UCAAudioBeamComponent, M_event) == 0x000248, "Member 'UCAAudioBeamComponent::M_event' has a wrong offset!");
static_assert(offsetof(UCAAudioBeamComponent, M_threshold) == 0x00024C, "Member 'UCAAudioBeamComponent::M_threshold' has a wrong offset!");
static_assert(offsetof(UCAAudioBeamComponent, M_use_listener) == 0x000250, "Member 'UCAAudioBeamComponent::M_use_listener' has a wrong offset!");

// Class CAAudio.CAAudioBlueprintFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UCAAudioBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 BeginTrackingRTPC(const struct FCAAudioRTPCNameType& Rtpc_name, const struct FCAAudioPlaybackInstance& Instance);
	static bool CompareHashIsEqual(const struct FCAAudioHashBase& A, const struct FCAAudioHashBase& b);
	static void EndTrackingRTPC(const int32 Tracking_id);
	static void GetEventInfo(const struct FCAAudioEventType& Event, float* Max_attenuation, float* Max_duration, bool* Is_3D, bool* Is_localised);
	static void GetMaterialAudio(const EPhysicalSurface Surface, struct FCAAudioSwitchValueType* Switch_value, struct FCAAudioBankNameType* Footstep_bank_name);
	static void GetObjectInfo(const class UCAAudioComponent* Component, const class AActor* Actor, bool* Is_playing, bool* Is_audible, bool* Is_3D, float* Radius, float* Distance_to_listener);
	static float GetTrackedRTPC(const int32 Tracking_id);
	static void HandleFootstep(class AActor* Actor, const struct FCAAudioSwitchValueType& Material_switch, const struct FCAAudioBankNameType& Material_bank, float Max_distance);
	static void IsBankLoaded(const struct FCAAudioBankNameType& bank_name, bool* Loaded, bool* Loading);
	static bool IsInAudibleRange(class AActor* Actor, float Max_distance);
	static void IsPlaybackFinished(const struct FCAAudioPlaybackInstance& Playback_instance, bool* Result);
	static void LoadBank(const struct FCAAudioBankNameType& bank_name, const ECAAudioMemoryPool Memory_pool, bool Async_load);
	static void PlayAmbientGroup(const class FString& Group_name);
	static void PlayDynamicEvent(const struct FCAAudioEventType& Event, const TArray<class FString>& Arguments, class UCAAudioComponent* Component, class AActor* Actor, const TDelegate<void(const struct FCAAudioEventType& Event_name)>& On_finished, struct FCAAudioPlaybackInstance* Playback_instance, bool* Play_success, const bool Stop_when_destroyed, const bool Ignore_out_of_range_oneshot, const bool Manage_loop, const bool Ignore_errors);
	static void PlayEvent(const struct FCAAudioEventType& Event, class UCAAudioComponent* Component, class AActor* Actor, const TDelegate<void(const struct FCAAudioEventType& Event_name)>& On_finished, struct FCAAudioPlaybackInstance* Playback_instance, bool* Play_success, const bool Stop_when_destroyed, const bool Ignore_out_of_range_oneshot, const bool Manage_loop, const bool Ignore_errors, const bool Single_instance);
	static void PlayEventInWorld(const struct FCAAudioEventType& Event, const struct FVector& Location, const struct FCAAudioSwitchNameType& Switch_name, const struct FCAAudioSwitchValueType& Switch_value, const struct FCAAudioRTPCNameType& Rtpc_name, const float Rtpc_value, struct FCAAudioPlaybackInstance* Playback_instance, bool* Play_success, const bool Ignore_out_of_range_oneshot);
	static void PlayPortalledEventInWorld(const struct FCAAudioEventType& Event, const struct FVector& Location, const struct FCAAudioSwitchNameType& Switch_name, const struct FCAAudioSwitchValueType& Switch_value, const struct FCAAudioRTPCNameType& Rtpc_name, const float Rtpc_value, struct FCAAudioPlaybackInstance* Playback_instance, bool* Play_success, const bool Ignore_out_of_range_oneshot, const bool Use_occluded_source);
	static void PlayWhizzBy(const struct FCAAudioEventType& Event, const struct FVector& Projectile_start, const struct FVector& Projectile_end, const float Max_end_distance, const float Trigger_distance, const float Ignore_distance);
	static void RequestDynamicDialogue(const struct FCAAudioEventType& Event, const TArray<class FString>& Arguments, class UCAAudioComponent* Component, class AActor* Actor, const struct FVector& Position, const TDelegate<void(const struct FCAAudioEventType& Event_name)>& On_finished, bool Is_streamed, float Max_queue_time, ECAAudioDialoguePriority Priority, bool Interrupt_equal_priority);
	static void RequestExternalDialogue(const struct FCAAudioEventType& Event, const class FString& Filename, const struct FCAAudioSwitchValueType& Projection, class UCAAudioComponent* Component, class AActor* Actor, const struct FVector& Position, const TDelegate<void(const struct FCAAudioEventType& Event_name)>& On_finished, const class FString& Target, bool Is_streamed, float Max_queue_time, ECAAudioDialoguePriority Priority, bool Interrupt_equal_priority);
	static void RequestSingleDialogue(const struct FCAAudioEventType& Event, class UCAAudioComponent* Component, class AActor* Actor, const TDelegate<void(const struct FCAAudioEventType& Event_name)>& On_finished, bool Is_streamed, float Max_queue_time, ECAAudioDialoguePriority Priority, bool Interrupt_equal_priority);
	static void SetPlaybackWorldPosition(const struct FCAAudioPlaybackInstance& Playback_instance, const struct FVector& Position);
	static void SetRTPC(class UCAAudioComponent* Component, class AActor* Actor, const struct FCAAudioRTPCNameType& Rtpc_name, const float Value, bool Global, const float Change_duration, const float Threshold);
	static void SetState(const struct FCAAudioStateNameType& State_name, const struct FCAAudioStateValueType& State_value);
	static void SetSwitch(class UCAAudioComponent* Component, class AActor* Actor, const struct FCAAudioSwitchNameType& Switch_name, const struct FCAAudioSwitchValueType& Switch_value);
	static void SimplePlayEvent(const struct FCAAudioEventType& Event, class AActor* Actor, const bool Stop_when_destroyed, const bool Ignore_out_of_range_oneshot);
	static void StopAmbientGroup(const class FString& Group_name, const int32 Fade_out_ms);
	static void StopEventByInstance(const struct FCAAudioPlaybackInstance& Playback_instance, const int32 Fade_out_ms);
	static void StopEventByName(const struct FCAAudioEventType& Event, const class UCAAudioComponent* Component, const class AActor* Actor, const int32 Fade_out_ms);
	static void StopObject(class UCAAudioComponent* Component, class AActor* Actor, const int32 Fade_out_ms);
	static void StringToEvent(const class FString& String, struct FCAAudioEventType* Event);
	static void StringToRTPCName(const class FString& String, struct FCAAudioRTPCNameType* Rtpc_name);
	static void StringToStateName(const class FString& String, struct FCAAudioStateNameType* State_name);
	static void StringToStateValue(const class FString& String, struct FCAAudioStateValueType* State_value);
	static void StringToSwitchName(const class FString& String, struct FCAAudioSwitchNameType* Switch_name);
	static void StringToSwitchValue(const class FString& String, struct FCAAudioSwitchValueType* Switch_value);
	static void UnloadBank(const struct FCAAudioBankNameType& bank_name, const bool Force_unload);

	void CompletionDelegate__DelegateSignature(const struct FCAAudioEventType& Event_name);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAAudioBlueprintFunctionLibrary">();
	}
	static class UCAAudioBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAAudioBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UCAAudioBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UCAAudioBlueprintFunctionLibrary");
static_assert(sizeof(UCAAudioBlueprintFunctionLibrary) == 0x000030, "Wrong size on UCAAudioBlueprintFunctionLibrary");

// Class CAAudio.CAAudioComponent
// 0x0080 (0x02D0 - 0x0250)
class UCAAudioComponent final : public USceneComponent
{
public:
	uint8                                         Pad_248[0x58];                                     // 0x0248(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_allow_portalling;                                // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_allow_occluded_source;                           // 0x02A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_allow_early_reflections;                         // 0x02A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A3[0x5];                                      // 0x02A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_early_reflection_bus;                            // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UCAAudioBank>>    M_banks;                                           // 0x02B8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAAudioComponent">();
	}
	static class UCAAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAAudioComponent>();
	}
};
static_assert(alignof(UCAAudioComponent) == 0x000010, "Wrong alignment on UCAAudioComponent");
static_assert(sizeof(UCAAudioComponent) == 0x0002D0, "Wrong size on UCAAudioComponent");
static_assert(offsetof(UCAAudioComponent, M_allow_portalling) == 0x0002A0, "Member 'UCAAudioComponent::M_allow_portalling' has a wrong offset!");
static_assert(offsetof(UCAAudioComponent, M_allow_occluded_source) == 0x0002A1, "Member 'UCAAudioComponent::M_allow_occluded_source' has a wrong offset!");
static_assert(offsetof(UCAAudioComponent, M_allow_early_reflections) == 0x0002A2, "Member 'UCAAudioComponent::M_allow_early_reflections' has a wrong offset!");
static_assert(offsetof(UCAAudioComponent, M_early_reflection_bus) == 0x0002A8, "Member 'UCAAudioComponent::M_early_reflection_bus' has a wrong offset!");
static_assert(offsetof(UCAAudioComponent, M_banks) == 0x0002B8, "Member 'UCAAudioComponent::M_banks' has a wrong offset!");

// Class CAAudio.CAAudioListenerComponent
// 0x0020 (0x0270 - 0x0250)
class UCAAudioListenerComponent final : public USceneComponent
{
public:
	uint8                                         Pad_248[0x28];                                     // 0x0248(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAAudioListenerComponent">();
	}
	static class UCAAudioListenerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAAudioListenerComponent>();
	}
};
static_assert(alignof(UCAAudioListenerComponent) == 0x000010, "Wrong alignment on UCAAudioListenerComponent");
static_assert(sizeof(UCAAudioListenerComponent) == 0x000270, "Wrong size on UCAAudioListenerComponent");

// Class CAAudio.CAAudioMultiObjectComponent
// 0x0020 (0x0270 - 0x0250)
class UCAAudioMultiObjectComponent final : public USceneComponent
{
public:
	class FString                                 Emitter_name;                                      // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x18];                                     // 0x0258(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterEmitter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAAudioMultiObjectComponent">();
	}
	static class UCAAudioMultiObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAAudioMultiObjectComponent>();
	}
};
static_assert(alignof(UCAAudioMultiObjectComponent) == 0x000010, "Wrong alignment on UCAAudioMultiObjectComponent");
static_assert(sizeof(UCAAudioMultiObjectComponent) == 0x000270, "Wrong size on UCAAudioMultiObjectComponent");
static_assert(offsetof(UCAAudioMultiObjectComponent, Emitter_name) == 0x000248, "Member 'UCAAudioMultiObjectComponent::Emitter_name' has a wrong offset!");

// Class CAAudio.CAAudioMultiObjectBlueprintFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UCAAudioMultiObjectBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddMultiObjectArea(class AActor* Area, const class FString& Area_name);
	static void PlayOnMultiObject(const struct FCAAudioEventType& Event, const class FString& Emitter_name, const class FString& Group_name, struct FCAAudioPlaybackInstance* Playback_instance);
	static void SetRTPCOnMultiObject(const struct FCAAudioSwitchNameType& Rtpc_name, float Rtpc_value, const class FString& Emitter_name, const class FString& Group_name);
	static void SetSwitchOnMultiObject(const struct FCAAudioSwitchNameType& Switch_name, const struct FCAAudioSwitchValueType& Switch_value, const class FString& Emitter_name, const class FString& Group_name);
	static void StopMultiObject(const class FString& Emitter_name, const class FString& Group_name);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAAudioMultiObjectBlueprintFunctionLibrary">();
	}
	static class UCAAudioMultiObjectBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAAudioMultiObjectBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UCAAudioMultiObjectBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UCAAudioMultiObjectBlueprintFunctionLibrary");
static_assert(sizeof(UCAAudioMultiObjectBlueprintFunctionLibrary) == 0x000030, "Wrong size on UCAAudioMultiObjectBlueprintFunctionLibrary");

// Class CAAudio.CAAudioSpatialLinkComponent
// 0x0070 (0x02C0 - 0x0250)
class UCAAudioSpatialLinkComponent final : public USceneComponent
{
public:
	FMulticastInlineDelegateProperty_             OpenAmountChangeEvent;                             // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         M_open_amount;                                     // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_can_be_orphaned;                                 // 0x025C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELinkType                                     M_link_type;                                       // 0x025D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_generate_samples;                                // 0x025E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_actor_extents;                               // 0x025F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_caspr_name;                                      // 0x0260(0x0010)(Edit, ZeroConstructor, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x50];                                     // 0x0270(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetOpenAmount();
	void SetOpenAmount(float Amount, float Min, float Max);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAAudioSpatialLinkComponent">();
	}
	static class UCAAudioSpatialLinkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAAudioSpatialLinkComponent>();
	}
};
static_assert(alignof(UCAAudioSpatialLinkComponent) == 0x000010, "Wrong alignment on UCAAudioSpatialLinkComponent");
static_assert(sizeof(UCAAudioSpatialLinkComponent) == 0x0002C0, "Wrong size on UCAAudioSpatialLinkComponent");
static_assert(offsetof(UCAAudioSpatialLinkComponent, OpenAmountChangeEvent) == 0x000248, "Member 'UCAAudioSpatialLinkComponent::OpenAmountChangeEvent' has a wrong offset!");
static_assert(offsetof(UCAAudioSpatialLinkComponent, M_open_amount) == 0x000258, "Member 'UCAAudioSpatialLinkComponent::M_open_amount' has a wrong offset!");
static_assert(offsetof(UCAAudioSpatialLinkComponent, M_can_be_orphaned) == 0x00025C, "Member 'UCAAudioSpatialLinkComponent::M_can_be_orphaned' has a wrong offset!");
static_assert(offsetof(UCAAudioSpatialLinkComponent, M_link_type) == 0x00025D, "Member 'UCAAudioSpatialLinkComponent::M_link_type' has a wrong offset!");
static_assert(offsetof(UCAAudioSpatialLinkComponent, M_generate_samples) == 0x00025E, "Member 'UCAAudioSpatialLinkComponent::M_generate_samples' has a wrong offset!");
static_assert(offsetof(UCAAudioSpatialLinkComponent, M_use_actor_extents) == 0x00025F, "Member 'UCAAudioSpatialLinkComponent::M_use_actor_extents' has a wrong offset!");
static_assert(offsetof(UCAAudioSpatialLinkComponent, M_caspr_name) == 0x000260, "Member 'UCAAudioSpatialLinkComponent::M_caspr_name' has a wrong offset!");

// Class CAAudio.CAAudioSpatialLinkObject
// 0x0008 (0x0260 - 0x0258)
class ACAAudioSpatialLinkObject final : public AActor
{
public:
	class UCAAudioSpatialLinkComponent*           Link_component;                                    // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAAudioSpatialLinkObject">();
	}
	static class ACAAudioSpatialLinkObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACAAudioSpatialLinkObject>();
	}
};
static_assert(alignof(ACAAudioSpatialLinkObject) == 0x000008, "Wrong alignment on ACAAudioSpatialLinkObject");
static_assert(sizeof(ACAAudioSpatialLinkObject) == 0x000260, "Wrong size on ACAAudioSpatialLinkObject");
static_assert(offsetof(ACAAudioSpatialLinkObject, Link_component) == 0x000258, "Member 'ACAAudioSpatialLinkObject::Link_component' has a wrong offset!");

// Class CAAudio.CAAudioSpatialNode
// 0x0000 (0x0258 - 0x0258)
class ACAAudioSpatialNode final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAAudioSpatialNode">();
	}
	static class ACAAudioSpatialNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACAAudioSpatialNode>();
	}
};
static_assert(alignof(ACAAudioSpatialNode) == 0x000008, "Wrong alignment on ACAAudioSpatialNode");
static_assert(sizeof(ACAAudioSpatialNode) == 0x000258, "Wrong size on ACAAudioSpatialNode");

// Class CAAudio.CAAudioSpatialZoneMarker
// 0x0030 (0x0288 - 0x0258)
class ACAAudioSpatialZoneMarker final : public AActor
{
public:
	struct FCAAudioEventType                      M_ambience;                                        // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioStateValueType                 M_room_size;                                       // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioAuxBusType                     M_reverb;                                          // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioAuxBusType                     M_secondary_reverb;                                // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_secondary_reverb_amount;                         // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_heuristic_scalar;                                // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ground_spacing;                                  // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_air_spacing;                                     // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_sample_cap;                                      // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_patch_cap;                                       // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sample_weighting;                                // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EZoneType                                     M_zone_type;                                       // 0x0284(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EZonePatchType                                M_patch_type;                                      // 0x0285(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EZonePatchFidelity                            M_patch_fidelity;                                  // 0x0286(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_287[0x1];                                      // 0x0287(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAAudioSpatialZoneMarker">();
	}
	static class ACAAudioSpatialZoneMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACAAudioSpatialZoneMarker>();
	}
};
static_assert(alignof(ACAAudioSpatialZoneMarker) == 0x000008, "Wrong alignment on ACAAudioSpatialZoneMarker");
static_assert(sizeof(ACAAudioSpatialZoneMarker) == 0x000288, "Wrong size on ACAAudioSpatialZoneMarker");
static_assert(offsetof(ACAAudioSpatialZoneMarker, M_ambience) == 0x000258, "Member 'ACAAudioSpatialZoneMarker::M_ambience' has a wrong offset!");
static_assert(offsetof(ACAAudioSpatialZoneMarker, M_room_size) == 0x00025C, "Member 'ACAAudioSpatialZoneMarker::M_room_size' has a wrong offset!");
static_assert(offsetof(ACAAudioSpatialZoneMarker, M_reverb) == 0x000260, "Member 'ACAAudioSpatialZoneMarker::M_reverb' has a wrong offset!");
static_assert(offsetof(ACAAudioSpatialZoneMarker, M_secondary_reverb) == 0x000264, "Member 'ACAAudioSpatialZoneMarker::M_secondary_reverb' has a wrong offset!");
static_assert(offsetof(ACAAudioSpatialZoneMarker, M_secondary_reverb_amount) == 0x000268, "Member 'ACAAudioSpatialZoneMarker::M_secondary_reverb_amount' has a wrong offset!");
static_assert(offsetof(ACAAudioSpatialZoneMarker, M_heuristic_scalar) == 0x00026C, "Member 'ACAAudioSpatialZoneMarker::M_heuristic_scalar' has a wrong offset!");
static_assert(offsetof(ACAAudioSpatialZoneMarker, M_ground_spacing) == 0x000270, "Member 'ACAAudioSpatialZoneMarker::M_ground_spacing' has a wrong offset!");
static_assert(offsetof(ACAAudioSpatialZoneMarker, M_air_spacing) == 0x000274, "Member 'ACAAudioSpatialZoneMarker::M_air_spacing' has a wrong offset!");
static_assert(offsetof(ACAAudioSpatialZoneMarker, M_sample_cap) == 0x000278, "Member 'ACAAudioSpatialZoneMarker::M_sample_cap' has a wrong offset!");
static_assert(offsetof(ACAAudioSpatialZoneMarker, M_patch_cap) == 0x00027C, "Member 'ACAAudioSpatialZoneMarker::M_patch_cap' has a wrong offset!");
static_assert(offsetof(ACAAudioSpatialZoneMarker, M_sample_weighting) == 0x000280, "Member 'ACAAudioSpatialZoneMarker::M_sample_weighting' has a wrong offset!");
static_assert(offsetof(ACAAudioSpatialZoneMarker, M_zone_type) == 0x000284, "Member 'ACAAudioSpatialZoneMarker::M_zone_type' has a wrong offset!");
static_assert(offsetof(ACAAudioSpatialZoneMarker, M_patch_type) == 0x000285, "Member 'ACAAudioSpatialZoneMarker::M_patch_type' has a wrong offset!");
static_assert(offsetof(ACAAudioSpatialZoneMarker, M_patch_fidelity) == 0x000286, "Member 'ACAAudioSpatialZoneMarker::M_patch_fidelity' has a wrong offset!");

// Class CAAudio.CAAudioSpatialZoneModifier
// 0x0010 (0x0268 - 0x0258)
class ACAAudioSpatialZoneModifier final : public AActor
{
public:
	bool                                          M_allow_navmesh_auto_node_creation;                // 0x0258(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_generate_nodes;                                  // 0x0259(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25A[0x2];                                      // 0x025A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_node_spacing;                                    // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          M_shape_component;                                 // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAAudioSpatialZoneModifier">();
	}
	static class ACAAudioSpatialZoneModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACAAudioSpatialZoneModifier>();
	}
};
static_assert(alignof(ACAAudioSpatialZoneModifier) == 0x000008, "Wrong alignment on ACAAudioSpatialZoneModifier");
static_assert(sizeof(ACAAudioSpatialZoneModifier) == 0x000268, "Wrong size on ACAAudioSpatialZoneModifier");
static_assert(offsetof(ACAAudioSpatialZoneModifier, M_allow_navmesh_auto_node_creation) == 0x000258, "Member 'ACAAudioSpatialZoneModifier::M_allow_navmesh_auto_node_creation' has a wrong offset!");
static_assert(offsetof(ACAAudioSpatialZoneModifier, M_generate_nodes) == 0x000259, "Member 'ACAAudioSpatialZoneModifier::M_generate_nodes' has a wrong offset!");
static_assert(offsetof(ACAAudioSpatialZoneModifier, M_node_spacing) == 0x00025C, "Member 'ACAAudioSpatialZoneModifier::M_node_spacing' has a wrong offset!");
static_assert(offsetof(ACAAudioSpatialZoneModifier, M_shape_component) == 0x000260, "Member 'ACAAudioSpatialZoneModifier::M_shape_component' has a wrong offset!");

// Class CAAudio.CAAudioSpatialZoneRegion
// 0x0010 (0x0268 - 0x0258)
class ACAAudioSpatialZoneRegion final : public AActor
{
public:
	class UBoxComponent*                          M_shape_component;                                 // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_voxel_resolution;                                // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAAudioSpatialZoneRegion">();
	}
	static class ACAAudioSpatialZoneRegion* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACAAudioSpatialZoneRegion>();
	}
};
static_assert(alignof(ACAAudioSpatialZoneRegion) == 0x000008, "Wrong alignment on ACAAudioSpatialZoneRegion");
static_assert(sizeof(ACAAudioSpatialZoneRegion) == 0x000268, "Wrong size on ACAAudioSpatialZoneRegion");
static_assert(offsetof(ACAAudioSpatialZoneRegion, M_shape_component) == 0x000258, "Member 'ACAAudioSpatialZoneRegion::M_shape_component' has a wrong offset!");
static_assert(offsetof(ACAAudioSpatialZoneRegion, M_voxel_resolution) == 0x000260, "Member 'ACAAudioSpatialZoneRegion::M_voxel_resolution' has a wrong offset!");

// Class CAAudio.CASpatialAudioDataAsset
// 0x00B0 (0x00E8 - 0x0038)
class UCASpatialAudioDataAsset final : public UDataAsset
{
public:
	float                                         SourceLinkDeadZone;                                // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceLinkInnerRadius;                             // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceLinkOuterRadius;                             // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryDistanceScalarMax;                        // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryDistanceScalarMin;                        // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusFor2D;                                       // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveLinkOcclusion;                             // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxObstructionHeightScalar;                        // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxObstructionHeight;                              // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinObstructionHeight;                              // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinConnectedReverb;                                // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxConnectedReverb;                                // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinConnectedReverbPercent;                         // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxConnectedReverbPercent;                         // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinReverbFadeInDistance;                           // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxReverbFadeInDistance;                           // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinReverbAtDeadzone;                               // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReverbDeadzone;                                    // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLinkApertureSize;                               // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinkApertureSize;                               // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinOcclusionRTPCValue;                             // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOcclusionRTPCValue;                             // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinOcclusionDistance;                              // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOcclusionDistance;                              // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForcedUpdateTime;                                  // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxForcedUpdatePerTick;                            // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForcedMaxDistance;                                 // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAAudioOccludedSourceMap>      OccludedSourceEventMap;                            // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCASpatialAudioEarlyReflectionData     EarlyReflections;                                  // 0x00B8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CASpatialAudioDataAsset">();
	}
	static class UCASpatialAudioDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCASpatialAudioDataAsset>();
	}
};
static_assert(alignof(UCASpatialAudioDataAsset) == 0x000008, "Wrong alignment on UCASpatialAudioDataAsset");
static_assert(sizeof(UCASpatialAudioDataAsset) == 0x0000E8, "Wrong size on UCASpatialAudioDataAsset");
static_assert(offsetof(UCASpatialAudioDataAsset, SourceLinkDeadZone) == 0x000038, "Member 'UCASpatialAudioDataAsset::SourceLinkDeadZone' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, SourceLinkInnerRadius) == 0x00003C, "Member 'UCASpatialAudioDataAsset::SourceLinkInnerRadius' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, SourceLinkOuterRadius) == 0x000040, "Member 'UCASpatialAudioDataAsset::SourceLinkOuterRadius' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, SecondaryDistanceScalarMax) == 0x000044, "Member 'UCASpatialAudioDataAsset::SecondaryDistanceScalarMax' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, SecondaryDistanceScalarMin) == 0x000048, "Member 'UCASpatialAudioDataAsset::SecondaryDistanceScalarMin' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, RadiusFor2D) == 0x00004C, "Member 'UCASpatialAudioDataAsset::RadiusFor2D' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, AdditiveLinkOcclusion) == 0x000050, "Member 'UCASpatialAudioDataAsset::AdditiveLinkOcclusion' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, MaxObstructionHeightScalar) == 0x000054, "Member 'UCASpatialAudioDataAsset::MaxObstructionHeightScalar' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, MaxObstructionHeight) == 0x000058, "Member 'UCASpatialAudioDataAsset::MaxObstructionHeight' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, MinObstructionHeight) == 0x00005C, "Member 'UCASpatialAudioDataAsset::MinObstructionHeight' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, MinConnectedReverb) == 0x000060, "Member 'UCASpatialAudioDataAsset::MinConnectedReverb' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, MaxConnectedReverb) == 0x000064, "Member 'UCASpatialAudioDataAsset::MaxConnectedReverb' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, MinConnectedReverbPercent) == 0x000068, "Member 'UCASpatialAudioDataAsset::MinConnectedReverbPercent' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, MaxConnectedReverbPercent) == 0x00006C, "Member 'UCASpatialAudioDataAsset::MaxConnectedReverbPercent' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, MinReverbFadeInDistance) == 0x000070, "Member 'UCASpatialAudioDataAsset::MinReverbFadeInDistance' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, MaxReverbFadeInDistance) == 0x000074, "Member 'UCASpatialAudioDataAsset::MaxReverbFadeInDistance' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, MinReverbAtDeadzone) == 0x000078, "Member 'UCASpatialAudioDataAsset::MinReverbAtDeadzone' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, ReverbDeadzone) == 0x00007C, "Member 'UCASpatialAudioDataAsset::ReverbDeadzone' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, MinLinkApertureSize) == 0x000080, "Member 'UCASpatialAudioDataAsset::MinLinkApertureSize' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, MaxLinkApertureSize) == 0x000084, "Member 'UCASpatialAudioDataAsset::MaxLinkApertureSize' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, MinOcclusionRTPCValue) == 0x000088, "Member 'UCASpatialAudioDataAsset::MinOcclusionRTPCValue' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, MaxOcclusionRTPCValue) == 0x00008C, "Member 'UCASpatialAudioDataAsset::MaxOcclusionRTPCValue' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, MinOcclusionDistance) == 0x000090, "Member 'UCASpatialAudioDataAsset::MinOcclusionDistance' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, MaxOcclusionDistance) == 0x000094, "Member 'UCASpatialAudioDataAsset::MaxOcclusionDistance' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, ForcedUpdateTime) == 0x000098, "Member 'UCASpatialAudioDataAsset::ForcedUpdateTime' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, MaxForcedUpdatePerTick) == 0x00009C, "Member 'UCASpatialAudioDataAsset::MaxForcedUpdatePerTick' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, ForcedMaxDistance) == 0x0000A0, "Member 'UCASpatialAudioDataAsset::ForcedMaxDistance' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, OccludedSourceEventMap) == 0x0000A8, "Member 'UCASpatialAudioDataAsset::OccludedSourceEventMap' has a wrong offset!");
static_assert(offsetof(UCASpatialAudioDataAsset, EarlyReflections) == 0x0000B8, "Member 'UCASpatialAudioDataAsset::EarlyReflections' has a wrong offset!");

// Class CAAudio.CASPrRuntimeData
// 0x0010 (0x0048 - 0x0038)
class UCASPrRuntimeData final : public UDataAsset
{
public:
	TArray<uint8>                                 Data;                                              // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CASPrRuntimeData">();
	}
	static class UCASPrRuntimeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCASPrRuntimeData>();
	}
};
static_assert(alignof(UCASPrRuntimeData) == 0x000008, "Wrong alignment on UCASPrRuntimeData");
static_assert(sizeof(UCASPrRuntimeData) == 0x000048, "Wrong size on UCASPrRuntimeData");
static_assert(offsetof(UCASPrRuntimeData, Data) == 0x000038, "Member 'UCASPrRuntimeData::Data' has a wrong offset!");

// Class CAAudio.CASPrVoxelData
// 0x0010 (0x0048 - 0x0038)
class UCASPrVoxelData final : public UDataAsset
{
public:
	TArray<uint8>                                 Data;                                              // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CASPrVoxelData">();
	}
	static class UCASPrVoxelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCASPrVoxelData>();
	}
};
static_assert(alignof(UCASPrVoxelData) == 0x000008, "Wrong alignment on UCASPrVoxelData");
static_assert(sizeof(UCASPrVoxelData) == 0x000048, "Wrong size on UCASPrVoxelData");
static_assert(offsetof(UCASPrVoxelData, Data) == 0x000038, "Member 'UCASPrVoxelData::Data' has a wrong offset!");

// Class CAAudio.CASPrPointDataInterface
// 0x0020 (0x0050 - 0x0030)
class UCASPrPointDataInterface final : public UObject
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetNext(struct FVector* Point, float* Weight, int32* Zone_id);
	bool GetZoneInfo(const struct FVector& Position, int32* Zone_id, TArray<int32>* Connected_zones);
	int64 PrepareIterator(ECASPrPointType Position_type, int32 Voxel_step, int32 Sample_step);
	void ResetNext();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CASPrPointDataInterface">();
	}
	static class UCASPrPointDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCASPrPointDataInterface>();
	}
};
static_assert(alignof(UCASPrPointDataInterface) == 0x000008, "Wrong alignment on UCASPrPointDataInterface");
static_assert(sizeof(UCASPrPointDataInterface) == 0x000050, "Wrong size on UCASPrPointDataInterface");

// Class CAAudio.CASPrBlueprintFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UCASPrBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AreInSameCASPrZone(const struct FVector& First, const struct FVector& Second);
	static bool GetCASPrZoneInfo(const class AActor* Object, int32* Id, EZoneType* Type, struct FCAAudioStateValueType* Size, float* Volume);
	static bool GetCASPrZoneInfoFromID(int32 Id, EZoneType* Type, struct FCAAudioStateValueType* Size, float* Volume);
	static bool GetCASPrZoneInfoFromLocation(const struct FVector& Pos, int32* Id, EZoneType* Type, struct FCAAudioStateValueType* Size, float* Volume);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CASPrBlueprintFunctionLibrary">();
	}
	static class UCASPrBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCASPrBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UCASPrBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UCASPrBlueprintFunctionLibrary");
static_assert(sizeof(UCASPrBlueprintFunctionLibrary) == 0x000030, "Wrong size on UCASPrBlueprintFunctionLibrary");

}

