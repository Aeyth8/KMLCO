#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Keaton

#include "Basic.hpp"

#include "CALocalisationRuntime_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "CAAudio_structs.hpp"
#include "CAGameDatabase_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "AIModule_structs.hpp"
#include "CAUIEvents_structs.hpp"
#include "AnimationCore_structs.hpp"
#include "SlateCore_structs.hpp"
#include "CARendering_structs.hpp"
#include "InputCore_structs.hpp"


namespace SDK
{

// Enum keaton.EBodyPart
// NumValues: 0x0007
enum class EBodyPart : uint8
{
	None                                     = 0,
	Head                                     = 1,
	Body                                     = 2,
	Arms                                     = 3,
	Legs                                     = 4,
	Max                                      = 5,
	EBodyPart_MAX                            = 6,
};

// Enum keaton.ECAWeaponClass
// NumValues: 0x001B
enum class ECAWeaponClass : uint8
{
	Unknown                                  = 0,
	Pistol                                   = 1,
	Rifle                                    = 2,
	SMG                                      = 3,
	Sniper                                   = 4,
	Shotgun                                  = 5,
	Laser                                    = 6,
	Explosive                                = 7,
	Fire                                     = 8,
	Melee                                    = 9,
	BankRobber_Turret                        = 10,
	Dragqueen_Shield                         = 11,
	Captain_Rocket                           = 12,
	Energy_Rifle                             = 13,
	Energy_Shotgun                           = 14,
	Energy_Turret                            = 15,
	Energy_Rocket                            = 16,
	Energy_Pistol                            = 17,
	Energy_SMG                               = 18,
	NPC_Melee                                = 19,
	Tank_Melee                               = 20,
	Tripwire                                 = 21,
	FloorLava                                = 22,
	LetsHaveBBQ                              = 23,
	UnstableReaction                         = 24,
	Max                                      = 25,
	ECAWeaponClass_MAX                       = 26,
};

// Enum keaton.ECAPlayerMovementMetaMode
// NumValues: 0x0010
enum class ECAPlayerMovementMetaMode : uint8
{
	UNDEFINED                                = 0,
	NPC                                      = 1,
	Loco                                     = 2,
	Sprint                                   = 3,
	Crouch                                   = 4,
	Slide                                    = 5,
	Fall                                     = 6,
	Jump                                     = 7,
	ZeroG                                    = 8,
	Traverse                                 = 9,
	MagBoots                                 = 10,
	MagBoots_Sprint                          = 11,
	FreeCam                                  = 12,
	Downed                                   = 13,
	Blocked                                  = 14,
	MAX                                      = 15,
};

// Enum keaton.ECAPlayerAbilityMode
// NumValues: 0x0034
enum class ECAPlayerAbilityMode : uint8
{
	UNDEFINED                                = 0,
	NPC                                      = 1,
	Loco                                     = 2,
	Sprint                                   = 3,
	CrouchedLoco                             = 4,
	Slide                                    = 5,
	Fall                                     = 6,
	Jump                                     = 7,
	LowTraverse                              = 8,
	HighTraverse                             = 9,
	ZeroG_Attached                           = 10,
	ZeroG_TakeOff                            = 11,
	ZeroG_Flying                             = 12,
	ZeroG_GravHook                           = 13,
	MagBoots                                 = 14,
	MagBoots_Sprint                          = 15,
	MagBoots_Crouch                          = 16,
	MagBoots_Fall                            = 17,
	FreeCam                                  = 18,
	Downed                                   = 19,
	Heal                                     = 20,
	Revive                                   = 21,
	Freeze                                   = 22,
	Emote                                    = 23,
	Melee                                    = 24,
	Fire                                     = 25,
	ADS                                      = 26,
	Reload                                   = 27,
	Next_weapon                              = 28,
	Next_weapon_mode                         = 29,
	Use                                      = 30,
	UseDowned                                = 31,
	UseAnimated                              = 32,
	Gadget                                   = 33,
	GadgetB                                  = 34,
	GadgetThrown                             = 35,
	GadgetStatic                             = 36,
	Ability_No_Hands                         = 37,
	Ability_One_Hand                         = 38,
	Ability_Two_Hands                        = 39,
	Anim_Only                                = 40,
	Electrocuted                             = 41,
	Foamed                                   = 42,
	Map                                      = 43,
	Spray                                    = 44,
	MAX                                      = 45,
	NONE                                     = 0,
	FIRST_PRIMARY                            = 2,
	NUM_PRIMARY                              = 19,
	NUM_SUPPORTING_MOVEMENT_EXCEPTIONS       = 20,
	FIRST_SECONDARY                          = 19,
	NUM_SECONDARY                            = 26,
};

// Enum keaton.ECAPlayerMovementMode
// NumValues: 0x0027
enum class ECAPlayerMovementMode : uint8
{
	NONE                                     = 0,
	UNDEFINED                                = 0,
	NPC                                      = 2,
	Loco                                     = 17,
	Sprint                                   = 33,
	Crouch                                   = 49,
	Slide_Initial                            = 65,
	Slide_DecelerationPhase                  = 81,
	MagBoots                                 = 97,
	MagBoots_Crouch                          = 113,
	PossessingNPC                            = 129,
	MagBoots_Sprint                          = 145,
	Traverse_HorizontalConverge_OnFloor      = 161,
	Fall_Initial                             = 19,
	Short_Fall                               = 35,
	Long_Fall                                = 51,
	Jump_Ascending                           = 67,
	Jump_Descending                          = 83,
	Jump_Ascending_DT                        = 99,
	MagBoots_AttractToGround                 = 115,
	MagBoots_AttractToGround_CanJump         = 131,
	MagBoots_Falling                         = 147,
	ScriptControlledFlying                   = 5,
	ZeroG_Flying                             = 37,
	ZeroG_TakeOff                            = 53,
	ZeroG_Flying_SmallGap                    = 69,
	ZeroG_Attached                           = 85,
	ZeroG_Attached_Fall                      = 101,
	Downed_ZeroG                             = 117,
	ZeroG_TakeOff_Corner                     = 133,
	ZeroG_GravHook                           = 149,
	ZeroG_Attached_Corner                    = 38,
	Traverse_MantleRise                      = 54,
	Traverse_VaultRise                       = 70,
	Traverse_HorizontalConverge_FindFloor    = 86,
	FreeCam                                  = 165,
	ScriptControlledCustom                   = 6,
	BeingInteractedWith_Ground               = 246,
	MAX                                      = 255,
};

// Enum keaton.EHealthState
// NumValues: 0x0005
enum class EHealthState : uint8
{
	Healthy                                  = 0,
	Injured                                  = 1,
	Downed                                   = 2,
	Dead                                     = 3,
	EHealthState_MAX                         = 4,
};

// Enum keaton.EZeroGPushOffResult
// NumValues: 0x0006
enum class EZeroGPushOffResult : uint8
{
	Successful                               = 0,
	Successful_CornerVault                   = 1,
	Unsuccessful                             = 2,
	Unsuccessful_Blocked                     = 3,
	Invalid                                  = 4,
	EZeroGPushOffResult_MAX                  = 5,
};

// Enum keaton.ECASteeringUD
// NumValues: 0x0004
enum class ECASteeringUD : uint8
{
	SteeringUD_None                          = 0,
	SteeringUD_Up                            = 1,
	SteeringUD_Down                          = 2,
	SteeringUD_MAX                           = 3,
};

// Enum keaton.ECASteeringLR
// NumValues: 0x0004
enum class ECASteeringLR : uint8
{
	SteeringLR_None                          = 0,
	SteeringLR_Left                          = 1,
	SteeringLR_Right                         = 2,
	SteeringLR_MAX                           = 3,
};

// Enum keaton.ECAGravHookStateChange
// NumValues: 0x0008
enum class ECAGravHookStateChange : uint8
{
	RangeFailed                              = 0,
	LostLineOfSight                          = 1,
	RegainedLineOfSight                      = 2,
	CanceledByLostLOS                        = 3,
	CanceledByPlayer                         = 4,
	Broken                                   = 5,
	Completed                                = 6,
	ECAGravHookStateChange_MAX               = 7,
};

// Enum keaton.ECAAwarenessState
// NumValues: 0x0006
enum class ECAAwarenessState : uint8
{
	Unaware                                  = 0,
	Suspicious                               = 1,
	Combat                                   = 2,
	Combat_Search                            = 3,
	Unaware_Alerted                          = 4,
	ECAAwarenessState_MAX                    = 5,
};

// Enum keaton.ECANPCLevelOfDetail
// NumValues: 0x0004
enum class ECANPCLevelOfDetail : uint8
{
	NotLoDed                                 = 0,
	AIFullyLoDed                             = 1,
	NPCPooled                                = 2,
	ECANPCLevelOfDetail_MAX                  = 3,
};

// Enum keaton.ECAZeroGLocoState
// NumValues: 0x0004
enum class ECAZeroGLocoState : uint8
{
	None                                     = 0,
	Floating                                 = 1,
	Magboots                                 = 2,
	ECAZeroGLocoState_MAX                    = 3,
};

// Enum keaton.ECAActivityState
// NumValues: 0x0006
enum class ECAActivityState : uint8
{
	Inactive                                 = 0,
	Active                                   = 1,
	Paused                                   = 2,
	Succeeded                                = 3,
	Failed                                   = 4,
	ECAActivityState_MAX                     = 5,
};

// Enum keaton.EGameFlowPlayerState
// NumValues: 0x000A
enum class EGameFlowPlayerState : uint8
{
	InLimbo                                  = 0,
	InLobby                                  = 1,
	InLobbyPreMatchLoad                      = 2,
	InGameAlive                              = 3,
	InGameDead                               = 4,
	InGameDowned                             = 5,
	InResultsScreen                          = 6,
	InGameMissionFailed                      = 7,
	LeavingMatch                             = 8,
	EGameFlowPlayerState_MAX                 = 9,
};

// Enum keaton.ECAThresholdState
// NumValues: 0x0018
enum class ECAThresholdState : uint8
{
	None                                     = 0,
	Initialisation                           = 1,
	Looting                                  = 2,
	ThresholdReached                         = 3,
	AwaitingExtractionRequest                = 4,
	RequestingExtractionPoint                = 5,
	EnemyExtractionRequestInProgress         = 6,
	EnemyHasHigherScoreUnableToRequestExtraction = 7,
	WaitingForExtraction                     = 8,
	ExtractionAvailable                      = 9,
	ExtractionProgress                       = 10,
	ExtractionPausedEnemies                  = 11,
	ExtractionPausedCash                     = 12,
	Overtime                                 = 13,
	OvertimeContested                        = 14,
	Extracted                                = 15,
	EmergencyExtraction                      = 16,
	EnemyExtractionAvailable                 = 17,
	EnemyWaitingForExtraction                = 18,
	EmergencyExtractionProgress              = 19,
	EnemyEmergencyExtractionProgress         = 20,
	EnemyExtractionContesting                = 21,
	EnemyExtractionProgress                  = 22,
	MAX                                      = 23,
};

// Enum keaton.EPlayerMatchState
// NumValues: 0x000B
enum class EPlayerMatchState : uint8
{
	Waiting                                  = 0,
	Playing                                  = 1,
	Downed                                   = 2,
	Killed                                   = 3,
	Extracted                                = 4,
	Disconnect                               = 5,
	TimedOut                                 = 6,
	Wiped                                    = 7,
	Failed                                   = 8,
	Succeeded                                = 9,
	EPlayerMatchState_MAX                    = 10,
};

// Enum keaton.ECAGender
// NumValues: 0x0006
enum class ECAGender : uint8
{
	None                                     = 0,
	Male                                     = 1,
	Female                                   = 2,
	NonBinary                                = 4,
	Neuter                                   = 8,
	ECAGender_MAX                            = 9,
};

// Enum keaton.ECAUI_ExtractionPhase
// NumValues: 0x0005
enum class ECAUI_ExtractionPhase : uint8
{
	Default                                  = 0,
	MoreScoreRequired                        = 1,
	ExtractionContested                      = 2,
	Extracting                               = 3,
	ECAUI_MAX                                = 4,
};

// Enum keaton.EExtractionAreaState
// NumValues: 0x0009
enum class EExtractionAreaState : uint8
{
	NotEnabled                               = 0,
	NotOccupied                              = 1,
	Occupied                                 = 2,
	Capturing                                = 3,
	Decaying                                 = 4,
	Releasing                                = 5,
	Contested                                = 6,
	Complete                                 = 7,
	MAX                                      = 8,
};

// Enum keaton.ECAHUDSection
// NumValues: 0x0010
enum class ECAHUDSection : uint8
{
	None                                     = 0,
	MiniMap                                  = 1,
	PartyWidgetUI                            = 2,
	Timer                                    = 3,
	HealthItemSlots                          = 4,
	PlayerHealthAndArmor                     = 5,
	WeaponAndAmmunition                      = 6,
	GadgetSlots                              = 7,
	LootThreshold                            = 8,
	SpecialistAbility                        = 9,
	SelfReviveCooldown                       = 10,
	LootObjective                            = 11,
	LootScoreboard                           = 12,
	BreachingTool                            = 13,
	ZeroGBoostHint                           = 14,
	ECAHUDSection_MAX                        = 15,
};

// Enum keaton.EYMatchState
// NumValues: 0x0005
enum class EYMatchState : uint8
{
	NotStarted                               = 0,
	PreMatch                                 = 1,
	DuringMatch                              = 2,
	MatchEnded                               = 3,
	EYMatchState_MAX                         = 4,
};

// Enum keaton.ECARelativeTeamRanking
// NumValues: 0x0006
enum class ECARelativeTeamRanking : uint8
{
	WinningStrongly                          = 0,
	WinningSlightly                          = 1,
	LosingSlightly                           = 2,
	LosingBadly                              = 3,
	None                                     = 4,
	ECARelativeTeamRanking_MAX               = 5,
};

// Enum keaton.ECAMissionManagerVaultState
// NumValues: 0x0006
enum class ECAMissionManagerVaultState : uint8
{
	None                                     = 0,
	Closed                                   = 1,
	BeingHacked                              = 2,
	Open                                     = 3,
	Cleared                                  = 4,
	MAX                                      = 5,
};

// Enum keaton.ECAMissionManagerExtractionPointState
// NumValues: 0x0004
enum class ECAMissionManagerExtractionPointState : uint8
{
	None                                     = 0,
	Deactivated                              = 1,
	Activated                                = 2,
	ECAMissionManagerExtractionPointState_MAX = 3,
};

// Enum keaton.ECAFrontendCharacterAnimSlotNames
// NumValues: 0x0020
enum class ECAFrontendCharacterAnimSlotNames : uint8
{
	Invalid                                  = 0,
	Idle                                     = 1,
	Deploy                                   = 2,
	Selected                                 = 3,
	ReadyUp                                  = 4,
	ReadyUp_Idle                             = 5,
	Selected_Start                           = 6,
	Collection_Idle                          = 7,
	Collection_Selection_Focus               = 8,
	Collection_Selection_Confirm_Owned       = 9,
	Collection_Selection_Confirm_NotOwned    = 10,
	Lobby_Start                              = 11,
	Lobby_Selection_Focus                    = 12,
	Lobby_Selection_Confirm                  = 13,
	Lobby_Selection_Remote                   = 14,
	Lobby_ReadyUp                            = 15,
	Lobby_Deploy                             = 16,
	Root_Idle_Solo                           = 17,
	Collection_Owned                         = 18,
	Collection_NotOwned                      = 19,
	Root_Idle_Party                          = 20,
	Root_Idle_Party_Remote                   = 21,
	Root_Party_ReadyUp_Remote                = 22,
	Root_Party_Matchmake                     = 23,
	Root_Party_Matchmake_Remote              = 24,
	Root_Solo_ReadyUp                        = 25,
	Lobby_Idle                               = 26,
	Lobby_Select_Confirm                     = 27,
	Lobby_Select_Confirm_Remote              = 28,
	Lobby_ReadyUp_Idle                       = 29,
	Lobby_ReadyUp_Idle_Remote                = 30,
	MAX                                      = 31,
};

// Enum keaton.ECAUIEventType
// NumValues: 0x00C4
enum class ECAUIEventType : uint8
{
	None                                     = 0,
	StartUp_CheckForServiceErrors            = 1,
	FSM_PermitTransition                     = 2,
	RandomiseCustomisations                  = 3,
	History_Empty                            = 4,
	History_NotEmpty                         = 5,
	History_Back                             = 6,
	History_BackCompleted                    = 7,
	MatchMake                                = 8,
	ReturnToBar                              = 9,
	EnableFooterMenu                         = 10,
	Header_MenuNext                          = 11,
	Header_MenuPrevious                      = 12,
	Header_SubMenuNext                       = 13,
	Header_SubMenuPrevious                   = 14,
	Header_MenuChanged                       = 15,
	Header_SubMenuChanged                    = 16,
	Header_SetMainTabIndex                   = 17,
	Header_SetSubTabIndex                    = 18,
	Header_Expand                            = 19,
	Header_Contract                          = 20,
	Header_EnableItemByNavigationID          = 21,
	Header_DisableItemByNavigationID         = 22,
	Header_ShowTitleBox                      = 23,
	Header_HideTitleBox                      = 24,
	Footer_EnableCarousel                    = 25,
	Footer_DisableCarousel                   = 26,
	Footer_EnablePartyWidget                 = 27,
	Footer_DisablePartyWidget                = 28,
	Footer_EnableTextChat                    = 29,
	Footer_OnEnterHomeScreen                 = 30,
	Footer_OnExitHomeScreen                  = 31,
	Enititlements_Specialist_PendingChanged  = 32,
	Enititlements_Loadout_DataChanged        = 33,
	Enititlements_SpecialistCosmetic_DataChanged = 34,
	Enititlements_EquipmentCosmetic_DataChanged = 35,
	Enititlements_EquipmentCosmetic_PendingChanged = 36,
	Enititlements_EquipmentCosmetic_EquipPending = 37,
	Enititlements_Specialist_Emote_DataChanged = 38,
	Generic_StartupCompleted                 = 39,
	Generic_MatchmakingStarted               = 40,
	Generic_MatchmakingStopped               = 41,
	Matchmaking_QueueChanged                 = 42,
	ToggleDebug                              = 43,
	Specialist_RequestSelectionPopup         = 44,
	Specialist_ItemSelected                  = 45,
	Specialist_ToggleAbilityDetailsPopup     = 46,
	UserData_RequestRefresh                  = 47,
	UserData_UpdateProfile_Started           = 48,
	UserData_UpdateProfile_Error             = 49,
	UserData_Changed                         = 50,
	PaginatedGrid_NextPage                   = 51,
	PaginatedGrid_PreviousPage               = 52,
	Profile_Missions_Changed                 = 53,
	Profile_Data_Changed                     = 54,
	Specialist_DebugPurchaseEntitlement      = 55,
	Startup_Video_RequestPlay                = 56,
	Startup_Video_RequestStop                = 57,
	Startup_Video_PlaybackCompleted          = 58,
	Progression_PrimaryProgressionClicked    = 59,
	Progression_PrimarySelectionClicked      = 60,
	Progression_SetMessage                   = 61,
	Progression_ConfirmSelectedListItem      = 62,
	Progression_Lock                         = 63,
	Progression_Return                       = 64,
	Control_PrimaryCallToAction              = 65,
	Control_SecondaryCallToAction            = 66,
	Control_Select                           = 67,
	Control_ReadyUp                          = 68,
	Control_Back                             = 69,
	Navigation_LateralNext                   = 70,
	Navigation_LateralPrevious               = 71,
	Navigation_VerticalUp                    = 72,
	Navigation_VerticalDown                  = 73,
	Settings_NavigateTo                      = 74,
	Settings_Reset_Default                   = 75,
	Settings_Reset_Default_Selected          = 76,
	Settings_Discard                         = 77,
	Settings_KeyInputCaptured                = 78,
	Settings_ExitRequestedFromSettings       = 79,
	Settings_ExitGame                        = 80,
	Settings_Apply                           = 81,
	Social_UserAddedAsFriend                 = 82,
	Social_RefreshFriendsList                = 83,
	Social_SendFriendRequest                 = 84,
	Social_PromoteToLeader                   = 85,
	Social_LeaveParty                        = 86,
	Social_KickUser                          = 87,
	Social_GotoFriends                       = 88,
	Social_RefreshRecentPlayerList           = 89,
	Social_RecentPartyInvite                 = 90,
	Social_ViewPlayerCard                    = 91,
	Social_InvitePlayerToParty               = 92,
	Social_NavigateToAddFriend               = 93,
	Social_ClosePartyOptions                 = 94,
	News_ThumbnailClicked                    = 95,
	TextChat_SetVisible                      = 96,
	TextChat_ShowHistoryOnly                 = 97,
	LocalPlayer_StateReady                   = 98,
	LocalPlayer_LoadoutChanged               = 99,
	LocalPlayer_IsReadyChanged               = 100,
	LocalPlayer_CountDownChanged             = 101,
	LocalPlayer_PreviewSpecialist            = 102,
	LocalPlayer_PreviewSkin                  = 103,
	LocalPlayer_PreviewEmote                 = 104,
	LocalPlayer_PreviewInfo                  = 105,
	LocalPlayer_PreviewGraffiti              = 106,
	LocalPlayer_PreviewEquipSkin             = 107,
	LocalPlayer_ResetSpecialist              = 108,
	LocalPlayer_ResetWeapon                  = 109,
	LocalPlayer_SpecialistChanged            = 110,
	LocalPlayer_SpecialistSkinChanged        = 111,
	LocalPlayer_SpecialistUnlocked           = 112,
	Input_InputTypeChanged                   = 113,
	RefreshLoadoutInfo                       = 114,
	UserBlob_Retrieved                       = 115,
	SceneManagement_RequestSceneChange       = 116,
	SceneManagement_RequestPreviousScene     = 117,
	TeamManagement_RegisterPlayerState       = 118,
	TeamManagement_RemovePlayerState         = 119,
	TeamManagement_TeamChanged               = 120,
	TeamManagement_ActivePlayerChanged       = 121,
	TeamManagement_LastSelectedSpecialistChanged = 122,
	TeamManagement_RemoteSpecialistHoverChanged = 123,
	TeamManagement_ActivePlayerSpecialistChanged = 124,
	TeamManagement_AnyPlayerSpecialistChanged = 125,
	TeamManagement_AnyPlayerIsReadyChanged   = 126,
	TeamManagement_ServerTeamDataChanged     = 127,
	Global_Cancel                            = 128,
	Global_RequestDebugScreen                = 129,
	Global_RequestOptionScreen               = 130,
	Global_RequestPlayerProfileScreen        = 131,
	Global_RequestSocialScreen               = 132,
	LobbyState_GetReady                      = 133,
	LobbyState_PrepareSelectSpecialist       = 134,
	LobbyState_SelectSpecialist              = 135,
	LobbyState_SelectSpecialistSafeZone      = 136,
	LobbyState_ToggleLoadoutview             = 137,
	LobbyState_CloseLoadoutView              = 138,
	LobbyState_VanLineUp                     = 139,
	LobbyState_VanFinalCountDown             = 140,
	LobbyState_VanTravelToGameImminent       = 141,
	LobbyState_SetHeaderTitle                = 142,
	Event_AR                                 = 143,
	Event_AS                                 = 144,
	Debug_ToggleUIVisibility                 = 145,
	Debug_ShowHomeChallenges                 = 146,
	PlayerProfile_TabChanged                 = 147,
	PlayerProfile_Enable                     = 148,
	PlayerProfile_Disable                    = 149,
	PlayerProfile_RecentMatchesRefreshed     = 150,
	PlayerProfile_MatchDetailRequest         = 151,
	PlayerProfile_MatchSummaryRequest        = 152,
	PlayerProfile_LevelUpComplete            = 153,
	PlayerProfile_LevelUpFailed              = 154,
	Global_RequestSocialPopup                = 155,
	Specialist_SelectCurrentItem             = 156,
	Party_MemberStateChanged                 = 157,
	Party_MemberReadyStateChanged            = 158,
	Party_ShowPartyMembers                   = 159,
	Party_HidePartyMembers                   = 160,
	Mastery_HeaderClicked                    = 161,
	Notification_OnPopup                     = 162,
	Notification_OnDismiss                   = 163,
	Notification_Confirm                     = 164,
	Notification_Cancel                      = 165,
	Notification_ThirdOption                 = 166,
	Notification_MatchResultsCompleted       = 167,
	Notification_ServicesNotificationUserAccepted = 168,
	Localisation_CultureChanged              = 169,
	FSM_AllTransitionsCompleted              = 170,
	FSM_TransitionDenied                     = 171,
	ServicesFetch_UpdateMessage              = 172,
	Services_DataUpdateCompete               = 173,
	Services_ExtraResourcesUpdateCompete     = 174,
	SceneChange_Completed                    = 175,
	ServicesErrorResponse_Continue           = 176,
	ServicesErrorResponse_CancelMatchMaking  = 177,
	ServicesErrorResponse_Retry              = 178,
	ServicesErrorResponse_Resolve            = 179,
	EndOfMatch_SkipAll                       = 180,
	HeroLoot_PreviewLootItem                 = 181,
	HeroLoot_MakeDecision                    = 182,
	HeroLoot_Collect                         = 183,
	HeroLoot_Fence                           = 184,
	Challenges_UpdateSubHeaderElement        = 185,
	Automation_SelectEntitlement             = 186,
	Automation_Skip                          = 187,
	FTUE_ChangeState                         = 188,
	Debug_Toggle_1                           = 189,
	Debug_Toggle_2                           = 190,
	Debug_Toggle_3                           = 191,
	Debug_ReceiveFakeFriendRequest           = 192,
	Debug_ToggleDailyChallengesEnabled       = 193,
	Gamemode_HowToPlay                       = 194,
	ECAUIEventType_MAX                       = 195,
};

// Enum keaton.ECAClientConnectionStep
// NumValues: 0x0013
enum class ECAClientConnectionStep : uint8
{
	ExpectedFromMatchmaking                  = 0,
	NotConnected                             = 1,
	Lobby_Disconnect                         = 2,
	Lobby_SuccessfulLogin                    = 3,
	Lobby_LateLogin                          = 4,
	Lobby_Configured                         = 5,
	Lobby_WaitingForClients                  = 6,
	Lobby_WaitingForServerIDs                = 7,
	Lobby_RetrievingProfiles                 = 8,
	Lobby_CountDownStarted                   = 9,
	Lobby_PrepareSpecialistSelect            = 10,
	Lobby_SpecialistSelect                   = 11,
	Lobby_LineUp                             = 12,
	Lobby_FinalCountDown                     = 13,
	Lobby_TravelImminent                     = 14,
	Game_SuccessfulTravel                    = 15,
	Game_TimedOut                            = 16,
	Game_SuccessfulLogout                    = 17,
	ECAClientConnectionStep_MAX              = 18,
};

// Enum keaton.ECAEndGameReason
// NumValues: 0x0005
enum class ECAEndGameReason : uint8
{
	None                                     = 0,
	TeamDead                                 = 1,
	TimedOut                                 = 2,
	Extracted                                = 3,
	MAX                                      = 4,
};

// Enum keaton.EClientInitStage
// NumValues: 0x0017
enum class EClientInitStage : uint8
{
	ECIS_WaitingForCreation                  = 0,
	ECIS_WaitingForLocalPlayer               = 1,
	ECIS_WaitingForPlayerState               = 2,
	ECIS_WaitingForProfileLoad               = 3,
	ECIS_WaitingForHUD                       = 4,
	ECIS_WaitingForSetup                     = 5,
	ECIS_WaitingForReady                     = 6,
	ECIS_WaitingForAssets                    = 7,
	ECIS_WaitingForStreaming                 = 8,
	ECIS_WaitingToSpawn                      = 9,
	ECIS_WaitingForInitialisation            = 10,
	ECIS_WaitingForAcknowledgement           = 11,
	ECIS_RequestingSpaceJump                 = 12,
	ECIS_PlayingSpaceJump                    = 13,
	ECIS_ExitingSpaceJump                    = 14,
	ECIS_SetupComplete                       = 15,
	ECIS_MatchStarted                        = 16,
	ECIS_Disconnected                        = 17,
	ECIS_SpawnFailed                         = 18,
	ECIS_LoadingFailed                       = 19,
	ECIS_InvalidGameMode                     = 20,
	ECIS_TravellingToNewMap                  = 21,
	ECIS_MAX                                 = 22,
};

// Enum keaton.ECARespawnStationState
// NumValues: 0x0007
enum class ECARespawnStationState : uint8
{
	Active                                   = 0,
	Deactivated                              = 1,
	Working                                  = 2,
	Success                                  = 3,
	Fail                                     = 4,
	None                                     = 5,
	ECARespawnStationState_MAX               = 6,
};

// Enum keaton.ESysSensorEventType
// NumValues: 0x0019
enum class ESysSensorEventType : uint8
{
	DECOMPRESSION                            = 0,
	REPRESSURIZED                            = 1,
	LOUD_SOUND                               = 2,
	ZERO_GRAVITY                             = 3,
	LOW_GRAVITY                              = 4,
	NORMAL_GRAVITY                           = 5,
	HIGH_GRAVITY                             = 6,
	PHYSICAL_DAMAGE                          = 7,
	ELECTRICAL_DAMAGE                        = 8,
	ENTERED_LINE_OF_SIGHT                    = 9,
	EXITED_LINE_OF_SIGHT                     = 10,
	ENTERED_PROXIMITY                        = 11,
	EXITED_PROXIMITY                         = 12,
	POWER_OUTAGE                             = 13,
	POWER_RESTORED                           = 14,
	SECURITY_NORMAL                          = 15,
	SECURITY_ELEVATED                        = 16,
	SECURITY_BREACH                          = 17,
	SECURITY_LOCKDOWN                        = 18,
	CUSTOM_1                                 = 19,
	CUSTOM_2                                 = 20,
	CUSTOM_3                                 = 21,
	INVALID                                  = 22,
	NUMBER_TYPES                             = 23,
	ESysSensorEventType_MAX                  = 24,
};

// Enum keaton.ECAProgressOperation
// NumValues: 0x0006
enum class ECAProgressOperation : uint8
{
	ECAPO_Set                                = 0,
	ECAPO_Add                                = 1,
	ECAPO_Sub                                = 2,
	ECAPO_Min                                = 3,
	ECAPO_Max                                = 4,
	ECAPO_MAX                                = 5,
};

// Enum keaton.ESysStatusType
// NumValues: 0x0007
enum class ESysStatusType : uint8
{
	UNDEFINED                                = 0,
	ENABLED                                  = 1,
	ENABLING                                 = 2,
	DISABLED                                 = 3,
	DISABLING                                = 4,
	SUSPENDED                                = 5,
	ESysStatusType_MAX                       = 6,
};

// Enum keaton.ESysDeviceStateType
// NumValues: 0x0012
enum class ESysDeviceStateType : uint8
{
	ACTIVE                                   = 0,
	OPEN                                     = 1,
	UNLOCKED                                 = 2,
	INTACT                                   = 3,
	POWERED                                  = 4,
	AERATED                                  = 5,
	CLEAN                                    = 6,
	SHIELDED                                 = 7,
	SECURE                                   = 8,
	READY                                    = 9,
	UPLOADED                                 = 10,
	CAPTURED                                 = 11,
	HACKED                                   = 12,
	CUSTOM_1                                 = 13,
	CUSTOM_2                                 = 14,
	CUSTOM_3                                 = 15,
	NUM_STATES                               = 16,
	ESysDeviceStateType_MAX                  = 17,
};

// Enum keaton.ECAUseInteractableType
// NumValues: 0x0020
enum class ECAUseInteractableType : uint8
{
	NONE                                     = 0,
	USE                                      = 1,
	PICKUP                                   = 2,
	PICKUP_ALL                               = 3,
	EXTRACT                                  = 4,
	ACTIVATE                                 = 5,
	DEACTIVATE                               = 6,
	OPEN                                     = 7,
	CLOSE                                    = 8,
	REVIVE                                   = 9,
	EXECUTE                                  = 10,
	REPAIR                                   = 11,
	HACK                                     = 12,
	CAPTURE                                  = 13,
	RELEASE                                  = 14,
	ACTIVATE_GRAVITY_GENERATOR               = 15,
	DEACTIVATE_GRAVITY_GENERATOR             = 16,
	REQUIRES_CREW_KEYCARD                    = 17,
	REQUIRES_OFFICER_KEYCARD                 = 18,
	REQUIRES_CAPTAINS_KEYCARD                = 19,
	REQUIRES_POWER                           = 20,
	REQUIRES_EXTRACTION_KEYCARD              = 21,
	REQUIRES_BIOMETRIC_BLUEPRINT             = 22,
	REQUIRES_LOWER_SECURITY                  = 23,
	BACKPACK_FULL                            = 24,
	CONTAINER_EMPTY                          = 25,
	FIX_FOAM_ABILITY                         = 26,
	FIX_FOAM_GADGET                          = 27,
	CUSTOM_1                                 = 28,
	CUSTOM_2                                 = 29,
	CUSTOM_3                                 = 30,
	ECAUseInteractableType_MAX               = 31,
};

// Enum keaton.ECASecurityAreaState
// NumValues: 0x0005
enum class ECASecurityAreaState : uint8
{
	AllClear                                 = 0,
	IntrudersInSight                         = 1,
	IntrudersOutOfSight                      = 2,
	ResetSecurityArea                        = 3,
	ECASecurityAreaState_MAX                 = 4,
};

// Enum keaton.ECAPressureState
// NumValues: 0x000A
enum class ECAPressureState : uint8
{
	None                                     = 0,
	HardVacuum                               = 1,
	SoftVacuum                               = 2,
	Stabilized                               = 3,
	Overpressure                             = 4,
	Pressurizing                             = 5,
	Decompressing                            = 6,
	Overloading                              = 7,
	Stabilizing                              = 8,
	ECAPressureState_MAX                     = 9,
};

// Enum keaton.ECAIntelTerminalState
// NumValues: 0x0007
enum class ECAIntelTerminalState : uint8
{
	Invalid                                  = 0,
	Available                                = 1,
	Active                                   = 2,
	Cooldown                                 = 3,
	Success                                  = 4,
	Failure                                  = 5,
	MAX                                      = 6,
};

// Enum keaton.ECADialogueResult
// NumValues: 0x0009
enum class ECADialogueResult : uint8
{
	None                                     = 0,
	Confirm                                  = 1,
	Cancel                                   = 2,
	ThirdOption                              = 3,
	Error                                    = 4,
	Outcome_4                                = 5,
	Outcome_5                                = 6,
	Outcome_6                                = 7,
	ECADialogueResult_MAX                    = 8,
};

// Enum keaton.ECALobbyState
// NumValues: 0x000F
enum class ECALobbyState : uint8
{
	Init                                     = 0,
	Configured                               = 1,
	WaitingForClients                        = 2,
	WaitingForServerIDs                      = 3,
	RetrievingProfiles                       = 4,
	ClientsReadyToReceive                    = 5,
	CountDownStarted                         = 6,
	GetReady                                 = 7,
	PrepareSpecialistSelect                  = 8,
	SpecialistSelect                         = 9,
	SpecialistSelect_SafeZone                = 10,
	LineUp                                   = 11,
	FinalCountDown                           = 12,
	TravelImminent                           = 13,
	ECALobbyState_MAX                        = 14,
};

// Enum keaton.ECAEquippedStatus
// NumValues: 0x0005
enum class ECAEquippedStatus : uint8
{
	None                                     = 0,
	Request                                  = 1,
	Validated                                = 2,
	Failed                                   = 3,
	ECAEquippedStatus_MAX                    = 4,
};

// Enum keaton.ECAInputMode
// NumValues: 0x0005
enum class ECAInputMode : uint8
{
	None                                     = 0,
	Mouse                                    = 1,
	Keyboard                                 = 2,
	Controller                               = 3,
	ECAInputMode_MAX                         = 4,
};

// Enum keaton.ECAPlayerStateChangeType
// NumValues: 0x000B
enum class ECAPlayerStateChangeType : uint8
{
	None                                     = 0,
	Specialist                               = 1,
	SpecialistSkin                           = 2,
	IsReady                                  = 3,
	TeamID                                   = 4,
	TeamData                                 = 5,
	Loadout                                  = 6,
	PingColour                               = 7,
	PlayerName                               = 8,
	Disconnected                             = 9,
	ECAPlayerStateChangeType_MAX             = 10,
};

// Enum keaton.ECAShowWithInputType
// NumValues: 0x0005
enum class ECAShowWithInputType : uint8
{
	Always                                   = 0,
	Never                                    = 1,
	ControllerOnly                           = 2,
	MKBOnly                                  = 3,
	ECAShowWithInputType_MAX                 = 4,
};

// Enum keaton.ECAServicesNotificationType
// NumValues: 0x0006
enum class ECAServicesNotificationType : uint8
{
	None                                     = 0,
	Messages                                 = 1,
	Player_level                             = 2,
	Mastery_level                            = 3,
	Daily_challenges                         = 4,
	ECAServicesNotificationType_MAX          = 5,
};

// Enum keaton.ECAHUDDroneAbilityState
// NumValues: 0x0008
enum class ECAHUDDroneAbilityState : uint8
{
	None                                     = 0,
	Spawned                                  = 1,
	TargetingOwner                           = 2,
	Destroyed                                = 3,
	TargetingTeammate                        = 4,
	TargetingEnemyPlayer                     = 5,
	TargetingNonPlayer                       = 6,
	ECAHUDDroneAbilityState_MAX              = 7,
};

// Enum keaton.ECAUIHUDEntityId
// NumValues: 0x0042
enum class ECAUIHUDEntityId : uint8
{
	None                                     = 0,
	Player                                   = 1,
	TeamPlayer                               = 2,
	EnemyPlayer                              = 3,
	Objective                                = 4,
	Terminal                                 = 5,
	Waypoint                                 = 6,
	KeycardPurple                            = 7,
	KeycardYellow                            = 8,
	OtherTerminal                            = 9,
	Door                                     = 10,
	ExtractionPoint                          = 11,
	HealthPack                               = 12,
	PistolAmmo                               = 13,
	HackingJack                              = 14,
	Loot                                     = 15,
	RegionMarker                             = 16,
	ServerCore                               = 17,
	SecurityArea                             = 18,
	NPC                                      = 19,
	Ping                                     = 20,
	PingWarning                              = 21,
	LivePing                                 = 22,
	MinimapPing                              = 23,
	ContextualPing                           = 24,
	StairsDown                               = 25,
	RespawnPoint                             = 26,
	OneStarLoot                              = 27,
	TwoStarLoot                              = 28,
	ThreeStarLoot                            = 29,
	RaidedLootOneStar                        = 30,
	RaidedLootTwoStar                        = 31,
	RaidedLootThreeStar                      = 32,
	RaidedLootFourStar                       = 33,
	RaidedLootFiveStar                       = 34,
	FiveStarLoot                             = 35,
	FourStarLoot                             = 36,
	LocalVault                               = 37,
	Projectile                               = 38,
	TeleportStartPoint                       = 39,
	TeleportEndPoint                         = 40,
	Valuables                                = 41,
	ArmourPing                               = 42,
	OffensiveGadget                          = 43,
	UtilityGadget                            = 44,
	UtilityArmourGadget                      = 45,
	WeaponBuff                               = 46,
	SpawnPoint                               = 47,
	TeamGadget                               = 48,
	ExtractionPointSmall                     = 49,
	ExtractionPointMedium                    = 50,
	ExtractionPointLarge                     = 51,
	AlarmTerminal                            = 52,
	EnemyPlayerFiredWeapon                   = 53,
	EnemyPlayerRevealed                      = 54,
	PlayerDetectedByIngredient               = 55,
	ObjectIndicator                          = 56,
	HighValueLootEvent                       = 57,
	HighValueLootEventEnded                  = 58,
	Unused17                                 = 59,
	Unused18                                 = 60,
	Unused19                                 = 61,
	Unused20                                 = 62,
	Unused21                                 = 63,
	Unused22                                 = 64,
	MAX                                      = 65,
};

// Enum keaton.ECAPingContext
// NumValues: 0x0006
enum class ECAPingContext : uint8
{
	None                                     = 0,
	Positive                                 = 1,
	Negative                                 = 2,
	Neutral                                  = 3,
	Invalid                                  = 4,
	ECAPingContext_MAX                       = 5,
};

// Enum keaton.ECAArcLensPingType
// NumValues: 0x001A
enum class ECAArcLensPingType : uint8
{
	None                                     = 0,
	MapPing                                  = 1,
	QuickPing                                = 2,
	GenericPositive                          = 3,
	GenericNegative                          = 4,
	GenericWarning                           = 5,
	GenericNeutral                           = 6,
	GenericContextual                        = 7,
	GenericQuestion                          = 8,
	No                                       = 9,
	Stealth                                  = 10,
	WatchThisArea                            = 11,
	Help                                     = 12,
	Retreat                                  = 13,
	WaitHere                                 = 14,
	OnMyWay                                  = 15,
	Countdown                                = 16,
	Ability                                  = 17,
	AbilityCharging                          = 18,
	AbilityReady                             = 19,
	Celebration                              = 20,
	Thanks                                   = 21,
	Yes                                      = 22,
	RandomEmote                              = 23,
	Invalid                                  = 24,
	ECAArcLensPingType_MAX                   = 25,
};

// Enum keaton.ECATextChatChannel
// NumValues: 0x0005
enum class ECATextChatChannel : uint8
{
	All                                      = 0,
	Team                                     = 1,
	Whisper                                  = 2,
	Local                                    = 3,
	MAX                                      = 4,
};

// Enum keaton.EKeatonPrivilegeError
// NumValues: 0x000C
enum class EKeatonPrivilegeError : uint8
{
	RequiredPatchAvailable                   = 0,
	RequiredSystemUpdate                     = 1,
	AgeRestrictionFailure                    = 2,
	AccountTypeFailure                       = 3,
	UserNotFound                             = 4,
	UserNotLoggedIn                          = 5,
	ChatRestriction                          = 6,
	UGCRestriction                           = 7,
	GenericFailure                           = 8,
	OnlinePlayRestricted                     = 9,
	NetworkConnectionUnavailable             = 10,
	EKeatonPrivilegeError_MAX                = 11,
};

// Enum keaton.EKeatonPrivilege
// NumValues: 0x0007
enum class EKeatonPrivilege : uint8
{
	CanPlay                                  = 0,
	CanPlayOnline                            = 1,
	CanCommunicateOnline                     = 2,
	CanUseUserGeneratedContent               = 3,
	CanUserCrossPlay                         = 4,
	None                                     = 5,
	EKeatonPrivilege_MAX                     = 6,
};

// Enum keaton.ECANPCFlyingHoldPositionParam
// NumValues: 0x0004
enum class ECANPCFlyingHoldPositionParam : uint8
{
	MinHorizontalDistancePerRepositionMove   = 0,
	MaxHorizontalDistancePerRepositionMove   = 1,
	VerticalDistancePerRepositionMove        = 2,
	ECANPCFlyingHoldPositionParam_MAX        = 3,
};

// Enum keaton.ECANPCHoldPositionParam
// NumValues: 0x0003
enum class ECANPCHoldPositionParam : uint8
{
	MinDistancePerRepositionMove             = 0,
	MaxDistancePerRepositionMove             = 1,
	ECANPCHoldPositionParam_MAX              = 2,
};

// Enum keaton.ECANPCVariableKeyB
// NumValues: 0x0004
enum class ECANPCVariableKeyB : uint8
{
	None                                     = 0,
	AttackLocation                           = 1,
	TargetLastSensedPosition                 = 2,
	ECANPCVariableKeyB_MAX                   = 3,
};

// Enum keaton.ECAFeatureToCheck
// NumValues: 0x0006
enum class ECAFeatureToCheck : uint8
{
	None                                     = 0,
	Feature_ca_npc_dnt                       = 1,
	Feature_ca_npc_epl                       = 2,
	Feature_ca_npc_idle_behaviour            = 3,
	Feature_ca_semiauto_turret_prototype     = 4,
	ECAFeatureToCheck_MAX                    = 5,
};

// Enum keaton.ECANPCVariableKey
// NumValues: 0x0004
enum class ECANPCVariableKey : uint8
{
	None                                     = 0,
	AttackLocation                           = 1,
	TargetLastSensedPosition                 = 2,
	ECANPCVariableKey_MAX                    = 3,
};

// Enum keaton.ECASenseCheckTest
// NumValues: 0x0004
enum class ECASenseCheckTest : uint8
{
	IsAbove                                  = 0,
	IsBelow                                  = 1,
	EqualTo                                  = 2,
	ECASenseCheckTest_MAX                    = 3,
};

// Enum keaton.ECASenseCheckThreshold
// NumValues: 0x0005
enum class ECASenseCheckThreshold : uint8
{
	None                                     = 0,
	Lower                                    = 1,
	Upper                                    = 2,
	Max                                      = 3,
	ECASenseCheckThreshold_MAX               = 4,
};

// Enum keaton.ECASenseCheckType
// NumValues: 0x0007
enum class ECASenseCheckType : uint8
{
	Sight                                    = 0,
	Hearing                                  = 1,
	Damage                                   = 2,
	Touch                                    = 3,
	Weapon                                   = 4,
	AnyNoiseEvent                            = 5,
	ECASenseCheckType_MAX                    = 6,
};

// Enum keaton.ECATargetLastSensedElapsedCheckTest
// NumValues: 0x0004
enum class ECATargetLastSensedElapsedCheckTest : uint8
{
	IsAbove                                  = 0,
	IsBelow                                  = 1,
	EqualTo                                  = 2,
	ECATargetLastSensedElapsedCheckTest_MAX  = 3,
};

// Enum keaton.ECASense
// NumValues: 0x0004
enum class ECASense : uint8
{
	Sight                                    = 0,
	Hearing                                  = 1,
	Damage                                   = 2,
	ECASense_MAX                             = 3,
};

// Enum keaton.ECATimeLimitTestValue
// NumValues: 0x0004
enum class ECATimeLimitTestValue : uint8
{
	TimeLimit                                = 0,
	RepositionRate                           = 1,
	RelocateAttackDuration                   = 2,
	ECATimeLimitTestValue_MAX                = 3,
};

// Enum keaton.ECAVariableToLoopCheck
// NumValues: 0x0006
enum class ECAVariableToLoopCheck : uint8
{
	None                                     = 0,
	HasVirtualVisionOnTarget                 = 1,
	HasLineOfSightToHighPriorityTargetObject = 2,
	HasLineOfSightToMediumPriorityTargetObject = 3,
	HasLineOfSightToLowPriorityTargetObject  = 4,
	ECAVariableToLoopCheck_MAX               = 5,
};

// Enum keaton.ECANPCBroadcastDelegateStateChanged
// NumValues: 0x0003
enum class ECANPCBroadcastDelegateStateChanged : uint8
{
	None                                     = 0,
	OnSpecialAbilityReady                    = 1,
	ECANPCBroadcastDelegateStateChanged_MAX  = 2,
};

// Enum keaton.ECANPCBroadcastDelegate
// NumValues: 0x0004
enum class ECANPCBroadcastDelegate : uint8
{
	None                                     = 0,
	OnActivateTargetLaser                    = 1,
	OnDeactivateTargetLaser                  = 2,
	ECANPCBroadcastDelegate_MAX              = 3,
};

// Enum keaton.DefaultAimStateType
// NumValues: 0x0004
enum class EDefaultAimStateType : uint8
{
	None                                     = 0,
	Combat                                   = 1,
	NonCombat                                = 2,
	DefaultAimStateType_MAX                  = 3,
};

// Enum keaton.AimStateType
// NumValues: 0x000A
enum class EAimStateType : uint8
{
	Actor                                    = 0,
	FocalPoint                               = 1,
	Freeze                                   = 2,
	Location                                 = 3,
	LastSensedPosition                       = 4,
	Sweep                                    = 5,
	LastSensedOrFocal                        = 6,
	TargetFoam                               = 7,
	LookDown                                 = 8,
	AimStateType_MAX                         = 9,
};

// Enum keaton.DefaultRotationStateType
// NumValues: 0x0004
enum class EDefaultRotationStateType : uint8
{
	None                                     = 0,
	Combat                                   = 1,
	NonCombat                                = 2,
	DefaultRotationStateType_MAX             = 3,
};

// Enum keaton.RotationStateType
// NumValues: 0x0005
enum class ERotationStateType : uint8
{
	FaceAimDirection                         = 0,
	AdjustOnMaxDelta                         = 1,
	Freeze                                   = 2,
	FocalPoint                               = 3,
	RotationStateType_MAX                    = 4,
};

// Enum keaton.ECAPermissionType
// NumValues: 0x0002
enum class ECAPermissionType : uint8
{
	None                                     = 0,
	ECAPermissionType_MAX                    = 1,
};

// Enum keaton.ECAFocalPointType
// NumValues: 0x0006
enum class ECAFocalPointType : uint8
{
	TowardContestedObjective                 = 0,
	AwayFromContestedObjective               = 1,
	ContestedObjectiveFacingDirection        = 2,
	AwayFromNearbyVaultDoor                  = 3,
	TowardGrenadeTargetLocation              = 4,
	ECAFocalPointType_MAX                    = 5,
};

// Enum keaton.ECAToggleSpecifiedVariable
// NumValues: 0x0003
enum class ECAToggleSpecifiedVariable : uint8
{
	None                                     = 0,
	SuspectResponseWarning                   = 1,
	ECAToggleSpecifiedVariable_MAX           = 2,
};

// Enum keaton.ECADialogueTypeToTrigger
// NumValues: 0x000A
enum class ECADialogueTypeToTrigger : uint8
{
	None                                     = 0,
	ExitCombatDeploy                         = 1,
	SummonAlly                               = 2,
	ThrowGrenade                             = 3,
	SlamAttack                               = 4,
	MeleeAttack                              = 5,
	AttackBreachingDevice                    = 6,
	CombatTacticalGenericMove                = 7,
	CombatEvasive                            = 8,
	ECADialogueTypeToTrigger_MAX             = 9,
};

// Enum keaton.ECADialogueFactUpdateValue
// NumValues: 0x0007
enum class ECADialogueFactUpdateValue : uint8
{
	None                                     = 0,
	Damage                                   = 1,
	Sight                                    = 2,
	Sound                                    = 3,
	Weapon                                   = 4,
	Touch                                    = 5,
	ECADialogueFactUpdateValue_MAX           = 6,
};

// Enum keaton.ECADialogueFactToUpdate
// NumValues: 0x0004
enum class ECADialogueFactToUpdate : uint8
{
	None                                     = 0,
	CombatTransitionSense                    = 1,
	SuspiciousTransitionSense                = 2,
	ECADialogueFactToUpdate_MAX              = 3,
};

// Enum keaton.ECANPCGoalAgents
// NumValues: 0x0002
enum class ECANPCGoalAgents : uint8
{
	SelfAgent                                = 0,
	ECANPCGoalAgents_MAX                     = 1,
};

// Enum keaton.ECAIfTargetUnreachable
// NumValues: 0x0003
enum class ECAIfTargetUnreachable : uint8
{
	MoveFails                                = 0,
	TryNearestReachable                      = 1,
	ECAIfTargetUnreachable_MAX               = 2,
};

// Enum keaton.ECADesiredStopDistance
// NumValues: 0x0005
enum class ECADesiredStopDistance : uint8
{
	UseAcceptanceRadius                      = 0,
	WeaponMaxRange                           = 1,
	WeaponEffectiveRange                     = 2,
	FollowRadiusInner                        = 3,
	ECADesiredStopDistance_MAX               = 4,
};

// Enum keaton.ECAMoveToType
// NumValues: 0x0016
enum class ECAMoveToType : uint8
{
	MoveToLocation                           = 0,
	MoveToActor                              = 1,
	MoveToAttackLocation                     = 2,
	MoveToCurrentJob                         = 3,
	MoveToSearchLocation                     = 4,
	MoveToTargetLastSensedPosition           = 5,
	MoveToHomeLocation                       = 6,
	MoveToCurrentTarget                      = 7,
	MoveToHighPriorityTargetObject           = 8,
	MoveToMediumPriorityTargetObject         = 9,
	MoveToLowPriorityTargetObject            = 10,
	MoveToMissionObjectiveLocation           = 11,
	MoveToAllyTarget                         = 12,
	MoveToFollowAllyLocation                 = 13,
	MoveToFlyingFollowAllyLocation           = 14,
	MoveToTargetLastSightedPosition          = 15,
	MoveToGuardLocation                      = 16,
	MoveToBindPoint                          = 17,
	MoveToContestedTargetObject              = 18,
	StayAtCurrentLocation                    = 19,
	MoveToIdleTarget                         = 20,
	ECAMoveToType_MAX                        = 21,
};

// Enum keaton.ECANPCQueryResultLocation
// NumValues: 0x0008
enum class ECANPCQueryResultLocation : uint8
{
	None                                     = 0,
	AttackLocation                           = 1,
	SearchLocation                           = 2,
	FollowAllyLocation                       = 3,
	GrenadeTargetLocation                    = 4,
	BindPoint                                = 5,
	CombatJumpTargetLocation                 = 6,
	ECANPCQueryResultLocation_MAX            = 7,
};

// Enum keaton.ECAContestedObjectiveType
// NumValues: 0x0003
enum class ECAContestedObjectiveType : uint8
{
	None                                     = 0,
	NearestObjectiveOuterJob                 = 1,
	ECAContestedObjectiveType_MAX            = 2,
};

// Enum keaton.ECASetTimeType
// NumValues: 0x0009
enum class ECASetTimeType : uint8
{
	TimeLastRelocateAttack                   = 0,
	TimeLastLostTargetMove                   = 1,
	TimeLastTryThrowGrenade                  = 2,
	TimeLastTryCombatJump                    = 3,
	TimeLastTryEMP                           = 4,
	TimeLastTryLaser                         = 5,
	TimeLastTryEvade                         = 6,
	TimeLastIdleBehaviour                    = 7,
	ECASetTimeType_MAX                       = 8,
};

// Enum keaton.ECATriggerNPCEvent
// NumValues: 0x0004
enum class ECATriggerNPCEvent : uint8
{
	NoEvent                                  = 0,
	OnSearchEnd                              = 1,
	MaxNPCEvents                             = 2,
	ECATriggerNPCEvent_MAX                   = 3,
};

// Enum keaton.ECARequestLayoutExe
// NumValues: 0x0003
enum class ECARequestLayoutExe : uint8
{
	PassThrough                              = 0,
	Completed                                = 1,
	ECARequestLayoutExe_MAX                  = 2,
};

// Enum keaton.ECAAbilityInputBinds
// NumValues: 0x0017
enum class ECAAbilityInputBinds : uint8
{
	Ability1                                 = 0,
	Ability2                                 = 1,
	Ability3                                 = 2,
	Ability7                                 = 3,
	AbilityUse                               = 4,
	AbilityNextWeapon                        = 5,
	AbilityPrevWeapon                        = 6,
	AbilityUseInhaler                        = 7,
	DebugWeapon                              = 8,
	GadgetOffensive                          = 9,
	ActiveAbility                            = 10,
	DebugGivePerfectWeapon                   = 11,
	AbilityCashSiphon                        = 12,
	AbilityPing                              = 13,
	DebugGiveAmmo                            = 14,
	DebugDoExecution                         = 15,
	AbilityNextConsumable                    = 16,
	DebugMinimapTeleport                     = 17,
	RequestExtraction                        = 18,
	AbilityInteractTacticalGadget            = 19,
	AbilityActivateNextTacticalSlot          = 20,
	GadgetTeam                               = 21,
	ECAAbilityInputBinds_MAX                 = 22,
};

// Enum keaton.ECAManagedGaplayAbilityTagType
// NumValues: 0x0008
enum class ECAManagedGaplayAbilityTagType : uint32
{
	Start                                    = 0,
	End                                      = 1,
	Active                                   = 2,
	PerpetualStart                           = 3,
	PerpetualEnd                             = 4,
	DoCommit                                 = 5,
	UNDEFINED                                = 6,
	MAX                                      = 6,
};

// Enum keaton.FReachSectionEnum
// NumValues: 0x0003
enum class EFReachSectionEnum : uint8
{
	OnReach                                  = 0,
	OnComplete                               = 1,
	FReachSectionEnum_MAX                    = 2,
};

// Enum keaton.ECAActionBindingSymbolType
// NumValues: 0x0005
enum class ECAActionBindingSymbolType : uint8
{
	None                                     = 0,
	Icon                                     = 1,
	Text                                     = 2,
	Auto                                     = 3,
	MAX                                      = 4,
};

// Enum keaton.ECAActivityTimerAction
// NumValues: 0x0005
enum class ECAActivityTimerAction : uint8
{
	Register                                 = 0,
	Resume                                   = 1,
	Pause                                    = 2,
	Clear                                    = 3,
	ECAActivityTimerAction_MAX               = 4,
};

// Enum keaton.EMapCheckMessageSeverity
// NumValues: 0x0006
enum class EMapCheckMessageSeverity : uint8
{
	CriticalError                            = 0,
	Error                                    = 1,
	PerformanceWarning                       = 2,
	Warning                                  = 3,
	Info                                     = 4,
	EMapCheckMessageSeverity_MAX             = 5,
};

// Enum keaton.EMovementBuffModifierTypes
// NumValues: 0x000F
enum class EMovementBuffModifierTypes : uint8
{
	Default                                  = 0,
	FlyingForwardInZeroG                     = 1,
	FlyingBackwardInZeroG                    = 2,
	LateralMovementInZeroG                   = 3,
	SprintingForwardInOneG                   = 4,
	MovingBackwardInOneG                     = 5,
	StrafingInOneG                           = 6,
	SlidingInOneG                            = 7,
	JumpingInOneG                            = 8,
	FallingInOneG                            = 9,
	ADS_FlyingForwardInZeroG                 = 10,
	ADS_FlyingBackwardInZeroG                = 11,
	ADS_LateralMovementInZeroG               = 12,
	MovingForwardInOneG                      = 13,
	EMovementBuffModifierTypes_MAX           = 14,
};

// Enum keaton.ECADistCheckTestValue
// NumValues: 0x0004
enum class ECADistCheckTestValue : uint8
{
	TestValue                                = 0,
	MinBehaveRadius                          = 1,
	MaxBehaveRadius                          = 2,
	ECADistCheckTestValue_MAX                = 3,
};

// Enum keaton.ECAFromSourceLocation
// NumValues: 0x0003
enum class ECAFromSourceLocation : uint8
{
	Self                                     = 0,
	CurrentTarget                            = 1,
	ECAFromSourceLocation_MAX                = 2,
};

// Enum keaton.ECAToTargetLocation
// NumValues: 0x0002
enum class ECAToTargetLocation : uint8
{
	BindPoint                                = 0,
	ECAToTargetLocation_MAX                  = 1,
};

// Enum keaton.ECATimeSinceTestValue
// NumValues: 0x000B
enum class ECATimeSinceTestValue : uint8
{
	Seconds                                  = 0,
	RelocateAttackCooldown                   = 1,
	RelocateAttackDuration                   = 2,
	TryThrowGrenadeCooldown                  = 3,
	TryEMPCooldown                           = 4,
	TryLaserCooldown                         = 5,
	TryCombatJumpCooldown                    = 6,
	TryEvadeCooldown                         = 7,
	SpecialAbilitiesInitialCooldown          = 8,
	IdleBehaviourCooldown                    = 9,
	ECATimeSinceTestValue_MAX                = 10,
};

// Enum keaton.ECATimeSince
// NumValues: 0x000F
enum class ECATimeSince : uint8
{
	LastInCombat                             = 0,
	LastSuspectResponseWarning               = 1,
	LastMoveToTargetAgentCommand             = 2,
	LastChangedTarget                        = 3,
	LastTimeExitedSuspectResponse            = 4,
	LastRelocateAttack                       = 5,
	LastLostTargetMove                       = 6,
	LastTryThrowGrenade                      = 7,
	LastTryEMP                               = 8,
	LastTryLaser                             = 9,
	LastTryCombatJump                        = 10,
	LastTryEvade                             = 11,
	LastEnteredCombat                        = 12,
	LastIdleBehaviour                        = 13,
	ECATimeSince_MAX                         = 14,
};

// Enum keaton.EDebugMagnetismType
// NumValues: 0x000E
enum class EDebugMagnetismType : uint8
{
	NoTarget                                 = 0,
	TotalMiss                                = 1,
	AccurateToCriticalHitPoint               = 2,
	AccurateToNonCritical                    = 3,
	CorrectedToCriticalFromAccurate          = 4,
	CorrectedToCriticalFromMiss              = 5,
	CorrectedToNonCriticalFromMiss           = 6,
	AccurateToObject                         = 7,
	CorrectedToObject                        = 8,
	AimAssistCancelled_WasOverGeometry_ToAccurate = 9,
	AltAim_CorrectedToObject                 = 10,
	AltAim_CorrectedToWeaponCollisionComponent = 11,
	AltAim_Miss                              = 12,
	EDebugMagnetismType_MAX                  = 13,
};

// Enum keaton.EAimAssist_TargetType
// NumValues: 0x0005
enum class EAimAssist_TargetType : uint8
{
	Player                                   = 0,
	NPC                                      = 1,
	Object                                   = 2,
	Max                                      = 3,
	EAimAssist_MAX                           = 4,
};

// Enum keaton.EAimAssist_CrosshairAreaType
// NumValues: 0x0005
enum class EAimAssist_CrosshairAreaType : uint8
{
	None                                     = 0,
	Outer                                    = 1,
	Inner                                    = 2,
	Max                                      = 3,
	EAimAssist_MAX                           = 4,
};

// Enum keaton.EAimAssistShape
// NumValues: 0x0005
enum class EAimAssistShape : uint8
{
	Capsule                                  = 0,
	Sphere                                   = 1,
	Box                                      = 2,
	Mesh                                     = 3,
	EAimAssistShape_MAX                      = 4,
};

// Enum keaton.ECANoiseEventTypes
// NumValues: 0x0006
enum class ECANoiseEventTypes : uint8
{
	MovementSound                            = 0,
	WeaponSound                              = 1,
	ProjectileImpactSound                    = 2,
	AlarmSound                               = 3,
	NumNoiseEventTypes                       = 4,
	ECANoiseEventTypes_MAX                   = 5,
};

// Enum keaton.ECAAIPortalGraphRoomType
// NumValues: 0x0005
enum class ECAAIPortalGraphRoomType : uint8
{
	None                                     = 0,
	OutsideCamp                              = 1,
	Outer                                    = 2,
	Inner                                    = 3,
	ECAAIPortalGraphRoomType_MAX             = 4,
};

// Enum keaton.ECAForcedAIPortalGraphAreaType
// NumValues: 0x0007
enum class ECAForcedAIPortalGraphAreaType : uint8
{
	None                                     = 0,
	NavMeshIsland                            = 1,
	OutsideCamp                              = 2,
	Outer                                    = 3,
	Inner                                    = 4,
	MissionObjective                         = 5,
	ECAForcedAIPortalGraphAreaType_MAX       = 6,
};

// Enum keaton.ECADistanceCheckTestValue
// NumValues: 0x000A
enum class ECADistanceCheckTestValue : uint8
{
	TestValue                                = 0,
	MinimumTargetDistanceRange               = 1,
	MaximumTargetDistanceRange               = 2,
	RelocateAttackRange                      = 3,
	MinimumTryThrowGrenadeRange              = 4,
	MaximumTryThrowGrenadeRange              = 5,
	MeleeAttackRange                         = 6,
	MeleePermissionCheckRange                = 7,
	AOESpecialAttackTriggerRange             = 8,
	ECADistanceCheckTestValue_MAX            = 9,
};

// Enum keaton.ECADistanceType
// NumValues: 0x0003
enum class ECADistanceType : uint8
{
	DirectDistance                           = 0,
	PathedDistance                           = 1,
	ECADistanceType_MAX                      = 2,
};

// Enum keaton.ECATargetDistanceCheckTest
// NumValues: 0x0004
enum class ECATargetDistanceCheckTest : uint8
{
	IsAbove                                  = 0,
	IsBelow                                  = 1,
	EqualTo                                  = 2,
	ECATargetDistanceCheckTest_MAX           = 3,
};

// Enum keaton.ECAVariableToCheck
// NumValues: 0x003B
enum class ECAVariableToCheck : uint8
{
	None                                     = 0,
	IsInCombat                               = 1,
	HasCurrentTarget                         = 2,
	HasLineOfFireToTarget                    = 3,
	HasLineOfSightToTarget                   = 4,
	HasVirtualVisionOnTarget                 = 5,
	IsTargetWithinMissionArea                = 6,
	TargetEnemyCloseToEWROfAttackLocation    = 7,
	TargetEnemyWithinEWROfAttackLocation     = 8,
	HasCurrentTargetChangedReset             = 9,
	HasLineOfSightToHighPriorityTargetObject = 10,
	HasLineOfSightToMediumPriorityTargetObject = 11,
	HasLineOfSightToLowPriorityTargetObject  = 12,
	ShouldUseSpecialAbilityAttackOnTargetObject = 13,
	IsForceJobSet                            = 14,
	IsForcingReposition                      = 15,
	SuspectResponseWarning                   = 16,
	CanFly                                   = 17,
	UseFlyingAttackLocations                 = 18,
	HasAnimatedReaction                      = 19,
	GameStarted                              = 20,
	NavMeshGenerated                         = 21,
	AllowedToAttackTarget                    = 22,
	AllowedToMeleeTarget                     = 23,
	WantsToCharge                            = 24,
	AllowedToDoSpecial                       = 25,
	HasAllyTarget                            = 26,
	AllowedToAddAreaBuff                     = 27,
	IsAreaBuffInMission                      = 28,
	IsInsideAreaBuff                         = 29,
	IsAllyTargetDamaged                      = 30,
	IsTargetDownedPlayer                     = 31,
	IsInInitialPosition                      = 32,
	HasGuardLocation                         = 33,
	TargetIsOutsideSoftBorder                = 34,
	TargetIsOutsideHardBorder                = 35,
	IsInMissionFilterArea                    = 36,
	IsTargetInMissionFilterArea              = 37,
	MainWeaponIsCharging                     = 38,
	IsFailingToMoveToTarget                  = 39,
	IsFloating                               = 40,
	HasContestedObjectiveJob                 = 41,
	IsMissionAreaEscalated                   = 42,
	AllowedToAttackContestedTargetObject     = 43,
	MainWeaponIsFiring                       = 44,
	AllowedToUseGrenadeAbility               = 45,
	IsUsingSplineGrenade                     = 46,
	HasValidGrenadeTargetLocation            = 47,
	AllowedToUseCombatJumpAbility            = 48,
	HasValidCombatJumpTargetLocation         = 49,
	IsInZeroG                                = 50,
	SecondaryWeaponIsCharging                = 51,
	AllowedToUseEMPAbility                   = 52,
	AllowedToUseLaserAbility                 = 53,
	IsInMissionArea                          = 54,
	AllowedToPerformIdleBehaviour            = 55,
	HasIdleBehaviourTarget                   = 56,
	IsOnTheGround                            = 57,
	ECAVariableToCheck_MAX                   = 58,
};

// Enum keaton.ECAAmputationMask
// NumValues: 0x0009
enum class ECAAmputationMask : uint8
{
	None                                     = 0,
	Head                                     = 1,
	LeftArm                                  = 2,
	RightArm                                 = 4,
	LeftLeg                                  = 8,
	RightLeg                                 = 16,
	Torso                                    = 32,
	Back                                     = 64,
	ECAAmputationMask_MAX                    = 65,
};

// Enum keaton.ECAAmputationLimb
// NumValues: 0x000A
enum class ECAAmputationLimb : uint8
{
	Head                                     = 0,
	LeftArm                                  = 1,
	RightArm                                 = 2,
	LeftLeg                                  = 3,
	RightLeg                                 = 4,
	Torso                                    = 5,
	Back                                     = 6,
	Invalid                                  = 7,
	Count                                    = 8,
	ECAAmputationLimb_MAX                    = 9,
};

// Enum keaton.ECALightTransitionType
// NumValues: 0x0006
enum class ECALightTransitionType : uint8
{
	Instant                                  = 0,
	Fade                                     = 1,
	FadeFlickerCustom                        = 2,
	Flicker                                  = 3,
	FlickerCustom                            = 4,
	MAX                                      = 5,
};

// Enum keaton.ECALightAnimationType
// NumValues: 0x0008
enum class ECALightAnimationType : uint8
{
	Uniform                                  = 0,
	Pulsate                                  = 1,
	Flicker                                  = 2,
	Fluctuate                                = 3,
	Flicker_Off                              = 4,
	Sparking                                 = 5,
	Blink                                    = 6,
	MAX                                      = 7,
};

// Enum keaton.EFP_TP_Selector
// NumValues: 0x0004
enum class EFP_TP_Selector : uint8
{
	Always                                   = 0,
	FP_Only                                  = 1,
	TP_Only                                  = 2,
	EFP_TP_MAX                               = 3,
};

// Enum keaton.ETPLayers
// NumValues: 0x0009
enum class ETPLayers : uint8
{
	Additive                                 = 0,
	Land                                     = 1,
	Stiff                                    = 2,
	Procedural                               = 3,
	IKJiggles                                = 4,
	SpecialistPose                           = 5,
	SpecialistIdle                           = 6,
	Override                                 = 7,
	ETPLayers_MAX                            = 8,
};

// Enum keaton.EFPLayers
// NumValues: 0x000B
enum class EFPLayers : uint8
{
	LookAt                                   = 0,
	Pitch                                    = 1,
	Bank                                     = 2,
	Fall                                     = 3,
	Movement                                 = 4,
	Jump                                     = 5,
	Land                                     = 6,
	Crouch                                   = 7,
	Procedural                               = 8,
	Override                                 = 9,
	EFPLayers_MAX                            = 10,
};

// Enum keaton.ELocomotionClass
// NumValues: 0x0007
enum class ELocomotionClass : uint8
{
	Default                                  = 0,
	OneHanded                                = 1,
	TwoHanded                                = 2,
	SmallGadget                              = 3,
	BigGadget                                = 4,
	DualWielding                             = 5,
	ELocomotionClass_MAX                     = 6,
};

// Enum keaton.EZeroGTakeOffType
// NumValues: 0x0007
enum class EZeroGTakeOffType : uint8
{
	None                                     = 0,
	FromMagBoots                             = 1,
	FromWall                                 = 2,
	FromFlying                               = 3,
	CornerVault                              = 4,
	Failed                                   = 5,
	EZeroGTakeOffType_MAX                    = 6,
};

// Enum keaton.EZeroGTakeOffDirection
// NumValues: 0x0006
enum class EZeroGTakeOffDirection : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Over                                     = 3,
	Under                                    = 4,
	EZeroGTakeOffDirection_MAX               = 5,
};

// Enum keaton.ENPCStatus
// NumValues: 0x0004
enum class ENPCStatus : uint8
{
	Normal                                   = 0,
	EMPed                                    = 1,
	Dead                                     = 2,
	ENPCStatus_MAX                           = 3,
};

// Enum keaton.ECAAnimMovementMode
// NumValues: 0x0022
enum class ECAAnimMovementMode : uint8
{
	UNDEFINED                                = 0,
	NPC                                      = 1,
	Loco                                     = 2,
	Sprint                                   = 3,
	Crouch                                   = 4,
	Slide                                    = 5,
	MagBoots                                 = 6,
	MagBoots_Crouch                          = 7,
	MagBoots_Sprint                          = 8,
	PossessingNPC                            = 9,
	Downed_Ground                            = 10,
	Reviving_Ground                          = 11,
	Fall_Initial                             = 12,
	Short_Fall                               = 13,
	Long_Fall                                = 14,
	Jump_Ascending                           = 15,
	Jump_Descending                          = 16,
	Downed_Falling                           = 17,
	MagBoots_AttractToGround                 = 18,
	ScriptControlledFlying                   = 19,
	ZeroG_Flying                             = 20,
	ZeroG_Flying_Boosted                     = 21,
	ZeroG_TakeOff                            = 22,
	Downed_ZeroG                             = 23,
	Ladder_Main                              = 24,
	Ladder_Mounting                          = 25,
	Ladder_Dismounting                       = 26,
	Jump_Apex                                = 27,
	AnimDocking                              = 28,
	ScriptControlledCustom                   = 29,
	Traverse                                 = 30,
	FreeCam                                  = 31,
	ZeroG_Attached                           = 32,
	ECAAnimMovementMode_MAX                  = 33,
};

// Enum keaton.ECAAntiCheatMessageType
// NumValues: 0x0003
enum class ECAAntiCheatMessageType : uint8
{
	InitInfo                                 = 1,
	DataBlob                                 = 2,
	ECAAntiCheatMessageType_MAX              = 3,
};

// Enum keaton.ECAArcLensEnemyInspectType
// NumValues: 0x0004
enum class ECAArcLensEnemyInspectType : uint8
{
	Default                                  = 0,
	NPC                                      = 1,
	Teammate                                 = 2,
	ECAArcLensEnemyInspectType_MAX           = 3,
};

// Enum keaton.ECAArcLensPingSlot
// NumValues: 0x0013
enum class ECAArcLensPingSlot : uint8
{
	None                                     = 0,
	PingSlot0                                = 1,
	PingSlot1                                = 2,
	PingSlot2                                = 3,
	PingSlot3                                = 4,
	PingSlot4                                = 5,
	PingSlot5                                = 6,
	PingSlot6                                = 7,
	PingSlot7                                = 8,
	PingSlot8                                = 9,
	PingSlot9                                = 10,
	PingSlot10                               = 11,
	PingSlot11                               = 12,
	PingSlot12                               = 13,
	PingSlot13                               = 14,
	PingSlot14                               = 15,
	PingSlot15                               = 16,
	Invalid                                  = 17,
	ECAArcLensPingSlot_MAX                   = 18,
};

// Enum keaton.ECAArcLensDisguisedState
// NumValues: 0x0005
enum class ECAArcLensDisguisedState : uint8
{
	None                                     = 0,
	AsNPC                                    = 1,
	AsPlayer                                 = 2,
	AsTeammate                               = 3,
	ECAArcLensDisguisedState_MAX             = 4,
};

// Enum keaton.ECAAudioCharacterType
// NumValues: 0x0005
enum class ECAAudioCharacterType : uint8
{
	None                                     = 0,
	NPC                                      = 1,
	EnemyPlayer                              = 2,
	TeamMate                                 = 3,
	ECAAudioCharacterType_MAX                = 4,
};

// Enum keaton.ECAAudioGameplayPhase
// NumValues: 0x0005
enum class ECAAudioGameplayPhase : uint8
{
	None                                     = 0,
	Frontend                                 = 1,
	InGame                                   = 2,
	Results                                  = 3,
	ECAAudioGameplayPhase_MAX                = 4,
};

// Enum keaton.ECAAudioExtractionPhase
// NumValues: 0x0005
enum class ECAAudioExtractionPhase : uint8
{
	None                                     = 0,
	Triggered                                = 1,
	CountingDown                             = 2,
	Departing                                = 3,
	ECAAudioExtractionPhase_MAX              = 4,
};

// Enum keaton.ECAAudioEnemyThreatState
// NumValues: 0x0004
enum class ECAAudioEnemyThreatState : uint8
{
	None                                     = 0,
	Suspicious                               = 1,
	InCombat                                 = 2,
	ECAAudioEnemyThreatState_MAX             = 3,
};

// Enum keaton.ECABaseItemIconOrientation
// NumValues: 0x0004
enum class ECABaseItemIconOrientation : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	ECABaseItemIconOrientation_MAX           = 3,
};

// Enum keaton.ECAPolicyType
// NumValues: 0x0005
enum class ECAPolicyType : uint8
{
	None                                     = 0,
	EULA                                     = 1,
	Privacy                                  = 2,
	CodeOfConduct                            = 3,
	ECAPolicyType_MAX                        = 4,
};

// Enum keaton.ECADamageEventType
// NumValues: 0x000C
enum class ECADamageEventType : uint8
{
	DET_OnZeroHealthEvent                    = 0,
	DET_OnDownedEvent                        = 1,
	DET_OnFullHealthEvent                    = 2,
	DET_OnHealthChangeEvent                  = 3,
	DET_OnHealthChangeEvent_Up               = 4,
	DET_OnHealthChangeEvent_Down             = 5,
	DET_OnArmourChangeEvent                  = 6,
	DET_OnArmourChangeEvent_Up               = 7,
	DET_OnArmourChangeEvent_Down             = 8,
	DET_OnHitReceivedEvent                   = 9,
	DET_OnHitDeliveredEvent                  = 10,
	DET_MAX                                  = 11,
};

// Enum keaton.ETelemetryStatus
// NumValues: 0x0003
enum class ETelemetryStatus : uint8
{
	Begin                                    = 0,
	End                                      = 1,
	ETelemetryStatus_MAX                     = 2,
};

// Enum keaton.ECAStateArrayOperatorType
// NumValues: 0x0003
enum class ECAStateArrayOperatorType : uint8
{
	And                                      = 0,
	Or                                       = 1,
	ECAStateArrayOperatorType_MAX            = 2,
};

// Enum keaton.ECASecurityAreaVaultExtractionState
// NumValues: 0x0009
enum class ECASecurityAreaVaultExtractionState : uint8
{
	VaultNone                                = 0,
	VaultClosed                              = 1,
	VaultBeingHacked                         = 2,
	VaultOpen                                = 3,
	VaultCleared                             = 4,
	ExtractionNone                           = 5,
	ExtractionDeactivated                    = 6,
	ExtractionActivated                      = 7,
	ECASecurityAreaVaultExtractionState_MAX  = 8,
};

// Enum keaton.ECASecurityAreaEncapsulationScope
// NumValues: 0x0004
enum class ECASecurityAreaEncapsulationScope : uint8
{
	Area                                     = 0,
	Module                                   = 1,
	Ship                                     = 2,
	ECASecurityAreaEncapsulationScope_MAX    = 3,
};

// Enum keaton.ECATRAIL_DROP_TYPE
// NumValues: 0x0005
enum class ECATRAIL_DROP_TYPE : uint8
{
	Directional                              = 0,
	Landing                                  = 1,
	Air                                      = 2,
	Entrance                                 = 3,
	ECATRAIL_DROP_MAX                        = 4,
};

// Enum keaton.ECABuddyDialoguePriority
// NumValues: 0x0005
enum class ECABuddyDialoguePriority : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Critical                                 = 3,
	ECABuddyDialoguePriority_MAX             = 4,
};

// Enum keaton.CABuffType
// NumValues: 0x0006
enum class ECABuffType : uint8
{
	OVERRIDEN_BASE                           = 0,
	ADDITIVE                                 = 1,
	MULTIPLICATIVE                           = 2,
	MIN                                      = 3,
	MAX_                                     = 4,
	CABuffType_MAX                           = 5,
};

// Enum keaton.CABuffableValueType
// NumValues: 0x0003
enum class ECABuffableValueType : uint8
{
	INT                                      = 0,
	FLOAT                                    = 1,
	CABuffableValueType_MAX                  = 2,
};

// Enum keaton.ECATPCameraFlags
// NumValues: 0x000A
enum class ECATPCameraFlags : uint8
{
	Reviving                                 = 0,
	Downed                                   = 1,
	UnspectatedProxy                         = 2,
	AnimNotify                               = 3,
	Emote                                    = 4,
	Cheat                                    = 5,
	StartSequence                            = 6,
	CharacterSequence                        = 7,
	Count                                    = 8,
	ECATPCameraFlags_MAX                     = 9,
};

// Enum keaton.EChallengeContextFlags
// NumValues: 0x0013
enum class EChallengeContextFlags : uint8
{
	CCFW_Object                              = 0,
	CCFW_Team                                = 1,
	CCFW_Class                               = 2,
	CCFW_Tags                                = 3,
	CCFW_Name                                = 4,
	CCFW_Movement                            = 5,
	CCFW_Hitbox                              = 6,
	CCFW_Position                            = 7,
	CCFW_SecurityModule                      = 8,
	CCFW_SecurityArea                        = 9,
	CCFW_Surface                             = 10,
	CCFW_Attachment                          = 11,
	CCFW_Score                               = 12,
	CCFW_PreviousTags                        = 13,
	CCFW_Armour                              = 14,
	CCFW_Stats                               = 15,
	CCFW_HitInfo                             = 16,
	CCFW_AreaInfo                            = 17,
	CCFW_MAX                                 = 18,
};

// Enum keaton.ECAChallengeLocations
// NumValues: 0x0004
enum class ECAChallengeLocations : uint8
{
	None                                     = 0,
	Vault                                    = 1,
	FoamedVault                              = 2,
	ECAChallengeLocations_MAX                = 3,
};

// Enum keaton.ECAChallengeHitRequirements
// NumValues: 0x0006
enum class ECAChallengeHitRequirements : uint8
{
	None                                     = 0,
	Backstab                                 = 1,
	WeakpointHit                             = 2,
	WeakpointBroken                          = 3,
	TargetWasFullHealth                      = 4,
	MAX                                      = 5,
};

// Enum keaton.ECAChallengeConstraintContext
// NumValues: 0x0008
enum class ECAChallengeConstraintContext : uint8
{
	CACT_Source                              = 0,
	CACT_Target                              = 1,
	CACT_Using                               = 2,
	CACT_SourceOwner                         = 3,
	CACT_TargetOwner                         = 4,
	CACT_OriginalSource                      = 5,
	CACT_Hit                                 = 6,
	CACT_MAX                                 = 7,
};

// Enum keaton.ECAChallengeConstraintAllegiance
// NumValues: 0x0005
enum class ECAChallengeConstraintAllegiance : uint8
{
	CACA_NotApplicable                       = 0,
	CACA_Neutral                             = 1,
	CACA_Allied                              = 2,
	CACA_Enemy                               = 3,
	CACA_MAX                                 = 4,
};

// Enum keaton.ECAChallengeConstraintApplication
// NumValues: 0x0003
enum class ECAChallengeConstraintApplication : uint8
{
	CACA_Automatic                           = 0,
	CACA_Manual                              = 1,
	CACA_MAX                                 = 2,
};

// Enum keaton.ECAChallengeConstraintScriptOwner
// NumValues: 0x0004
enum class ECAChallengeConstraintScriptOwner : uint8
{
	CACSO_Either                             = 0,
	CACSO_Source                             = 1,
	CACSO_Target                             = 2,
	CACSO_MAX                                = 3,
};

// Enum keaton.ECAChallengeConstraintLogic
// NumValues: 0x0003
enum class ECAChallengeConstraintLogic : uint8
{
	CACL_Include                             = 0,
	CACL_Exclude                             = 1,
	CACL_MAX                                 = 2,
};

// Enum keaton.ECAChallengeEventFlags
// NumValues: 0x0022
enum class ECAChallengeEventFlags : uint8
{
	CACE_Custom                              = 0,
	CACE_Challenge                           = 1,
	CACE_EndOfMatch                          = 2,
	CACE_Performed                           = 3,
	CACE_Killed                              = 4,
	CACE_Damaged                             = 5,
	CACE_Downed                              = 6,
	CACE_Interacted                          = 7,
	CACE_Extracted                           = 8,
	CACE_LootCollected                       = 9,
	CACE_Dropped                             = 10,
	CACE_Movement                            = 11,
	CACE_Foamed                              = 12,
	CACE_SpottedBy                           = 13,
	CACE_NonLootCollected                    = 14,
	CACE_DamageAbsorbed                      = 15,
	CACE_StartOfMatch                        = 16,
	CACE_Completed                           = 17,
	CACE_Rank                                = 18,
	CACE_AffectedByAbility                   = 19,
	CACE_TagsChanged                         = 20,
	CACE_Defoamed                            = 21,
	CACE_Deployed                            = 22,
	CACE_AssistedKill                        = 23,
	CACE_Breached                            = 24,
	CACE_Entered                             = 25,
	CACE_Exited                              = 26,
	CACE_AssistedHeal                        = 27,
	CACE_Assist                              = 28,
	CACE_Respawn                             = 29,
	CACE_ArmourDamaged                       = 30,
	CACE_ArmourBroken                        = 31,
	EventCount                               = 32,
	ECAChallengeEventFlags_MAX               = 33,
};

// Enum keaton.EBooleanOutputPin
// NumValues: 0x0003
enum class EBooleanOutputPin : uint8
{
	Success                                  = 0,
	Failure                                  = 1,
	EBooleanOutputPin_MAX                    = 2,
};

// Enum keaton.ECAInputType
// NumValues: 0x0004
enum class ECAInputType : uint8
{
	Movement                                 = 0,
	Camera                                   = 1,
	Generic                                  = 2,
	ECAInputType_MAX                         = 3,
};

// Enum keaton.ECAMaxCharmedNPCType
// NumValues: 0x0005
enum class ECAMaxCharmedNPCType : uint8
{
	NPCCountPerPlayer                        = 0,
	NPCTokenValuePerPlayer                   = 1,
	NPCCountPerTeam                          = 2,
	NPCTokenValuePerTeam                     = 3,
	ECAMaxCharmedNPCType_MAX                 = 4,
};

// Enum keaton.ECACharmedNPCDisposalSelectionType
// NumValues: 0x0006
enum class ECACharmedNPCDisposalSelectionType : uint8
{
	Distance                                 = 0,
	Age                                      = 1,
	Health                                   = 2,
	HighestTokenCost                         = 3,
	LowestTokenCost                          = 4,
	ECACharmedNPCDisposalSelectionType_MAX   = 5,
};

// Enum keaton.ECACharmedNPCDisposalType
// NumValues: 0x0007
enum class ECACharmedNPCDisposalType : uint8
{
	TeleportOut                              = 0,
	SetToDespawn                             = 1,
	ReturnToBindPoint                        = 2,
	BindToCurrentLocation                    = 3,
	BindToPlayersLastKnownLocation           = 4,
	BindToTeamMate                           = 5,
	ECACharmedNPCDisposalType_MAX            = 6,
};

// Enum keaton.ECI_Gamepad_SprintInputMode
// NumValues: 0x0007
enum class ECI_Gamepad_SprintInputMode : uint8
{
	CI_Toggle                                = 0,
	CI_Hold                                  = 1,
	CI_Auto                                  = 2,
	CI_Goto                                  = 3,
	CI_UseSettings                           = 4,
	CI_DoNotChange                           = 5,
	CI_MAX                                   = 6,
};

// Enum keaton.ECAAimAssistTargetType
// NumValues: 0x0004
enum class ECAAimAssistTargetType : uint8
{
	Friction                                 = 0,
	Rotation                                 = 1,
	BulletMagnetism                          = 2,
	ECAAimAssistTargetType_MAX               = 3,
};

// Enum keaton.ECANPCMoveToTargetFailureCorrectionType
// NumValues: 0x000B
enum class ECANPCMoveToTargetFailureCorrectionType : uint8
{
	IfPlayerObservableSetLocationToGoalLocation = 0,
	IfNotPlayerObservableSetLocationToGoalLocation = 1,
	IfPlayerObservableSetLocationToLastGoodLocation = 2,
	IfNotPlayerObservableSetLocationToLastGoodLocation = 3,
	IfPlayerObservableTeleportOut            = 4,
	IfNotPlayerObservableTeleportOut         = 5,
	IfPlayerObservableDie                    = 6,
	IfNotPlayerObservableDie                 = 7,
	IfPlayerObservableTryPushToNearestNavMesh = 8,
	IfNotPlayerObservableTryPushToNearestNavMesh = 9,
	ECANPCMoveToTargetFailureCorrectionType_MAX = 10,
};

// Enum keaton.ECANPCMoveToTargetFailureType
// NumValues: 0x0010
enum class ECANPCMoveToTargetFailureType : uint8
{
	Default                                  = 0,
	PathBlocked                              = 1,
	NullPtrMemories                          = 2,
	ImmobilisedStatus                        = 3,
	NullLocationAssignmentManager            = 4,
	NonVectorLocation                        = 5,
	NoTargetObject                           = 6,
	NoAssignedMission                        = 7,
	ZeroVectorTargetLocation                 = 8,
	ReservedAttackLocations                  = 9,
	ProjectedLocationInDifferentRoom         = 10,
	NoPathExists                             = 11,
	NoPathExistsToBindPoint                  = 12,
	LocationNotOnNavMesh                     = 13,
	LocationOutsideOfMissionArea             = 14,
	ECANPCMoveToTargetFailureType_MAX        = 15,
};

// Enum keaton.ECANPCDialogueTriggerType
// NumValues: 0x0009
enum class ECANPCDialogueTriggerType : uint8
{
	None                                     = 0,
	BuffAlly                                 = 1,
	BuffedByAlly                             = 2,
	HealAlly                                 = 3,
	HealedByAlly                             = 4,
	HealSelf                                 = 5,
	ExecutePlayer                            = 6,
	RetrieveLoot                             = 7,
	ECANPCDialogueTriggerType_MAX            = 8,
};

// Enum keaton.ECAAbilityType
// NumValues: 0x0004
enum class ECAAbilityType : uint8
{
	None                                     = 0,
	Primary                                  = 1,
	Secondary                                = 2,
	MAX                                      = 3,
};

// Enum keaton.FCACharacterCombatEventType
// NumValues: 0x0004
enum class EFCACharacterCombatEventType : uint32
{
	Missed                                   = 0,
	HitEnemy                                 = 1,
	HitByEnemy                               = 2,
	FCACharacterCombatEventType_MAX          = 3,
};

// Enum keaton.ECADebugDrawTypes
// NumValues: 0x000A
enum class ECADebugDrawTypes : uint8
{
	DebugPoint                               = 0,
	DebugString                              = 1,
	DebugLine                                = 2,
	DebugSphere                              = 3,
	DebugCone                                = 4,
	DebugBox                                 = 5,
	DebugArrow                               = 6,
	DebugUI                                  = 7,
	NumDebugTypes                            = 8,
	ECADebugDrawTypes_MAX                    = 9,
};

// Enum keaton.ECADebugItems
// NumValues: 0x0025
enum class ECADebugItems : uint8
{
	Name                                     = 0,
	Memories                                 = 1,
	LastSensed                               = 2,
	Target                                   = 3,
	MoveTo                                   = 4,
	Attack                                   = 5,
	Health                                   = 6,
	Senses                                   = 7,
	CombatJump                               = 8,
	Audio                                    = 9,
	BTNodeHistory                            = 10,
	BTNodeTrail                              = 11,
	View                                     = 12,
	Teams                                    = 13,
	BehaviourTree                            = 14,
	Path                                     = 15,
	Goals                                    = 16,
	Flying                                   = 17,
	DesiredAnimState                         = 18,
	HitChance                                = 19,
	Awareness                                = 20,
	DialogueState                            = 21,
	Motivations                              = 22,
	ViewSimple                               = 23,
	MissionDetails                           = 24,
	Cover                                    = 25,
	BindPoint                                = 26,
	PauseLogic_Selected                      = 27,
	PauseLogic_All                           = 28,
	DialogueTeamId                           = 29,
	MoveToTargetFailures                     = 30,
	ContestedTarget                          = 31,
	IgnorePermissions                        = 32,
	LineOfFireEQS                            = 33,
	IdleBehaviour                            = 34,
	NPCNumDebugItems                         = 35,
	ECADebugItems_MAX                        = 36,
};

// Enum keaton.ECHUDZeroGAbilityMode
// NumValues: 0x0004
enum class ECHUDZeroGAbilityMode : uint8
{
	GravHook                                 = 0,
	DirectionalBoost                         = 1,
	Ballerina                                = 2,
	ECHUDZeroGAbilityMode_MAX                = 3,
};

// Enum keaton.ECATransitionOverrideState
// NumValues: 0x0004
enum class ECATransitionOverrideState : uint8
{
	NONE                                     = 0,
	CANCELS                                  = 3,
	CONCURRENT                               = 4,
	ECATransitionOverrideState_MAX           = 5,
};

// Enum keaton.ECATransitionState
// NumValues: 0x0007
enum class ECATransitionState : uint8
{
	SELF                                     = 0,
	SYS                                      = 1,
	BLOCKED                                  = 2,
	CANCELS                                  = 3,
	CONCURRENT                               = 4,
	PARENT                                   = 5,
	ECATransitionState_MAX                   = 6,
};

// Enum keaton.ECACustomisationPartFirstPersonVisibility
// NumValues: 0x0006
enum class ECACustomisationPartFirstPersonVisibility : uint8
{
	FollowFirstPersonSkeleton                = 0,
	FollowThirdPersonSkeleton                = 1,
	FollowThirdPersonSkeleton_OnlyShadowsForFirstPerson = 2,
	FollowThirdPersonSkeleton_DuplicatedForFirstPerson = 3,
	FollowThirdPersonSkeleton_OnlyShadowsNoCollapsed = 4,
	MAX                                      = 5,
};

// Enum keaton.ECAVisibilityGroup
// NumValues: 0x0006
enum class ECAVisibilityGroup : uint8
{
	All                                      = 0,
	FirstPerson                              = 1,
	FirstPersonOnlyFirstPersonSkeleton       = 2,
	FirstPersonOnlyThirdPersonSkeleton       = 3,
	ThirdPerson                              = 4,
	MAX                                      = 5,
};

// Enum keaton.ECharacterSignificanceLevel
// NumValues: 0x0007
enum class ECharacterSignificanceLevel : uint8
{
	Offscreen                                = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	Critical                                 = 4,
	Num                                      = 5,
	ECharacterSignificanceLevel_MAX          = 6,
};

// Enum keaton.ECAGameModeType
// NumValues: 0x0005
enum class ECAGameModeType : uint8
{
	None                                     = 0,
	PVP                                      = 1,
	PVE                                      = 2,
	Neutral                                  = 3,
	ECAGameModeType_MAX                      = 4,
};

// Enum keaton.ECACosmeticType
// NumValues: 0x0007
enum class ECACosmeticType : uint8
{
	Cosmetic_Invalid                         = 0,
	Cosmetic_SpecialistSkin                  = 1,
	Cosmetic_WeaponSkin                      = 2,
	Cosmetic_WeaponPendant                   = 3,
	Cosmetic_Emote                           = 4,
	Cosmetic_Spray                           = 5,
	Cosmetic_MAX                             = 6,
};

// Enum keaton.ECAReleaseState
// NumValues: 0x0006
enum class ECAReleaseState : uint8
{
	Stage_1__ProofOfConcept                  = 0,
	Stage_2__Prototype                       = 1,
	Stage_3__PreAlpha                        = 2,
	Stage_4__ReadyForRelease                 = 3,
	Stage_5__ApprovedForRelease              = 4,
	Stage_MAX                                = 5,
};

// Enum keaton.ECACollisionLayerType
// NumValues: 0x0012
enum class ECACollisionLayerType : uint8
{
	ECLT_World                               = 0,
	ECLT_Pawn                                = 1,
	ECLT_Gravity                             = 2,
	ECLT_Security                            = 3,
	ECLT_Radiation                           = 4,
	ECLT_Pressure                            = 5,
	ECLT_Sensor                              = 6,
	ECLT_AreaOfEffect                        = 7,
	ECLT_Interaction                         = 8,
	ECLT_Augmentation                        = 9,
	ECLT_Foam                                = 10,
	ECLT_TargetObject                        = 11,
	ECLT_RemoteAccess                        = 12,
	ECLT_Module                              = 13,
	ECLT_Extraction                          = 14,
	ECLT_Information                         = 15,
	ECLT_Count                               = 16,
	ECLT_MAX                                 = 17,
};

// Enum keaton.ECACollisionPrimitiveType
// NumValues: 0x0008
enum class ECACollisionPrimitiveType : uint8
{
	ECPT_Point                               = 0,
	ECPT_Sphere                              = 1,
	ECPT_Box                                 = 2,
	ECPT_AlignedBox                          = 3,
	ECPT_Zone                                = 4,
	ECPT_Capsule                             = 5,
	ECPT_Invalid                             = 6,
	ECPT_MAX                                 = 7,
};

// Enum keaton.ECACommsMessageTypes
// NumValues: 0x0006
enum class ECACommsMessageTypes : uint8
{
	CommsInvalidMessage                      = 0,
	CommsNotifyEnemySighted                  = 1,
	CommsNotifyEnemyLostSight                = 2,
	CommsNotifyDamageTaken                   = 3,
	CommsNotifyEnemySightedUpdate            = 4,
	ECACommsMessageTypes_MAX                 = 5,
};

// Enum keaton.ECAAttackRange
// NumValues: 0x0007
enum class ECAAttackRange : uint8
{
	Melee                                    = 0,
	Short                                    = 1,
	Medium                                   = 2,
	Long                                     = 3,
	Sniper                                   = 4,
	NUM                                      = 5,
	ECAAttackRange_MAX                       = 6,
};

// Enum keaton.ECAAttackResult
// NumValues: 0x0005
enum class ECAAttackResult : uint8
{
	None                                     = 0,
	Fire                                     = 1,
	Reload                                   = 2,
	Cancel                                   = 3,
	ECAAttackResult_MAX                      = 4,
};

// Enum keaton.ECADebugAttackResult
// NumValues: 0x000A
enum class ECADebugAttackResult : uint8
{
	NotAttacking                             = 0,
	Firing                                   = 1,
	Disarmed                                 = 2,
	Sprinting                                = 3,
	BeamTargetNoLineOfFire                   = 4,
	NoLineOfFire                             = 5,
	NoAttackPermission                       = 6,
	TargetObjectInvalid                      = 7,
	TargetOutOfRange                         = 8,
	ECADebugAttackResult_MAX                 = 9,
};

// Enum keaton.ECADialogueState
// NumValues: 0x000E
enum class ECADialogueState : uint8
{
	Unaware                                  = 0,
	Combat                                   = 1,
	Suspicious                               = 2,
	Search                                   = 3,
	Despawn                                  = 4,
	Patrol                                   = 5,
	DefendCurrentLocation                    = 6,
	CombatDeploy                             = 7,
	AttackHighPriorityTargetObject           = 8,
	AttackMediumPriorityTargetObject         = 9,
	AttackLowPriorityTargetObject            = 10,
	ShootTarget                              = 11,
	MoveToAttackLocation                     = 12,
	ECADialogueState_MAX                     = 13,
};

// Enum keaton.ECANPCTargetObjectMoveAcceptanceType
// NumValues: 0x0003
enum class ECANPCTargetObjectMoveAcceptanceType : uint8
{
	MoveToWithinMaximumWeaponRange           = 0,
	MoveToDefinedDistance                    = 1,
	ECANPCTargetObjectMoveAcceptanceType_MAX = 2,
};

// Enum keaton.ECANPCTargetObjectAttackType
// NumValues: 0x0003
enum class ECANPCTargetObjectAttackType : uint8
{
	Shoot                                    = 0,
	SpecialAbility                           = 1,
	ECANPCTargetObjectAttackType_MAX         = 2,
};

// Enum keaton.ECANPCTargetObjectPriority
// NumValues: 0x0005
enum class ECANPCTargetObjectPriority : uint8
{
	High                                     = 0,
	Contested                                = 1,
	Medium                                   = 2,
	Low                                      = 3,
	ECANPCTargetObjectPriority_MAX           = 4,
};

// Enum keaton.ECANPCTargetAssignmentReason
// NumValues: 0x000D
enum class ECANPCTargetAssignmentReason : uint8
{
	None                                     = 0,
	HackedNPC                                = 1,
	Distance                                 = 2,
	Health                                   = 3,
	CurrentlyAssigned                        = 4,
	Security                                 = 5,
	Sight                                    = 6,
	Damage                                   = 7,
	Hearing                                  = 8,
	Touch                                    = 9,
	WeaponNoise                              = 10,
	NumberOfReasons                          = 11,
	ECANPCTargetAssignmentReason_MAX         = 12,
};

// Enum keaton.ECAConnectionStatus
// NumValues: 0x0004
enum class ECAConnectionStatus : uint8
{
	Unknown                                  = 0,
	NotConnected                             = 1,
	Connected                                = 2,
	ECAConnectionStatus_MAX                  = 3,
};

// Enum keaton.ECARarity
// NumValues: 0x0005
enum class ECARarity : uint8
{
	Default                                  = 0,
	Common                                   = 1,
	Epic                                     = 2,
	Legendary                                = 3,
	MAX                                      = 4,
};

// Enum keaton.ECACosmeticSlot
// NumValues: 0x0005
enum class ECACosmeticSlot : uint8
{
	SPECIALIST_SKIN                          = 0,
	WEAPON_SKINS                             = 1,
	PENDANTS                                 = 2,
	INVALID                                  = 3,
	ECACosmeticSlot_MAX                      = 4,
};

// Enum keaton.ECAFirstPersonAttachment
// NumValues: 0x0005
enum class ECAFirstPersonAttachment : uint8
{
	FollowThirdPersonSkeleton                = 0,
	FollowFirstPersonSkeleton                = 1,
	None                                     = 2,
	FollowBothSkeleton                       = 3,
	MAX                                      = 4,
};

// Enum keaton.ECADamageGameplayEventFlags
// NumValues: 0x0009
enum class ECADamageGameplayEventFlags : uint8
{
	None                                     = 0,
	ArmourBroken                             = 1,
	Downed                                   = 2,
	Killed                                   = 4,
	Critical                                 = 8,
	Headshot                                 = 16,
	Explosive                                = 32,
	ReceiveDamage                            = 64,
	ECADamageGameplayEventFlags_MAX          = 65,
};

// Enum keaton.ECADeathSource
// NumValues: 0x0003
enum class ECADeathSource : uint8
{
	Gun                                      = 0,
	Explosive                                = 1,
	ECADeathSource_MAX                       = 2,
};

// Enum keaton.EDebugData_Flags
// NumValues: 0x0016
enum class EDebugData_Flags : uint8
{
	Invisible                                = 0,
	Inaudible                                = 1,
	Infinite_Ammo                            = 2,
	Invulnerable                             = 3,
	Flying                                   = 4,
	Healed                                   = 5,
	Zero_G                                   = 6,
	GiveAmmo                                 = 7,
	GiveWeapons                              = 8,
	Camera                                   = 9,
	KilledNPCInView                          = 10,
	KilledNearbyNPCs                         = 11,
	DebugScore                               = 12,
	MinimapTeleport                          = 13,
	DebugAddItem                             = 14,
	AutoHeal                                 = 15,
	HasEverCheated                           = 28,
	CheatsAllowed                            = 29,
	CheatsUnlocked                           = 30,
	CheatsSilenced                           = 31,
	Max                                      = 32,
	EDebugData_MAX                           = 33,
};

// Enum keaton.ECALoadoutSlot
// NumValues: 0x0008
enum class ECALoadoutSlot : uint8
{
	PRIMARY_WEAPONS                          = 0,
	SECONDARY_WEAPONS                        = 1,
	UTILITY_ITEMS                            = 2,
	MELEE_WEAPONS                            = 3,
	HEALING_ITEMS                            = 4,
	INVALID                                  = 5,
	DEPENDENT                                = 6,
	ECALoadoutSlot_MAX                       = 7,
};

// Enum keaton.EDetectorEffectState
// NumValues: 0x0004
enum class EDetectorEffectState : uint8
{
	Scanning                                 = 0,
	Detected                                 = 1,
	Combat                                   = 2,
	EDetectorEffectState_MAX                 = 3,
};

// Enum keaton.ECADialogueAnimNotifyPerspective
// NumValues: 0x0004
enum class ECADialogueAnimNotifyPerspective : uint8
{
	FirstPerson                              = 0,
	ThirdPerson                              = 1,
	Enemy                                    = 2,
	ECADialogueAnimNotifyPerspective_MAX     = 3,
};

// Enum keaton.ECADialoguePlayerState
// NumValues: 0x0004
enum class ECADialoguePlayerState : uint8
{
	Exploration                              = 0,
	Combat                                   = 1,
	Stealth                                  = 2,
	ECADialoguePlayerState_MAX               = 3,
};

// Enum keaton.ECANotificationPriority
// NumValues: 0x000A
enum class ECANotificationPriority : uint8
{
	Critical                                 = 0,
	ServicesError                            = 1,
	Celebration                              = 2,
	Immediate                                = 3,
	PartyInvite                              = 4,
	FriendInvite                             = 5,
	BattleResults                            = 6,
	Incidental                               = 7,
	Whenever                                 = 8,
	ECANotificationPriority_MAX              = 9,
};

// Enum keaton.ECADialogueVariantType
// NumValues: 0x0005
enum class ECADialogueVariantType : uint8
{
	INT32                                    = 0,
	FLOAT                                    = 1,
	NAME                                     = 2,
	INVALID                                  = 3,
	ECADialogueVariantType_MAX               = 4,
};

// Enum keaton.ECADragQueenBalancingVariableType
// NumValues: 0x000C
enum class ECADragQueenBalancingVariableType : uint8
{
	ABSORB_MAXDAMAGE                         = 0,
	ABSORB_MINDAMAGE                         = 1,
	ABSORB_MINIMPULSE_NPC                    = 2,
	ABSORB_MAXIMPULSE_NPC                    = 3,
	ABSORB_MINIMPULSE_PLAYER                 = 4,
	ABSORB_MAXIMPULSE_PLAYER                 = 5,
	ABSORB_ZEROGIMPULSEBONUS_NPC             = 6,
	ABSORB_ZEROGIMPULSEBONUS_PLAYER          = 7,
	ABSORB_MINDAMAGE_FOAM                    = 8,
	ABSORB_DAMAGE_MULTIPLIER                 = 9,
	Count                                    = 10,
	ECADragQueenBalancingVariableType_MAX    = 11,
};

// Enum keaton.EQualityLevel
// NumValues: 0x0006
enum class EQualityLevel : uint8
{
	QL_Low                                   = 0,
	QL_Medium                                = 1,
	QL_High                                  = 2,
	QL_Epic                                  = 3,
	QL_Cinematic                             = 4,
	QL_MAX                                   = 5,
};

// Enum keaton.EQualityType
// NumValues: 0x0008
enum class EQualityType : uint8
{
	QT_ViewDistance                          = 0,
	QT_AntiAliasing                          = 1,
	QT_Shadow                                = 2,
	QT_PostProcess                           = 3,
	QT_Texture                               = 4,
	QT_Effects                               = 5,
	QT_Foliage                               = 6,
	QT_MAX                                   = 7,
};

// Enum keaton.ECAQueueEventType
// NumValues: 0x0005
enum class ECAQueueEventType : uint8
{
	None                                     = 0,
	AllChanged                               = 1,
	ItemChanged                              = 2,
	PendingChanged                           = 3,
	ECAQueueEventType_MAX                    = 4,
};

// Enum keaton.ECABoolOutputPins
// NumValues: 0x0003
enum class ECABoolOutputPins : uint8
{
	Yes                                      = 0,
	No                                       = 1,
	ECABoolOutputPins_MAX                    = 2,
};

// Enum keaton.ECALevelUpOutputPins
// NumValues: 0x0003
enum class ECALevelUpOutputPins : uint8
{
	LevelUpAvailable                         = 0,
	LevelUpUnavailable                       = 1,
	ECALevelUpOutputPins_MAX                 = 2,
};

// Enum keaton.ECAEntitlementPropertyOutputPins
// NumValues: 0x0007
enum class ECAEntitlementPropertyOutputPins : uint8
{
	Entitled                                 = 0,
	Affordable_Now                           = 1,
	Affordable_Later                         = 2,
	Available_by_reward                      = 3,
	Unavailable                              = 4,
	Unavaliable_Owned                        = 5,
	ECAEntitlementPropertyOutputPins_MAX     = 6,
};

// Enum keaton.ECAPurchaseState
// NumValues: 0x0006
enum class ECAPurchaseState : uint8
{
	None                                     = 0,
	Unlock                                   = 1,
	UnlockResults                            = 2,
	Equip                                    = 3,
	EquipFail                                = 4,
	ECAPurchaseState_MAX                     = 5,
};

// Enum keaton.ECANPCPathType
// NumValues: 0x0009
enum class ECANPCPathType : uint8
{
	Sentinel                                 = 0,
	Patrol                                   = 1,
	OuterAreaInnerLocations                  = 2,
	OuterAreaOuterLocations                  = 3,
	InnerAreaInnerLocations                  = 4,
	InnerAreaOuterLocations                  = 5,
	MissionObjectiveAreaInnerLocations       = 6,
	MissionObjectiveAreaOuterLocations       = 7,
	ECANPCPathType_MAX                       = 8,
};

// Enum keaton.EEquipmentSlotID
// NumValues: 0x0006
enum class EEquipmentSlotID : uint8
{
	PrimaryHeavy                             = 0,
	PrimaryLight                             = 1,
	SecondaryLight                           = 2,
	MeleeHidden                              = 3,
	MeleeKnife                               = 4,
	EEquipmentSlotID_MAX                     = 5,
};

// Enum keaton.ECCALaunchType
// NumValues: 0x0003
enum class ECCALaunchType : uint8
{
	DirectFire                               = 0,
	IndirectProjectile                       = 1,
	ECCALaunchType_MAX                       = 2,
};

// Enum keaton.EEquipmentSlotPriority
// NumValues: 0x0003
enum class EEquipmentSlotPriority : uint8
{
	SlotPrimary                              = 0,
	SlotSecondary                            = 1,
	EEquipmentSlotPriority_MAX               = 2,
};

// Enum keaton.EExtractionType
// NumValues: 0x0003
enum class EExtractionType : uint8
{
	Area                                     = 0,
	Gadget                                   = 1,
	EExtractionType_MAX                      = 2,
};

// Enum keaton.ECAGameExtractionState
// NumValues: 0x0004
enum class ECAGameExtractionState : uint8
{
	NoExtraction                             = 0,
	SingleExtraction                         = 1,
	MultipleExtractions                      = 2,
	MAX                                      = 3,
};

// Enum keaton.EExtractionAreaVisualState
// NumValues: 0x0007
enum class EExtractionAreaVisualState : uint8
{
	NotEnabled                               = 0,
	NotOccupied                              = 1,
	Occupied                                 = 2,
	Capturing                                = 3,
	Contested                                = 4,
	OneTeamSufficientLootDecapturing         = 5,
	EExtractionAreaVisualState_MAX           = 6,
};

// Enum keaton.EExtractionMapIconVisibility
// NumValues: 0x0005
enum class EExtractionMapIconVisibility : uint8
{
	None                                     = 0,
	PlayerOnly                               = 1,
	TeamOnly                                 = 2,
	All                                      = 3,
	EExtractionMapIconVisibility_MAX         = 4,
};

// Enum keaton.ECAInputImpulseType
// NumValues: 0x0004
enum class ECAInputImpulseType : uint8
{
	None                                     = 0,
	Avoidance                                = 1,
	Impulse                                  = 2,
	ECAInputImpulseType_MAX                  = 3,
};

// Enum keaton.ECAConsumableKeyInfo
// NumValues: 0x000B
enum class ECAConsumableKeyInfo : uint8
{
	Zerog_StepDown                           = 0,
	Zerog_StepForward                        = 1,
	GravHook_Start                           = 2,
	GravHook_Montage_done                    = 3,
	GravHook_Cancel                          = 4,
	GravHook_Finished                        = 5,
	ActivateMagBoots                         = 6,
	Jump                                     = 7,
	Max                                      = 8,
	None                                     = 9,
	ECAConsumableKeyInfo_MAX                 = 10,
};

// Enum keaton.ECAFPFResultType
// NumValues: 0x000C
enum class ECAFPFResultType : uint8
{
	FPFResult_Error                          = 0,
	FPFResult_AlreadyAtGoal                  = 1,
	FPFResult_Success                        = 2,
	FPFResult_Success_Partial                = 3,
	FPFResult_Fail_InvalidStartCell          = 4,
	FPFResult_Fail_InvalidEndCell            = 5,
	FPFResult_Fail_NoGridPath                = 6,
	FPFResult_Fail_NoExternalPath            = 7,
	FPFResult_Fail_SearchLimitReached        = 8,
	FPFResult_Fail_StartCellUnreachable      = 9,
	FPFResult_Fail_EndCellUnreachable        = 10,
	FPFResult_MAX                            = 11,
};

// Enum keaton.EFoamBlobState
// NumValues: 0x0006
enum class EFoamBlobState : uint8
{
	EFBS_WaitingToForm                       = 0,
	EFBS_Forming                             = 1,
	EFBS_Formed                              = 2,
	EFBS_Destroyed                           = 3,
	EFBS_Blocked                             = 4,
	EFBS_MAX                                 = 5,
};

// Enum keaton.ECAAlignmentPosition
// NumValues: 0x0006
enum class ECAAlignmentPosition : uint8
{
	Up                                       = 0,
	Down                                     = 1,
	Right                                    = 2,
	Left                                     = 3,
	None                                     = 4,
	ECAAlignmentPosition_MAX                 = 5,
};

// Enum keaton.ECAFoamMode
// NumValues: 0x0003
enum class ECAFoamMode : uint8
{
	Horizontal                               = 0,
	Vertical                                 = 1,
	ECAFoamMode_MAX                          = 2,
};

// Enum keaton.ECAFSMState
// NumValues: 0x0004
enum class ECAFSMState : uint8
{
	StateChanged                             = 0,
	TransitionDenied                         = 1,
	AllTransitionsComplete                   = 2,
	ECAFSMState_MAX                          = 3,
};

// Enum keaton.ECAFlowDirection
// NumValues: 0x0008
enum class ECAFlowDirection : uint8
{
	None                                     = 0,
	Internal                                 = 1,
	Incoming                                 = 2,
	Outgoing                                 = 3,
	Bounce                                   = 4,
	InternalNoForward                        = 5,
	IncomingNoForward                        = 6,
	ECAFlowDirection_MAX                     = 7,
};

// Enum keaton.ECAFlowAction
// NumValues: 0x0004
enum class ECAFlowAction : uint8
{
	None                                     = 0,
	Return                                   = 1,
	Continue                                 = 2,
	ECAFlowAction_MAX                        = 3,
};

// Enum keaton.ECAFSMTransitionAction
// NumValues: 0x001F
enum class ECAFSMTransitionAction : uint8
{
	None                                     = 0,
	PrimaryProgression                       = 1,
	SecondaryProgression                     = 2,
	TertiaryProgression                      = 3,
	Continue                                 = 4,
	Return                                   = 5,
	Canceling                                = 6,
	Selecting                                = 7,
	Editing                                  = 8,
	Waiting                                  = 9,
	Go_FastTrack_EntryPoint                  = 10,
	Go_Frontend_Home                         = 11,
	Go_Frontend_Collection                   = 12,
	Go_Frontend_BattlePass                   = 13,
	Go_Frontend_Shop                         = 14,
	Go_Frontend_Social                       = 15,
	Go_EndMatch_Scoreboard                   = 16,
	Go_EndMatch_Progression                  = 17,
	Go_EndMatch_Challenges                   = 18,
	Go_EndMatch_StatList                     = 19,
	Go_Settings_Options                      = 20,
	Go_Settings_Keyboard                     = 21,
	Go_Settings_Controller                   = 22,
	Go_Settings_Exit_Game                    = 23,
	Go_Settings_Overlay                      = 24,
	Go_Social_Friends                        = 25,
	Go_Social_Recent                         = 26,
	Go_Social_Search                         = 27,
	Go_Social_Settings                       = 28,
	ALL                                      = 29,
	MAX                                      = 30,
};

// Enum keaton.ECAFLowState
// NumValues: 0x0038
enum class ECAFLowState : uint8
{
	None                                     = 0,
	StateStart                               = 1,
	StateFrontendStartUp                     = 2,
	StateStartUpInitiate                     = 3,
	StateStartUpPlatformLogin                = 4,
	StateStartUpAuthenticate                 = 5,
	StateStartUpRefreshUserData              = 6,
	StateStartUpContextBranch                = 7,
	StateStartUpSplash                       = 8,
	StateStartUpMOTD                         = 9,
	StateStartUpVideo                        = 10,
	StateStartUpLevelUp                      = 11,
	StateStartUpConfigureUI                  = 12,
	StateStartUpMatchResults                 = 13,
	State_Frontend_Configure                 = 14,
	State_Frontend_Hub                       = 15,
	State_Frontend_Collection                = 16,
	State_Frontend_Shop                      = 17,
	State_Frontend_Matchmaking               = 18,
	State_Frontend_Home                      = 19,
	State_Frontend_Social                    = 20,
	State_Frontend_FactionPass               = 21,
	StateDebugServer                         = 22,
	StateOptions                             = 23,
	StateDevTesting                          = 24,
	StateVanStartUp                          = 25,
	StateVanHome                             = 26,
	StateVanCharacterSelect                  = 27,
	StateVanRemoteCharacterSelect            = 28,
	StateVanLoadoutEdit                      = 29,
	StateVanGetReady                         = 30,
	StateVanPrepareLineUp                    = 31,
	StateVanLineUp                           = 32,
	StateVanSkinSelect                       = 33,
	StateVanLockDown                         = 34,
	StateGlobalLoggedOut                     = 35,
	State_Global_PlayerProfile               = 36,
	State_EndMatch_Configure                 = 37,
	State_EndMatch_Hub                       = 38,
	State_EndMatch_Scoreboard                = 39,
	State_EndMatch_Progression               = 40,
	State_EndMatch_Challenges                = 41,
	State_EndMatch_StatList                  = 42,
	State_Settings_Configure                 = 43,
	State_Settings_Hub                       = 44,
	State_Settings_Options                   = 45,
	State_Settings_Keyboard                  = 46,
	State_Settings_Controller                = 47,
	State_Settings_Exit_Game                 = 48,
	State_Settings_Overlay                   = 49,
	State_Social_Friends                     = 50,
	State_Social_Hub                         = 51,
	State_Social_Search                      = 52,
	State_Social_Recent                      = 53,
	State_Social_Settings                    = 54,
	MAX                                      = 55,
};

// Enum keaton.ECAIndicatorValueType
// NumValues: 0x0004
enum class ECAIndicatorValueType : uint8
{
	GameModeType                             = 0,
	PartyCapacity                            = 1,
	CurrentNumberOfTeams                     = 2,
	ECAIndicatorValueType_MAX                = 3,
};

// Enum keaton.EPlayerMatchPhase
// NumValues: 0x0005
enum class EPlayerMatchPhase : uint8
{
	WaitingForStart                          = 0,
	MatchInProgress                          = 1,
	ReadyToExtract                           = 2,
	MatchEnded                               = 3,
	EPlayerMatchPhase_MAX                    = 4,
};

// Enum keaton.ECAGameModeFlag
// NumValues: 0x0006
enum class ECAGameModeFlag : uint8
{
	PostSeamlessTravel                       = 0,
	GameOptionsLoaded                        = 1,
	ActorsInitialized                        = 2,
	GameStarted                              = 3,
	GameEnded                                = 4,
	ECAGameModeFlag_MAX                      = 5,
};

// Enum keaton.ECALootDistributionPolicy
// NumValues: 0x0004
enum class ECALootDistributionPolicy : uint8
{
	None                                     = 0,
	Value                                    = 1,
	Ratio                                    = 2,
	ECALootDistributionPolicy_MAX            = 3,
};

// Enum keaton.ECARespawnPolicy
// NumValues: 0x0004
enum class ECARespawnPolicy : uint8
{
	Automatic                                = 0,
	Manual                                   = 1,
	Team                                     = 2,
	ECARespawnPolicy_MAX                     = 3,
};

// Enum keaton.ECAPlayerElimination
// NumValues: 0x000A
enum class ECAPlayerElimination : uint8
{
	Downed                                   = 0,
	Killed                                   = 1,
	Extracted                                = 2,
	Disconnected                             = 3,
	Success                                  = 4,
	Failed                                   = 5,
	TimeOut                                  = 6,
	TeamWiped                                = 7,
	Spectating                               = 8,
	ECAPlayerElimination_MAX                 = 9,
};

// Enum keaton.ECASpawnSelection
// NumValues: 0x0007
enum class ECASpawnSelection : uint8
{
	Fixed                                    = 0,
	Random                                   = 1,
	Scripted                                 = 2,
	TeamSpawn                                = 3,
	TeamNearest                              = 4,
	Map                                      = 5,
	ECASpawnSelection_MAX                    = 6,
};

// Enum keaton.EThresholdType
// NumValues: 0x0004
enum class EThresholdType : uint8
{
	Custom                                   = 0,
	Attribute                                = 1,
	MovementMode                             = 2,
	EThresholdType_MAX                       = 3,
};

// Enum keaton.EThresholdCondition
// NumValues: 0x0008
enum class EThresholdCondition : uint8
{
	Ignore                                   = 0,
	Greater                                  = 1,
	GreaterOrEqual                           = 2,
	Less                                     = 3,
	LessOrEqual                              = 4,
	Equal                                    = 5,
	NotEqual                                 = 6,
	EThresholdCondition_MAX                  = 7,
};

// Enum keaton.ECAGameplayTriggerEvent
// NumValues: 0x001A
enum class ECAGameplayTriggerEvent : uint8
{
	None                                     = 0,
	Initial                                  = 1,
	HealthChange                             = 2,
	MinHealthChange                          = 3,
	MaxHealthChange                          = 4,
	PendingChange                            = 5,
	ArmourChange                             = 6,
	MaxArmourChange                          = 7,
	StaticArmourChange                       = 8,
	HitReceived                              = 9,
	Landed                                   = 10,
	RadiationChange                          = 11,
	HitDelivered                             = 12,
	CollisionInZeroG                         = 13,
	InjuredTarget                            = 14,
	DownedTarget                             = 15,
	KilledTarget                             = 16,
	OnStartOrStopMoving                      = 17,
	OnMovementModeChange                     = 18,
	OnInjured                                = 19,
	OnDowned                                 = 20,
	OnKilled                                 = 21,
	OnGenericChargeAChange                   = 22,
	OnGenericChargeBChange                   = 23,
	OnForceDeath                             = 24,
	ECAGameplayTriggerEvent_MAX              = 25,
};

// Enum keaton.ECAGameplayEffectGravityValue
// NumValues: 0x0004
enum class ECAGameplayEffectGravityValue : uint8
{
	Any                                      = 0,
	Gravity_0g                               = 1,
	Gravity_1g                               = 2,
	ECAGameplayEffectGravityValue_MAX        = 3,
};

// Enum keaton.ECAAILoDRuleType
// NumValues: 0x001D
enum class ECAAILoDRuleType : uint8
{
	NPCIsInsideOfInnerRadiusToClosestPlayer  = 0,
	NPCIsBetweenInnerAndOuterRadiusToClosestPlayer = 1,
	NPCIsOutsideOfOuterRadiusToClosestPlayer = 2,
	MaxTotalNPCLimitNotMet                   = 3,
	MaxTotalNPCLimitMet                      = 4,
	MaxTotalNPCLimitExceeded                 = 5,
	MaxActiveNPCLimitNotMet                  = 6,
	MaxActiveNPCLimitMet                     = 7,
	MaxActiveNPCLimitExceeded                = 8,
	HigherPriorityNPCRequested               = 9,
	NPCIsInSecurityArea                      = 10,
	NPCIsInSecurityAreaWithPlayers           = 11,
	NPCIsInSecurityAreaGroupWithPlayers      = 12,
	NPCHasLineOfSightToPlayer                = 13,
	NPCIsInCombat                            = 14,
	NPCShouldDespawn                         = 15,
	PlayerRecentlySensed                     = 16,
	NPCIsInAreaWithVault                     = 17,
	NPCIsInAreaWithLootedVault               = 18,
	NPCIsInAreaWithVaultBeingHacked          = 19,
	NPCIsInAreaWithNonFullVault              = 20,
	NPCIsInAreaWithOpenVault                 = 21,
	NPCDamageTakenRecently                   = 22,
	HasFullyLoDMotivation                    = 23,
	IsOnNPCTeam                              = 24,
	HasHadExtendedLoDDuration                = 25,
	IsMovingToBindPoint                      = 26,
	AllowedToAttackContestedTargetObject     = 27,
	ECAAILoDRuleType_MAX                     = 28,
};

// Enum keaton.ECAAILoDState
// NumValues: 0x0004
enum class ECAAILoDState : uint8
{
	FullLoD                                  = 0,
	DespawnNPC                               = 1,
	DespawnAndReRequestNPC                   = 2,
	ECAAILoDState_MAX                        = 3,
};

// Enum keaton.ECATargetObjectTargetingRuleType
// NumValues: 0x0010
enum class ECATargetObjectTargetingRuleType : uint8
{
	ThisNPCWithinRange                       = 0,
	ThisNPCWithinMaxWeaponRange              = 1,
	ClosestToNPC                             = 2,
	AnyPlayersWithinRange                    = 3,
	TargetPlayerWithinRange                  = 4,
	OtherNPCsWithinRange                     = 5,
	BlocksLineOfSightToTarget                = 6,
	HasLineOfSight                           = 7,
	AnyPlayersWithinRangeOfNPC               = 8,
	NPCHasTakenDamage                        = 9,
	HasLineOfSightFromBindPoint              = 10,
	BlocksPathToBindPoint                    = 11,
	IsOnNavMeshIsland                        = 12,
	NPCCanUseSpecialAbility                  = 13,
	ObjectInViewCone                         = 14,
	ECATargetObjectTargetingRuleType_MAX     = 15,
};

// Enum keaton.ECAMissionObjectiveTypeEnum
// NumValues: 0x0005
enum class ECAMissionObjectiveTypeEnum : uint8
{
	Vault                                    = 0,
	Extraction                               = 1,
	HVLECrate                                = 2,
	MissionObjectiveObject                   = 3,
	ECAMissionObjectiveTypeEnum_MAX          = 4,
};

// Enum keaton.ECAJobRotation
// NumValues: 0x0008
enum class ECAJobRotation : uint8
{
	AwayFromPreviousJob                      = 0,
	TowardsMissionObjective                  = 1,
	AwayFromMissionObjective                 = 2,
	AwayFromClosestPortal                    = 3,
	TowardsClosestPortal                     = 4,
	AwayFromClosestWall                      = 5,
	TowardsClosestVisibleSecurityAreaEntrance = 6,
	ECAJobRotation_MAX                       = 7,
};

// Enum keaton.EHighlightLOS
// NumValues: 0x0004
enum class EHighlightLOS : uint8
{
	NoLOSCheck                               = 0,
	ShowWhenLOSBlocked                       = 1,
	ShowWhenLOSNotBlocked                    = 2,
	EHighlightLOS_MAX                        = 3,
};

// Enum keaton.ECANavigationIndices
// NumValues: 0x0005
enum class ECANavigationIndices : uint8
{
	None                                     = 0,
	Primary                                  = 1,
	Secondary                                = 2,
	All                                      = 3,
	ECANavigationIndices_MAX                 = 4,
};

// Enum keaton.ECAHistoryState
// NumValues: 0x0005
enum class ECAHistoryState : uint8
{
	Empty                                    = 0,
	Idle                                     = 1,
	BackLoop                                 = 2,
	BackFinalStep                            = 3,
	ECAHistoryState_MAX                      = 4,
};

// Enum keaton.ECAHistoryBehaviourPriority
// NumValues: 0x0005
enum class ECAHistoryBehaviourPriority : uint8
{
	VerySpecific                             = 0,
	Specific                                 = 1,
	General                                  = 2,
	Fallback                                 = 3,
	ECAHistoryBehaviourPriority_MAX          = 4,
};

// Enum keaton.ECAUIhit3DBounceDirection
// NumValues: 0x0004
enum class ECAUIhit3DBounceDirection : uint8
{
	Vertical                                 = 0,
	OutFromCentre                            = 1,
	Both                                     = 2,
	ECAUIhit3DBounceDirection_MAX            = 3,
};

// Enum keaton.ECABRAbilityState
// NumValues: 0x000A
enum class ECABRAbilityState : uint8
{
	None                                     = 0,
	Undeployed                               = 1,
	Unaware                                  = 2,
	Warning                                  = 3,
	Suspicious                               = 4,
	Combat_Search                            = 5,
	Unaware_Alerted                          = 6,
	OutOfRange                               = 7,
	Combat                                   = 8,
	ECABRAbilityState_MAX                    = 9,
};

// Enum keaton.ECAHUDAbilityCosplayerState
// NumValues: 0x0006
enum class ECAHUDAbilityCosplayerState : uint8
{
	None                                     = 0,
	Available                                = 1,
	Active                                   = 2,
	PassiveAbility                           = 3,
	Cooldown                                 = 4,
	ECAHUDAbilityCosplayerState_MAX          = 5,
};

// Enum keaton.ECAAmmoStatus
// NumValues: 0x0006
enum class ECAAmmoStatus : uint8
{
	Infinite                                 = 0,
	InfiniteAmmo                             = 1,
	InfiniteMaxAmmo                          = 2,
	MaxAmmoDepleted                          = 3,
	Regular                                  = 4,
	ECAAmmoStatus_MAX                        = 5,
};

// Enum keaton.ECAHUDArcLensFovRegion
// NumValues: 0x0004
enum class ECAHUDArcLensFovRegion : uint8
{
	Center                                   = 0,
	Intermediate                             = 1,
	Peripheral                               = 2,
	MAX                                      = 3,
};

// Enum keaton.ECAHUDClampDirection
// NumValues: 0x0006
enum class ECAHUDClampDirection : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Top                                      = 3,
	Down                                     = 4,
	MAX                                      = 5,
};

// Enum keaton.ECAHUDClampingStyle
// NumValues: 0x0006
enum class ECAHUDClampingStyle : uint8
{
	None                                     = 0,
	Edges                                    = 1,
	Circle                                   = 2,
	Ellipse                                  = 3,
	EllipseHybrid                            = 4,
	MAX                                      = 5,
};

// Enum keaton.ECompassItemPlacement
// NumValues: 0x0004
enum class ECompassItemPlacement : uint8
{
	Above                                    = 0,
	Centred                                  = 1,
	Below                                    = 2,
	ECompassItemPlacement_MAX                = 3,
};

// Enum keaton.ECompassItemType
// NumValues: 0x0004
enum class ECompassItemType : uint8
{
	Enemy                                    = 0,
	Objective                                = 1,
	Location                                 = 2,
	ECompassItemType_MAX                     = 3,
};

// Enum keaton.ECAHUDDisguiseType
// NumValues: 0x0005
enum class ECAHUDDisguiseType : uint8
{
	None                                     = 0,
	NPC                                      = 1,
	Teammate                                 = 2,
	Enemy                                    = 3,
	ECAHUDDisguiseType_MAX                   = 4,
};

// Enum keaton.ECAFovActorType
// NumValues: 0x0005
enum class ECAFovActorType : uint8
{
	Default                                  = 0,
	NPC                                      = 1,
	Enemy                                    = 2,
	Teammate                                 = 3,
	ECAFovActorType_MAX                      = 4,
};

// Enum keaton.ECAHUDDistanceLevel
// NumValues: 0x0006
enum class ECAHUDDistanceLevel : uint8
{
	None                                     = 0,
	VeryFar                                  = 1,
	Far                                      = 2,
	Medium                                   = 3,
	Close                                    = 4,
	ECAHUDDistanceLevel_MAX                  = 5,
};

// Enum keaton.ECAFovLevel
// NumValues: 0x0006
enum class ECAFovLevel : uint8
{
	None                                     = 0,
	FOV1                                     = 1,
	FOV2                                     = 2,
	FOV3                                     = 3,
	FOV4                                     = 4,
	MAX                                      = 5,
};

// Enum keaton.ECAUI_GameTimerPhase
// NumValues: 0x0006
enum class ECAUI_GameTimerPhase : uint8
{
	Looting                                  = 0,
	ThresholdReached                         = 1,
	ShouldActivateExtraction                 = 2,
	WaitingForExtraction                     = 3,
	ExtractionOpen                           = 4,
	ECAUI_MAX                                = 5,
};

// Enum keaton.ECAUI_ReticuleTargettingMode
// NumValues: 0x0007
enum class ECAUI_ReticuleTargettingMode : uint8
{
	Default                                  = 0,
	Ally                                     = 1,
	Enemy                                    = 2,
	Environment                              = 3,
	NPC                                      = 4,
	Other                                    = 5,
	ECAUI_MAX                                = 6,
};

// Enum keaton.ECAUI_EscapeMenuTabs
// NumValues: 0x0004
enum class ECAUI_EscapeMenuTabs : uint8
{
	INVENTORY                                = 0,
	MAP                                      = 1,
	ROOT                                     = 2,
	ECAUI_MAX                                = 3,
};

// Enum keaton.ECAScreenTitles
// NumValues: 0x0007
enum class ECAScreenTitles : uint8
{
	ST_MAIN_MENU                             = 0,
	ST_SPLASH                                = 1,
	ST_LOADING_SCREEN                        = 2,
	ST_OPTIONS_MAIN                          = 3,
	ST_OPTIONS_GRAPHICS                      = 4,
	ST_OPTIONS_SOUND                         = 5,
	ST_MAX                                   = 6,
};

// Enum keaton.ECAHUDInputDisplayStyle
// NumValues: 0x0003
enum class ECAHUDInputDisplayStyle : uint8
{
	Light                                    = 0,
	Dark                                     = 1,
	ECAHUDInputDisplayStyle_MAX              = 2,
};

// Enum keaton.ECAHUDInventoryAbilityType
// NumValues: 0x0007
enum class ECAHUDInventoryAbilityType : uint8
{
	None                                     = 0,
	PrimaryWeapon                            = 1,
	SecondaryWeapon                          = 2,
	SpecialistAbility                        = 3,
	PrimaryGadget                            = 4,
	SecondaryGadget                          = 5,
	ECAHUDInventoryAbilityType_MAX           = 6,
};

// Enum keaton.ECAHUDNotificationType
// NumValues: 0x0004
enum class ECAHUDNotificationType : uint8
{
	Invalid                                  = 0,
	Notification                             = 1,
	Error                                    = 2,
	ECAHUDNotificationType_MAX               = 3,
};

// Enum keaton.ECAHUDPopupPriority
// NumValues: 0x0006
enum class ECAHUDPopupPriority : uint8
{
	Lowest                                   = 0,
	Low                                      = 1,
	Middle                                   = 2,
	High                                     = 3,
	Highest                                  = 4,
	ECAHUDPopupPriority_MAX                  = 5,
};

// Enum keaton.ECAPostDeathFlowState
// NumValues: 0x000B
enum class ECAPostDeathFlowState : uint8
{
	None                                     = 0,
	TeamEndAnim                              = 1,
	TeamEndAnimFinalised                     = 2,
	KilledInfoScreen                         = 3,
	KilledInfoScreenFinalised                = 4,
	TeammateSpectatorScreen                  = 5,
	EnemySpectatorScreen                     = 6,
	SpectatorScreen                          = 7,
	MatchEndScreen                           = 8,
	WinnersScreen                            = 9,
	ECAPostDeathFlowState_MAX                = 10,
};

// Enum keaton.ECAPartyPlayerCardState
// NumValues: 0x0006
enum class ECAPartyPlayerCardState : uint8
{
	None                                     = 0,
	Empty                                    = 1,
	Info                                     = 2,
	Disconnected                             = 3,
	Actions                                  = 4,
	ECAPartyPlayerCardState_MAX              = 5,
};

// Enum keaton.ECAHUDPickupAction
// NumValues: 0x0006
enum class ECAHUDPickupAction : uint8
{
	Pickup                                   = 0,
	IncreaseAmountInSlot                     = 1,
	InventoryFull                            = 2,
	SwapHold                                 = 3,
	SwapPress                                = 4,
	ECAHUDPickupAction_MAX                   = 5,
};

// Enum keaton.ECAHUDPickupType
// NumValues: 0x0005
enum class ECAHUDPickupType : uint8
{
	Default                                  = 0,
	Gadget                                   = 1,
	Armour                                   = 2,
	Loot                                     = 3,
	ECAHUDPickupType_MAX                     = 4,
};

// Enum keaton.ETeamVoiceIndicatorMode
// NumValues: 0x0003
enum class ETeamVoiceIndicatorMode : uint8
{
	HUD                                      = 0,
	SpaceJump                                = 1,
	ETeamVoiceIndicatorMode_MAX              = 2,
};

// Enum keaton.ECAHUDThresholdObjective
// NumValues: 0x000A
enum class ECAHUDThresholdObjective : uint8
{
	None                                     = 0,
	Looting                                  = 1,
	GetToGetaway                             = 2,
	DefendGetaway                            = 3,
	GetawayChallenged                        = 4,
	StopRivalCrew                            = 5,
	StopRivalGetaway                         = 6,
	RivalGetawayChallenged                   = 7,
	InsufficientLootInArea                   = 8,
	ECAHUDThresholdObjective_MAX             = 9,
};

// Enum keaton.ECACharacterImpactType
// NumValues: 0x0012
enum class ECACharacterImpactType : uint8
{
	Flesh_Player_Normal                      = 0,
	Flesh_Player_Large                       = 1,
	Flesh_Player_Critical                    = 2,
	Flesh_Player_Break                       = 3,
	Flesh_NPC_Normal                         = 4,
	Flesh_NPC_Large                          = 5,
	Flesh_NPC_Critical                       = 6,
	Flesh_NPC_Break                          = 7,
	Armour_Player_Normal                     = 8,
	Armour_Player_Large                      = 9,
	Armour_Player_Critical                   = 10,
	Armour_Player_Break                      = 11,
	Armour_NPC_Normal                        = 12,
	Armour_NPC_Large                         = 13,
	Armour_NPC_Critical                      = 14,
	Armour_NPC_Break                         = 15,
	Count                                    = 16,
	ECACharacterImpactType_MAX               = 17,
};

// Enum keaton.ECAInclusionSetting
// NumValues: 0x0003
enum class ECAInclusionSetting : uint8
{
	IncludeAll                               = 0,
	ExcludeAll                               = 1,
	ECAInclusionSetting_MAX                  = 2,
};

// Enum keaton.ECAInformationControlLevel
// NumValues: 0x0005
enum class ECAInformationControlLevel : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Basic                                    = 2,
	Full                                     = 3,
	MAX                                      = 4,
};

// Enum keaton.ECAInputMappingToggleGroup
// NumValues: 0x0006
enum class ECAInputMappingToggleGroup : uint8
{
	None                                     = 0,
	Crouch                                   = 1,
	Sprint                                   = 2,
	Other_1                                  = 3,
	Max                                      = 4,
	ECAInputMappingToggleGroup_MAX           = 5,
};

// Enum keaton.ECAZerGRequirment
// NumValues: 0x0004
enum class ECAZerGRequirment : uint8
{
	DontCare                                 = 0,
	NotZeroG                                 = 1,
	ZeroGOnly                                = 2,
	ECAZerGRequirment_MAX                    = 3,
};

// Enum keaton.ECAHUDInputType
// NumValues: 0x0005
enum class ECAHUDInputType : uint8
{
	Action                                   = 0,
	Axis_Positive                            = 1,
	Axis_Negative                            = 2,
	Icon                                     = 3,
	ECAHUDInputType_MAX                      = 4,
};

// Enum keaton.ECAInstrumentTimerGroup
// NumValues: 0x0009
enum class ECAInstrumentTimerGroup : uint8
{
	None                                     = 0,
	General                                  = 1,
	Aiming                                   = 2,
	PlayerMovement                           = 3,
	AI                                       = 4,
	RepGraph                                 = 5,
	FlyingNav                                = 6,
	Max                                      = 7,
	ECAInstrumentTimerGroup_MAX              = 8,
};

// Enum keaton.ECAInstrumentTimerReportingPolicy
// NumValues: 0x0004
enum class ECAInstrumentTimerReportingPolicy : uint8
{
	All                                      = 0,
	ScreenOnly                               = 1,
	LogOnly                                  = 2,
	ECAInstrumentTimerReportingPolicy_MAX    = 3,
};

// Enum keaton.ECAItemChangeReason
// NumValues: 0x000B
enum class ECAItemChangeReason : uint8
{
	None                                     = 0,
	Initialized                              = 1,
	Collected                                = 2,
	Replenished                              = 3,
	Consumed                                 = 4,
	Dropped                                  = 5,
	Swapped                                  = 6,
	Stolen                                   = 7,
	Transfer                                 = 8,
	Debug                                    = 9,
	ECAItemChangeReason_MAX                  = 10,
};

// Enum keaton.ECAGadgetType
// NumValues: 0x0004
enum class ECAGadgetType : uint8
{
	NonThrowable                             = 0,
	GadgetProgressionV1                      = 1,
	GadgetProgressionV2                      = 2,
	ECAGadgetType_MAX                        = 3,
};

// Enum keaton.ECAPickupMethod
// NumValues: 0x0003
enum class ECAPickupMethod : uint8
{
	Interaction                              = 0,
	Collision                                = 1,
	ECAPickupMethod_MAX                      = 2,
};

// Enum keaton.FItemRarityTier
// NumValues: 0x0005
enum class EFItemRarityTier : uint8
{
	Tier0                                    = 0,
	Tier1                                    = 1,
	Tier2                                    = 2,
	Tier3                                    = 3,
	FItemRarityTier_MAX                      = 4,
};

// Enum keaton.FItemWeightCategory
// NumValues: 0x0004
enum class EFItemWeightCategory : uint8
{
	Light                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	FItemWeightCategory_MAX                  = 3,
};

// Enum keaton.ECAAllowItemState
// NumValues: 0x000D
enum class ECAAllowItemState : uint8
{
	Storable                                 = 0,
	Grabable                                 = 1,
	Equipable                                = 2,
	Dropable                                 = 3,
	Prop                                     = 4,
	LootConvertible                          = 5,
	NotUserSelectable                        = 6,
	Consumable                               = 7,
	Stackable                                = 8,
	TeamShared                               = 9,
	PersistsThroughDeath                     = 10,
	StayNormalToCamera                       = 11,
	ECAAllowItemState_MAX                    = 12,
};

// Enum keaton.ECAJobType
// NumValues: 0x0009
enum class ECAJobType : uint8
{
	JobTypeIdle                              = 0,
	JobTypeSearch                            = 1,
	JobTypePatrol                            = 2,
	JobTypeDespawn                           = 3,
	JobTypePlaceholder1                      = 4,
	JobTypePlaceholder2                      = 5,
	JobTypePlaceholder3                      = 6,
	JobTypePlaceholder4                      = 7,
	ECAJobType_MAX                           = 8,
};

// Enum keaton.ECAJobSearchDirection
// NumValues: 0x0004
enum class ECAJobSearchDirection : uint8
{
	Nearest                                  = 0,
	Farthest                                 = 1,
	Random                                   = 2,
	ECAJobSearchDirection_MAX                = 3,
};

// Enum keaton.ECAJobSearchSource
// NumValues: 0x0005
enum class ECAJobSearchSource : uint8
{
	SearchFromCurrentPos                     = 0,
	SearchFromHomeLocation                   = 1,
	SearchFromLocation                       = 2,
	SearchFromBindPoint                      = 3,
	ECAJobSearchSource_MAX                   = 4,
};

// Enum keaton.ECAJobSearchType
// NumValues: 0x0008
enum class ECAJobSearchType : uint8
{
	JobSearch_Nearest                        = 0,
	JobSearch_NearestToMissionObjective      = 1,
	JobSearch_Path                           = 2,
	JobSearch_Random                         = 3,
	JobSearch_Determined_By_Job              = 4,
	JobSearch_Determined_By_Job_On_Random_Path = 5,
	JobSearch_NearestToward_ContestedObjective = 6,
	JobSearch_MAX                            = 7,
};

// Enum keaton.ECALadderInfo
// NumValues: 0x0005
enum class ECALadderInfo : uint8
{
	None                                     = 0,
	Up                                       = 1,
	Down                                     = 2,
	On                                       = 3,
	MAX                                      = 4,
};

// Enum keaton.ELaserTargetEffectState
// NumValues: 0x0005
enum class ELaserTargetEffectState : uint8
{
	Idle                                     = 0,
	Charge0                                  = 1,
	Charge1                                  = 2,
	Charge2                                  = 3,
	ELaserTargetEffectState_MAX              = 4,
};

// Enum keaton.ECALayoutManagerState
// NumValues: 0x0004
enum class ECALayoutManagerState : uint8
{
	Inactive                                 = 0,
	Initialising                             = 1,
	LoadingLayout                            = 2,
	ECALayoutManagerState_MAX                = 3,
};

// Enum keaton.FLoadoutState
// NumValues: 0x0004
enum class EFLoadoutState : uint8
{
	Empty                                    = 0,
	Grab                                     = 1,
	Equip                                    = 2,
	FLoadoutState_MAX                        = 3,
};

// Enum keaton.ECATeamAllocation
// NumValues: 0x0004
enum class ECATeamAllocation : uint8
{
	Default                                  = 0,
	RoundRobin                               = 1,
	FillFirst                                = 2,
	MAX                                      = 3,
};

// Enum keaton.EControllerRotationYawType
// NumValues: 0x0006
enum class EControllerRotationYawType : uint8
{
	Default                                  = 0,
	DownedPlayer                             = 1,
	DownedPlayerLocomotion                   = 2,
	DownedRevivingPlayer                     = 3,
	Emote                                    = 4,
	MAX                                      = 5,
};

// Enum keaton.EDownedLocomotionStates
// NumValues: 0x0005
enum class EDownedLocomotionStates : uint8
{
	Downed_Started                           = 0,
	Downed_Failed                            = 1,
	Downed_Locomotion                        = 2,
	Downed_Completed                         = 3,
	MAX                                      = 4,
};

// Enum keaton.ECAMapLegendType
// NumValues: 0x0004
enum class ECAMapLegendType : uint8
{
	None                                     = 0,
	Entity                                   = 1,
	Zone                                     = 2,
	ECAMapLegendType_MAX                     = 3,
};

// Enum keaton.ECASupplyLevel
// NumValues: 0x0006
enum class ECASupplyLevel : uint8
{
	Invalid                                  = 0,
	Depleted                                 = 1,
	Low                                      = 2,
	Medium                                   = 3,
	High                                     = 4,
	ECASupplyLevel_MAX                       = 5,
};

// Enum keaton.ECAMapZoneType
// NumValues: 0x0005
enum class ECAMapZoneType : uint8
{
	Invalid                                  = 0,
	Transition                               = 1,
	Supply                                   = 2,
	Merch                                    = 3,
	ECAMapZoneType_MAX                       = 4,
};

// Enum keaton.ECAFrontendMatchCategoryRank
// NumValues: 0x0005
enum class ECAFrontendMatchCategoryRank : uint8
{
	First                                    = 0,
	Second                                   = 1,
	Third                                    = 2,
	Default                                  = 3,
	ECAFrontendMatchCategoryRank_MAX         = 4,
};

// Enum keaton.ECAMetricsLootSourceType
// NumValues: 0x0007
enum class ECAMetricsLootSourceType : uint8
{
	Vault                                    = 0,
	NPC                                      = 1,
	Crate                                    = 2,
	GadgetBox                                = 3,
	Player                                   = 4,
	Unknown                                  = 5,
	ECAMetricsLootSourceType_MAX             = 6,
};

// Enum keaton.ECANPCCountType
// NumValues: 0x0006
enum class ECANPCCountType : uint8
{
	None                                     = 0,
	Total                                    = 1,
	Pooled                                   = 2,
	Active                                   = 3,
	Inactive                                 = 4,
	ECANPCCountType_MAX                      = 5,
};

// Enum keaton.ECANPCAttackType
// NumValues: 0x0005
enum class ECANPCAttackType : uint8
{
	None                                     = 0,
	Melee                                    = 1,
	Ranged                                   = 2,
	Special                                  = 3,
	ECANPCAttackType_MAX                     = 4,
};

// Enum keaton.ECAMissionAreaFilterType
// NumValues: 0x000D
enum class ECAMissionAreaFilterType : uint8
{
	IsInMissionArea                          = 0,
	IsInOuterMissionArea                     = 1,
	IsInInnerMissionArea                     = 2,
	IsInsideMissionObjective                 = 3,
	IsInInnerMissionAreaOrMissionObjective   = 4,
	IsOutsideOuterInnerAndMissionObjectiveAreas = 5,
	IsValidAIPortalGraphLocation             = 6,
	IsInVacantOuterArea                      = 7,
	IsInVacantInnerArea                      = 8,
	IsInVacantMissionObjective               = 9,
	IsInBlockedRoom                          = 10,
	IsInNPCTeleportBlockedRoom               = 11,
	ECAMissionAreaFilterType_MAX             = 12,
};

// Enum keaton.ECAUIMessageType
// NumValues: 0x0006
enum class ECAUIMessageType : uint8
{
	None                                     = 0,
	All                                      = 1,
	GameNews_Always                          = 2,
	Information                              = 3,
	MOTD                                     = 4,
	ECAUIMessageType_MAX                     = 5,
};

// Enum keaton.ECADesiredMoveSpeed
// NumValues: 0x0005
enum class ECADesiredMoveSpeed : uint8
{
	MoveSpeedWalk                            = 0,
	MoveSpeedJog                             = 1,
	MoveSpeedRun                             = 2,
	MoveFastTravel                           = 3,
	ECADesiredMoveSpeed_MAX                  = 4,
};

// Enum keaton.SteeringStyle
// NumValues: 0x0006
enum class ESteeringStyle : uint8
{
	None                                     = 0,
	Arrow_Keys                               = 1,
	StandardFlight                           = 2,
	JetBoost                                 = 3,
	Directional_Force                        = 4,
	SteeringStyle_MAX                        = 5,
};

// Enum keaton.ECAMovementErrorCorrectionRequestType
// NumValues: 0x0004
enum class ECAMovementErrorCorrectionRequestType : uint8
{
	Default                                  = 0,
	PlayDockedMontage                        = 1,
	Ability                                  = 2,
	MAX                                      = 3,
};

// Enum keaton.ECAExceptionData_BoolOperator
// NumValues: 0x0003
enum class ECAExceptionData_BoolOperator : uint8
{
	Ignore                                   = 0,
	Override                                 = 1,
	ECAExceptionData_MAX                     = 2,
};

// Enum keaton.ECAExceptionData_Operator_MPY_Only
// NumValues: 0x0005
enum class ECAExceptionData_Operator_MPY_Only : uint8
{
	Ignore                                   = 0,
	Override                                 = 1,
	Multiply_Exclusive                       = 2,
	Multiply_Stacked                         = 3,
	ECAExceptionData_Operator_MPY_MAX        = 4,
};

// Enum keaton.ECAExceptionData_Operator
// NumValues: 0x0006
enum class ECAExceptionData_Operator : uint8
{
	Ignore                                   = 0,
	Override                                 = 1,
	Multiply_Exclusive                       = 2,
	Multiply_Stacked                         = 3,
	Add                                      = 4,
	ECAExceptionData_MAX                     = 5,
};

// Enum keaton.ECAExceptionData_Priority
// NumValues: 0x0007
enum class ECAExceptionData_Priority : uint8
{
	ADS                                      = 0,
	Debuff                                   = 1,
	Buff                                     = 2,
	Max                                      = 3,
	First_pass                               = 0,
	Final_pass                               = 2,
	ECAExceptionData_MAX                     = 4,
};

// Enum keaton.ECAMusicPriority
// NumValues: 0x0004
enum class ECAMusicPriority : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	ECAMusicPriority_MAX                     = 3,
};

// Enum keaton.ECAAIHintType
// NumValues: 0x0006
enum class ECAAIHintType : uint8
{
	Cover                                    = 0,
	Jump                                     = 1,
	Vault                                    = 2,
	Drop                                     = 3,
	PreprocessedEQSQueries                   = 4,
	ECAAIHintType_MAX                        = 5,
};

// Enum keaton.ECAGenerationMode
// NumValues: 0x0003
enum class ECAGenerationMode : uint8
{
	GenerateAllButExceptions                 = 0,
	GenerateNoneButExceptions                = 1,
	ECAGenerationMode_MAX                    = 2,
};

// Enum keaton.ECAAimState
// NumValues: 0x000E
enum class ECAAimState : uint8
{
	LastSensedPosition                       = 0,
	LookDown                                 = 1,
	TargetObject                             = 2,
	FocalPoint                               = 3,
	Sweep                                    = 4,
	FreezeInCombat                           = 5,
	StrafeCombat                             = 6,
	PatrolJob                                = 7,
	BuffAlly                                 = 8,
	Offline                                  = 9,
	TurnToTarget                             = 10,
	CharmPlayer                              = 11,
	ZeroGRotation                            = 12,
	ECAAimState_MAX                          = 13,
};

// Enum keaton.ECANPCAwarenessUIState
// NumValues: 0x0005
enum class ECANPCAwarenessUIState : uint8
{
	Blank                                    = 0,
	Question                                 = 1,
	Exclamation                              = 2,
	Cross                                    = 3,
	ECANPCAwarenessUIState_MAX               = 4,
};

// Enum keaton.ECAEnemyTargetRule
// NumValues: 0x0003
enum class ECAEnemyTargetRule : uint8
{
	Default                                  = 0,
	VisibleOnly                              = 1,
	ECAEnemyTargetRule_MAX                   = 2,
};

// Enum keaton.ECAAllyTargetRule
// NumValues: 0x0003
enum class ECAAllyTargetRule : uint8
{
	HealToughest                             = 0,
	FollowIdentifierTag                      = 1,
	ECAAllyTargetRule_MAX                    = 2,
};

// Enum keaton.ECANPCSquadHierarchyRoleType
// NumValues: 0x0004
enum class ECANPCSquadHierarchyRoleType : uint8
{
	Leader                                   = 0,
	Follower                                 = 1,
	Outlier                                  = 2,
	ECANPCSquadHierarchyRoleType_MAX         = 3,
};

// Enum keaton.ECAFastTravelMode
// NumValues: 0x0003
enum class ECAFastTravelMode : uint8
{
	Teleport                                 = 0,
	SuperSpeed                               = 1,
	ECAFastTravelMode_MAX                    = 2,
};

// Enum keaton.ECriticalHitWeaponMultiplier
// NumValues: 0x0005
enum class ECriticalHitWeaponMultiplier : uint8
{
	NoWeaponMultiplier                       = 0,
	HeadShotMultiplier                       = 1,
	BodyShotMultiplier                       = 2,
	LegsShotMultiplier                       = 3,
	ECriticalHitWeaponMultiplier_MAX         = 4,
};

// Enum keaton.ECriticalHitTriggerSource
// NumValues: 0x0004
enum class ECriticalHitTriggerSource : uint8
{
	TriggeredViaHitsToAttachedMeshes         = 0,
	TriggeredViaHitsToMainMeshWithBoneName   = 1,
	TriggeredViaHitsToAttachedComponentsOrMainMeshWithBoneName = 2,
	ECriticalHitTriggerSource_MAX            = 3,
};

// Enum keaton.ECriticalHitDamageTransfer
// NumValues: 0x0004
enum class ECriticalHitDamageTransfer : uint8
{
	DamagesHitPointAndActor                  = 0,
	DamagesOnlyHitPoint                      = 1,
	ImperviousToDamage                       = 2,
	ECriticalHitDamageTransfer_MAX           = 3,
};

// Enum keaton.ENPCGameplayHintType
// NumValues: 0x0003
enum class ENPCGameplayHintType : uint8
{
	None                                     = 0,
	AreaBuff                                 = 1,
	ENPCGameplayHintType_MAX                 = 2,
};

// Enum keaton.ECADamageType
// NumValues: 0x0006
enum class ECADamageType : uint8
{
	BaseDamage                               = 0,
	InstantDamage                            = 1,
	BleedDamage                              = 2,
	MaxHealthDamage                          = 3,
	ArmourDamage                             = 4,
	ECADamageType_MAX                        = 5,
};

// Enum keaton.ECADoDamageToTarget
// NumValues: 0x0006
enum class ECADoDamageToTarget : uint8
{
	CurrentTarget                            = 0,
	HighPriorityTargetObject                 = 1,
	MediumPriorityTargetObject               = 2,
	LowPriorityTargetObject                  = 3,
	Self                                     = 4,
	ECADoDamageToTarget_MAX                  = 5,
};

// Enum keaton.ECAKillOrDestroyTarget
// NumValues: 0x0006
enum class ECAKillOrDestroyTarget : uint8
{
	CurrentTarget                            = 0,
	HighPriorityTargetObject                 = 1,
	MediumPriorityTargetObject               = 2,
	LowPriorityTargetObject                  = 3,
	Self                                     = 4,
	ECAKillOrDestroyTarget_MAX               = 5,
};

// Enum keaton.ECADistanceMeasurement
// NumValues: 0x0004
enum class ECADistanceMeasurement : uint8
{
	Distance2D                               = 0,
	Distance3D                               = 1,
	PathedDistance                           = 2,
	ECADistanceMeasurement_MAX               = 3,
};

// Enum keaton.ECAMoveTargetType
// NumValues: 0x0009
enum class ECAMoveTargetType : uint8
{
	CurrentTarget                            = 0,
	HighPriorityTargetObject                 = 1,
	MediumPriorityTargetObject               = 2,
	LowPriorityTargetObject                  = 3,
	CurrentJob                               = 4,
	OwnLocation                              = 5,
	MissionObjectiveLocation                 = 6,
	SearchLocation                           = 7,
	ECAMoveTargetType_MAX                    = 8,
};

// Enum keaton.ECAShootAtTarget
// NumValues: 0x0005
enum class ECAShootAtTarget : uint8
{
	CurrentTarget                            = 0,
	CurrentHighPriorityTargetObject          = 1,
	CurrentMediumPriorityTargetObject        = 2,
	CurrentLowPriorityTargetObject           = 3,
	ECAShootAtTarget_MAX                     = 4,
};

// Enum keaton.ECANPCStaggerState
// NumValues: 0x0004
enum class ECANPCStaggerState : uint8
{
	Disabled                                 = 0,
	AccumulatingPain                         = 1,
	Cooldown                                 = 2,
	ECANPCStaggerState_MAX                   = 3,
};

// Enum keaton.ECANPCPolitenessCategory
// NumValues: 0x0006
enum class ECANPCPolitenessCategory : uint8
{
	None                                     = 0,
	Standard                                 = 1,
	Special                                  = 2,
	Hard                                     = 3,
	Melee                                    = 4,
	ECANPCPolitenessCategory_MAX             = 5,
};

// Enum keaton.ECANPCSenses
// NumValues: 0x0007
enum class ECANPCSenses : uint8
{
	SightSense                               = 0,
	HearingSense                             = 1,
	DamageSense                              = 2,
	TouchSense                               = 3,
	WeaponSense                              = 4,
	NumNPCSenses                             = 5,
	ECANPCSenses_MAX                         = 6,
};

// Enum keaton.ECASpawnInclusionSetting
// NumValues: 0x0003
enum class ECASpawnInclusionSetting : uint8
{
	IncludeAll                               = 0,
	ExcludeAll                               = 1,
	ECASpawnInclusionSetting_MAX             = 2,
};

// Enum keaton.ECAWaitTimer
// NumValues: 0x0004
enum class ECAWaitTimer : uint8
{
	None                                     = 0,
	RepositionRate                           = 1,
	CombatStartDelay                         = 2,
	ECAWaitTimer_MAX                         = 3,
};

// Enum keaton.ECAZeroGReaction
// NumValues: 0x0005
enum class ECAZeroGReaction : uint8
{
	Float                                    = 0,
	None                                     = 1,
	Magboots                                 = 2,
	TimedFloatThenMagboots                   = 3,
	ECAZeroGReaction_MAX                     = 4,
};

// Enum keaton.ECARemappingValidationResults
// NumValues: 0x0006
enum class ECARemappingValidationResults : uint8
{
	None                                     = 0,
	Success                                  = 1,
	FailedLocally                            = 2,
	FailedSystemically                       = 3,
	Failed                                   = 4,
	ECARemappingValidationResults_MAX        = 5,
};

// Enum keaton.ECAActionType
// NumValues: 0x0006
enum class ECAActionType : uint8
{
	None                                     = 0,
	Action                                   = 1,
	PositiveAxis                             = 2,
	NegativeAxis                             = 3,
	Max                                      = 4,
	ECAActionType_MAX                        = 5,
};

// Enum keaton.ECAPeekAngle
// NumValues: 0x0006
enum class ECAPeekAngle : uint8
{
	None                                     = 0,
	Up                                       = 1,
	Left                                     = 2,
	Right                                    = 3,
	Blocked                                  = 4,
	MAX                                      = 5,
};

// Enum keaton.ECAPerceptionStates
// NumValues: 0x0004
enum class ECAPerceptionStates : uint8
{
	PerceptionStateIdle                      = 0,
	PerceptionStateCombat                    = 1,
	NumPerceptionStates                      = 2,
	ECAPerceptionStates_MAX                  = 3,
};

// Enum keaton.ECAPingResponseContext
// NumValues: 0x0006
enum class ECAPingResponseContext : uint8
{
	None                                     = 0,
	Response                                 = 1,
	Generic                                  = 2,
	Cancel                                   = 3,
	Invalid                                  = 4,
	ECAPingResponseContext_MAX               = 5,
};

// Enum keaton.PlatformPrivilege
// NumValues: 0x0008
enum class EPlatformPrivilege : uint8
{
	Multiplayer                              = 0,
	CrossPlay                                = 1,
	Communication                            = 2,
	SessionSharing                           = 3,
	UserGeneratedContent                     = 4,
	SocialNetworkSharing                     = 5,
	Count                                    = 6,
	PlatformPrivilege_MAX                    = 7,
};

// Enum keaton.EPostProcessType
// NumValues: 0x0003
enum class EPostProcessType : uint8
{
	OneShot                                  = 0,
	Continuous                               = 1,
	EPostProcessType_MAX                     = 2,
};

// Enum keaton.EForceFeedbackGamePad
// NumValues: 0x0005
enum class EForceFeedbackGamePad : uint8
{
	EFGP_2_Motors                            = 0,
	EFGP_PS5                                 = 1,
	EFGP_4_Motors                            = 2,
	EFGP_None                                = 3,
	EFGP_MAX                                 = 4,
};

// Enum keaton.EForceFeedbackCategory
// NumValues: 0x0008
enum class EForceFeedbackCategory : uint8
{
	Abilities                                = 0,
	Damage                                   = 1,
	Environment                              = 2,
	Gunplay                                  = 3,
	Interactions                             = 4,
	Movement                                 = 5,
	None                                     = 6,
	EForceFeedbackCategory_MAX               = 7,
};

// Enum keaton.EGamepad_Type
// NumValues: 0x0007
enum class EGamepad_Type : uint8
{
	XBox_Series                              = 0,
	XBox_One                                 = 1,
	XBox_360                                 = 2,
	PS4_DualShock4                           = 3,
	PS5_DualSense                            = 4,
	Invalid                                  = 255,
	EGamepad_MAX                             = 256,
};

// Enum keaton.ESpecialistAssetContext
// NumValues: 0x0004
enum class ESpecialistAssetContext : uint8
{
	LocalPlayer                              = 0,
	TeamMate                                 = 1,
	Enemy                                    = 2,
	ESpecialistAssetContext_MAX              = 3,
};

// Enum keaton.ECAPlayerStatId
// NumValues: 0x0015
enum class ECAPlayerStatId : uint8
{
	None                                     = 0,
	Matches_won                              = 1,
	Win_rate                                 = 2,
	K_d_ratio                                = 3,
	Allies_revived                           = 4,
	Respawners_used                          = 5,
	Killed_tanks                             = 6,
	Killed_lasers                            = 7,
	Vaults_breached                          = 8,
	Loot_total                               = 9,
	Killed_npcs                              = 10,
	Killed_players                           = 11,
	Deaths_in_pvp                            = 12,
	Downed_players                           = 13,
	Self_downed                              = 14,
	Damage_dealt_normal                      = 15,
	Damage_dealt_critical                    = 16,
	Matches_completed                        = 17,
	Matches_survived                         = 18,
	Matches_wiped                            = 19,
	ECAPlayerStatId_MAX                      = 20,
};

// Enum keaton.ECAControllerMotor
// NumValues: 0x0006
enum class ECAControllerMotor : uint8
{
	LeftLarge                                = 0,
	LeftSmall                                = 1,
	RightLarge                               = 2,
	RightSmall                               = 3,
	Max                                      = 4,
	ECAControllerMotor_MAX                   = 5,
};

// Enum keaton.ECAPostDeathScreen
// NumValues: 0x0003
enum class ECAPostDeathScreen : uint8
{
	KilledInfo                               = 0,
	DamageHistory                            = 1,
	ECAPostDeathScreen_MAX                   = 2,
};

// Enum keaton.ECAPostGameScreenPhase
// NumValues: 0x0009
enum class ECAPostGameScreenPhase : uint8
{
	None                                     = 0,
	Intro                                    = 1,
	Precheck                                 = 2,
	Main                                     = 3,
	MatchEnded                               = 4,
	ShowRank                                 = 5,
	ShowScore                                = 6,
	ShuttingDown                             = 7,
	MAX                                      = 8,
};

// Enum keaton.ECAPrestigeRankStates
// NumValues: 0x0004
enum class ECAPrestigeRankStates : uint8
{
	DefaultState                             = 0,
	MinimisedState                           = 1,
	ExpandedState                            = 2,
	ECAPrestigeRankStates_MAX                = 3,
};

// Enum keaton.ECAHUDPrimaryMessageQueueType
// NumValues: 0x0003
enum class ECAHUDPrimaryMessageQueueType : uint8
{
	Main                                     = 0,
	Second                                   = 1,
	ECAHUDPrimaryMessageQueueType_MAX        = 2,
};

// Enum keaton.ECAAOELoadSpreadType
// NumValues: 0x0004
enum class ECAAOELoadSpreadType : uint8
{
	SplitOverTwoFrames                       = 0,
	MaxPerFrame                              = 1,
	Disabled                                 = 2,
	ECAAOELoadSpreadType_MAX                 = 3,
};

// Enum keaton.ECAAOEProjectileEventType
// NumValues: 0x0008
enum class ECAAOEProjectileEventType : uint8
{
	Default                                  = 0,
	FuseStart                                = 1,
	FuseDone                                 = 2,
	Detonate                                 = 3,
	Disabled                                 = 4,
	Defused                                  = 5,
	Max                                      = 6,
	ECAAOEProjectileEventType_MAX            = 7,
};

// Enum keaton.ECAAOEDetonationType
// NumValues: 0x0006
enum class ECAAOEDetonationType : uint8
{
	Impact                                   = 0,
	Fuse                                     = 1,
	Bounce                                   = 2,
	PausableFuse                             = 3,
	Disabled                                 = 4,
	ECAAOEDetonationType_MAX                 = 5,
};

// Enum keaton.ECAAOEProjectileStateType
// NumValues: 0x0008
enum class ECAAOEProjectileStateType : uint8
{
	Default                                  = 0,
	Fuse                                     = 1,
	Bounce                                   = 2,
	Detonate                                 = 3,
	Impact                                   = 4,
	Disabled                                 = 5,
	PausableFuse                             = 6,
	ECAAOEProjectileStateType_MAX            = 7,
};

// Enum keaton.ECARangedAttackWeaponType
// NumValues: 0x0004
enum class ECARangedAttackWeaponType : uint8
{
	UsePrimaryWeapon                         = 0,
	UseSecondaryWeapon                       = 1,
	UseBestWeaponVsObjects                   = 2,
	ECARangedAttackWeaponType_MAX            = 3,
};

// Enum keaton.ECARangedAttackType
// NumValues: 0x000B
enum class ECARangedAttackType : uint8
{
	AttackCurrentTarget                      = 0,
	AttackHighPriorityTargetObject           = 1,
	AttackMediumPriorityTargetObject         = 2,
	AttackLowPriorityTargetObject            = 3,
	AttackTargetLastSensedPosition           = 4,
	AttackTargetLocation                     = 5,
	BeamAttackCurrentTarget                  = 6,
	ClusterAttackTargetLocation              = 7,
	AttackContestedTargetObject              = 8,
	None                                     = 9,
	ECARangedAttackType_MAX                  = 10,
};

// Enum keaton.ECADeathType
// NumValues: 0x0003
enum class ECADeathType : uint8
{
	None                                     = 0,
	Bullet                                   = 1,
	ECADeathType_MAX                         = 2,
};

// Enum keaton.ECAReactionState
// NumValues: 0x0004
enum class ECAReactionState : uint8
{
	None                                     = 0,
	Start                                    = 1,
	Stop                                     = 2,
	ECAReactionState_MAX                     = 3,
};

// Enum keaton.ECAReactionType
// NumValues: 0x0003
enum class ECAReactionType : uint8
{
	None                                     = 0,
	EMP                                      = 1,
	ECAReactionType_MAX                      = 2,
};

// Enum keaton.ECAReactionDirection
// NumValues: 0x0006
enum class ECAReactionDirection : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Back                                     = 2,
	Left                                     = 3,
	Right                                    = 4,
	ECAReactionDirection_MAX                 = 5,
};

// Enum keaton.ECARecastNavMeshGenerationState
// NumValues: 0x0010
enum class ECARecastNavMeshGenerationState : uint8
{
	NotGenerating                            = 0,
	InitialiseNavMesh                        = 1,
	AnalyseNavMesh                           = 2,
	NavLinks                                 = 3,
	AIPortalGraph                            = 4,
	InitialiseAIPortalGraphNavMesh           = 5,
	TransferAIPortalGraphNavMesh             = 6,
	FlyingGrid                               = 7,
	PreprocessedData                         = 8,
	NavModifierVolumes                       = 9,
	SavePreProcessedDataToFile               = 10,
	RemoveUnwantedNavLinks                   = 11,
	ValidateAIPortalGraphNavMesh             = 12,
	ResetNavigationAutoUpdateEnabledVariables = 13,
	LiveGame                                 = 14,
	ECARecastNavMeshGenerationState_MAX      = 15,
};

// Enum keaton.ECARecoilState
// NumValues: 0x0004
enum class ECARecoilState : uint8
{
	ERecoilState_NotFiring                   = 0,
	ERecoilState_Firing                      = 1,
	ERecoilState_Decay                       = 2,
	ERecoilState_MAX                         = 3,
};

// Enum keaton.ECARepGraphRoutingPolicy
// NumValues: 0x000D
enum class ECARepGraphRoutingPolicy : uint8
{
	AlwaysRelevant                           = 0,
	AlwaysRelevantDormant                    = 1,
	OnlyRelevantToOwner                      = 2,
	OnlyRelevantToOwnerDormant               = 3,
	NotSetUp                                 = 4,
	Spatial_Static                           = 5,
	Spatial_StaticDormant                    = 6,
	Spatial_Dynamic                          = 7,
	Spatial_DynamicDormant                   = 8,
	Custom                                   = 9,
	DebugMenus                               = 10,
	DependentActor                           = 11,
	ECARepGraphRoutingPolicy_MAX             = 12,
};

// Enum keaton.ECACellSubNode
// NumValues: 0x0004
enum class ECACellSubNode : uint8
{
	Static                                   = 0,
	Dormant                                  = 1,
	Dynamic                                  = 2,
	ECACellSubNode_MAX                       = 3,
};

// Enum keaton.ECARewardBoxState
// NumValues: 0x0004
enum class ECARewardBoxState : uint8
{
	Empty                                    = 0,
	Available                                = 1,
	Offering                                 = 2,
	MAX                                      = 3,
};

// Enum keaton.ECAActivityRewardType
// NumValues: 0x0006
enum class ECAActivityRewardType : uint8
{
	Invalid                                  = 0,
	Intel                                    = 1,
	Event                                    = 2,
	Power                                    = 3,
	Value                                    = 4,
	MAX                                      = 5,
};

// Enum keaton.ECARewardQuerySourceTypeScope
// NumValues: 0x0006
enum class ECARewardQuerySourceTypeScope : uint8
{
	NPC                                      = 0,
	SupplyCrate                              = 1,
	GadgetBox                                = 2,
	Vault                                    = 3,
	All                                      = 4,
	ECARewardQuerySourceTypeScope_MAX        = 5,
};

// Enum keaton.ECARewardQueryLocationScope
// NumValues: 0x0005
enum class ECARewardQueryLocationScope : uint8
{
	ObjectiveLoop                            = 0,
	Area                                     = 1,
	Module                                   = 2,
	Ship                                     = 3,
	ECARewardQueryLocationScope_MAX          = 4,
};

// Enum keaton.ECARewardQueryReceiverScope
// NumValues: 0x0004
enum class ECARewardQueryReceiverScope : uint8
{
	Player                                   = 0,
	Team                                     = 1,
	General                                  = 2,
	ECARewardQueryReceiverScope_MAX          = 3,
};

// Enum keaton.ECAItemProgressionSetSubjectType
// NumValues: 0x0003
enum class ECAItemProgressionSetSubjectType : uint8
{
	Player                                   = 0,
	Team                                     = 1,
	ECAItemProgressionSetSubjectType_MAX     = 2,
};

// Enum keaton.ECARuleCriteriaEvaluationResult
// NumValues: 0x0004
enum class ECARuleCriteriaEvaluationResult : uint8
{
	Unevaluated                              = 0,
	EvaluatesTrue                            = 1,
	EvaluatesFalse                           = 2,
	ECARuleCriteriaEvaluationResult_MAX      = 3,
};

// Enum keaton.ECARewardDistributionRuleOperationParameterType
// NumValues: 0x0003
enum class ECARewardDistributionRuleOperationParameterType : uint8
{
	GivenValue                               = 0,
	PlayerGuidanceLevelWeight                = 1,
	ECARewardDistributionRuleOperationParameterType_MAX = 2,
};

// Enum keaton.ECARewardDistributionRuleOperationTargetType
// NumValues: 0x0003
enum class ECARewardDistributionRuleOperationTargetType : uint8
{
	GivenRewardTags                          = 0,
	SelectedRewardTags                       = 1,
	ECARewardDistributionRuleOperationTargetType_MAX = 2,
};

// Enum keaton.ECARewardDistributionRuleOperationType
// NumValues: 0x0005
enum class ECARewardDistributionRuleOperationType : uint8
{
	Set                                      = 0,
	Multiply                                 = 1,
	Add                                      = 2,
	Subtract                                 = 3,
	ECARewardDistributionRuleOperationType_MAX = 4,
};

// Enum keaton.ECARotationState
// NumValues: 0x0004
enum class ECARotationState : uint8
{
	AdjustOnMaxDelta                         = 0,
	FaceAim                                  = 1,
	Freeze                                   = 2,
	ECARotationState_MAX                     = 3,
};

// Enum keaton.ECAItemEvent
// NumValues: 0x0006
enum class ECAItemEvent : uint8
{
	PickedUp                                 = 0,
	Dropped                                  = 1,
	Swapped                                  = 2,
	Upgraded                                 = 3,
	Used                                     = 4,
	MAX                                      = 5,
};

// Enum keaton.ECABreachDeviceState
// NumValues: 0x0005
enum class ECABreachDeviceState : uint8
{
	NotPlanted                               = 0,
	Planted                                  = 1,
	Destroyed                                = 2,
	BreachCompleted                          = 3,
	MAX                                      = 4,
};

// Enum keaton.ECAHealthStateChange
// NumValues: 0x0005
enum class ECAHealthStateChange : uint8
{
	NoChange                                 = 0,
	Downed                                   = 1,
	Killed                                   = 2,
	Executed                                 = 3,
	ECAHealthStateChange_MAX                 = 4,
};

// Enum keaton.ECADamageSourceType
// NumValues: 0x000A
enum class ECADamageSourceType : uint8
{
	PlayerOther                              = 0,
	PlayerExecution                          = 1,
	PlayerPrimaryWeapon                      = 2,
	PlayerSecondaryWeapon                    = 3,
	SpecialistAbility                        = 4,
	NPC                                      = 5,
	Security                                 = 6,
	Other                                    = 7,
	Unknown                                  = 8,
	MAX                                      = 9,
};

// Enum keaton.ECACharacterLoaderID
// NumValues: 0x0004
enum class ECACharacterLoaderID : uint8
{
	Player_0                                 = 0,
	Player_1                                 = 1,
	Player_2                                 = 2,
	MAX                                      = 3,
};

// Enum keaton.ECAScreenPreloadGroup
// NumValues: 0x0009
enum class ECAScreenPreloadGroup : uint8
{
	None                                     = 0,
	Collection                               = 1,
	Lobby                                    = 2,
	Startup                                  = 3,
	Prestige                                 = 4,
	EndMatch                                 = 5,
	Tutorial                                 = 6,
	GC                                       = 7,
	ECAScreenPreloadGroup_MAX                = 8,
};

// Enum keaton.ECARequestScreenStatus
// NumValues: 0x0007
enum class ECARequestScreenStatus : uint8
{
	Initialising                             = 0,
	Pending                                  = 1,
	AlreadyShowing                           = 2,
	Showing                                  = 3,
	Complete                                 = 4,
	Error                                    = 5,
	ECARequestScreenStatus_MAX               = 6,
};

// Enum keaton.ECARequestScreenPins
// NumValues: 0x0005
enum class ECARequestScreenPins : uint8
{
	PassThrough                              = 0,
	AlreadyShowing                           = 1,
	OnShow                                   = 2,
	OnError                                  = 3,
	ECARequestScreenPins_MAX                 = 4,
};

// Enum keaton.ECAFrontEndZones
// NumValues: 0x000B
enum class ECAFrontEndZones : uint8
{
	StartUp                                  = 0,
	Home                                     = 1,
	EndMatch                                 = 2,
	PlayerProfile                            = 3,
	Collection                               = 4,
	Social                                   = 5,
	Challenges                               = 6,
	News                                     = 7,
	Options                                  = 8,
	Other                                    = 9,
	ECAFrontEndZones_MAX                     = 10,
};

// Enum keaton.ECADisplaySlotPrefixes
// NumValues: 0x0006
enum class ECADisplaySlotPrefixes : uint8
{
	Main                                     = 0,
	Permanent                                = 1,
	Dialogue                                 = 2,
	Debug                                    = 3,
	Other                                    = 4,
	ECADisplaySlotPrefixes_MAX               = 5,
};

// Enum keaton.ECADisplaySlot
// NumValues: 0x0017
enum class ECADisplaySlot : uint8
{
	None                                     = 0,
	MainASlot                                = 1,
	MainBSlot                                = 2,
	MainCSlot                                = 3,
	MainDSlot                                = 4,
	MainESlot                                = 5,
	SlotF                                    = 6,
	SlotG                                    = 7,
	SlotH                                    = 8,
	SlotI                                    = 9,
	SlotJ                                    = 10,
	BackgroundSlot                           = 11,
	PermanentPlayerCard                      = 12,
	PermanentFooterSlot                      = 13,
	PermanentHeaderLeftSlot                  = 14,
	PermanentHeaderRightSlot                 = 15,
	PermanentSubHeaderSlot                   = 16,
	PermanentNotificationSlot                = 17,
	PermanentTextChatSlot                    = 18,
	DialogueAlertSlot                        = 19,
	OverlaySlot                              = 20,
	DebugSlot                                = 21,
	MAX                                      = 22,
};

// Enum keaton.ECALayoutID
// NumValues: 0x0005
enum class ECALayoutID : uint8
{
	None                                     = 0,
	LayoutA                                  = 1,
	LayoutB                                  = 2,
	LayoutC                                  = 3,
	MAX                                      = 4,
};

// Enum keaton.ECAScreenID
// NumValues: 0x0002
enum class ECAScreenID : uint8
{
	None                                     = 0,
	ECAScreenID_MAX                          = 1,
};

// Enum keaton.ECAZoneState
// NumValues: 0x0006
enum class ECAZoneState : uint8
{
	Normal                                   = 0,
	Alerted                                  = 1,
	Lockdown                                 = 2,
	Recovery                                 = 3,
	Invalid                                  = 4,
	ECAZoneState_MAX                         = 5,
};

// Enum keaton.ECADetectorType
// NumValues: 0x0003
enum class ECADetectorType : uint8
{
	Trap                                     = 0,
	NPC                                      = 1,
	ECADetectorType_MAX                      = 2,
};

// Enum keaton.ECASecurityModuleType
// NumValues: 0x0005
enum class ECASecurityModuleType : uint8
{
	Module                                   = 0,
	CampArea                                 = 1,
	ExtractionArea                           = 2,
	ObjectiveLoop                            = 3,
	ECASecurityModuleType_MAX                = 4,
};

// Enum keaton.ECASenseThresholds
// NumValues: 0x0005
enum class ECASenseThresholds : uint8
{
	ThresholdLower                           = 0,
	ThresholdUpper                           = 1,
	ThresholdMax                             = 2,
	NumThresholds                            = 3,
	ECASenseThresholds_MAX                   = 4,
};

// Enum keaton.ECAServicesErrorResponse
// NumValues: 0x0008
enum class ECAServicesErrorResponse : uint8
{
	None                                     = 0,
	Exit                                     = 1,
	Restart                                  = 2,
	Continue                                 = 3,
	Retry                                    = 4,
	Resolve                                  = 5,
	CustomEvent                              = 6,
	ECAServicesErrorResponse_MAX             = 7,
};

// Enum keaton.ECAAvailableVia
// NumValues: 0x0006
enum class ECAAvailableVia : uint8
{
	Unknown                                  = 0,
	LevelUp                                  = 1,
	Mastery                                  = 2,
	Prestige                                 = 3,
	BattlePass                               = 4,
	ECAAvailableVia_MAX                      = 5,
};

// Enum keaton.ECAObtainableType
// NumValues: 0x0003
enum class ECAObtainableType : uint8
{
	None                                     = 0,
	Purchase                                 = 1,
	ECAObtainableType_MAX                    = 2,
};

// Enum keaton.ECAServicesSlot
// NumValues: 0x000A
enum class ECAServicesSlot : uint8
{
	Invalid                                  = 0,
	Melee_weapons                            = 1,
	Primary_weapons                          = 2,
	Secondary_weapons                        = 3,
	Utility_items                            = 4,
	Healing_items                            = 5,
	Specialist_skins                         = 6,
	Weapon_skins                             = 7,
	Pendants                                 = 8,
	ECAServicesSlot_MAX                      = 9,
};

// Enum keaton.ECAPlayerExtractionStatus
// NumValues: 0x0005
enum class ECAPlayerExtractionStatus : uint8
{
	DroppedOut                               = 0,
	Killed                                   = 1,
	NotExtracted                             = 2,
	Extracted                                = 3,
	ECAPlayerExtractionStatus_MAX            = 4,
};

// Enum keaton.ECANPCSquadTagEvaluationType
// NumValues: 0x0003
enum class ECANPCSquadTagEvaluationType : uint8
{
	And                                      = 0,
	Or                                       = 1,
	ECANPCSquadTagEvaluationType_MAX         = 2,
};

// Enum keaton.ECANPCSquadSpecifierType
// NumValues: 0x0004
enum class ECANPCSquadSpecifierType : uint8
{
	Manual                                   = 0,
	Reference                                = 1,
	Tags                                     = 2,
	ECANPCSquadSpecifierType_MAX             = 3,
};

// Enum keaton.ECANPCSpawnInterCoherencyType
// NumValues: 0x0005
enum class ECANPCSpawnInterCoherencyType : uint8
{
	RandomCoherency                          = 0,
	NoCoherency                              = 1,
	FullCoherency                            = 2,
	UseSpawnEQSQuery                         = 3,
	ECANPCSpawnInterCoherencyType_MAX        = 4,
};

// Enum keaton.ECANPCSpawnCoherencyType
// NumValues: 0x0005
enum class ECANPCSpawnCoherencyType : uint8
{
	RandomCoherency                          = 0,
	NoCoherency                              = 1,
	FullCoherency                            = 2,
	UseSpawnEQSQuery                         = 3,
	ECANPCSpawnCoherencyType_MAX             = 4,
};

// Enum keaton.ECAMissionObjectiveAreaSelectionWeightTypes
// NumValues: 0x0015
enum class ECAMissionObjectiveAreaSelectionWeightTypes : uint8
{
	ClosestToAverageNPCLocation              = 0,
	PreviouslySelected                       = 1,
	PreviouslySelectedThatHasNotYetBeenReached = 2,
	IsMissionArea                            = 3,
	IsParentToMissionArea                    = 4,
	Escalated                                = 5,
	ContainsVault                            = 6,
	ContainsClosedVault                      = 7,
	ContainsVaultBeingHacked                 = 8,
	ContainsOpenVault                        = 9,
	ContainsExtractionPoint                  = 10,
	ContainsActiveExtractionPoint            = 11,
	ContainsLoot                             = 12,
	ContainsHighestLootValue                 = 13,
	ContainsReachableVaultBeingHackedWithLowestRemainingTime = 14,
	ContainsPlayerWithHighestScore           = 15,
	ContainsTeamWithHighestScore             = 16,
	ContainsPlayers                          = 17,
	ContainsHighestPlayerCount               = 18,
	ContainsHighestPlayerTeamCount           = 19,
	ECAMissionObjectiveAreaSelectionWeightTypes_MAX = 20,
};

// Enum keaton.ECAMissionObjectiveAreaType
// NumValues: 0x0003
enum class ECAMissionObjectiveAreaType : uint8
{
	SecurityArea                             = 0,
	SecurityModule                           = 1,
	ECAMissionObjectiveAreaType_MAX          = 2,
};

// Enum keaton.ECAMissionObjectiveType
// NumValues: 0x0004
enum class ECAMissionObjectiveType : uint8
{
	Job                                      = 0,
	PlayerLastKnownLocation                  = 1,
	MissionObjective                         = 2,
	ECAMissionObjectiveType_MAX              = 3,
};

// Enum keaton.ECALimiter
// NumValues: 0x0004
enum class ECALimiter : uint8
{
	PerMissionArea                           = 0,
	PerKnownTeamInMissionArea                = 1,
	PerKnownPlayerInMissionArea              = 2,
	ECALimiter_MAX                           = 3,
};

// Enum keaton.ECAMissionAreaType
// NumValues: 0x0003
enum class ECAMissionAreaType : uint8
{
	SecurityArea                             = 0,
	SecurityModule                           = 1,
	ECAMissionAreaType_MAX                   = 2,
};

// Enum keaton.ECAMotivationActivationPhaseMode
// NumValues: 0x0003
enum class ECAMotivationActivationPhaseMode : uint8
{
	Sequential                               = 0,
	Parallel                                 = 1,
	ECAMotivationActivationPhaseMode_MAX     = 2,
};

// Enum keaton.ECATriValue
// NumValues: 0x0004
enum class ECATriValue : uint8
{
	DefaultVal                               = 0,
	TrueVal                                  = 1,
	FalseVal                                 = 2,
	ECATriValue_MAX                          = 3,
};

// Enum keaton.ECAMissionObjectiveLocationType
// NumValues: 0x0004
enum class ECAMissionObjectiveLocationType : uint8
{
	Static                                   = 0,
	Dynamic                                  = 1,
	Default                                  = 2,
	ECAMissionObjectiveLocationType_MAX      = 3,
};

// Enum keaton.ECAMissionState
// NumValues: 0x0004
enum class ECAMissionState : uint8
{
	Initializing                             = 0,
	Running                                  = 1,
	Terminated                               = 2,
	ECAMissionState_MAX                      = 3,
};

// Enum keaton.ECAMissionManagerInitializeMissionsMode
// NumValues: 0x0003
enum class ECAMissionManagerInitializeMissionsMode : uint8
{
	KeepPreviousMissions                     = 0,
	TerminateAllMissions                     = 1,
	ECAMissionManagerInitializeMissionsMode_MAX = 2,
};

// Enum keaton.ECAMissionAreaDialogueEvent
// NumValues: 0x0010
enum class ECAMissionAreaDialogueEvent : uint8
{
	NewMissionWaveStarting                   = 0,
	NewMissionWaveStarted                    = 1,
	MissionEnding                            = 2,
	MissionEnded                             = 3,
	AreaEscalated                            = 4,
	AreaDeescalated                          = 5,
	LootableAreaEscalated                    = 6,
	LootableAreaDeescalated                  = 7,
	LootTaken                                = 8,
	VaultCleared                             = 9,
	ExtractionPowered                        = 10,
	ExtractionActivated                      = 11,
	VaultHackStarted                         = 12,
	VaultOpen                                = 13,
	RigMissionCalled                         = 14,
	ECAMissionAreaDialogueEvent_MAX          = 15,
};

// Enum keaton.ECAShipsVoicePriority
// NumValues: 0x0005
enum class ECAShipsVoicePriority : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Critical                                 = 3,
	ECAShipsVoicePriority_MAX                = 4,
};

// Enum keaton.ECAShipWideEventSecurityAreaQueryType
// NumValues: 0x0005
enum class ECAShipWideEventSecurityAreaQueryType : uint8
{
	Type                                     = 0,
	TypeAndSecurityGroup                     = 1,
	SecurityAreaProvidedByTrigger            = 2,
	CustomSecurityAreaQuery                  = 3,
	ECAShipWideEventSecurityAreaQueryType_MAX = 4,
};

// Enum keaton.ECASecurityAreaEnteredStateTriggerSubtype
// NumValues: 0x0004
enum class ECASecurityAreaEnteredStateTriggerSubtype : uint8
{
	SingleSecurityArea                       = 0,
	AllSecurityAreasWithSameStateMachine     = 1,
	SpecificNumberOfSecurityAreas            = 2,
	ECASecurityAreaEnteredStateTriggerSubtype_MAX = 3,
};

// Enum keaton.ECAShipWideEventTrigger
// NumValues: 0x0007
enum class ECAShipWideEventTrigger : uint8
{
	MatchStart                               = 0,
	SecurityAreaEnteredState                 = 1,
	ThresholdReached                         = 2,
	AllVaultsLootedNoTeamThreshold           = 3,
	ExtractionVolumeEnabled                  = 4,
	MatchTimeElapsed                         = 5,
	ECAShipWideEventTrigger_MAX              = 6,
};

// Enum keaton.ECAPlayerCardAddButtonBehaviour
// NumValues: 0x0005
enum class ECAPlayerCardAddButtonBehaviour : uint8
{
	AlwaysShow                               = 0,
	NeverShow                                = 1,
	OnlyShowUnknown                          = 2,
	OnlyShowPendingOutbound                  = 3,
	ECAPlayerCardAddButtonBehaviour_MAX      = 4,
};

// Enum keaton.ECAUIFriendInviteStatus
// NumValues: 0x0007
enum class ECAUIFriendInviteStatus : uint8
{
	Unknown                                  = 0,
	Accepted                                 = 1,
	PendingInbound                           = 2,
	PendingOutbound                          = 3,
	Blocked                                  = 4,
	Suggested                                = 5,
	ECAUIFriendInviteStatus_MAX              = 6,
};

// Enum keaton.ESpawnerType
// NumValues: 0x0005
enum class ESpawnerType : uint8
{
	Point                                    = 0,
	Group                                    = 1,
	Station                                  = 2,
	Gadget                                   = 3,
	ESpawnerType_MAX                         = 4,
};

// Enum keaton.ECANPCType
// NumValues: 0x000E
enum class ECANPCType : uint8
{
	S_None                                   = 0,
	S_HumanGrunt                             = 1,
	S_HumanShotgun                           = 2,
	S_HumanRocketeer                         = 3,
	S_EliteLaser                             = 4,
	S_EliteTank                              = 5,
	S_DroneLight                             = 6,
	S_DroneRusher                            = 7,
	S_TurretRailgun                          = 8,
	S_TurretSpecialist                       = 9,
	S_TurretSpecialist_WallVariation         = 10,
	S_Bot_Metaller                           = 11,
	S_Bot_BankRobber                         = 12,
	S_MAX                                    = 13,
};

// Enum keaton.ECASpecialistPerkType
// NumValues: 0x0003
enum class ECASpecialistPerkType : uint8
{
	Signature                                = 0,
	Archetype                                = 1,
	ECASpecialistPerkType_MAX                = 2,
};

// Enum keaton.ESplineActuatorDirection
// NumValues: 0x0003
enum class ESplineActuatorDirection : uint8
{
	Forward                                  = 0,
	Backward                                 = 1,
	ESplineActuatorDirection_MAX             = 2,
};

// Enum keaton.ESplineActuatorWrapType
// NumValues: 0x0004
enum class ESplineActuatorWrapType : uint8
{
	Clamp                                    = 0,
	Wrap                                     = 1,
	Oscillate                                = 2,
	ESplineActuatorWrapType_MAX              = 3,
};

// Enum keaton.EStatus
// NumValues: 0x0003
enum class EStatus : uint8
{
	Active                                   = 0,
	Inactive                                 = 1,
	EStatus_MAX                              = 2,
};

// Enum keaton.ECASubtitlesTextSize
// NumValues: 0x0004
enum class ECASubtitlesTextSize : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	ECASubtitlesTextSize_MAX                 = 3,
};

// Enum keaton.ESysSecurityEventType
// NumValues: 0x0017
enum class ESysSecurityEventType : uint8
{
	Seen                                     = 0,
	LostSight                                = 1,
	Heard                                    = 2,
	TriggeredAlarm                           = 3,
	DamageTaken                              = 4,
	TriggerMaximumAlert                      = 5,
	SeenFiringWeapon                         = 6,
	SeenUsingExplosive                       = 7,
	SeenAttackingDeviceWithWeapon            = 8,
	SeenAttackingDeviceWithEmp               = 9,
	SeenAttackingNpcWithWeapon               = 10,
	SeenAttackingNpcWithEmp                  = 11,
	SeenDestroyingDeviceWithWeapon           = 12,
	SeenDestroyingDeviceWithExplosive        = 13,
	SeenDestroyingNpcWithWeapon              = 14,
	SeenDestroyingNpcWithExplosive           = 15,
	KilledEntityFound                        = 16,
	ExplosiveDecompression                   = 17,
	ReportingActorDead                       = 18,
	ExtractionStarted                        = 19,
	ObjectivePickedUp                        = 20,
	GlobalObjectivePickedUp                  = 21,
	MAX                                      = 22,
};

// Enum keaton.ECAAIActorTypes
// NumValues: 0x0008
enum class ECAAIActorTypes : uint8
{
	Door                                     = 0,
	Vault                                    = 1,
	Extraction                               = 2,
	MissionObjective                         = 3,
	Loot                                     = 4,
	Jobs                                     = 5,
	IntelTerminals                           = 6,
	ECAAIActorTypes_MAX                      = 7,
};

// Enum keaton.ECAWaypointTrackingMovementType
// NumValues: 0x0003
enum class ECAWaypointTrackingMovementType : uint8
{
	Loop                                     = 0,
	Alternate                                = 1,
	ECAWaypointTrackingMovementType_MAX      = 2,
};

// Enum keaton.ESysTrackingStateType
// NumValues: 0x0006
enum class ESysTrackingStateType : uint8
{
	TRACKING_OFF                             = 0,
	TRACKING_SCANNING                        = 1,
	TRACKING_IDENTIFYING                     = 2,
	TRACKING_UPLOADING                       = 3,
	TRACKING_ALERTED                         = 4,
	TRACKING_MAX                             = 5,
};

// Enum keaton.ECATargetInViewCone
// NumValues: 0x0006
enum class ECATargetInViewCone : uint8
{
	TargetNotInViewCone                      = 0,
	CloseViewCone                            = 1,
	MediumViewCone                           = 2,
	LongViewCone                             = 3,
	NumViewCones                             = 4,
	ECATargetInViewCone_MAX                  = 5,
};

// Enum keaton.ECANPCTargetAssignmentTypes
// NumValues: 0x0009
enum class ECANPCTargetAssignmentTypes : uint8
{
	None                                     = 0,
	Security                                 = 1,
	SenseSight                               = 2,
	SenseHearing                             = 4,
	SenseDamage                              = 8,
	CurrentlyAssigned                        = 16,
	SenseTouch                               = 32,
	SenseWeapon                              = 64,
	ECANPCTargetAssignmentTypes_MAX          = 65,
};

// Enum keaton.ECATargetScoreRange
// NumValues: 0x000B
enum class ECATargetScoreRange : uint8
{
	Range_Band_9                             = 0,
	Range_Band_8                             = 1,
	Range_Band_7                             = 2,
	Range_Band_6                             = 3,
	Range_Band_5                             = 4,
	Range_Band_4                             = 5,
	Range_Band_3                             = 6,
	Range_Band_2                             = 7,
	Range_Band_1                             = 8,
	Range_Band_0                             = 9,
	Range_Band_MAX                           = 10,
};

// Enum keaton.ECATargetRuleEvaluationType
// NumValues: 0x0003
enum class ECATargetRuleEvaluationType : uint8
{
	Score_Result                             = 0,
	Filter_Result                            = 1,
	ECATargetRuleEvaluationType_MAX          = 2,
};

// Enum keaton.ECATargetVisibility
// NumValues: 0x0005
enum class ECATargetVisibility : uint8
{
	TargetNotVisible                         = 0,
	TargetBody                               = 1,
	TargetHead                               = 2,
	NumTargetVisibility                      = 3,
	ECATargetVisibility_MAX                  = 4,
};

// Enum keaton.ECATeamIDNumbers
// NumValues: 0x000B
enum class ECATeamIDNumbers : uint8
{
	Player_Team_Min                          = 0,
	Player_Team_Max                          = 199,
	NPC_Team_Number_Min                      = 200,
	NPC_Team_Default                         = 200,
	NPC_Team_Allied_With_Players             = 201,
	NPC_Team_Number_Min_Unreserved           = 202,
	Environment_Team                         = 203,
	NPC_Team_Number_Max                      = 253,
	All_Player_Teams                         = 254,
	NPC_Team_Invalid                         = 255,
	ECATeamIDNumbers_MAX                     = 256,
};

// Enum keaton.ECATeleportLifetimeSetup
// NumValues: 0x0004
enum class ECATeleportLifetimeSetup : uint8
{
	NoLifespan                               = 0,
	LifespanFromDeploy                       = 1,
	LifespanFromUses                         = 2,
	ECATeleportLifetimeSetup_MAX             = 3,
};

// Enum keaton.ECATimedMovementFlags
// NumValues: 0x0013
enum class ECATimedMovementFlags : uint8
{
	ECAM_Moving                              = 0,
	ECAM_Flashing                            = 1,
	ECAM_Pulsing                             = 2,
	ECAM_IsBeamActive                        = 3,
	ECAM_IsBeamVisible                       = 4,
	ECAM_IsBeamHidden                        = 5,
	ECAM_IsBeamTriggered                     = 6,
	ECAM_IsBeamDisarmed                      = 7,
	ECAM_IsBeamRearming                      = 8,
	ECAM_HasAuthority                        = 9,
	ECAM_UpdateTags                          = 10,
	ECAM_IsTicking                           = 11,
	ECAM_IsPaused                            = 12,
	ECAM_IsOccupied                          = 13,
	ECAM_IsAlerted                           = 14,
	ECAM_IsDetectingWhileOccupied            = 15,
	ECAM_PendingState                        = 16,
	ECAM_HasBeenTriggered                    = 17,
	ECAM_MAX                                 = 18,
};

// Enum keaton.ETransitionState
// NumValues: 0x0006
enum class ETransitionState : uint8
{
	Inactive                                 = 0,
	Deactivating                             = 1,
	Active                                   = 2,
	Activating                               = 3,
	Suspended                                = 4,
	ETransitionState_MAX                     = 5,
};

// Enum keaton.ETransitionOperatorState
// NumValues: 0x0007
enum class ETransitionOperatorState : uint8
{
	Undefined                                = 0,
	Inactive                                 = 1,
	Deactivating                             = 2,
	Active                                   = 3,
	Activating                               = 4,
	Suspended                                = 5,
	ETransitionOperatorState_MAX             = 6,
};

// Enum keaton.ECATweenEaseType
// NumValues: 0x0020
enum class ECATweenEaseType : uint8
{
	Linear                                   = 0,
	EaseInQuadratic                          = 1,
	EaseOutQuadratic                         = 2,
	EaseInAndOutQuadratic                    = 3,
	EaseInCubic                              = 4,
	EaseOutCubic                             = 5,
	EaseInAndOutCubic                        = 6,
	EaseInQuartic                            = 7,
	EaseOutQuartic                           = 8,
	EaseInAndOutQuartic                      = 9,
	EaseInQuintic                            = 10,
	EaseOutQuintic                           = 11,
	EaseInAndOutQuintic                      = 12,
	EaseInSine                               = 13,
	EaseOutSine                              = 14,
	EaseInAndOutSine                         = 15,
	EaseInExponential                        = 16,
	EaseOutExponential                       = 17,
	EaseInAndOutExponential                  = 18,
	EaseInCircular                           = 19,
	EaseOutCircular                          = 20,
	EaseInAndOutCircular                     = 21,
	EaseInBounce                             = 22,
	EaseOutBounce                            = 23,
	EaseInAndOutBounce                       = 24,
	EaseInBack                               = 25,
	EaseOutBack                              = 26,
	EaseInAndOutBack                         = 27,
	EaseInElastic                            = 28,
	EaseOutElastic                           = 29,
	EaseInAndOutElastic                      = 30,
	ECATweenEaseType_MAX                     = 31,
};

// Enum keaton.OUT_EXEC_TWEEN
// NumValues: 0x0004
enum class EOUT_EXEC_TWEEN : uint8
{
	PassThrough                              = 0,
	Update                                   = 1,
	Complete                                 = 2,
	OUT_EXEC_MAX                             = 3,
};

// Enum keaton.ECAChallengesType
// NumValues: 0x0006
enum class ECAChallengesType : uint8
{
	None                                     = 0,
	All                                      = 1,
	Training                                 = 2,
	Daily                                    = 3,
	Mastery                                  = 4,
	ECAChallengesType_MAX                    = 5,
};

// Enum keaton.ECAUIOptionDataType
// NumValues: 0x0007
enum class ECAUIOptionDataType : uint8
{
	None                                     = 0,
	bool_value                               = 1,
	Int_value                                = 2,
	Float_value                              = 3,
	String_value                             = 4,
	Max                                      = 5,
	ECAUIOptionDataType_MAX                  = 6,
};

// Enum keaton.ECAUIHUDEntityType
// NumValues: 0x001D
enum class ECAUIHUDEntityType : uint8
{
	Stairwell                                = 0,
	Keycard                                  = 1,
	PlayableCharacter                        = 2,
	Mission                                  = 3,
	Objective                                = 4,
	ExtractionPoint                          = 5,
	NPC                                      = 6,
	Door                                     = 7,
	StartingPoint                            = 8,
	Consumable                               = 9,
	Equipment                                = 10,
	Waypoint                                 = 11,
	Ping                                     = 12,
	Terminal                                 = 13,
	Valuables                                = 14,
	Switch                                   = 15,
	SystemObject                             = 16,
	Fire                                     = 17,
	RespawnPoint                             = 18,
	Projectile                               = 19,
	TeleportPoint                            = 20,
	ArmourPing                               = 21,
	OffensiveGadget                          = 22,
	UtilityGadget                            = 23,
	UtilityArmourGadget                      = 24,
	WeaponBuff                               = 25,
	SpawnPoint                               = 26,
	TeamGadget                               = 27,
	MAX                                      = 28,
};

// Enum keaton.ECATickPriorities
// NumValues: 0x0005
enum class ECATickPriorities : uint8
{
	Static                                   = 0,
	Periodic                                 = 1,
	Volatile                                 = 2,
	RegionMarker                             = 3,
	ECATickPriorities_MAX                    = 4,
};

// Enum keaton.ECAMapArea
// NumValues: 0x0007
enum class ECAMapArea : uint8
{
	Engineering                              = 0,
	Farming                                  = 1,
	Seeding                                  = 2,
	QualityControl                           = 3,
	ServiceCore                              = 4,
	Invalid                                  = 5,
	ECAMapArea_MAX                           = 6,
};

// Enum keaton.ECAUIOptionCacheState
// NumValues: 0x0005
enum class ECAUIOptionCacheState : uint8
{
	None                                     = 0,
	FromDefault                              = 1,
	FromSave                                 = 2,
	FromCache                                = 3,
	ECAUIOptionCacheState_MAX                = 4,
};

// Enum keaton.ECAUIPlatforms
// NumValues: 0x0006
enum class ECAUIPlatforms : uint8
{
	WINDOWS                                  = 0,
	XB1                                      = 1,
	XBX                                      = 2,
	PS4                                      = 3,
	PS5                                      = 4,
	ECAUIPlatforms_MAX                       = 5,
};

// Enum keaton.ECAServicesNotificationState
// NumValues: 0x0007
enum class ECAServicesNotificationState : uint8
{
	None                                     = 0,
	Claimed                                  = 1,
	Notified                                 = 2,
	Celebrated_major                         = 3,
	Celebrated_minor                         = 4,
	Complete                                 = 5,
	ECAServicesNotificationState_MAX         = 6,
};

// Enum keaton.ECAUIFlowTrackingState
// NumValues: 0x000A
enum class ECAUIFlowTrackingState : uint8
{
	None                                     = 0,
	HasShownStartScreen                      = 1,
	HasFooterBeenTurnedOn                    = 2,
	HasNavigatedNonEssentialFetch            = 3,
	HasResolvedServicesError                 = 4,
	HasNavigatedEndMatch                     = 5,
	HasStartupCompleted                      = 6,
	HasRequestedDailyChallenges              = 7,
	HasShownPostTutorialPurchase             = 8,
	ECAUIFlowTrackingState_MAX               = 9,
};

// Enum keaton.ECAFTUETrackingFlag
// NumValues: 0x0004
enum class ECAFTUETrackingFlag : uint8
{
	None                                     = 0,
	HasShownTutorialComplete                 = 1,
	HasShownGameModeSelection                = 2,
	ECAFTUETrackingFlag_MAX                  = 3,
};

// Enum keaton.ECAFTUEState
// NumValues: 0x0008
enum class ECAFTUEState : uint8
{
	FirstRun                                 = 0,
	TutorialWelcome                          = 1,
	Tutorial                                 = 2,
	PostTutorialPurchase                     = 3,
	PvE                                      = 4,
	Complete                                 = 5,
	Any                                      = 6,
	ECAFTUEState_MAX                         = 7,
};

// Enum keaton.ECAFrontendContext
// NumValues: 0x000B
enum class ECAFrontendContext : uint8
{
	None                                     = 0,
	Boot                                     = 1,
	Frontend                                 = 2,
	Lobby                                    = 3,
	Game                                     = 4,
	Tutorial                                 = 5,
	Sandbox                                  = 6,
	Benchmark                                = 7,
	PvEQuitEarly                             = 8,
	Any                                      = 9,
	MAX                                      = 10,
};

// Enum keaton.ECAVerticalNavigationType
// NumValues: 0x0006
enum class ECAVerticalNavigationType : uint32
{
	INVALID                                  = 0,
	LEDGE_DROP                               = 1,
	JUMP                                     = 2,
	VAULT                                    = 3,
	NUM                                      = 4,
	ECAVerticalNavigationType_MAX            = 5,
};

// Enum keaton.ECAViewConeActiveType
// NumValues: 0x0004
enum class ECAViewConeActiveType : uint8
{
	Always                                   = 0,
	CombatOnly                               = 1,
	NonCombatOnly                            = 2,
	ECAViewConeActiveType_MAX                = 3,
};

// Enum keaton.ECAVoiceChatState
// NumValues: 0x0006
enum class ECAVoiceChatState : uint8
{
	Unknown                                  = 0,
	Connecting                               = 1,
	Connected                                = 2,
	Disconnecting                            = 3,
	Disconnected                             = 4,
	ECAVoiceChatState_MAX                    = 5,
};

// Enum keaton.ECAVoiceChatChannel
// NumValues: 0x0003
enum class ECAVoiceChatChannel : uint8
{
	Party                                    = 0,
	Team                                     = 1,
	ECAVoiceChatChannel_MAX                  = 2,
};

// Enum keaton.ECAVoiceChatMode
// NumValues: 0x0004
enum class ECAVoiceChatMode : uint8
{
	Off                                      = 0,
	PushToTalk                               = 1,
	AlwaysOn                                 = 2,
	ECAVoiceChatMode_MAX                     = 3,
};

// Enum keaton.ECAUIVoiceChatTalkerState
// NumValues: 0x0005
enum class ECAUIVoiceChatTalkerState : uint8
{
	Default                                  = 0,
	Talking                                  = 1,
	Muted                                    = 2,
	DeviceError                              = 3,
	ECAUIVoiceChatTalkerState_MAX            = 4,
};

// Enum keaton.ECAWeaponValidationResult
// NumValues: 0x0007
enum class ECAWeaponValidationResult : uint8
{
	Success                                  = 0,
	StartLocation                            = 1,
	ClientParallelTrace                      = 2,
	HistoricalHitLocationNearTarget          = 3,
	NoData                                   = 4,
	Num                                      = 5,
	ECAWeaponValidationResult_MAX            = 6,
};

// Enum keaton.ECAWeaponBuffDisplayedCategory
// NumValues: 0x0010
enum class ECAWeaponBuffDisplayedCategory : uint8
{
	None                                     = 0,
	EquipTime                                = 1,
	AdsDelay                                 = 2,
	ReloadRate                               = 3,
	ClipSize                                 = 4,
	Spread                                   = 5,
	SpreadAds                                = 6,
	DamageHead                               = 7,
	DamageNpc                                = 8,
	FireRate                                 = 9,
	ShotsPerPress                            = 10,
	Recoil                                   = 11,
	RecoilAds                                = 12,
	Damage                                   = 13,
	DamageAoe                                = 14,
	ECAWeaponBuffDisplayedCategory_MAX       = 15,
};

// Enum keaton.ECAWeaponBuffableStatID
// NumValues: 0x0023
enum class ECAWeaponBuffableStatID : uint8
{
	Invalid                                  = 0,
	ClipSize                                 = 1,
	EquipInTime                              = 2,
	AdsInDelay                               = 3,
	AdsFovDivider                            = 4,
	SpreadOverallMultiplier                  = 5,
	SpreadAdsMultiplier                      = 6,
	PelletDistributionMultiplier             = 7,
	PelletSpreadMultiplier                   = 8,
	FireRate                                 = 9,
	WeightFireRate                           = 10,
	VariableFireRateVariant1                 = 11,
	WeightVariant1                           = 12,
	VariableFireRateVariant2                 = 13,
	WeightVariant2                           = 14,
	TriggerReleasePenalty                    = 15,
	ReloadRate                               = 16,
	RecoilMultiplierX                        = 17,
	RecoilMultiplierY                        = 18,
	AdsRecoilMultiplierX                     = 19,
	AdsRecoilMultiplierY                     = 20,
	HipRecoilMultiplierX                     = 21,
	HipRecoilMultiplierY                     = 22,
	ShotsPerPress                            = 23,
	ShotPatternHoldTime                      = 24,
	RecoilCameraDecay                        = 25,
	RecoilCameraCutoffAngle                  = 26,
	ShotPatternDistance                      = 27,
	Range                                    = 28,
	Damage                                   = 29,
	AoeDamage                                = 30,
	HeadDamageMultiplier                     = 31,
	NpcDamageMultiplier                      = 32,
	FoamDamageMultiplier                     = 33,
	ECAWeaponBuffableStatID_MAX              = 34,
};

// Enum keaton.ECAWeaponStatID
// NumValues: 0x0086
enum class ECAWeaponStatID : uint8
{
	Invalid                                  = 0,
	FeDamagePerShot                          = 1,
	FeAccuracy                               = 2,
	FeFireRate                               = 3,
	FeRecoil                                 = 4,
	Fov                                      = 5,
	MoveSpeedMultiplier                      = 6,
	MovementExceptionTag                     = 7,
	TwoHanded                                = 8,
	SecondaryFire                            = 9,
	AbilityTransitionTableOverride           = 10,
	ClipSize                                 = 11,
	AmmoInventoryItem                        = 12,
	ExpendWholeClipOnReload                  = 13,
	EquipInTime                              = 14,
	EquipOutTime                             = 15,
	AdsInDelay                               = 16,
	AdsOutDelay                              = 17,
	AdsFovDivider                            = 18,
	AdsMovementExceptionTag                  = 19,
	AdsMoveSpeedMultiplier                   = 20,
	ShowReticuleDuringAds                    = 21,
	ShowReticuleRegular                      = 22,
	ShowReticuleReload                       = 23,
	ShowReticuleSprint                       = 24,
	OverrideMeshFovInAds                     = 25,
	OverriddenMeshFov                        = 26,
	SniperPostProcess                        = 27,
	AdsSensitivityRatio                      = 28,
	SpreadOverallMultiplier                  = 29,
	SpreadAdsMultiplier                      = 30,
	SpreadAdsStartingMultiplier              = 31,
	SpreadMovementMultiplier                 = 32,
	SpreadMovementMinimumSpeedMultiplier     = 33,
	SpreadMovementMaximumSpeedMultiplier     = 34,
	SpreadCrouchMultiplier                   = 35,
	SpreadJumpMultiplier                     = 36,
	SpreadSprintMultiplier                   = 37,
	SpreadSlideMultiplier                    = 38,
	SpreadMaximumX                           = 39,
	SpreadMaximumY                           = 40,
	SpreadZerogFloatMultiplier               = 41,
	SpreadZerogGrabMultiplier                = 42,
	SpreadZerogBootsMultiplier               = 43,
	PelletDistributionMultiplier             = 44,
	PelletSpreadMultiplier                   = 45,
	FireRate                                 = 46,
	HasVariableFireRate                      = 47,
	WeightFireRate                           = 48,
	VariableFireRateVariant1                 = 49,
	WeightVariant1                           = 50,
	VariableFireRateVariant2                 = 51,
	WeightVariant2                           = 52,
	HasDynamicFireRate                       = 53,
	FireRateBeforeFirstShot                  = 54,
	ChargeTime                               = 55,
	TriggerReleasePenalty                    = 56,
	FireNoiseRange                           = 57,
	ReloadRate                               = 58,
	ReloadTime                               = 59,
	ReloadSoftCancelDuration                 = 60,
	AlwaysFireAfterReloadSoftCancel          = 61,
	AimAssistWeaponArchetype                 = 62,
	NpcDesiredAttackRange                    = 63,
	AnimatedFireRate                         = 64,
	InfiniteAmmo                             = 65,
	InfiniteClip                             = 66,
	AutoPeekRaycastForward                   = 67,
	RecoilMultiplier                         = 68,
	RecoilMultiplierX                        = 69,
	RecoilMultiplierY                        = 70,
	AdsRecoilMultiplier                      = 71,
	AdsRecoilMultiplierX                     = 72,
	AdsRecoilMultiplierY                     = 73,
	HipRecoilMultiplier                      = 74,
	HipRecoilMultiplierX                     = 75,
	HipRecoilMultiplierY                     = 76,
	CrosshairColourChangeAdsEffectiveRange   = 77,
	CrosshairColourChangeHipEffectiveRange   = 78,
	CrosshairIndex                           = 79,
	CrosshairIndexInAdsOptional              = 80,
	FireCrosshairRadiusUpMultiplier          = 81,
	FireCrosshairUpAnimationTime             = 82,
	FireCrosshairDownAnimationSpeedMultiplier = 83,
	FireCrosshairMinimumAnimationRadius      = 84,
	CrosshairUpMultiplierInHipfire           = 85,
	FireType                                 = 86,
	ShotsPerPress                            = 87,
	PelletsPerShot                           = 88,
	PrimaryAbilityOverride                   = 89,
	SecondaryAbilityOverride                 = 90,
	Feature                                  = 91,
	ShotPatternDataTableAsset                = 92,
	ShotPatternHoldTime                      = 93,
	CameraRecoilProportion                   = 94,
	AnchorPointRecoilProportion              = 95,
	SpreadAnchorShiftProportion              = 96,
	RecoilCameraAttack                       = 97,
	RecoilCameraHold                         = 98,
	RecoilCameraDecay                        = 99,
	RecoilCameraCutoffAngle                  = 100,
	RepeatedLastIndicies                     = 101,
	ShotPatternDistance                      = 102,
	ShotPatternGamepadScale                  = 103,
	RecoilCameraDecayCurves                  = 104,
	UseRecoilDecayRange                      = 105,
	RecoilDecayRange                         = 106,
	BulletFeature                            = 107,
	DamageCurve                              = 108,
	ProjDamageCurve                          = 109,
	Range                                    = 110,
	Damage                                   = 111,
	AoeDamage                                = 112,
	HeadDamageMultiplier                     = 113,
	BodyDamageMultiplier                     = 114,
	ExtremetiesDamageMultiplier              = 115,
	RearDamageMultiplier                     = 116,
	NpcDamageMultiplier                      = 117,
	NpcComponentDamageMultiplier             = 118,
	FoamDamageMultiplier                     = 119,
	DeviceDamageMultiplier                   = 120,
	AdditionalDamageType                     = 121,
	ArmourPiercingRatio                      = 122,
	HeadDamageRatio                          = 123,
	BodyDamageRatio                          = 124,
	ExtremetiesDamageRatio                   = 125,
	MaxHealthDamageMultiplier                = 126,
	ProjLifetime                             = 127,
	ProjInitialSpeed                         = 128,
	ProjInitialAngle                         = 129,
	ProjUseLaunchConfig                      = 130,
	ProjSocketFireOffsetSocket               = 131,
	ProjClass                                = 132,
	ECAWeaponStatID_MAX                      = 133,
};

// Enum keaton.FCAFireType
// NumValues: 0x0003
enum class EFCAFireType : uint8
{
	Bullet                                   = 0,
	Projectile                               = 1,
	FCAFireType_MAX                          = 2,
};

// Enum keaton.ECADialogueTargetActorType
// NumValues: 0x0007
enum class ECADialogueTargetActorType : uint8
{
	SELF                                     = 0,
	TEAM                                     = 1,
	TEAM_RELATIONSHIP                        = 2,
	TEAM_RECIPIENT                           = 3,
	RIVAL                                    = 4,
	NPC                                      = 5,
	ECADialogueTargetActorType_MAX           = 6,
};

// Enum keaton.ECAWritebackOperator
// NumValues: 0x0005
enum class ECAWritebackOperator : uint8
{
	EQUALS                                   = 0,
	PLUS_EQUALS                              = 1,
	MINUS_EQUALS                             = 2,
	NONE                                     = 3,
	ECAWritebackOperator_MAX                 = 4,
};

// Enum keaton.ECADialogueFollowUpType
// NumValues: 0x000B
enum class ECADialogueFollowUpType : uint8
{
	SELF                                     = 0,
	TEAM_RANDOM                              = 1,
	TEAM_CLOSEST                             = 2,
	TEAM_FURTHEST                            = 3,
	TEAM_QUIETEST                            = 4,
	LAST_INTERACTED                          = 5,
	RELATIONSHIP                             = 6,
	SCANNER                                  = 7,
	NPC_RANDOM                               = 8,
	ENEMY_SPECIALIST_RANDOM                  = 9,
	ECADialogueFollowUpType_MAX              = 10,
};

// Enum keaton.ECADialogueVariableOperator
// NumValues: 0x000A
enum class ECADialogueVariableOperator : uint8
{
	EQUALS                                   = 0,
	LESS                                     = 1,
	LOWER_OR_EQUAL                           = 2,
	GREATER                                  = 3,
	GREATER_OR_EQUAL                         = 4,
	TIME_LESS                                = 5,
	TIME_GREATER                             = 6,
	COOLDOWN                                 = 7,
	NONE                                     = 8,
	ECADialogueVariableOperator_MAX          = 9,
};

// Enum keaton.ECADialogueVariableScope
// NumValues: 0x0005
enum class ECADialogueVariableScope : uint8
{
	SELF                                     = 0,
	TEAM                                     = 1,
	GLOBAL                                   = 2,
	LAST_INTERACTED                          = 3,
	ECADialogueVariableScope_MAX             = 4,
};

// Enum keaton.ECADialogueVariableType
// NumValues: 0x0005
enum class ECADialogueVariableType : uint8
{
	INT                                      = 0,
	FLOAT                                    = 1,
	BOOL                                     = 2,
	STRING                                   = 3,
	ECADialogueVariableType_MAX              = 4,
};

// Enum keaton.ECAUIFetchBattleResultOutcome
// NumValues: 0x0004
enum class ECAUIFetchBattleResultOutcome : uint8
{
	Failed                                   = 0,
	Partial                                  = 1,
	Full                                     = 2,
	ECAUIFetchBattleResultOutcome_MAX        = 3,
};

// Enum keaton.ECAItemType
// NumValues: 0x0003
enum class ECAItemType : uint32
{
	Actor                                    = 0,
	Vector                                   = 1,
	ECAItemType_MAX                          = 2,
};

// Enum keaton.ECADistanceOverride
// NumValues: 0x0004
enum class ECADistanceOverride : uint8
{
	None                                     = 0,
	MaxBehaveRadius                          = 1,
	MinBehaveRadius                          = 2,
	ECADistanceOverride_MAX                  = 3,
};

// Enum keaton.ETestMode
// NumValues: 0x0003
enum class ETestMode : uint8
{
	AIPortalGraph                            = 0,
	CASPr                                    = 1,
	ETestMode_MAX                            = 2,
};

// Enum keaton.ECAVerticalLimitTestType
// NumValues: 0x0003
enum class ECAVerticalLimitTestType : uint8
{
	Geometry                                 = 0,
	NavMesh                                  = 1,
	ECAVerticalLimitTestType_MAX             = 2,
};

// Enum keaton.ECAVerticalLimitType
// NumValues: 0x0003
enum class ECAVerticalLimitType : uint8
{
	Ceiling                                  = 0,
	Floor                                    = 1,
	ECAVerticalLimitType_MAX                 = 2,
};

// Enum keaton.ECACoverCheckType
// NumValues: 0x0006
enum class ECACoverCheckType : uint32
{
	IsCover                                  = 0,
	IsLowCover                               = 1,
	IsHighCover                              = 2,
	IsEdgeCover                              = 3,
	IsBlindCover                             = 4,
	ECACoverCheckType_MAX                    = 5,
};

// Enum keaton.ECARadiusType
// NumValues: 0x0003
enum class ECARadiusType : uint8
{
	GivenRadius                              = 0,
	FarthestFromPlayers                      = 1,
	ECARadiusType_MAX                        = 2,
};

// Enum keaton.ECAPostGameState
// NumValues: 0x0006
enum class ECAPostGameState : uint8
{
	None                                     = 0,
	GotoEndOfMatch                           = 1,
	Disconnected                             = 2,
	Development                              = 3,
	JoinServer                               = 4,
	MAX                                      = 5,
};

// Enum keaton.ELocalisationCulture
// NumValues: 0x000D
enum class ELocalisationCulture : uint8
{
	None                                     = 0,
	En_GB                                    = 1,
	Fr_FR                                    = 2,
	It_IT                                    = 3,
	De_DE                                    = 4,
	Es_ES                                    = 5,
	Pt_BR                                    = 6,
	Ru                                       = 7,
	Zh_HANS                                  = 8,
	Zh_HANT                                  = 9,
	Ko                                       = 10,
	Pl                                       = 11,
	MAX                                      = 12,
};

// Enum keaton.ETrigger
// NumValues: 0x0003
enum class ETrigger : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	ETrigger_MAX                             = 2,
};

// Enum keaton.ECAIntegerSwitchOutputPins
// NumValues: 0x0004
enum class ECAIntegerSwitchOutputPins : uint8
{
	LessThan                                 = 0,
	EqualTo                                  = 1,
	GreaterThan                              = 2,
	ECAIntegerSwitchOutputPins_MAX           = 3,
};

// ScriptStruct keaton.CAHUDAvatarImageTableRow
// 0x0030 (0x0038 - 0x0008)
struct FCAHUDAvatarImageTableRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UTexture>                M_avatar_image_data_item;                          // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDAvatarImageTableRow) == 0x000008, "Wrong alignment on FCAHUDAvatarImageTableRow");
static_assert(sizeof(FCAHUDAvatarImageTableRow) == 0x000038, "Wrong size on FCAHUDAvatarImageTableRow");
static_assert(offsetof(FCAHUDAvatarImageTableRow, M_avatar_image_data_item) == 0x000008, "Member 'FCAHUDAvatarImageTableRow::M_avatar_image_data_item' has a wrong offset!");

// ScriptStruct keaton.CAAudioProxyReplicatedLocationItem
// 0x002C (0x0038 - 0x000C)
struct FCAAudioProxyReplicatedLocationItem final : public FFastArraySerializerItem
{
public:
	uint32                                        Id;                                                // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    Location;                                          // 0x0010(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    Forward;                                           // 0x001C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACAEquipmentBase*                       Object;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAudioProxyReplicatedLocationItem) == 0x000008, "Wrong alignment on FCAAudioProxyReplicatedLocationItem");
static_assert(sizeof(FCAAudioProxyReplicatedLocationItem) == 0x000038, "Wrong size on FCAAudioProxyReplicatedLocationItem");
static_assert(offsetof(FCAAudioProxyReplicatedLocationItem, Id) == 0x00000C, "Member 'FCAAudioProxyReplicatedLocationItem::Id' has a wrong offset!");
static_assert(offsetof(FCAAudioProxyReplicatedLocationItem, Location) == 0x000010, "Member 'FCAAudioProxyReplicatedLocationItem::Location' has a wrong offset!");
static_assert(offsetof(FCAAudioProxyReplicatedLocationItem, Forward) == 0x00001C, "Member 'FCAAudioProxyReplicatedLocationItem::Forward' has a wrong offset!");
static_assert(offsetof(FCAAudioProxyReplicatedLocationItem, Object) == 0x000028, "Member 'FCAAudioProxyReplicatedLocationItem::Object' has a wrong offset!");

// ScriptStruct keaton.CAUIFlags
// 0x0008 (0x0008 - 0x0000)
struct FCAUIFlags final
{
public:
	struct FFeatureKeyItem                        M_feature_flag;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         M_valid_platforms;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAUIFlags) == 0x000004, "Wrong alignment on FCAUIFlags");
static_assert(sizeof(FCAUIFlags) == 0x000008, "Wrong size on FCAUIFlags");
static_assert(offsetof(FCAUIFlags, M_feature_flag) == 0x000000, "Member 'FCAUIFlags::M_feature_flag' has a wrong offset!");
static_assert(offsetof(FCAUIFlags, M_valid_platforms) == 0x000004, "Member 'FCAUIFlags::M_valid_platforms' has a wrong offset!");

// ScriptStruct keaton.CAUITransitionDefinition
// 0x0018 (0x0018 - 0x0000)
struct FCAUITransitionDefinition final
{
public:
	struct FCAGameDatabaseRowHandle               M_transition_handle;                               // 0x0000(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAUITransitionDefinition) == 0x000004, "Wrong alignment on FCAUITransitionDefinition");
static_assert(sizeof(FCAUITransitionDefinition) == 0x000018, "Wrong size on FCAUITransitionDefinition");
static_assert(offsetof(FCAUITransitionDefinition, M_transition_handle) == 0x000000, "Member 'FCAUITransitionDefinition::M_transition_handle' has a wrong offset!");

// ScriptStruct keaton.CAFTUEFlags
// 0x0002 (0x0002 - 0x0000)
struct FCAFTUEFlags final
{
public:
	ECAFTUEState                                  M_enabled_ftue_state;                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAFTUETrackingFlag                           M_tracking_flag;                                   // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFTUEFlags) == 0x000001, "Wrong alignment on FCAFTUEFlags");
static_assert(sizeof(FCAFTUEFlags) == 0x000002, "Wrong size on FCAFTUEFlags");
static_assert(offsetof(FCAFTUEFlags, M_enabled_ftue_state) == 0x000000, "Member 'FCAFTUEFlags::M_enabled_ftue_state' has a wrong offset!");
static_assert(offsetof(FCAFTUEFlags, M_tracking_flag) == 0x000001, "Member 'FCAFTUEFlags::M_tracking_flag' has a wrong offset!");

// ScriptStruct keaton.CAMenuNavigationItem
// 0x0070 (0x0070 - 0x0000)
struct FCAMenuNavigationItem final
{
public:
	class FName                                   M_navigation_item_id;                              // 0x0000(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_label;                                           // 0x0010(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_is_default;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_hide_in_menu;                                    // 0x0041(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAUITransitionDefinition              M_transition;                                      // 0x0044(0x0018)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_transition_automatically;                        // 0x005C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_enabled;                                      // 0x005D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_excluded;                                     // 0x005E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F[0x1];                                       // 0x005F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAUIFlags                             M_flags;                                           // 0x0060(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAFTUEFlags                           M_ftue;                                            // 0x0068(0x0002)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_show_title_bar;                                  // 0x006A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B[0x5];                                       // 0x006B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMenuNavigationItem) == 0x000008, "Wrong alignment on FCAMenuNavigationItem");
static_assert(sizeof(FCAMenuNavigationItem) == 0x000070, "Wrong size on FCAMenuNavigationItem");
static_assert(offsetof(FCAMenuNavigationItem, M_navigation_item_id) == 0x000000, "Member 'FCAMenuNavigationItem::M_navigation_item_id' has a wrong offset!");
static_assert(offsetof(FCAMenuNavigationItem, M_label) == 0x000010, "Member 'FCAMenuNavigationItem::M_label' has a wrong offset!");
static_assert(offsetof(FCAMenuNavigationItem, M_is_default) == 0x000040, "Member 'FCAMenuNavigationItem::M_is_default' has a wrong offset!");
static_assert(offsetof(FCAMenuNavigationItem, M_hide_in_menu) == 0x000041, "Member 'FCAMenuNavigationItem::M_hide_in_menu' has a wrong offset!");
static_assert(offsetof(FCAMenuNavigationItem, M_transition) == 0x000044, "Member 'FCAMenuNavigationItem::M_transition' has a wrong offset!");
static_assert(offsetof(FCAMenuNavigationItem, M_transition_automatically) == 0x00005C, "Member 'FCAMenuNavigationItem::M_transition_automatically' has a wrong offset!");
static_assert(offsetof(FCAMenuNavigationItem, M_is_enabled) == 0x00005D, "Member 'FCAMenuNavigationItem::M_is_enabled' has a wrong offset!");
static_assert(offsetof(FCAMenuNavigationItem, M_is_excluded) == 0x00005E, "Member 'FCAMenuNavigationItem::M_is_excluded' has a wrong offset!");
static_assert(offsetof(FCAMenuNavigationItem, M_flags) == 0x000060, "Member 'FCAMenuNavigationItem::M_flags' has a wrong offset!");
static_assert(offsetof(FCAMenuNavigationItem, M_ftue) == 0x000068, "Member 'FCAMenuNavigationItem::M_ftue' has a wrong offset!");
static_assert(offsetof(FCAMenuNavigationItem, M_show_title_bar) == 0x00006A, "Member 'FCAMenuNavigationItem::M_show_title_bar' has a wrong offset!");

// ScriptStruct keaton.CampConfigToMissionTables
// 0x0030 (0x0030 - 0x0000)
struct FCampConfigToMissionTables final
{
public:
	struct FGameplayTagContainer                  M_gameplay_tags;                                   // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	TArray<class UDataTable*>                     M_mission_tables;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCampConfigToMissionTables) == 0x000008, "Wrong alignment on FCampConfigToMissionTables");
static_assert(sizeof(FCampConfigToMissionTables) == 0x000030, "Wrong size on FCampConfigToMissionTables");
static_assert(offsetof(FCampConfigToMissionTables, M_gameplay_tags) == 0x000000, "Member 'FCampConfigToMissionTables::M_gameplay_tags' has a wrong offset!");
static_assert(offsetof(FCampConfigToMissionTables, M_mission_tables) == 0x000020, "Member 'FCampConfigToMissionTables::M_mission_tables' has a wrong offset!");

// ScriptStruct keaton.SubLevelsForReplication
// 0x0010 (0x0010 - 0x0000)
struct FSubLevelsForReplication final
{
public:
	TArray<class FName>                           Sublevels;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubLevelsForReplication) == 0x000008, "Wrong alignment on FSubLevelsForReplication");
static_assert(sizeof(FSubLevelsForReplication) == 0x000010, "Wrong size on FSubLevelsForReplication");
static_assert(offsetof(FSubLevelsForReplication, Sublevels) == 0x000000, "Member 'FSubLevelsForReplication::Sublevels' has a wrong offset!");

// ScriptStruct keaton.SysDeviceSensorStateMapping
// 0x0003 (0x0003 - 0x0000)
struct FSysDeviceSensorStateMapping final
{
public:
	ESysSensorEventType                           M_event;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESysDeviceStateType                           M_state;                                           // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_enabled;                                         // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSysDeviceSensorStateMapping) == 0x000001, "Wrong alignment on FSysDeviceSensorStateMapping");
static_assert(sizeof(FSysDeviceSensorStateMapping) == 0x000003, "Wrong size on FSysDeviceSensorStateMapping");
static_assert(offsetof(FSysDeviceSensorStateMapping, M_event) == 0x000000, "Member 'FSysDeviceSensorStateMapping::M_event' has a wrong offset!");
static_assert(offsetof(FSysDeviceSensorStateMapping, M_state) == 0x000001, "Member 'FSysDeviceSensorStateMapping::M_state' has a wrong offset!");
static_assert(offsetof(FSysDeviceSensorStateMapping, M_enabled) == 0x000002, "Member 'FSysDeviceSensorStateMapping::M_enabled' has a wrong offset!");

// ScriptStruct keaton.CATeamID
// 0x0004 (0x0004 - 0x0000)
struct FCATeamID final
{
public:
	int32                                         M_id;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATeamID) == 0x000004, "Wrong alignment on FCATeamID");
static_assert(sizeof(FCATeamID) == 0x000004, "Wrong size on FCATeamID");
static_assert(offsetof(FCATeamID, M_id) == 0x000000, "Member 'FCATeamID::M_id' has a wrong offset!");

// ScriptStruct keaton.CAPlayerHitUIData
// 0x0068 (0x0068 - 0x0000)
struct FCAPlayerHitUIData final
{
public:
	class AActor*                                 M_hit_actor;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_hit_location;                                    // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_hit_direction;                                   // 0x0014(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_damage;                                          // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_armour_damage;                                   // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_armour_hit;                                      // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_armour_broken;                                   // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_weak_point_broken;                               // 0x002A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_downed_target;                                   // 0x002B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_killed_target;                                   // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_critical;                                     // 0x002D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_headshot;                                        // 0x002E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F[0x1];                                       // 0x002F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_source_actor;                                    // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_instigator_actor;                                // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_hit_actor_name;                                  // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_specialist_name;                                 // 0x0050(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_player;                                       // 0x005C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCATeamID                              M_target_team_id;                                  // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPlayerHitUIData) == 0x000008, "Wrong alignment on FCAPlayerHitUIData");
static_assert(sizeof(FCAPlayerHitUIData) == 0x000068, "Wrong size on FCAPlayerHitUIData");
static_assert(offsetof(FCAPlayerHitUIData, M_hit_actor) == 0x000000, "Member 'FCAPlayerHitUIData::M_hit_actor' has a wrong offset!");
static_assert(offsetof(FCAPlayerHitUIData, M_hit_location) == 0x000008, "Member 'FCAPlayerHitUIData::M_hit_location' has a wrong offset!");
static_assert(offsetof(FCAPlayerHitUIData, M_hit_direction) == 0x000014, "Member 'FCAPlayerHitUIData::M_hit_direction' has a wrong offset!");
static_assert(offsetof(FCAPlayerHitUIData, M_damage) == 0x000020, "Member 'FCAPlayerHitUIData::M_damage' has a wrong offset!");
static_assert(offsetof(FCAPlayerHitUIData, M_armour_damage) == 0x000024, "Member 'FCAPlayerHitUIData::M_armour_damage' has a wrong offset!");
static_assert(offsetof(FCAPlayerHitUIData, M_armour_hit) == 0x000028, "Member 'FCAPlayerHitUIData::M_armour_hit' has a wrong offset!");
static_assert(offsetof(FCAPlayerHitUIData, M_armour_broken) == 0x000029, "Member 'FCAPlayerHitUIData::M_armour_broken' has a wrong offset!");
static_assert(offsetof(FCAPlayerHitUIData, M_weak_point_broken) == 0x00002A, "Member 'FCAPlayerHitUIData::M_weak_point_broken' has a wrong offset!");
static_assert(offsetof(FCAPlayerHitUIData, M_downed_target) == 0x00002B, "Member 'FCAPlayerHitUIData::M_downed_target' has a wrong offset!");
static_assert(offsetof(FCAPlayerHitUIData, M_killed_target) == 0x00002C, "Member 'FCAPlayerHitUIData::M_killed_target' has a wrong offset!");
static_assert(offsetof(FCAPlayerHitUIData, M_is_critical) == 0x00002D, "Member 'FCAPlayerHitUIData::M_is_critical' has a wrong offset!");
static_assert(offsetof(FCAPlayerHitUIData, M_headshot) == 0x00002E, "Member 'FCAPlayerHitUIData::M_headshot' has a wrong offset!");
static_assert(offsetof(FCAPlayerHitUIData, M_source_actor) == 0x000030, "Member 'FCAPlayerHitUIData::M_source_actor' has a wrong offset!");
static_assert(offsetof(FCAPlayerHitUIData, M_instigator_actor) == 0x000038, "Member 'FCAPlayerHitUIData::M_instigator_actor' has a wrong offset!");
static_assert(offsetof(FCAPlayerHitUIData, M_hit_actor_name) == 0x000040, "Member 'FCAPlayerHitUIData::M_hit_actor_name' has a wrong offset!");
static_assert(offsetof(FCAPlayerHitUIData, M_specialist_name) == 0x000050, "Member 'FCAPlayerHitUIData::M_specialist_name' has a wrong offset!");
static_assert(offsetof(FCAPlayerHitUIData, M_is_player) == 0x00005C, "Member 'FCAPlayerHitUIData::M_is_player' has a wrong offset!");
static_assert(offsetof(FCAPlayerHitUIData, M_target_team_id) == 0x000060, "Member 'FCAPlayerHitUIData::M_target_team_id' has a wrong offset!");

// ScriptStruct keaton.CAGadgebilitiesInfo
// 0x0030 (0x0030 - 0x0000)
struct FCAGadgebilitiesInfo final
{
public:
	int32                                         Total_uses;                                        // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Total_success_uses;                                // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Total_effects;                                     // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_dealt_to_players;                           // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_dealt_to_npcs;                              // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_dealt_to_self;                              // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage_dealt_to_others;                            // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Life_healed_to_players;                            // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Life_healed_to_npcs;                               // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Life_healed_to_self;                               // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Life_healed_to_others;                             // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_ability;                                        // 0x002C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAGadgebilitiesInfo) == 0x000004, "Wrong alignment on FCAGadgebilitiesInfo");
static_assert(sizeof(FCAGadgebilitiesInfo) == 0x000030, "Wrong size on FCAGadgebilitiesInfo");
static_assert(offsetof(FCAGadgebilitiesInfo, Total_uses) == 0x000000, "Member 'FCAGadgebilitiesInfo::Total_uses' has a wrong offset!");
static_assert(offsetof(FCAGadgebilitiesInfo, Total_success_uses) == 0x000004, "Member 'FCAGadgebilitiesInfo::Total_success_uses' has a wrong offset!");
static_assert(offsetof(FCAGadgebilitiesInfo, Total_effects) == 0x000008, "Member 'FCAGadgebilitiesInfo::Total_effects' has a wrong offset!");
static_assert(offsetof(FCAGadgebilitiesInfo, Damage_dealt_to_players) == 0x00000C, "Member 'FCAGadgebilitiesInfo::Damage_dealt_to_players' has a wrong offset!");
static_assert(offsetof(FCAGadgebilitiesInfo, Damage_dealt_to_npcs) == 0x000010, "Member 'FCAGadgebilitiesInfo::Damage_dealt_to_npcs' has a wrong offset!");
static_assert(offsetof(FCAGadgebilitiesInfo, Damage_dealt_to_self) == 0x000014, "Member 'FCAGadgebilitiesInfo::Damage_dealt_to_self' has a wrong offset!");
static_assert(offsetof(FCAGadgebilitiesInfo, Damage_dealt_to_others) == 0x000018, "Member 'FCAGadgebilitiesInfo::Damage_dealt_to_others' has a wrong offset!");
static_assert(offsetof(FCAGadgebilitiesInfo, Life_healed_to_players) == 0x00001C, "Member 'FCAGadgebilitiesInfo::Life_healed_to_players' has a wrong offset!");
static_assert(offsetof(FCAGadgebilitiesInfo, Life_healed_to_npcs) == 0x000020, "Member 'FCAGadgebilitiesInfo::Life_healed_to_npcs' has a wrong offset!");
static_assert(offsetof(FCAGadgebilitiesInfo, Life_healed_to_self) == 0x000024, "Member 'FCAGadgebilitiesInfo::Life_healed_to_self' has a wrong offset!");
static_assert(offsetof(FCAGadgebilitiesInfo, Life_healed_to_others) == 0x000028, "Member 'FCAGadgebilitiesInfo::Life_healed_to_others' has a wrong offset!");
static_assert(offsetof(FCAGadgebilitiesInfo, Is_ability) == 0x00002C, "Member 'FCAGadgebilitiesInfo::Is_ability' has a wrong offset!");

// ScriptStruct keaton.CAGameplayObjectiveHelper
// 0x0028 (0x0028 - 0x0000)
struct FCAGameplayObjectiveHelper final
{
public:
	int32                                         M_priority;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_objective;                                       // 0x0008(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_counter;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_remaining;                                       // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_collected;                                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAGameplayObjectiveHelper) == 0x000008, "Wrong alignment on FCAGameplayObjectiveHelper");
static_assert(sizeof(FCAGameplayObjectiveHelper) == 0x000028, "Wrong size on FCAGameplayObjectiveHelper");
static_assert(offsetof(FCAGameplayObjectiveHelper, M_priority) == 0x000000, "Member 'FCAGameplayObjectiveHelper::M_priority' has a wrong offset!");
static_assert(offsetof(FCAGameplayObjectiveHelper, M_objective) == 0x000008, "Member 'FCAGameplayObjectiveHelper::M_objective' has a wrong offset!");
static_assert(offsetof(FCAGameplayObjectiveHelper, M_counter) == 0x000018, "Member 'FCAGameplayObjectiveHelper::M_counter' has a wrong offset!");
static_assert(offsetof(FCAGameplayObjectiveHelper, M_remaining) == 0x00001C, "Member 'FCAGameplayObjectiveHelper::M_remaining' has a wrong offset!");
static_assert(offsetof(FCAGameplayObjectiveHelper, M_collected) == 0x000020, "Member 'FCAGameplayObjectiveHelper::M_collected' has a wrong offset!");

// ScriptStruct keaton.CAAnimInstance_Component
// 0x0010 (0x0010 - 0x0000)
struct FCAAnimInstance_Component
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCAAnimInstance_Specialist*             M_owner;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FCAAnimInstance_Component) == 0x000008, "Wrong alignment on FCAAnimInstance_Component");
static_assert(sizeof(FCAAnimInstance_Component) == 0x000010, "Wrong size on FCAAnimInstance_Component");
static_assert(offsetof(FCAAnimInstance_Component, M_owner) == 0x000008, "Member 'FCAAnimInstance_Component::M_owner' has a wrong offset!");

// ScriptStruct keaton.CAAnimInstance_Component_FP_Movement_Layer
// 0x0000 (0x0010 - 0x0010)
struct FCAAnimInstance_Component_FP_Movement_Layer final : public FCAAnimInstance_Component
{
};
static_assert(alignof(FCAAnimInstance_Component_FP_Movement_Layer) == 0x000008, "Wrong alignment on FCAAnimInstance_Component_FP_Movement_Layer");
static_assert(sizeof(FCAAnimInstance_Component_FP_Movement_Layer) == 0x000010, "Wrong size on FCAAnimInstance_Component_FP_Movement_Layer");

// ScriptStruct keaton.CAInventoryEntry
// 0x0020 (0x0020 - 0x0000)
struct FCAInventoryEntry final
{
public:
	struct FGameplayTag                           M_slot;                                            // 0x0000(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCAInventoryItem*                       M_item;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_amount;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_old_amount;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAInventoryEntry) == 0x000008, "Wrong alignment on FCAInventoryEntry");
static_assert(sizeof(FCAInventoryEntry) == 0x000020, "Wrong size on FCAInventoryEntry");
static_assert(offsetof(FCAInventoryEntry, M_slot) == 0x000000, "Member 'FCAInventoryEntry::M_slot' has a wrong offset!");
static_assert(offsetof(FCAInventoryEntry, M_item) == 0x000010, "Member 'FCAInventoryEntry::M_item' has a wrong offset!");
static_assert(offsetof(FCAInventoryEntry, M_amount) == 0x000018, "Member 'FCAInventoryEntry::M_amount' has a wrong offset!");
static_assert(offsetof(FCAInventoryEntry, M_old_amount) == 0x00001C, "Member 'FCAInventoryEntry::M_old_amount' has a wrong offset!");

// ScriptStruct keaton.CATargetInfo
// 0x0018 (0x0018 - 0x0000)
struct FCATargetInfo final
{
public:
	class AActor*                                 M_target;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCATargetInfo) == 0x000008, "Wrong alignment on FCATargetInfo");
static_assert(sizeof(FCATargetInfo) == 0x000018, "Wrong size on FCATargetInfo");
static_assert(offsetof(FCATargetInfo, M_target) == 0x000000, "Member 'FCATargetInfo::M_target' has a wrong offset!");

// ScriptStruct keaton.CADebugTargetData
// 0x0028 (0x0028 - 0x0000)
struct FCADebugTargetData final
{
public:
	struct FCATargetInfo                          M_target;                                          // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_score;                                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_time_until_lockon;                               // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_time_until_lock_lost;                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADebugTargetData) == 0x000008, "Wrong alignment on FCADebugTargetData");
static_assert(sizeof(FCADebugTargetData) == 0x000028, "Wrong size on FCADebugTargetData");
static_assert(offsetof(FCADebugTargetData, M_target) == 0x000000, "Member 'FCADebugTargetData::M_target' has a wrong offset!");
static_assert(offsetof(FCADebugTargetData, M_score) == 0x000018, "Member 'FCADebugTargetData::M_score' has a wrong offset!");
static_assert(offsetof(FCADebugTargetData, M_time_until_lockon) == 0x00001C, "Member 'FCADebugTargetData::M_time_until_lockon' has a wrong offset!");
static_assert(offsetof(FCADebugTargetData, M_time_until_lock_lost) == 0x000020, "Member 'FCADebugTargetData::M_time_until_lock_lost' has a wrong offset!");

// ScriptStruct keaton.CAAbilityUser
// 0x0020 (0x0020 - 0x0000)
struct FCAAbilityUser final
{
public:
	class AActor*                                 M_AbilityUser;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAGameplayAbility*                     M_AbilityInstance;                                 // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAbilityUser) == 0x000008, "Wrong alignment on FCAAbilityUser");
static_assert(sizeof(FCAAbilityUser) == 0x000020, "Wrong size on FCAAbilityUser");
static_assert(offsetof(FCAAbilityUser, M_AbilityUser) == 0x000000, "Member 'FCAAbilityUser::M_AbilityUser' has a wrong offset!");
static_assert(offsetof(FCAAbilityUser, M_AbilityInstance) == 0x000008, "Member 'FCAAbilityUser::M_AbilityInstance' has a wrong offset!");

// ScriptStruct keaton.CAGameplayAbilityApplicator
// 0x0010 (0x0010 - 0x0000)
struct FCAGameplayAbilityApplicator final
{
public:
	TArray<struct FCAAbilityUser>                 M_AbilityUsers;                                    // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCAGameplayAbilityApplicator) == 0x000008, "Wrong alignment on FCAGameplayAbilityApplicator");
static_assert(sizeof(FCAGameplayAbilityApplicator) == 0x000010, "Wrong size on FCAGameplayAbilityApplicator");
static_assert(offsetof(FCAGameplayAbilityApplicator, M_AbilityUsers) == 0x000000, "Member 'FCAGameplayAbilityApplicator::M_AbilityUsers' has a wrong offset!");

// ScriptStruct keaton.CAReplicatedBuffValue
// 0x0008 (0x0008 - 0x0000)
struct FCAReplicatedBuffValue final
{
public:
	uint8                                         Id;                                                // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAReplicatedBuffValue) == 0x000004, "Wrong alignment on FCAReplicatedBuffValue");
static_assert(sizeof(FCAReplicatedBuffValue) == 0x000008, "Wrong size on FCAReplicatedBuffValue");
static_assert(offsetof(FCAReplicatedBuffValue, Id) == 0x000000, "Member 'FCAReplicatedBuffValue::Id' has a wrong offset!");
static_assert(offsetof(FCAReplicatedBuffValue, Value) == 0x000004, "Member 'FCAReplicatedBuffValue::Value' has a wrong offset!");

// ScriptStruct keaton.CAScreenItem
// 0x0068 (0x0070 - 0x0008)
struct FCAScreenItem final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   M_screen_class;                                    // 0x0008(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_mediator;                                        // 0x0038(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_preload_group;                                   // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_cache;                                           // 0x006C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAScreenItem) == 0x000008, "Wrong alignment on FCAScreenItem");
static_assert(sizeof(FCAScreenItem) == 0x000070, "Wrong size on FCAScreenItem");
static_assert(offsetof(FCAScreenItem, M_screen_class) == 0x000008, "Member 'FCAScreenItem::M_screen_class' has a wrong offset!");
static_assert(offsetof(FCAScreenItem, M_mediator) == 0x000038, "Member 'FCAScreenItem::M_mediator' has a wrong offset!");
static_assert(offsetof(FCAScreenItem, M_preload_group) == 0x000068, "Member 'FCAScreenItem::M_preload_group' has a wrong offset!");
static_assert(offsetof(FCAScreenItem, M_cache) == 0x00006C, "Member 'FCAScreenItem::M_cache' has a wrong offset!");

// ScriptStruct keaton.CATraceAuxiliaryResult
// 0x000C (0x000C - 0x0000)
struct FCATraceAuxiliaryResult final
{
public:
	int32                                         Priority;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         User_index;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Trace_index;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATraceAuxiliaryResult) == 0x000004, "Wrong alignment on FCATraceAuxiliaryResult");
static_assert(sizeof(FCATraceAuxiliaryResult) == 0x00000C, "Wrong size on FCATraceAuxiliaryResult");
static_assert(offsetof(FCATraceAuxiliaryResult, Priority) == 0x000000, "Member 'FCATraceAuxiliaryResult::Priority' has a wrong offset!");
static_assert(offsetof(FCATraceAuxiliaryResult, User_index) == 0x000004, "Member 'FCATraceAuxiliaryResult::User_index' has a wrong offset!");
static_assert(offsetof(FCATraceAuxiliaryResult, Trace_index) == 0x000008, "Member 'FCATraceAuxiliaryResult::Trace_index' has a wrong offset!");

// ScriptStruct keaton.NetworkedHit_DownedData
// 0x0008 (0x0008 - 0x0000)
struct FNetworkedHit_DownedData final
{
public:
	int32                                         M_random_number;                                   // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_direction_index;                                 // 0x0004(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetworkedHit_DownedData) == 0x000004, "Wrong alignment on FNetworkedHit_DownedData");
static_assert(sizeof(FNetworkedHit_DownedData) == 0x000008, "Wrong size on FNetworkedHit_DownedData");
static_assert(offsetof(FNetworkedHit_DownedData, M_random_number) == 0x000000, "Member 'FNetworkedHit_DownedData::M_random_number' has a wrong offset!");
static_assert(offsetof(FNetworkedHit_DownedData, M_direction_index) == 0x000004, "Member 'FNetworkedHit_DownedData::M_direction_index' has a wrong offset!");

// ScriptStruct keaton.NetworkedHit
// 0x0068 (0x0068 - 0x0000)
struct FNetworkedHit final
{
public:
	struct FVector_NetQuantize                    M_victim_location;                                 // 0x0000(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_victim_yaw;                                      // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    M_hit_location;                                    // 0x0010(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_hit_direction;                                   // 0x001C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_base_damage;                                     // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_index;                                           // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_valid;                                        // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_downed;                                          // 0x0031(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_friendly_fire;                                // 0x0032(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBodyPart                                     M_body_part;                                       // 0x0033(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_bone_name;                                       // 0x0034(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACAEquipmentBase*                       M_source_equipment;                                // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_attacker;                                        // 0x0048(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAInventoryItem*                       M_ammo_inventory_item;                             // 0x0050(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAWeaponClass                                M_weapon_class;                                    // 0x0058(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNetworkedHit_DownedData               M_downed_only_data;                                // 0x005C(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetworkedHit) == 0x000008, "Wrong alignment on FNetworkedHit");
static_assert(sizeof(FNetworkedHit) == 0x000068, "Wrong size on FNetworkedHit");
static_assert(offsetof(FNetworkedHit, M_victim_location) == 0x000000, "Member 'FNetworkedHit::M_victim_location' has a wrong offset!");
static_assert(offsetof(FNetworkedHit, M_victim_yaw) == 0x00000C, "Member 'FNetworkedHit::M_victim_yaw' has a wrong offset!");
static_assert(offsetof(FNetworkedHit, M_hit_location) == 0x000010, "Member 'FNetworkedHit::M_hit_location' has a wrong offset!");
static_assert(offsetof(FNetworkedHit, M_hit_direction) == 0x00001C, "Member 'FNetworkedHit::M_hit_direction' has a wrong offset!");
static_assert(offsetof(FNetworkedHit, M_base_damage) == 0x000028, "Member 'FNetworkedHit::M_base_damage' has a wrong offset!");
static_assert(offsetof(FNetworkedHit, M_index) == 0x00002C, "Member 'FNetworkedHit::M_index' has a wrong offset!");
static_assert(offsetof(FNetworkedHit, M_is_valid) == 0x000030, "Member 'FNetworkedHit::M_is_valid' has a wrong offset!");
static_assert(offsetof(FNetworkedHit, M_downed) == 0x000031, "Member 'FNetworkedHit::M_downed' has a wrong offset!");
static_assert(offsetof(FNetworkedHit, M_is_friendly_fire) == 0x000032, "Member 'FNetworkedHit::M_is_friendly_fire' has a wrong offset!");
static_assert(offsetof(FNetworkedHit, M_body_part) == 0x000033, "Member 'FNetworkedHit::M_body_part' has a wrong offset!");
static_assert(offsetof(FNetworkedHit, M_bone_name) == 0x000034, "Member 'FNetworkedHit::M_bone_name' has a wrong offset!");
static_assert(offsetof(FNetworkedHit, M_source_equipment) == 0x000040, "Member 'FNetworkedHit::M_source_equipment' has a wrong offset!");
static_assert(offsetof(FNetworkedHit, M_attacker) == 0x000048, "Member 'FNetworkedHit::M_attacker' has a wrong offset!");
static_assert(offsetof(FNetworkedHit, M_ammo_inventory_item) == 0x000050, "Member 'FNetworkedHit::M_ammo_inventory_item' has a wrong offset!");
static_assert(offsetof(FNetworkedHit, M_weapon_class) == 0x000058, "Member 'FNetworkedHit::M_weapon_class' has a wrong offset!");
static_assert(offsetof(FNetworkedHit, M_downed_only_data) == 0x00005C, "Member 'FNetworkedHit::M_downed_only_data' has a wrong offset!");

// ScriptStruct keaton.CAMovementModeData_CommonBase
// 0x0000 (0x0008 - 0x0008)
struct FCAMovementModeData_CommonBase : public FTableRowBase
{
};
static_assert(alignof(FCAMovementModeData_CommonBase) == 0x000008, "Wrong alignment on FCAMovementModeData_CommonBase");
static_assert(sizeof(FCAMovementModeData_CommonBase) == 0x000008, "Wrong size on FCAMovementModeData_CommonBase");

// ScriptStruct keaton.CAMovementModeData
// 0x0008 (0x0010 - 0x0008)
struct FCAMovementModeData : public FCAMovementModeData_CommonBase
{
public:
	uint8                                         Pad_8[0x4];                                        // 0x0008(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_trail_lerp_value;                                // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMovementModeData) == 0x000008, "Wrong alignment on FCAMovementModeData");
static_assert(sizeof(FCAMovementModeData) == 0x000010, "Wrong size on FCAMovementModeData");
static_assert(offsetof(FCAMovementModeData, M_trail_lerp_value) == 0x00000C, "Member 'FCAMovementModeData::M_trail_lerp_value' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_ZeroGTakeOff
// 0x0090 (0x00A0 - 0x0010)
struct FCAMovementData_ZeroGTakeOff final : public FCAMovementModeData
{
public:
	uint8                                         Pad_10[0x4];                                       // 0x0010(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_wall_vault_distance_check;                       // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_pushoff_away_from_surface_distance_horizontal;   // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_pushoff_away_from_surface_distance_vertical;     // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_distance_for_high_speed_take_off;            // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_distance_for_lowest_speed_takeoff;               // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_takeoff_speed_cap;                               // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_maximum_takeoff_speed;                           // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_rapid_takeoff_speed_boost;                       // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_longest_duration_for_full_rapid_takeoff;         // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_duration_for_default_takeoff;                    // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_lowest_possible_takeoff_speed;                   // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_minimum_takeoff_duration;                        // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_maximum_strafe_only_takeoff_pitch;               // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_yaw_from_fall_slide;                         // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_pitch_from_fall_slide;                       // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_slide_pitch_up;                                  // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_post_corner_distance_check;                      // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_search_step_size;                                // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_always_takeoff_distance;                         // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_corner_search_minimum_distance_straight_ahead;   // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_corner_search_minimum_distance_not_ahead;        // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_corner_search_max_step_straight_ahead;           // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_corner_search_max_step_30_degrees;               // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_corner_search_max_step_45_degrees;               // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_corner_search_max_step_90_degrees;               // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_corner_search_max_step_135_degrees;              // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_corner_search_max_step_180_degrees;              // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_stick_flick_inner;                               // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_stick_flick_outer;                               // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_stick_flick_time;                                // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_direction_quantization;                          // 0x008C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_spam_time;                                       // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_spam_count;                                      // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_spam_takeoff_speed;                              // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementData_ZeroGTakeOff) == 0x000008, "Wrong alignment on FCAMovementData_ZeroGTakeOff");
static_assert(sizeof(FCAMovementData_ZeroGTakeOff) == 0x0000A0, "Wrong size on FCAMovementData_ZeroGTakeOff");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_wall_vault_distance_check) == 0x000014, "Member 'FCAMovementData_ZeroGTakeOff::M_wall_vault_distance_check' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_pushoff_away_from_surface_distance_horizontal) == 0x000018, "Member 'FCAMovementData_ZeroGTakeOff::M_pushoff_away_from_surface_distance_horizontal' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_pushoff_away_from_surface_distance_vertical) == 0x00001C, "Member 'FCAMovementData_ZeroGTakeOff::M_pushoff_away_from_surface_distance_vertical' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_min_distance_for_high_speed_take_off) == 0x000020, "Member 'FCAMovementData_ZeroGTakeOff::M_min_distance_for_high_speed_take_off' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_distance_for_lowest_speed_takeoff) == 0x000024, "Member 'FCAMovementData_ZeroGTakeOff::M_distance_for_lowest_speed_takeoff' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_takeoff_speed_cap) == 0x000028, "Member 'FCAMovementData_ZeroGTakeOff::M_takeoff_speed_cap' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_maximum_takeoff_speed) == 0x00002C, "Member 'FCAMovementData_ZeroGTakeOff::M_maximum_takeoff_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_rapid_takeoff_speed_boost) == 0x000030, "Member 'FCAMovementData_ZeroGTakeOff::M_rapid_takeoff_speed_boost' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_longest_duration_for_full_rapid_takeoff) == 0x000034, "Member 'FCAMovementData_ZeroGTakeOff::M_longest_duration_for_full_rapid_takeoff' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_duration_for_default_takeoff) == 0x000038, "Member 'FCAMovementData_ZeroGTakeOff::M_duration_for_default_takeoff' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_lowest_possible_takeoff_speed) == 0x00003C, "Member 'FCAMovementData_ZeroGTakeOff::M_lowest_possible_takeoff_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_minimum_takeoff_duration) == 0x000040, "Member 'FCAMovementData_ZeroGTakeOff::M_minimum_takeoff_duration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_maximum_strafe_only_takeoff_pitch) == 0x000044, "Member 'FCAMovementData_ZeroGTakeOff::M_maximum_strafe_only_takeoff_pitch' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_max_yaw_from_fall_slide) == 0x000048, "Member 'FCAMovementData_ZeroGTakeOff::M_max_yaw_from_fall_slide' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_max_pitch_from_fall_slide) == 0x00004C, "Member 'FCAMovementData_ZeroGTakeOff::M_max_pitch_from_fall_slide' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_slide_pitch_up) == 0x000050, "Member 'FCAMovementData_ZeroGTakeOff::M_slide_pitch_up' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_post_corner_distance_check) == 0x000054, "Member 'FCAMovementData_ZeroGTakeOff::M_post_corner_distance_check' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_search_step_size) == 0x000058, "Member 'FCAMovementData_ZeroGTakeOff::M_search_step_size' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_always_takeoff_distance) == 0x00005C, "Member 'FCAMovementData_ZeroGTakeOff::M_always_takeoff_distance' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_corner_search_minimum_distance_straight_ahead) == 0x000060, "Member 'FCAMovementData_ZeroGTakeOff::M_corner_search_minimum_distance_straight_ahead' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_corner_search_minimum_distance_not_ahead) == 0x000064, "Member 'FCAMovementData_ZeroGTakeOff::M_corner_search_minimum_distance_not_ahead' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_corner_search_max_step_straight_ahead) == 0x000068, "Member 'FCAMovementData_ZeroGTakeOff::M_corner_search_max_step_straight_ahead' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_corner_search_max_step_30_degrees) == 0x00006C, "Member 'FCAMovementData_ZeroGTakeOff::M_corner_search_max_step_30_degrees' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_corner_search_max_step_45_degrees) == 0x000070, "Member 'FCAMovementData_ZeroGTakeOff::M_corner_search_max_step_45_degrees' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_corner_search_max_step_90_degrees) == 0x000074, "Member 'FCAMovementData_ZeroGTakeOff::M_corner_search_max_step_90_degrees' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_corner_search_max_step_135_degrees) == 0x000078, "Member 'FCAMovementData_ZeroGTakeOff::M_corner_search_max_step_135_degrees' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_corner_search_max_step_180_degrees) == 0x00007C, "Member 'FCAMovementData_ZeroGTakeOff::M_corner_search_max_step_180_degrees' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_stick_flick_inner) == 0x000080, "Member 'FCAMovementData_ZeroGTakeOff::M_stick_flick_inner' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_stick_flick_outer) == 0x000084, "Member 'FCAMovementData_ZeroGTakeOff::M_stick_flick_outer' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_stick_flick_time) == 0x000088, "Member 'FCAMovementData_ZeroGTakeOff::M_stick_flick_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_direction_quantization) == 0x00008C, "Member 'FCAMovementData_ZeroGTakeOff::M_direction_quantization' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_spam_time) == 0x000090, "Member 'FCAMovementData_ZeroGTakeOff::M_spam_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_spam_count) == 0x000094, "Member 'FCAMovementData_ZeroGTakeOff::M_spam_count' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGTakeOff, M_spam_takeoff_speed) == 0x000098, "Member 'FCAMovementData_ZeroGTakeOff::M_spam_takeoff_speed' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_FreeCam
// 0x0008 (0x0018 - 0x0010)
struct FCAMovementData_FreeCam final : public FCAMovementModeData
{
public:
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementData_FreeCam) == 0x000008, "Wrong alignment on FCAMovementData_FreeCam");
static_assert(sizeof(FCAMovementData_FreeCam) == 0x000018, "Wrong size on FCAMovementData_FreeCam");

// ScriptStruct keaton.CAFlowStateDefinition
// 0x0018 (0x0018 - 0x0000)
struct FCAFlowStateDefinition final
{
public:
	struct FCAGameDatabaseRowHandle               M_state_handle;                                    // 0x0000(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFlowStateDefinition) == 0x000004, "Wrong alignment on FCAFlowStateDefinition");
static_assert(sizeof(FCAFlowStateDefinition) == 0x000018, "Wrong size on FCAFlowStateDefinition");
static_assert(offsetof(FCAFlowStateDefinition, M_state_handle) == 0x000000, "Member 'FCAFlowStateDefinition::M_state_handle' has a wrong offset!");

// ScriptStruct keaton.CAGetIntDelegate
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FCAGetIntDelegate final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAGetIntDelegate) == 0x000008, "Wrong alignment on FCAGetIntDelegate");
static_assert(sizeof(FCAGetIntDelegate) == 0x000028, "Wrong size on FCAGetIntDelegate");

// ScriptStruct keaton.CAEffectUser
// 0x0020 (0x0020 - 0x0000)
struct FCAEffectUser final
{
public:
	class AActor*                                 M_EffectUser;                                      // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_EffectSource;                                    // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAEffectUser) == 0x000008, "Wrong alignment on FCAEffectUser");
static_assert(sizeof(FCAEffectUser) == 0x000020, "Wrong size on FCAEffectUser");
static_assert(offsetof(FCAEffectUser, M_EffectUser) == 0x000000, "Member 'FCAEffectUser::M_EffectUser' has a wrong offset!");
static_assert(offsetof(FCAEffectUser, M_EffectSource) == 0x000008, "Member 'FCAEffectUser::M_EffectSource' has a wrong offset!");

// ScriptStruct keaton.CAAttributeChangeData
// 0x0328 (0x0328 - 0x0000)
struct FCAAttributeChangeData final
{
public:
	struct FGameplayAttribute                     M_attribute;                                       // 0x0000(0x0038)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_new_value;                                       // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_old_value;                                       // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    M_spec;                                            // 0x0040(0x0298)(NativeAccessSpecifierPublic)
	struct FGameplayModifierEvaluatedData         M_mod;                                             // 0x02D8(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAttributeChangeData) == 0x000008, "Wrong alignment on FCAAttributeChangeData");
static_assert(sizeof(FCAAttributeChangeData) == 0x000328, "Wrong size on FCAAttributeChangeData");
static_assert(offsetof(FCAAttributeChangeData, M_attribute) == 0x000000, "Member 'FCAAttributeChangeData::M_attribute' has a wrong offset!");
static_assert(offsetof(FCAAttributeChangeData, M_new_value) == 0x000038, "Member 'FCAAttributeChangeData::M_new_value' has a wrong offset!");
static_assert(offsetof(FCAAttributeChangeData, M_old_value) == 0x00003C, "Member 'FCAAttributeChangeData::M_old_value' has a wrong offset!");
static_assert(offsetof(FCAAttributeChangeData, M_spec) == 0x000040, "Member 'FCAAttributeChangeData::M_spec' has a wrong offset!");
static_assert(offsetof(FCAAttributeChangeData, M_mod) == 0x0002D8, "Member 'FCAAttributeChangeData::M_mod' has a wrong offset!");

// ScriptStruct keaton.CADialogueNPCManagerDT
// 0x0040 (0x0048 - 0x0008)
struct FCADialogueNPCManagerDT final : public FTableRowBase
{
public:
	float                                         RadiusFromPlayer;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRequests;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeBeforeProcessingRequest;                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeBeforeProcessingRequest;                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeBeforeIdle;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeBeforeIdle;                                 // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeBeforeCombatGenerative;                     // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeBeforeCombatGenerative;                     // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRequestPlayWindowTime;                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRequestPlayWindowTime;                          // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           IdleStatementTriggers;                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TauntMaxDistance;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADialogueNPCManagerDT) == 0x000008, "Wrong alignment on FCADialogueNPCManagerDT");
static_assert(sizeof(FCADialogueNPCManagerDT) == 0x000048, "Wrong size on FCADialogueNPCManagerDT");
static_assert(offsetof(FCADialogueNPCManagerDT, RadiusFromPlayer) == 0x000008, "Member 'FCADialogueNPCManagerDT::RadiusFromPlayer' has a wrong offset!");
static_assert(offsetof(FCADialogueNPCManagerDT, MaxRequests) == 0x00000C, "Member 'FCADialogueNPCManagerDT::MaxRequests' has a wrong offset!");
static_assert(offsetof(FCADialogueNPCManagerDT, MinTimeBeforeProcessingRequest) == 0x000010, "Member 'FCADialogueNPCManagerDT::MinTimeBeforeProcessingRequest' has a wrong offset!");
static_assert(offsetof(FCADialogueNPCManagerDT, MaxTimeBeforeProcessingRequest) == 0x000014, "Member 'FCADialogueNPCManagerDT::MaxTimeBeforeProcessingRequest' has a wrong offset!");
static_assert(offsetof(FCADialogueNPCManagerDT, MinTimeBeforeIdle) == 0x000018, "Member 'FCADialogueNPCManagerDT::MinTimeBeforeIdle' has a wrong offset!");
static_assert(offsetof(FCADialogueNPCManagerDT, MaxTimeBeforeIdle) == 0x00001C, "Member 'FCADialogueNPCManagerDT::MaxTimeBeforeIdle' has a wrong offset!");
static_assert(offsetof(FCADialogueNPCManagerDT, MinTimeBeforeCombatGenerative) == 0x000020, "Member 'FCADialogueNPCManagerDT::MinTimeBeforeCombatGenerative' has a wrong offset!");
static_assert(offsetof(FCADialogueNPCManagerDT, MaxTimeBeforeCombatGenerative) == 0x000024, "Member 'FCADialogueNPCManagerDT::MaxTimeBeforeCombatGenerative' has a wrong offset!");
static_assert(offsetof(FCADialogueNPCManagerDT, MinRequestPlayWindowTime) == 0x000028, "Member 'FCADialogueNPCManagerDT::MinRequestPlayWindowTime' has a wrong offset!");
static_assert(offsetof(FCADialogueNPCManagerDT, MaxRequestPlayWindowTime) == 0x00002C, "Member 'FCADialogueNPCManagerDT::MaxRequestPlayWindowTime' has a wrong offset!");
static_assert(offsetof(FCADialogueNPCManagerDT, IdleStatementTriggers) == 0x000030, "Member 'FCADialogueNPCManagerDT::IdleStatementTriggers' has a wrong offset!");
static_assert(offsetof(FCADialogueNPCManagerDT, TauntMaxDistance) == 0x000040, "Member 'FCADialogueNPCManagerDT::TauntMaxDistance' has a wrong offset!");

// ScriptStruct keaton.MatchStartSequenceContext
// 0x0020 (0x0020 - 0x0000)
struct FMatchStartSequenceContext final
{
public:
	class ALevelSequenceActor*                    M_sequence_actor;                                  // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequencePlayer*                   M_sequence_player;                                 // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_sequence_ended;                               // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_can_transition_to_first_person;                  // 0x0011(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0xE];                                       // 0x0012(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchStartSequenceContext) == 0x000008, "Wrong alignment on FMatchStartSequenceContext");
static_assert(sizeof(FMatchStartSequenceContext) == 0x000020, "Wrong size on FMatchStartSequenceContext");
static_assert(offsetof(FMatchStartSequenceContext, M_sequence_actor) == 0x000000, "Member 'FMatchStartSequenceContext::M_sequence_actor' has a wrong offset!");
static_assert(offsetof(FMatchStartSequenceContext, M_sequence_player) == 0x000008, "Member 'FMatchStartSequenceContext::M_sequence_player' has a wrong offset!");
static_assert(offsetof(FMatchStartSequenceContext, M_is_sequence_ended) == 0x000010, "Member 'FMatchStartSequenceContext::M_is_sequence_ended' has a wrong offset!");
static_assert(offsetof(FMatchStartSequenceContext, M_can_transition_to_first_person) == 0x000011, "Member 'FMatchStartSequenceContext::M_can_transition_to_first_person' has a wrong offset!");

// ScriptStruct keaton.SysSecurityEvent
// 0x001C (0x001C - 0x0000)
struct FSysSecurityEvent final
{
public:
	ESysSecurityEventType                         M_type;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  M_committing_actor;                                // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  M_reporting_actor;                                 // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  M_target_actor;                                    // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSysSecurityEvent) == 0x000004, "Wrong alignment on FSysSecurityEvent");
static_assert(sizeof(FSysSecurityEvent) == 0x00001C, "Wrong size on FSysSecurityEvent");
static_assert(offsetof(FSysSecurityEvent, M_type) == 0x000000, "Member 'FSysSecurityEvent::M_type' has a wrong offset!");
static_assert(offsetof(FSysSecurityEvent, M_committing_actor) == 0x000004, "Member 'FSysSecurityEvent::M_committing_actor' has a wrong offset!");
static_assert(offsetof(FSysSecurityEvent, M_reporting_actor) == 0x00000C, "Member 'FSysSecurityEvent::M_reporting_actor' has a wrong offset!");
static_assert(offsetof(FSysSecurityEvent, M_target_actor) == 0x000014, "Member 'FSysSecurityEvent::M_target_actor' has a wrong offset!");

// ScriptStruct keaton.HitReactionEntry
// 0x0028 (0x0028 - 0x0000)
struct FHitReactionEntry final
{
public:
	struct FGameplayTagContainer                  M_tags;                                            // 0x0000(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_montage;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitReactionEntry) == 0x000008, "Wrong alignment on FHitReactionEntry");
static_assert(sizeof(FHitReactionEntry) == 0x000028, "Wrong size on FHitReactionEntry");
static_assert(offsetof(FHitReactionEntry, M_tags) == 0x000000, "Member 'FHitReactionEntry::M_tags' has a wrong offset!");
static_assert(offsetof(FHitReactionEntry, M_montage) == 0x000020, "Member 'FHitReactionEntry::M_montage' has a wrong offset!");

// ScriptStruct keaton.ItemCountPair
// 0x0010 (0x0010 - 0x0000)
struct FItemCountPair final
{
public:
	class UCAInventoryItem*                       M_item;                                            // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_amount;                                          // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemCountPair) == 0x000008, "Wrong alignment on FItemCountPair");
static_assert(sizeof(FItemCountPair) == 0x000010, "Wrong size on FItemCountPair");
static_assert(offsetof(FItemCountPair, M_item) == 0x000000, "Member 'FItemCountPair::M_item' has a wrong offset!");
static_assert(offsetof(FItemCountPair, M_amount) == 0x000008, "Member 'FItemCountPair::M_amount' has a wrong offset!");

// ScriptStruct keaton.CAGrantedRewardsRegistryData
// 0x0040 (0x0040 - 0x0000)
struct FCAGrantedRewardsRegistryData final
{
public:
	class AActor*                                 M_reward_source;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_initiator;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FItemCountPair>                 M_rewards;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACASecurityModule*>              M_applicable_security_modules;                     // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	ECARewardQuerySourceTypeScope                 M_source_type;                                     // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAGrantedRewardsRegistryData) == 0x000008, "Wrong alignment on FCAGrantedRewardsRegistryData");
static_assert(sizeof(FCAGrantedRewardsRegistryData) == 0x000040, "Wrong size on FCAGrantedRewardsRegistryData");
static_assert(offsetof(FCAGrantedRewardsRegistryData, M_reward_source) == 0x000000, "Member 'FCAGrantedRewardsRegistryData::M_reward_source' has a wrong offset!");
static_assert(offsetof(FCAGrantedRewardsRegistryData, M_initiator) == 0x000008, "Member 'FCAGrantedRewardsRegistryData::M_initiator' has a wrong offset!");
static_assert(offsetof(FCAGrantedRewardsRegistryData, M_rewards) == 0x000010, "Member 'FCAGrantedRewardsRegistryData::M_rewards' has a wrong offset!");
static_assert(offsetof(FCAGrantedRewardsRegistryData, M_applicable_security_modules) == 0x000028, "Member 'FCAGrantedRewardsRegistryData::M_applicable_security_modules' has a wrong offset!");
static_assert(offsetof(FCAGrantedRewardsRegistryData, M_source_type) == 0x000038, "Member 'FCAGrantedRewardsRegistryData::M_source_type' has a wrong offset!");

// ScriptStruct keaton.NamedIntegerEntry
// 0x0010 (0x001C - 0x000C)
struct FNamedIntegerEntry final : public FFastArraySerializerItem
{
public:
	class FName                                   Name;                                              // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNamedIntegerEntry) == 0x000004, "Wrong alignment on FNamedIntegerEntry");
static_assert(sizeof(FNamedIntegerEntry) == 0x00001C, "Wrong size on FNamedIntegerEntry");
static_assert(offsetof(FNamedIntegerEntry, Name) == 0x00000C, "Member 'FNamedIntegerEntry::Name' has a wrong offset!");
static_assert(offsetof(FNamedIntegerEntry, Value) == 0x000018, "Member 'FNamedIntegerEntry::Value' has a wrong offset!");

// ScriptStruct keaton.NamedIntegerArray
// 0x0010 (0x0118 - 0x0108)
struct FNamedIntegerArray final : public FFastArraySerializer
{
public:
	TArray<struct FNamedIntegerEntry>             Items;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNamedIntegerArray) == 0x000008, "Wrong alignment on FNamedIntegerArray");
static_assert(sizeof(FNamedIntegerArray) == 0x000118, "Wrong size on FNamedIntegerArray");
static_assert(offsetof(FNamedIntegerArray, Items) == 0x000108, "Member 'FNamedIntegerArray::Items' has a wrong offset!");

// ScriptStruct keaton.CARewardsForBlueprintStruct
// 0x0010 (0x0010 - 0x0000)
struct FCARewardsForBlueprintStruct final
{
public:
	TArray<class UObject*>                        M_rewards;                                         // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARewardsForBlueprintStruct) == 0x000008, "Wrong alignment on FCARewardsForBlueprintStruct");
static_assert(sizeof(FCARewardsForBlueprintStruct) == 0x000010, "Wrong size on FCARewardsForBlueprintStruct");
static_assert(offsetof(FCARewardsForBlueprintStruct, M_rewards) == 0x000000, "Member 'FCARewardsForBlueprintStruct::M_rewards' has a wrong offset!");

// ScriptStruct keaton.CACharacterInstantHitInfo
// 0x0034 (0x0040 - 0x000C)
struct FCACharacterInstantHitInfo final : public FFastArraySerializerItem
{
public:
	uint8                                         M_FX_index;                                        // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    M_origin;                                          // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              M_shoot_dir;                                       // 0x001C(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_actor_hit;                                       // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACAWeapon*                              M_weapon;                                          // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_fired_from_slave;                                // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCACharacterInstantHitInfo) == 0x000008, "Wrong alignment on FCACharacterInstantHitInfo");
static_assert(sizeof(FCACharacterInstantHitInfo) == 0x000040, "Wrong size on FCACharacterInstantHitInfo");
static_assert(offsetof(FCACharacterInstantHitInfo, M_FX_index) == 0x00000C, "Member 'FCACharacterInstantHitInfo::M_FX_index' has a wrong offset!");
static_assert(offsetof(FCACharacterInstantHitInfo, M_origin) == 0x000010, "Member 'FCACharacterInstantHitInfo::M_origin' has a wrong offset!");
static_assert(offsetof(FCACharacterInstantHitInfo, M_shoot_dir) == 0x00001C, "Member 'FCACharacterInstantHitInfo::M_shoot_dir' has a wrong offset!");
static_assert(offsetof(FCACharacterInstantHitInfo, M_actor_hit) == 0x000028, "Member 'FCACharacterInstantHitInfo::M_actor_hit' has a wrong offset!");
static_assert(offsetof(FCACharacterInstantHitInfo, M_weapon) == 0x000030, "Member 'FCACharacterInstantHitInfo::M_weapon' has a wrong offset!");
static_assert(offsetof(FCACharacterInstantHitInfo, M_fired_from_slave) == 0x000038, "Member 'FCACharacterInstantHitInfo::M_fired_from_slave' has a wrong offset!");

// ScriptStruct keaton.CAGameplayExecutionLoadedReferences
// 0x0018 (0x0018 - 0x0000)
struct FCAGameplayExecutionLoadedReferences final
{
public:
	class UAnimMontage*                           M_executioner_anim_montage;                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_victim_anim_montage;                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequence*                         M_camera_option;                                   // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAGameplayExecutionLoadedReferences) == 0x000008, "Wrong alignment on FCAGameplayExecutionLoadedReferences");
static_assert(sizeof(FCAGameplayExecutionLoadedReferences) == 0x000018, "Wrong size on FCAGameplayExecutionLoadedReferences");
static_assert(offsetof(FCAGameplayExecutionLoadedReferences, M_executioner_anim_montage) == 0x000000, "Member 'FCAGameplayExecutionLoadedReferences::M_executioner_anim_montage' has a wrong offset!");
static_assert(offsetof(FCAGameplayExecutionLoadedReferences, M_victim_anim_montage) == 0x000008, "Member 'FCAGameplayExecutionLoadedReferences::M_victim_anim_montage' has a wrong offset!");
static_assert(offsetof(FCAGameplayExecutionLoadedReferences, M_camera_option) == 0x000010, "Member 'FCAGameplayExecutionLoadedReferences::M_camera_option' has a wrong offset!");

// ScriptStruct keaton.CAMutuallyExclusiveInputConfigs
// 0x0010 (0x0010 - 0x0000)
struct FCAMutuallyExclusiveInputConfigs final
{
public:
	TArray<struct FGameplayTag>                   M_config_ids;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMutuallyExclusiveInputConfigs) == 0x000008, "Wrong alignment on FCAMutuallyExclusiveInputConfigs");
static_assert(sizeof(FCAMutuallyExclusiveInputConfigs) == 0x000010, "Wrong size on FCAMutuallyExclusiveInputConfigs");
static_assert(offsetof(FCAMutuallyExclusiveInputConfigs, M_config_ids) == 0x000000, "Member 'FCAMutuallyExclusiveInputConfigs::M_config_ids' has a wrong offset!");

// ScriptStruct keaton.CAHUDGamerDroneInfo
// 0x0010 (0x0010 - 0x0000)
struct FCAHUDGamerDroneInfo final
{
public:
	ECAHUDDroneAbilityState                       M_drone_ability_state;                             // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_drone_target;                                    // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDGamerDroneInfo) == 0x000008, "Wrong alignment on FCAHUDGamerDroneInfo");
static_assert(sizeof(FCAHUDGamerDroneInfo) == 0x000010, "Wrong size on FCAHUDGamerDroneInfo");
static_assert(offsetof(FCAHUDGamerDroneInfo, M_drone_ability_state) == 0x000000, "Member 'FCAHUDGamerDroneInfo::M_drone_ability_state' has a wrong offset!");
static_assert(offsetof(FCAHUDGamerDroneInfo, M_drone_target) == 0x000008, "Member 'FCAHUDGamerDroneInfo::M_drone_target' has a wrong offset!");

// ScriptStruct keaton.NamedBooleanEntry
// 0x0010 (0x001C - 0x000C)
struct FNamedBooleanEntry final : public FFastArraySerializerItem
{
public:
	class FName                                   Name;                                              // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Value;                                             // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNamedBooleanEntry) == 0x000004, "Wrong alignment on FNamedBooleanEntry");
static_assert(sizeof(FNamedBooleanEntry) == 0x00001C, "Wrong size on FNamedBooleanEntry");
static_assert(offsetof(FNamedBooleanEntry, Name) == 0x00000C, "Member 'FNamedBooleanEntry::Name' has a wrong offset!");
static_assert(offsetof(FNamedBooleanEntry, Value) == 0x000018, "Member 'FNamedBooleanEntry::Value' has a wrong offset!");

// ScriptStruct keaton.CADamageEffectInfo
// 0x02F8 (0x02F8 - 0x0000)
struct FCADamageEffectInfo final
{
public:
	class AActor*                                 M_target_actor;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            M_target_controller;                               // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_source_actor;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            M_source_controller;                               // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBodyPart                                     M_hit_body_part;                                   // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectSpec                    M_effect_spec;                                     // 0x0028(0x0298)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          M_is_backstab;                                     // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_weakpoint;                                    // 0x02C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_weakpoint_broken;                                // 0x02C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_target_was_full_health;                          // 0x02C3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_injured_target;                                  // 0x02C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_downed_target;                                   // 0x02C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_killed_target;                                   // 0x02C6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C7[0x1];                                      // 0x02C7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_base_damage;                                     // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_instant_damage;                                  // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_bleed_damage;                                    // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_health_damage;                               // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_armour_damage;                                   // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_impact_location;                                 // 0x02DC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_impact_normal;                                   // 0x02E8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADamageEffectInfo) == 0x000008, "Wrong alignment on FCADamageEffectInfo");
static_assert(sizeof(FCADamageEffectInfo) == 0x0002F8, "Wrong size on FCADamageEffectInfo");
static_assert(offsetof(FCADamageEffectInfo, M_target_actor) == 0x000000, "Member 'FCADamageEffectInfo::M_target_actor' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_target_controller) == 0x000008, "Member 'FCADamageEffectInfo::M_target_controller' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_source_actor) == 0x000010, "Member 'FCADamageEffectInfo::M_source_actor' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_source_controller) == 0x000018, "Member 'FCADamageEffectInfo::M_source_controller' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_hit_body_part) == 0x000020, "Member 'FCADamageEffectInfo::M_hit_body_part' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_effect_spec) == 0x000028, "Member 'FCADamageEffectInfo::M_effect_spec' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_is_backstab) == 0x0002C0, "Member 'FCADamageEffectInfo::M_is_backstab' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_is_weakpoint) == 0x0002C1, "Member 'FCADamageEffectInfo::M_is_weakpoint' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_weakpoint_broken) == 0x0002C2, "Member 'FCADamageEffectInfo::M_weakpoint_broken' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_target_was_full_health) == 0x0002C3, "Member 'FCADamageEffectInfo::M_target_was_full_health' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_injured_target) == 0x0002C4, "Member 'FCADamageEffectInfo::M_injured_target' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_downed_target) == 0x0002C5, "Member 'FCADamageEffectInfo::M_downed_target' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_killed_target) == 0x0002C6, "Member 'FCADamageEffectInfo::M_killed_target' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_base_damage) == 0x0002C8, "Member 'FCADamageEffectInfo::M_base_damage' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_instant_damage) == 0x0002CC, "Member 'FCADamageEffectInfo::M_instant_damage' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_bleed_damage) == 0x0002D0, "Member 'FCADamageEffectInfo::M_bleed_damage' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_max_health_damage) == 0x0002D4, "Member 'FCADamageEffectInfo::M_max_health_damage' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_armour_damage) == 0x0002D8, "Member 'FCADamageEffectInfo::M_armour_damage' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_impact_location) == 0x0002DC, "Member 'FCADamageEffectInfo::M_impact_location' has a wrong offset!");
static_assert(offsetof(FCADamageEffectInfo, M_impact_normal) == 0x0002E8, "Member 'FCADamageEffectInfo::M_impact_normal' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_bool
// 0x0002 (0x0002 - 0x0000)
struct FCAExceptionData_bool final
{
public:
	ECAExceptionData_BoolOperator                 M_operator;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_value;                                           // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAExceptionData_bool) == 0x000001, "Wrong alignment on FCAExceptionData_bool");
static_assert(sizeof(FCAExceptionData_bool) == 0x000002, "Wrong size on FCAExceptionData_bool");
static_assert(offsetof(FCAExceptionData_bool, M_operator) == 0x000000, "Member 'FCAExceptionData_bool::M_operator' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_bool, M_value) == 0x000001, "Member 'FCAExceptionData_bool::M_value' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_float
// 0x0008 (0x0008 - 0x0000)
struct FCAExceptionData_float final
{
public:
	ECAExceptionData_Operator                     M_operator;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_value;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAExceptionData_float) == 0x000004, "Wrong alignment on FCAExceptionData_float");
static_assert(sizeof(FCAExceptionData_float) == 0x000008, "Wrong size on FCAExceptionData_float");
static_assert(offsetof(FCAExceptionData_float, M_operator) == 0x000000, "Member 'FCAExceptionData_float::M_operator' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_float, M_value) == 0x000004, "Member 'FCAExceptionData_float::M_value' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_JumpProfile_Elt
// 0x0024 (0x0024 - 0x0000)
struct FCAExceptionData_JumpProfile_Elt final
{
public:
	struct FCAExceptionData_float                 M_jump_height;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_running_jump_distance;                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_sprinting_jump_distance;                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_sliding_jump_distance;                           // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_bool                  M_can_accelerate;                                  // 0x0020(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAExceptionData_JumpProfile_Elt) == 0x000004, "Wrong alignment on FCAExceptionData_JumpProfile_Elt");
static_assert(sizeof(FCAExceptionData_JumpProfile_Elt) == 0x000024, "Wrong size on FCAExceptionData_JumpProfile_Elt");
static_assert(offsetof(FCAExceptionData_JumpProfile_Elt, M_jump_height) == 0x000000, "Member 'FCAExceptionData_JumpProfile_Elt::M_jump_height' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_JumpProfile_Elt, M_running_jump_distance) == 0x000008, "Member 'FCAExceptionData_JumpProfile_Elt::M_running_jump_distance' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_JumpProfile_Elt, M_sprinting_jump_distance) == 0x000010, "Member 'FCAExceptionData_JumpProfile_Elt::M_sprinting_jump_distance' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_JumpProfile_Elt, M_sliding_jump_distance) == 0x000018, "Member 'FCAExceptionData_JumpProfile_Elt::M_sliding_jump_distance' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_JumpProfile_Elt, M_can_accelerate) == 0x000020, "Member 'FCAExceptionData_JumpProfile_Elt::M_can_accelerate' has a wrong offset!");

// ScriptStruct keaton.CAMovementModeExceptionData
// 0x0000 (0x0008 - 0x0008)
struct FCAMovementModeExceptionData : public FCAMovementModeData_CommonBase
{
};
static_assert(alignof(FCAMovementModeExceptionData) == 0x000008, "Wrong alignment on FCAMovementModeExceptionData");
static_assert(sizeof(FCAMovementModeExceptionData) == 0x000008, "Wrong size on FCAMovementModeExceptionData");

// ScriptStruct keaton.CAExceptionData_Jump
// 0x0018 (0x0020 - 0x0008)
struct FCAExceptionData_Jump final : public FCAMovementModeExceptionData
{
public:
	struct FCAExceptionData_bool                  M_is_blocked;                                      // 0x0008(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_bool                  M_allow_gap_jump_boost;                            // 0x000A(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAExceptionData_JumpProfile_Elt> M_jump_profiles;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAExceptionData_Jump) == 0x000008, "Wrong alignment on FCAExceptionData_Jump");
static_assert(sizeof(FCAExceptionData_Jump) == 0x000020, "Wrong size on FCAExceptionData_Jump");
static_assert(offsetof(FCAExceptionData_Jump, M_is_blocked) == 0x000008, "Member 'FCAExceptionData_Jump::M_is_blocked' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Jump, M_allow_gap_jump_boost) == 0x00000A, "Member 'FCAExceptionData_Jump::M_allow_gap_jump_boost' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Jump, M_jump_profiles) == 0x000010, "Member 'FCAExceptionData_Jump::M_jump_profiles' has a wrong offset!");

// ScriptStruct keaton.CAAILoDRuleType
// 0x0002 (0x0002 - 0x0000)
struct FCAAILoDRuleType final
{
public:
	ECAAILoDRuleType                              M_lod_rule_type;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bool_match;                                      // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAILoDRuleType) == 0x000001, "Wrong alignment on FCAAILoDRuleType");
static_assert(sizeof(FCAAILoDRuleType) == 0x000002, "Wrong size on FCAAILoDRuleType");
static_assert(offsetof(FCAAILoDRuleType, M_lod_rule_type) == 0x000000, "Member 'FCAAILoDRuleType::M_lod_rule_type' has a wrong offset!");
static_assert(offsetof(FCAAILoDRuleType, M_bool_match) == 0x000001, "Member 'FCAAILoDRuleType::M_bool_match' has a wrong offset!");

// ScriptStruct keaton.CAAILoDRule
// 0x0020 (0x0020 - 0x0000)
struct FCAAILoDRule final
{
public:
	bool                                          M_enabled;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAAILoDRuleType>               M_lod_rule_types;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ECAAILoDState                                 M_lod_state;                                       // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAILoDRule) == 0x000008, "Wrong alignment on FCAAILoDRule");
static_assert(sizeof(FCAAILoDRule) == 0x000020, "Wrong size on FCAAILoDRule");
static_assert(offsetof(FCAAILoDRule, M_enabled) == 0x000000, "Member 'FCAAILoDRule::M_enabled' has a wrong offset!");
static_assert(offsetof(FCAAILoDRule, M_lod_rule_types) == 0x000008, "Member 'FCAAILoDRule::M_lod_rule_types' has a wrong offset!");
static_assert(offsetof(FCAAILoDRule, M_lod_state) == 0x000018, "Member 'FCAAILoDRule::M_lod_state' has a wrong offset!");

// ScriptStruct keaton.CAStatInformation
// 0x0010 (0x0010 - 0x0000)
struct FCAStatInformation final
{
public:
	class FName                                   M_stat_name;                                       // 0x0000(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_stat_value;                                      // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAStatInformation) == 0x000004, "Wrong alignment on FCAStatInformation");
static_assert(sizeof(FCAStatInformation) == 0x000010, "Wrong size on FCAStatInformation");
static_assert(offsetof(FCAStatInformation, M_stat_name) == 0x000000, "Member 'FCAStatInformation::M_stat_name' has a wrong offset!");
static_assert(offsetof(FCAStatInformation, M_stat_value) == 0x00000C, "Member 'FCAStatInformation::M_stat_value' has a wrong offset!");

// ScriptStruct keaton.CAPlayerStats
// 0x0020 (0x0020 - 0x0000)
struct FCAPlayerStats final
{
public:
	class FName                                   M_user_id;                                         // 0x0000(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAStatInformation>             M_stats;                                           // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPlayerStats) == 0x000008, "Wrong alignment on FCAPlayerStats");
static_assert(sizeof(FCAPlayerStats) == 0x000020, "Wrong size on FCAPlayerStats");
static_assert(offsetof(FCAPlayerStats, M_user_id) == 0x000000, "Member 'FCAPlayerStats::M_user_id' has a wrong offset!");
static_assert(offsetof(FCAPlayerStats, M_stats) == 0x000010, "Member 'FCAPlayerStats::M_stats' has a wrong offset!");

// ScriptStruct keaton.CADynamicHeaderNavigationItem
// 0x0058 (0x0058 - 0x0000)
struct FCADynamicHeaderNavigationItem final
{
public:
	struct FCAText                                M_label;                                           // 0x0000(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   M_id;                                              // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAUITransitionDefinition              M_transition;                                      // 0x003C(0x0018)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_default;                                      // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_transition_automatically;                        // 0x0055(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADynamicHeaderNavigationItem) == 0x000008, "Wrong alignment on FCADynamicHeaderNavigationItem");
static_assert(sizeof(FCADynamicHeaderNavigationItem) == 0x000058, "Wrong size on FCADynamicHeaderNavigationItem");
static_assert(offsetof(FCADynamicHeaderNavigationItem, M_label) == 0x000000, "Member 'FCADynamicHeaderNavigationItem::M_label' has a wrong offset!");
static_assert(offsetof(FCADynamicHeaderNavigationItem, M_id) == 0x000030, "Member 'FCADynamicHeaderNavigationItem::M_id' has a wrong offset!");
static_assert(offsetof(FCADynamicHeaderNavigationItem, M_transition) == 0x00003C, "Member 'FCADynamicHeaderNavigationItem::M_transition' has a wrong offset!");
static_assert(offsetof(FCADynamicHeaderNavigationItem, M_is_default) == 0x000054, "Member 'FCADynamicHeaderNavigationItem::M_is_default' has a wrong offset!");
static_assert(offsetof(FCADynamicHeaderNavigationItem, M_transition_automatically) == 0x000055, "Member 'FCADynamicHeaderNavigationItem::M_transition_automatically' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_MagBoots
// 0x0028 (0x0030 - 0x0008)
struct FCAExceptionData_MagBoots final : public FCAMovementModeExceptionData
{
public:
	struct FCAExceptionData_float                 M_ground_friction;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_deceleration;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_acceleration;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_max_speed;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_max_diagonal_angle;                              // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAExceptionData_MagBoots) == 0x000008, "Wrong alignment on FCAExceptionData_MagBoots");
static_assert(sizeof(FCAExceptionData_MagBoots) == 0x000030, "Wrong size on FCAExceptionData_MagBoots");
static_assert(offsetof(FCAExceptionData_MagBoots, M_ground_friction) == 0x000008, "Member 'FCAExceptionData_MagBoots::M_ground_friction' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_MagBoots, M_deceleration) == 0x000010, "Member 'FCAExceptionData_MagBoots::M_deceleration' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_MagBoots, M_acceleration) == 0x000018, "Member 'FCAExceptionData_MagBoots::M_acceleration' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_MagBoots, M_max_speed) == 0x000020, "Member 'FCAExceptionData_MagBoots::M_max_speed' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_MagBoots, M_max_diagonal_angle) == 0x000028, "Member 'FCAExceptionData_MagBoots::M_max_diagonal_angle' has a wrong offset!");

// ScriptStruct keaton.CAPlayerEncounterRecord
// 0x0060 (0x0060 - 0x0000)
struct FCAPlayerEncounterRecord final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECAPlayerAbilityMode, float>             M_mode_time;                                       // 0x0010(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPlayerEncounterRecord) == 0x000008, "Wrong alignment on FCAPlayerEncounterRecord");
static_assert(sizeof(FCAPlayerEncounterRecord) == 0x000060, "Wrong size on FCAPlayerEncounterRecord");
static_assert(offsetof(FCAPlayerEncounterRecord, M_mode_time) == 0x000010, "Member 'FCAPlayerEncounterRecord::M_mode_time' has a wrong offset!");

// ScriptStruct keaton.NamedFloatEntry
// 0x0010 (0x001C - 0x000C)
struct FNamedFloatEntry final : public FFastArraySerializerItem
{
public:
	class FName                                   Name;                                              // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNamedFloatEntry) == 0x000004, "Wrong alignment on FNamedFloatEntry");
static_assert(sizeof(FNamedFloatEntry) == 0x00001C, "Wrong size on FNamedFloatEntry");
static_assert(offsetof(FNamedFloatEntry, Name) == 0x00000C, "Member 'FNamedFloatEntry::Name' has a wrong offset!");
static_assert(offsetof(FNamedFloatEntry, Value) == 0x000018, "Member 'FNamedFloatEntry::Value' has a wrong offset!");

// ScriptStruct keaton.CAHitIndicatorData
// 0x0030 (0x0030 - 0x0000)
struct FCAHitIndicatorData final
{
public:
	struct FVector                                M_direction;                                       // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_location;                                        // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_damage;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_actor;                                           // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAHitIndicatorData) == 0x000008, "Wrong alignment on FCAHitIndicatorData");
static_assert(sizeof(FCAHitIndicatorData) == 0x000030, "Wrong size on FCAHitIndicatorData");
static_assert(offsetof(FCAHitIndicatorData, M_direction) == 0x000000, "Member 'FCAHitIndicatorData::M_direction' has a wrong offset!");
static_assert(offsetof(FCAHitIndicatorData, M_location) == 0x00000C, "Member 'FCAHitIndicatorData::M_location' has a wrong offset!");
static_assert(offsetof(FCAHitIndicatorData, M_damage) == 0x000018, "Member 'FCAHitIndicatorData::M_damage' has a wrong offset!");
static_assert(offsetof(FCAHitIndicatorData, M_actor) == 0x000020, "Member 'FCAHitIndicatorData::M_actor' has a wrong offset!");

// ScriptStruct keaton.NamedObjectEntry
// 0x0014 (0x0020 - 0x000C)
struct FNamedObjectEntry final : public FFastArraySerializerItem
{
public:
	class FName                                   Name;                                              // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Value;                                             // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNamedObjectEntry) == 0x000008, "Wrong alignment on FNamedObjectEntry");
static_assert(sizeof(FNamedObjectEntry) == 0x000020, "Wrong size on FNamedObjectEntry");
static_assert(offsetof(FNamedObjectEntry, Name) == 0x00000C, "Member 'FNamedObjectEntry::Name' has a wrong offset!");
static_assert(offsetof(FNamedObjectEntry, Value) == 0x000018, "Member 'FNamedObjectEntry::Value' has a wrong offset!");

// ScriptStruct keaton.NamedObjectArray
// 0x0010 (0x0118 - 0x0108)
struct FNamedObjectArray final : public FFastArraySerializer
{
public:
	TArray<struct FNamedObjectEntry>              Items;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNamedObjectArray) == 0x000008, "Wrong alignment on FNamedObjectArray");
static_assert(sizeof(FNamedObjectArray) == 0x000118, "Wrong size on FNamedObjectArray");
static_assert(offsetof(FNamedObjectArray, Items) == 0x000108, "Member 'FNamedObjectArray::Items' has a wrong offset!");

// ScriptStruct keaton.CAHashableString
// 0x0004 (0x0004 - 0x0000)
struct FCAHashableString final
{
public:
	int32                                         M_hash;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHashableString) == 0x000004, "Wrong alignment on FCAHashableString");
static_assert(sizeof(FCAHashableString) == 0x000004, "Wrong size on FCAHashableString");
static_assert(offsetof(FCAHashableString, M_hash) == 0x000000, "Member 'FCAHashableString::M_hash' has a wrong offset!");

// ScriptStruct keaton.CADialogueHashData
// 0x0010 (0x0018 - 0x0008)
struct FCADialogueHashData final : public FTableRowBase
{
public:
	struct FCAHashableString                      Hash;                                              // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Text;                                              // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADialogueHashData) == 0x000008, "Wrong alignment on FCADialogueHashData");
static_assert(sizeof(FCADialogueHashData) == 0x000018, "Wrong size on FCADialogueHashData");
static_assert(offsetof(FCADialogueHashData, Hash) == 0x000008, "Member 'FCADialogueHashData::Hash' has a wrong offset!");
static_assert(offsetof(FCADialogueHashData, Text) == 0x00000C, "Member 'FCADialogueHashData::Text' has a wrong offset!");

// ScriptStruct keaton.CAFoamCharacterAttachments
// 0x0010 (0x0010 - 0x0000)
struct FCAFoamCharacterAttachments final
{
public:
	class FName                                   M_bone_name;                                       // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_remove_at_foam_percentage_left;                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFoamCharacterAttachments) == 0x000004, "Wrong alignment on FCAFoamCharacterAttachments");
static_assert(sizeof(FCAFoamCharacterAttachments) == 0x000010, "Wrong size on FCAFoamCharacterAttachments");
static_assert(offsetof(FCAFoamCharacterAttachments, M_bone_name) == 0x000000, "Member 'FCAFoamCharacterAttachments::M_bone_name' has a wrong offset!");
static_assert(offsetof(FCAFoamCharacterAttachments, M_remove_at_foam_percentage_left) == 0x00000C, "Member 'FCAFoamCharacterAttachments::M_remove_at_foam_percentage_left' has a wrong offset!");

// ScriptStruct keaton.CAFoamPercentageEffects
// 0x0018 (0x0018 - 0x0000)
struct FCAFoamPercentageEffects final
{
public:
	float                                         M_apply_effects_at_percentage;                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           M_effects;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFoamPercentageEffects) == 0x000008, "Wrong alignment on FCAFoamPercentageEffects");
static_assert(sizeof(FCAFoamPercentageEffects) == 0x000018, "Wrong size on FCAFoamPercentageEffects");
static_assert(offsetof(FCAFoamPercentageEffects, M_apply_effects_at_percentage) == 0x000000, "Member 'FCAFoamPercentageEffects::M_apply_effects_at_percentage' has a wrong offset!");
static_assert(offsetof(FCAFoamPercentageEffects, M_effects) == 0x000008, "Member 'FCAFoamPercentageEffects::M_effects' has a wrong offset!");

// ScriptStruct keaton.CAFoamPercentageRemovalModifierMultiplier
// 0x0008 (0x0008 - 0x0000)
struct FCAFoamPercentageRemovalModifierMultiplier final
{
public:
	float                                         M_percentage;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_multiplier;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFoamPercentageRemovalModifierMultiplier) == 0x000004, "Wrong alignment on FCAFoamPercentageRemovalModifierMultiplier");
static_assert(sizeof(FCAFoamPercentageRemovalModifierMultiplier) == 0x000008, "Wrong size on FCAFoamPercentageRemovalModifierMultiplier");
static_assert(offsetof(FCAFoamPercentageRemovalModifierMultiplier, M_percentage) == 0x000000, "Member 'FCAFoamPercentageRemovalModifierMultiplier::M_percentage' has a wrong offset!");
static_assert(offsetof(FCAFoamPercentageRemovalModifierMultiplier, M_multiplier) == 0x000004, "Member 'FCAFoamPercentageRemovalModifierMultiplier::M_multiplier' has a wrong offset!");

// ScriptStruct keaton.CAFoamCharacterConfiguration
// 0x0068 (0x0070 - 0x0008)
struct FCAFoamCharacterConfiguration final : public FTableRowBase
{
public:
	struct FGameplayTag                           M_foamable;                                        // 0x0008(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAFoamCharacterAttachments>    M_attachments;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         FoamRemovalMultiplier;                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumFoamCoverage;                               // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScale;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScale;                                          // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOffset;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           M_default_effects;                                 // 0x0040(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FCAFoamPercentageEffects>       M_percentage_effects;                              // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCAFoamPercentageRemovalModifierMultiplier> M_removal_multipliers;                             // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFoamCharacterConfiguration) == 0x000008, "Wrong alignment on FCAFoamCharacterConfiguration");
static_assert(sizeof(FCAFoamCharacterConfiguration) == 0x000070, "Wrong size on FCAFoamCharacterConfiguration");
static_assert(offsetof(FCAFoamCharacterConfiguration, M_foamable) == 0x000008, "Member 'FCAFoamCharacterConfiguration::M_foamable' has a wrong offset!");
static_assert(offsetof(FCAFoamCharacterConfiguration, M_attachments) == 0x000018, "Member 'FCAFoamCharacterConfiguration::M_attachments' has a wrong offset!");
static_assert(offsetof(FCAFoamCharacterConfiguration, FoamRemovalMultiplier) == 0x000028, "Member 'FCAFoamCharacterConfiguration::FoamRemovalMultiplier' has a wrong offset!");
static_assert(offsetof(FCAFoamCharacterConfiguration, MaximumFoamCoverage) == 0x00002C, "Member 'FCAFoamCharacterConfiguration::MaximumFoamCoverage' has a wrong offset!");
static_assert(offsetof(FCAFoamCharacterConfiguration, MinScale) == 0x000030, "Member 'FCAFoamCharacterConfiguration::MinScale' has a wrong offset!");
static_assert(offsetof(FCAFoamCharacterConfiguration, MaxScale) == 0x000034, "Member 'FCAFoamCharacterConfiguration::MaxScale' has a wrong offset!");
static_assert(offsetof(FCAFoamCharacterConfiguration, MaxOffset) == 0x000038, "Member 'FCAFoamCharacterConfiguration::MaxOffset' has a wrong offset!");
static_assert(offsetof(FCAFoamCharacterConfiguration, M_default_effects) == 0x000040, "Member 'FCAFoamCharacterConfiguration::M_default_effects' has a wrong offset!");
static_assert(offsetof(FCAFoamCharacterConfiguration, M_percentage_effects) == 0x000050, "Member 'FCAFoamCharacterConfiguration::M_percentage_effects' has a wrong offset!");
static_assert(offsetof(FCAFoamCharacterConfiguration, M_removal_multipliers) == 0x000060, "Member 'FCAFoamCharacterConfiguration::M_removal_multipliers' has a wrong offset!");

// ScriptStruct keaton.CACharacterFXPostProcess
// 0x0010 (0x0010 - 0x0000)
struct FCACharacterFXPostProcess final
{
public:
	class ACAPostProcessEffect*                   M_effect;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCACharacterFXPostProcess) == 0x000008, "Wrong alignment on FCACharacterFXPostProcess");
static_assert(sizeof(FCACharacterFXPostProcess) == 0x000010, "Wrong size on FCACharacterFXPostProcess");
static_assert(offsetof(FCACharacterFXPostProcess, M_effect) == 0x000000, "Member 'FCACharacterFXPostProcess::M_effect' has a wrong offset!");

// ScriptStruct keaton.CAFragGrenadeBounceDataRow
// 0x0018 (0x0018 - 0x0000)
struct FCAFragGrenadeBounceDataRow final
{
public:
	int32                                         M_bounce_num;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_radius;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_damage;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_override_explosion_effect;                       // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACAExplosionEffect>         M_bounce_explosion_effect;                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFragGrenadeBounceDataRow) == 0x000008, "Wrong alignment on FCAFragGrenadeBounceDataRow");
static_assert(sizeof(FCAFragGrenadeBounceDataRow) == 0x000018, "Wrong size on FCAFragGrenadeBounceDataRow");
static_assert(offsetof(FCAFragGrenadeBounceDataRow, M_bounce_num) == 0x000000, "Member 'FCAFragGrenadeBounceDataRow::M_bounce_num' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeBounceDataRow, M_radius) == 0x000004, "Member 'FCAFragGrenadeBounceDataRow::M_radius' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeBounceDataRow, M_damage) == 0x000008, "Member 'FCAFragGrenadeBounceDataRow::M_damage' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeBounceDataRow, M_override_explosion_effect) == 0x00000C, "Member 'FCAFragGrenadeBounceDataRow::M_override_explosion_effect' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeBounceDataRow, M_bounce_explosion_effect) == 0x000010, "Member 'FCAFragGrenadeBounceDataRow::M_bounce_explosion_effect' has a wrong offset!");

// ScriptStruct keaton.CAClientConnection
// 0x0068 (0x0068 - 0x0000)
struct FCAClientConnection final
{
public:
	struct FDateTime                              M_timestamp;                                       // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAClientConnectionStep                       M_current_connection_step;                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAClientConnectionStep                       M_previous_connection_step;                        // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_online_username;                                 // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCATeamID                              M_assigned_team_id;                                // 0x0018(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_player_name;                                     // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_selected_specialist_name;                        // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_player_level;                                    // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_prestige_level;                                  // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_current_platform;                                // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_avatar_services_id;                              // 0x0058(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAClientConnection) == 0x000008, "Wrong alignment on FCAClientConnection");
static_assert(sizeof(FCAClientConnection) == 0x000068, "Wrong size on FCAClientConnection");
static_assert(offsetof(FCAClientConnection, M_timestamp) == 0x000000, "Member 'FCAClientConnection::M_timestamp' has a wrong offset!");
static_assert(offsetof(FCAClientConnection, M_current_connection_step) == 0x000008, "Member 'FCAClientConnection::M_current_connection_step' has a wrong offset!");
static_assert(offsetof(FCAClientConnection, M_previous_connection_step) == 0x000009, "Member 'FCAClientConnection::M_previous_connection_step' has a wrong offset!");
static_assert(offsetof(FCAClientConnection, M_online_username) == 0x00000C, "Member 'FCAClientConnection::M_online_username' has a wrong offset!");
static_assert(offsetof(FCAClientConnection, M_assigned_team_id) == 0x000018, "Member 'FCAClientConnection::M_assigned_team_id' has a wrong offset!");
static_assert(offsetof(FCAClientConnection, M_player_name) == 0x000020, "Member 'FCAClientConnection::M_player_name' has a wrong offset!");
static_assert(offsetof(FCAClientConnection, M_selected_specialist_name) == 0x000030, "Member 'FCAClientConnection::M_selected_specialist_name' has a wrong offset!");
static_assert(offsetof(FCAClientConnection, M_player_level) == 0x00003C, "Member 'FCAClientConnection::M_player_level' has a wrong offset!");
static_assert(offsetof(FCAClientConnection, M_prestige_level) == 0x000040, "Member 'FCAClientConnection::M_prestige_level' has a wrong offset!");
static_assert(offsetof(FCAClientConnection, M_current_platform) == 0x000048, "Member 'FCAClientConnection::M_current_platform' has a wrong offset!");
static_assert(offsetof(FCAClientConnection, M_avatar_services_id) == 0x000058, "Member 'FCAClientConnection::M_avatar_services_id' has a wrong offset!");

// ScriptStruct keaton.CADialogueWWiseMappingData
// 0x0010 (0x0018 - 0x0008)
struct FCADialogueWWiseMappingData final : public FTableRowBase
{
public:
	struct FCAHashableString                      ResponseName;                                      // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAAudioHashBase                       WWiseID;                                           // 0x000C(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioSwitchValueType                Projection;                                        // 0x0010(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADialogueWWiseMappingData) == 0x000008, "Wrong alignment on FCADialogueWWiseMappingData");
static_assert(sizeof(FCADialogueWWiseMappingData) == 0x000018, "Wrong size on FCADialogueWWiseMappingData");
static_assert(offsetof(FCADialogueWWiseMappingData, ResponseName) == 0x000008, "Member 'FCADialogueWWiseMappingData::ResponseName' has a wrong offset!");
static_assert(offsetof(FCADialogueWWiseMappingData, WWiseID) == 0x00000C, "Member 'FCADialogueWWiseMappingData::WWiseID' has a wrong offset!");
static_assert(offsetof(FCADialogueWWiseMappingData, Projection) == 0x000010, "Member 'FCADialogueWWiseMappingData::Projection' has a wrong offset!");

// ScriptStruct keaton.AdditionalMesh
// 0x0020 (0x0020 - 0x0000)
struct FAdditionalMesh final
{
public:
	class FName                                   M_socket_name;                                     // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_weld;                                            // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          M_tp_mesh;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          M_frontend_mesh;                                   // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAdditionalMesh) == 0x000008, "Wrong alignment on FAdditionalMesh");
static_assert(sizeof(FAdditionalMesh) == 0x000020, "Wrong size on FAdditionalMesh");
static_assert(offsetof(FAdditionalMesh, M_socket_name) == 0x000000, "Member 'FAdditionalMesh::M_socket_name' has a wrong offset!");
static_assert(offsetof(FAdditionalMesh, M_weld) == 0x00000C, "Member 'FAdditionalMesh::M_weld' has a wrong offset!");
static_assert(offsetof(FAdditionalMesh, M_tp_mesh) == 0x000010, "Member 'FAdditionalMesh::M_tp_mesh' has a wrong offset!");
static_assert(offsetof(FAdditionalMesh, M_frontend_mesh) == 0x000018, "Member 'FAdditionalMesh::M_frontend_mesh' has a wrong offset!");

// ScriptStruct keaton.CAGameplayAbilityTargetData_TurretPlacement
// 0x0098 (0x00A0 - 0x0008)
struct FCAGameplayAbilityTargetData_TurretPlacement final : public FGameplayAbilityTargetData
{
public:
	struct FHitResult                             M_hit_result;                                      // 0x0008(0x0090)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          M_can_place;                                       // 0x0098(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_wall_variation;                              // 0x0099(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAGameplayAbilityTargetData_TurretPlacement) == 0x000008, "Wrong alignment on FCAGameplayAbilityTargetData_TurretPlacement");
static_assert(sizeof(FCAGameplayAbilityTargetData_TurretPlacement) == 0x0000A0, "Wrong size on FCAGameplayAbilityTargetData_TurretPlacement");
static_assert(offsetof(FCAGameplayAbilityTargetData_TurretPlacement, M_hit_result) == 0x000008, "Member 'FCAGameplayAbilityTargetData_TurretPlacement::M_hit_result' has a wrong offset!");
static_assert(offsetof(FCAGameplayAbilityTargetData_TurretPlacement, M_can_place) == 0x000098, "Member 'FCAGameplayAbilityTargetData_TurretPlacement::M_can_place' has a wrong offset!");
static_assert(offsetof(FCAGameplayAbilityTargetData_TurretPlacement, M_use_wall_variation) == 0x000099, "Member 'FCAGameplayAbilityTargetData_TurretPlacement::M_use_wall_variation' has a wrong offset!");

// ScriptStruct keaton.CAPendingLockedOnTargetData
// 0x000C (0x000C - 0x0000)
struct FCAPendingLockedOnTargetData final
{
public:
	float                                         M_time_until_locked_on;                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  M_actor;                                           // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPendingLockedOnTargetData) == 0x000004, "Wrong alignment on FCAPendingLockedOnTargetData");
static_assert(sizeof(FCAPendingLockedOnTargetData) == 0x00000C, "Wrong size on FCAPendingLockedOnTargetData");
static_assert(offsetof(FCAPendingLockedOnTargetData, M_time_until_locked_on) == 0x000000, "Member 'FCAPendingLockedOnTargetData::M_time_until_locked_on' has a wrong offset!");
static_assert(offsetof(FCAPendingLockedOnTargetData, M_actor) == 0x000004, "Member 'FCAPendingLockedOnTargetData::M_actor' has a wrong offset!");

// ScriptStruct keaton.CAAnimInstance_Component_FP_LookAt_Layer
// 0x0000 (0x0010 - 0x0010)
struct FCAAnimInstance_Component_FP_LookAt_Layer final : public FCAAnimInstance_Component
{
};
static_assert(alignof(FCAAnimInstance_Component_FP_LookAt_Layer) == 0x000008, "Wrong alignment on FCAAnimInstance_Component_FP_LookAt_Layer");
static_assert(sizeof(FCAAnimInstance_Component_FP_LookAt_Layer) == 0x000010, "Wrong size on FCAAnimInstance_Component_FP_LookAt_Layer");

// ScriptStruct keaton.CANPCSquadDataEntry
// 0x00D8 (0x00D8 - 0x0000)
struct FCANPCSquadDataEntry final
{
public:
	ECANPCSquadSpecifierType                      M_npc_squad_specifier_type;                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCANPCSquadData*                        M_npc_squad_ref;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   M_npc_squad_tags;                                  // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ECANPCSquadTagEvaluationType                  M_npc_squad_tag_evaluation_type;                   // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECANPCType, int32>                       M_npcs;                                            // 0x0028(0x0050)(Edit, NativeAccessSpecifierPublic)
	class FString                                 M_squad_debug_name;                                // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ECANPCType, int32>                       M_npc_escalators;                                  // 0x0088(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANPCSquadDataEntry) == 0x000008, "Wrong alignment on FCANPCSquadDataEntry");
static_assert(sizeof(FCANPCSquadDataEntry) == 0x0000D8, "Wrong size on FCANPCSquadDataEntry");
static_assert(offsetof(FCANPCSquadDataEntry, M_npc_squad_specifier_type) == 0x000000, "Member 'FCANPCSquadDataEntry::M_npc_squad_specifier_type' has a wrong offset!");
static_assert(offsetof(FCANPCSquadDataEntry, M_npc_squad_ref) == 0x000008, "Member 'FCANPCSquadDataEntry::M_npc_squad_ref' has a wrong offset!");
static_assert(offsetof(FCANPCSquadDataEntry, M_npc_squad_tags) == 0x000010, "Member 'FCANPCSquadDataEntry::M_npc_squad_tags' has a wrong offset!");
static_assert(offsetof(FCANPCSquadDataEntry, M_npc_squad_tag_evaluation_type) == 0x000020, "Member 'FCANPCSquadDataEntry::M_npc_squad_tag_evaluation_type' has a wrong offset!");
static_assert(offsetof(FCANPCSquadDataEntry, M_npcs) == 0x000028, "Member 'FCANPCSquadDataEntry::M_npcs' has a wrong offset!");
static_assert(offsetof(FCANPCSquadDataEntry, M_squad_debug_name) == 0x000078, "Member 'FCANPCSquadDataEntry::M_squad_debug_name' has a wrong offset!");
static_assert(offsetof(FCANPCSquadDataEntry, M_npc_escalators) == 0x000088, "Member 'FCANPCSquadDataEntry::M_npc_escalators' has a wrong offset!");

// ScriptStruct keaton.CAPatrolMotivationActivationPhaseData
// 0x0060 (0x0060 - 0x0000)
struct FCAPatrolMotivationActivationPhaseData final
{
public:
	bool                                          M_use_given_patrol_path;                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class ACAJob>                  M_patrol_path_node;                                // 0x0008(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   M_patrol_path_types;                               // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   M_blacklisted_patrol_path_types;                   // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPatrolMotivationActivationPhaseData) == 0x000008, "Wrong alignment on FCAPatrolMotivationActivationPhaseData");
static_assert(sizeof(FCAPatrolMotivationActivationPhaseData) == 0x000060, "Wrong size on FCAPatrolMotivationActivationPhaseData");
static_assert(offsetof(FCAPatrolMotivationActivationPhaseData, M_use_given_patrol_path) == 0x000000, "Member 'FCAPatrolMotivationActivationPhaseData::M_use_given_patrol_path' has a wrong offset!");
static_assert(offsetof(FCAPatrolMotivationActivationPhaseData, M_patrol_path_node) == 0x000008, "Member 'FCAPatrolMotivationActivationPhaseData::M_patrol_path_node' has a wrong offset!");
static_assert(offsetof(FCAPatrolMotivationActivationPhaseData, M_patrol_path_types) == 0x000040, "Member 'FCAPatrolMotivationActivationPhaseData::M_patrol_path_types' has a wrong offset!");
static_assert(offsetof(FCAPatrolMotivationActivationPhaseData, M_blacklisted_patrol_path_types) == 0x000050, "Member 'FCAPatrolMotivationActivationPhaseData::M_blacklisted_patrol_path_types' has a wrong offset!");

// ScriptStruct keaton.CAMissionObjectiveAreaSelectionWeightData
// 0x0008 (0x0008 - 0x0000)
struct FCAMissionObjectiveAreaSelectionWeightData final
{
public:
	float                                         M_weight_value;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAMissionObjectiveAreaType                   M_area_type;                                       // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAMissionObjectiveAreaSelectionWeightTypes   M_weight_type;                                     // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_only_consider_currently_observed_players;        // 0x0006(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMissionObjectiveAreaSelectionWeightData) == 0x000004, "Wrong alignment on FCAMissionObjectiveAreaSelectionWeightData");
static_assert(sizeof(FCAMissionObjectiveAreaSelectionWeightData) == 0x000008, "Wrong size on FCAMissionObjectiveAreaSelectionWeightData");
static_assert(offsetof(FCAMissionObjectiveAreaSelectionWeightData, M_weight_value) == 0x000000, "Member 'FCAMissionObjectiveAreaSelectionWeightData::M_weight_value' has a wrong offset!");
static_assert(offsetof(FCAMissionObjectiveAreaSelectionWeightData, M_area_type) == 0x000004, "Member 'FCAMissionObjectiveAreaSelectionWeightData::M_area_type' has a wrong offset!");
static_assert(offsetof(FCAMissionObjectiveAreaSelectionWeightData, M_weight_type) == 0x000005, "Member 'FCAMissionObjectiveAreaSelectionWeightData::M_weight_type' has a wrong offset!");
static_assert(offsetof(FCAMissionObjectiveAreaSelectionWeightData, M_only_consider_currently_observed_players) == 0x000006, "Member 'FCAMissionObjectiveAreaSelectionWeightData::M_only_consider_currently_observed_players' has a wrong offset!");

// ScriptStruct keaton.CAMotivationActivationPhaseData
// 0x00D0 (0x00D0 - 0x0000)
struct FCAMotivationActivationPhaseData final
{
public:
	struct FGameplayTag                           M_motivation;                                      // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAPatrolMotivationActivationPhaseData M_additional_patrol_motivation_data;               // 0x0010(0x0060)(Edit, NativeAccessSpecifierPublic)
	bool                                          M_hide_motivation_settings;                        // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   M_activation_triggers;                             // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_start_time_offset;                               // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_duration;                                        // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_distance_threshold_from_objective_location_at_which_to_start_duration; // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAMissionObjectiveType                       M_mission_objective_type;                          // 0x0094(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   M_mission_objective_job_types;                     // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCAMissionObjectiveAreaSelectionWeightData> M_mission_objective_area_selection_weights;        // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_default_mission_objective_area_is_mission_area;  // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   M_end_triggers;                                    // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMotivationActivationPhaseData) == 0x000008, "Wrong alignment on FCAMotivationActivationPhaseData");
static_assert(sizeof(FCAMotivationActivationPhaseData) == 0x0000D0, "Wrong size on FCAMotivationActivationPhaseData");
static_assert(offsetof(FCAMotivationActivationPhaseData, M_motivation) == 0x000000, "Member 'FCAMotivationActivationPhaseData::M_motivation' has a wrong offset!");
static_assert(offsetof(FCAMotivationActivationPhaseData, M_additional_patrol_motivation_data) == 0x000010, "Member 'FCAMotivationActivationPhaseData::M_additional_patrol_motivation_data' has a wrong offset!");
static_assert(offsetof(FCAMotivationActivationPhaseData, M_hide_motivation_settings) == 0x000070, "Member 'FCAMotivationActivationPhaseData::M_hide_motivation_settings' has a wrong offset!");
static_assert(offsetof(FCAMotivationActivationPhaseData, M_activation_triggers) == 0x000078, "Member 'FCAMotivationActivationPhaseData::M_activation_triggers' has a wrong offset!");
static_assert(offsetof(FCAMotivationActivationPhaseData, M_start_time_offset) == 0x000088, "Member 'FCAMotivationActivationPhaseData::M_start_time_offset' has a wrong offset!");
static_assert(offsetof(FCAMotivationActivationPhaseData, M_duration) == 0x00008C, "Member 'FCAMotivationActivationPhaseData::M_duration' has a wrong offset!");
static_assert(offsetof(FCAMotivationActivationPhaseData, M_distance_threshold_from_objective_location_at_which_to_start_duration) == 0x000090, "Member 'FCAMotivationActivationPhaseData::M_distance_threshold_from_objective_location_at_which_to_start_duration' has a wrong offset!");
static_assert(offsetof(FCAMotivationActivationPhaseData, M_mission_objective_type) == 0x000094, "Member 'FCAMotivationActivationPhaseData::M_mission_objective_type' has a wrong offset!");
static_assert(offsetof(FCAMotivationActivationPhaseData, M_mission_objective_job_types) == 0x000098, "Member 'FCAMotivationActivationPhaseData::M_mission_objective_job_types' has a wrong offset!");
static_assert(offsetof(FCAMotivationActivationPhaseData, M_mission_objective_area_selection_weights) == 0x0000A8, "Member 'FCAMotivationActivationPhaseData::M_mission_objective_area_selection_weights' has a wrong offset!");
static_assert(offsetof(FCAMotivationActivationPhaseData, M_default_mission_objective_area_is_mission_area) == 0x0000B8, "Member 'FCAMotivationActivationPhaseData::M_default_mission_objective_area_is_mission_area' has a wrong offset!");
static_assert(offsetof(FCAMotivationActivationPhaseData, M_end_triggers) == 0x0000C0, "Member 'FCAMotivationActivationPhaseData::M_end_triggers' has a wrong offset!");

// ScriptStruct keaton.CANPCTaskGroup
// 0x00C8 (0x00C8 - 0x0000)
struct FCANPCTaskGroup final
{
public:
	bool                                          M_empty_npc_task_group;                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECANPCType, int32>                       M_npcs_to_assign_to_mission_wave_S;                // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ECANPCType, int32>                       M_npc_escalators;                                  // 0x0058(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FCAMotivationActivationPhaseData> M_motivation_activation_phases;                    // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UEnvQuery*                              M_npc_teleport_in_additional_spawn_location_query; // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAMotivationActivationPhaseMode              M_motivation_activation_phase_mode;                // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_repeat_motivation_activation_phase_sequence;     // 0x00C1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCTaskGroup) == 0x000008, "Wrong alignment on FCANPCTaskGroup");
static_assert(sizeof(FCANPCTaskGroup) == 0x0000C8, "Wrong size on FCANPCTaskGroup");
static_assert(offsetof(FCANPCTaskGroup, M_empty_npc_task_group) == 0x000000, "Member 'FCANPCTaskGroup::M_empty_npc_task_group' has a wrong offset!");
static_assert(offsetof(FCANPCTaskGroup, M_npcs_to_assign_to_mission_wave_S) == 0x000008, "Member 'FCANPCTaskGroup::M_npcs_to_assign_to_mission_wave_S' has a wrong offset!");
static_assert(offsetof(FCANPCTaskGroup, M_npc_escalators) == 0x000058, "Member 'FCANPCTaskGroup::M_npc_escalators' has a wrong offset!");
static_assert(offsetof(FCANPCTaskGroup, M_motivation_activation_phases) == 0x0000A8, "Member 'FCANPCTaskGroup::M_motivation_activation_phases' has a wrong offset!");
static_assert(offsetof(FCANPCTaskGroup, M_npc_teleport_in_additional_spawn_location_query) == 0x0000B8, "Member 'FCANPCTaskGroup::M_npc_teleport_in_additional_spawn_location_query' has a wrong offset!");
static_assert(offsetof(FCANPCTaskGroup, M_motivation_activation_phase_mode) == 0x0000C0, "Member 'FCANPCTaskGroup::M_motivation_activation_phase_mode' has a wrong offset!");
static_assert(offsetof(FCANPCTaskGroup, M_repeat_motivation_activation_phase_sequence) == 0x0000C1, "Member 'FCANPCTaskGroup::M_repeat_motivation_activation_phase_sequence' has a wrong offset!");

// ScriptStruct keaton.CAMissionWaveData
// 0x00D8 (0x00E0 - 0x0008)
struct FCAMissionWaveData final : public FTableRowBase
{
public:
	class FString                                 M_wave_name;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCANPCTaskGroup>                M_npc_task_groups;                                 // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UEnvQuery*                              M_npc_teleport_in_additional_spawn_location_query; // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_spawn_in_combat_state;                           // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECANPCSpawnCoherencyType                      M_intra_mission_spawn_coherency_type;              // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              M_npc_squad_spawn_location_query;                  // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECANPCSpawnInterCoherencyType                 M_subsequent_npc_of_squad_coherency_type;          // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              M_subsequent_npc_spawn_location_query;             // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_spawn_facing_mission_objective_outer;            // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_contest_mission_objective_outer;                 // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATriValue                                   M_should_release_npcs_from_previous_wave;          // 0x0052(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_restart_motivation_activation_phases_on_wave_repeat; // 0x0053(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_mission_wave_repeat_count;                       // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_time_between_mission_wave_repeats;               // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_time_between_this_wave_end_and_next_wave_start;  // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_mission_wave_npc_replace_limit;                  // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_time_between_npc_replacements;                   // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   M_mission_wave_end_triggers;                       // 0x0068(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	int32                                         M_mission_wave_duration;                           // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_wait_for_entire_mission_wave_duration;           // 0x007C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_can_stream_spawn_npcs;                           // 0x007D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x12];                                      // 0x007E(0x0012)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECANPCType, int32>                       M_mission_wave_replace_limit;                      // 0x0090(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMissionWaveData) == 0x000008, "Wrong alignment on FCAMissionWaveData");
static_assert(sizeof(FCAMissionWaveData) == 0x0000E0, "Wrong size on FCAMissionWaveData");
static_assert(offsetof(FCAMissionWaveData, M_wave_name) == 0x000008, "Member 'FCAMissionWaveData::M_wave_name' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_npc_task_groups) == 0x000018, "Member 'FCAMissionWaveData::M_npc_task_groups' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_npc_teleport_in_additional_spawn_location_query) == 0x000028, "Member 'FCAMissionWaveData::M_npc_teleport_in_additional_spawn_location_query' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_spawn_in_combat_state) == 0x000030, "Member 'FCAMissionWaveData::M_spawn_in_combat_state' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_intra_mission_spawn_coherency_type) == 0x000031, "Member 'FCAMissionWaveData::M_intra_mission_spawn_coherency_type' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_npc_squad_spawn_location_query) == 0x000038, "Member 'FCAMissionWaveData::M_npc_squad_spawn_location_query' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_subsequent_npc_of_squad_coherency_type) == 0x000040, "Member 'FCAMissionWaveData::M_subsequent_npc_of_squad_coherency_type' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_subsequent_npc_spawn_location_query) == 0x000048, "Member 'FCAMissionWaveData::M_subsequent_npc_spawn_location_query' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_spawn_facing_mission_objective_outer) == 0x000050, "Member 'FCAMissionWaveData::M_spawn_facing_mission_objective_outer' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_contest_mission_objective_outer) == 0x000051, "Member 'FCAMissionWaveData::M_contest_mission_objective_outer' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_should_release_npcs_from_previous_wave) == 0x000052, "Member 'FCAMissionWaveData::M_should_release_npcs_from_previous_wave' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_restart_motivation_activation_phases_on_wave_repeat) == 0x000053, "Member 'FCAMissionWaveData::M_restart_motivation_activation_phases_on_wave_repeat' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_mission_wave_repeat_count) == 0x000054, "Member 'FCAMissionWaveData::M_mission_wave_repeat_count' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_time_between_mission_wave_repeats) == 0x000058, "Member 'FCAMissionWaveData::M_time_between_mission_wave_repeats' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_time_between_this_wave_end_and_next_wave_start) == 0x00005C, "Member 'FCAMissionWaveData::M_time_between_this_wave_end_and_next_wave_start' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_mission_wave_npc_replace_limit) == 0x000060, "Member 'FCAMissionWaveData::M_mission_wave_npc_replace_limit' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_time_between_npc_replacements) == 0x000064, "Member 'FCAMissionWaveData::M_time_between_npc_replacements' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_mission_wave_end_triggers) == 0x000068, "Member 'FCAMissionWaveData::M_mission_wave_end_triggers' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_mission_wave_duration) == 0x000078, "Member 'FCAMissionWaveData::M_mission_wave_duration' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_wait_for_entire_mission_wave_duration) == 0x00007C, "Member 'FCAMissionWaveData::M_wait_for_entire_mission_wave_duration' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_can_stream_spawn_npcs) == 0x00007D, "Member 'FCAMissionWaveData::M_can_stream_spawn_npcs' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveData, M_mission_wave_replace_limit) == 0x000090, "Member 'FCAMissionWaveData::M_mission_wave_replace_limit' has a wrong offset!");

// ScriptStruct keaton.CAMissionWaveGroupTupleData
// 0x00F8 (0x00F8 - 0x0000)
struct FCAMissionWaveGroupTupleData final
{
public:
	float                                         M_mission_wave_probability;                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCANPCSquadDataEntry>           M_npc_squads;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCAMissionWaveData                     M_mission_wave;                                    // 0x0018(0x00E0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMissionWaveGroupTupleData) == 0x000008, "Wrong alignment on FCAMissionWaveGroupTupleData");
static_assert(sizeof(FCAMissionWaveGroupTupleData) == 0x0000F8, "Wrong size on FCAMissionWaveGroupTupleData");
static_assert(offsetof(FCAMissionWaveGroupTupleData, M_mission_wave_probability) == 0x000000, "Member 'FCAMissionWaveGroupTupleData::M_mission_wave_probability' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveGroupTupleData, M_npc_squads) == 0x000008, "Member 'FCAMissionWaveGroupTupleData::M_npc_squads' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveGroupTupleData, M_mission_wave) == 0x000018, "Member 'FCAMissionWaveGroupTupleData::M_mission_wave' has a wrong offset!");

// ScriptStruct keaton.CAAdrenalineJunkiePerkBalancingTableRow
// 0x0018 (0x0020 - 0x0008)
struct FCAAdrenalineJunkiePerkBalancingTableRow final : public FTableRowBase
{
public:
	float                                         M_value;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EMovementBuffModifierTypes>            buff_types;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAdrenalineJunkiePerkBalancingTableRow) == 0x000008, "Wrong alignment on FCAAdrenalineJunkiePerkBalancingTableRow");
static_assert(sizeof(FCAAdrenalineJunkiePerkBalancingTableRow) == 0x000020, "Wrong size on FCAAdrenalineJunkiePerkBalancingTableRow");
static_assert(offsetof(FCAAdrenalineJunkiePerkBalancingTableRow, M_value) == 0x000008, "Member 'FCAAdrenalineJunkiePerkBalancingTableRow::M_value' has a wrong offset!");
static_assert(offsetof(FCAAdrenalineJunkiePerkBalancingTableRow, buff_types) == 0x000010, "Member 'FCAAdrenalineJunkiePerkBalancingTableRow::buff_types' has a wrong offset!");

// ScriptStruct keaton.DialogueAnimParams
// 0x0008 (0x0008 - 0x0000)
struct FDialogueAnimParams final
{
public:
	float                                         M_duration;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_sfx;                                          // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDialogueAnimParams) == 0x000004, "Wrong alignment on FDialogueAnimParams");
static_assert(sizeof(FDialogueAnimParams) == 0x000008, "Wrong size on FDialogueAnimParams");
static_assert(offsetof(FDialogueAnimParams, M_duration) == 0x000000, "Member 'FDialogueAnimParams::M_duration' has a wrong offset!");
static_assert(offsetof(FDialogueAnimParams, M_is_sfx) == 0x000004, "Member 'FDialogueAnimParams::M_is_sfx' has a wrong offset!");

// ScriptStruct keaton.CADecoderBattleLoot
// 0x001C (0x001C - 0x0000)
struct FCADecoderBattleLoot final
{
public:
	struct FCAGameDatabaseRowHandle               M_handle;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         M_quantity;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADecoderBattleLoot) == 0x000004, "Wrong alignment on FCADecoderBattleLoot");
static_assert(sizeof(FCADecoderBattleLoot) == 0x00001C, "Wrong size on FCADecoderBattleLoot");
static_assert(offsetof(FCADecoderBattleLoot, M_handle) == 0x000000, "Member 'FCADecoderBattleLoot::M_handle' has a wrong offset!");
static_assert(offsetof(FCADecoderBattleLoot, M_quantity) == 0x000018, "Member 'FCADecoderBattleLoot::M_quantity' has a wrong offset!");

// ScriptStruct keaton.CAPlayerProfileTeamMateInfo
// 0x0020 (0x0020 - 0x0000)
struct FCAPlayerProfileTeamMateInfo final
{
public:
	class FString                                 M_teammate_name;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_teammate_specialist;                             // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPlayerProfileTeamMateInfo) == 0x000008, "Wrong alignment on FCAPlayerProfileTeamMateInfo");
static_assert(sizeof(FCAPlayerProfileTeamMateInfo) == 0x000020, "Wrong size on FCAPlayerProfileTeamMateInfo");
static_assert(offsetof(FCAPlayerProfileTeamMateInfo, M_teammate_name) == 0x000000, "Member 'FCAPlayerProfileTeamMateInfo::M_teammate_name' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileTeamMateInfo, M_teammate_specialist) == 0x000010, "Member 'FCAPlayerProfileTeamMateInfo::M_teammate_specialist' has a wrong offset!");

// ScriptStruct keaton.CAPlayerProfileMatchResult
// 0x0058 (0x0058 - 0x0000)
struct FCAPlayerProfileMatchResult final
{
public:
	class FString                                 M_battle_id;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_partial;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_team_rank;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_did_extract;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_loot_amount;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCADecoderBattleLoot>           M_loot;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   M_player_specialist;                               // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAPlayerProfileTeamMateInfo>   M_teammate_info;                                   // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDateTime                              M_date_time;                                       // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPlayerProfileMatchResult) == 0x000008, "Wrong alignment on FCAPlayerProfileMatchResult");
static_assert(sizeof(FCAPlayerProfileMatchResult) == 0x000058, "Wrong size on FCAPlayerProfileMatchResult");
static_assert(offsetof(FCAPlayerProfileMatchResult, M_battle_id) == 0x000000, "Member 'FCAPlayerProfileMatchResult::M_battle_id' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileMatchResult, M_is_partial) == 0x000010, "Member 'FCAPlayerProfileMatchResult::M_is_partial' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileMatchResult, M_team_rank) == 0x000014, "Member 'FCAPlayerProfileMatchResult::M_team_rank' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileMatchResult, M_did_extract) == 0x000018, "Member 'FCAPlayerProfileMatchResult::M_did_extract' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileMatchResult, M_loot_amount) == 0x00001C, "Member 'FCAPlayerProfileMatchResult::M_loot_amount' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileMatchResult, M_loot) == 0x000020, "Member 'FCAPlayerProfileMatchResult::M_loot' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileMatchResult, M_player_specialist) == 0x000030, "Member 'FCAPlayerProfileMatchResult::M_player_specialist' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileMatchResult, M_teammate_info) == 0x000040, "Member 'FCAPlayerProfileMatchResult::M_teammate_info' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileMatchResult, M_date_time) == 0x000050, "Member 'FCAPlayerProfileMatchResult::M_date_time' has a wrong offset!");

// ScriptStruct keaton.CAFlashLevelData
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x04) FCAFlashLevelData final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAFlashLevelData) == 0x000004, "Wrong alignment on FCAFlashLevelData");
static_assert(sizeof(FCAFlashLevelData) == 0x000028, "Wrong size on FCAFlashLevelData");

// ScriptStruct keaton.CAFlashbangApplicationData
// 0x002C (0x002C - 0x0000)
struct FCAFlashbangApplicationData final
{
public:
	float                                         M_flash_duration;                                  // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAFlashLevelData                      M_flash_level;                                     // 0x0004(0x0028)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFlashbangApplicationData) == 0x000004, "Wrong alignment on FCAFlashbangApplicationData");
static_assert(sizeof(FCAFlashbangApplicationData) == 0x00002C, "Wrong size on FCAFlashbangApplicationData");
static_assert(offsetof(FCAFlashbangApplicationData, M_flash_duration) == 0x000000, "Member 'FCAFlashbangApplicationData::M_flash_duration' has a wrong offset!");
static_assert(offsetof(FCAFlashbangApplicationData, M_flash_level) == 0x000004, "Member 'FCAFlashbangApplicationData::M_flash_level' has a wrong offset!");

// ScriptStruct keaton.CAFlashbangCalculationData
// 0x0040 (0x0040 - 0x0000)
struct FCAFlashbangCalculationData final
{
public:
	float                                         M_flash_remaining_time;                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_flashbang_origin;                                // 0x0004(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAFlashbangApplicationData            M_previous_application_data;                       // 0x0010(0x002C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_multiplier_zero_g;                               // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFlashbangCalculationData) == 0x000004, "Wrong alignment on FCAFlashbangCalculationData");
static_assert(sizeof(FCAFlashbangCalculationData) == 0x000040, "Wrong size on FCAFlashbangCalculationData");
static_assert(offsetof(FCAFlashbangCalculationData, M_flash_remaining_time) == 0x000000, "Member 'FCAFlashbangCalculationData::M_flash_remaining_time' has a wrong offset!");
static_assert(offsetof(FCAFlashbangCalculationData, M_flashbang_origin) == 0x000004, "Member 'FCAFlashbangCalculationData::M_flashbang_origin' has a wrong offset!");
static_assert(offsetof(FCAFlashbangCalculationData, M_previous_application_data) == 0x000010, "Member 'FCAFlashbangCalculationData::M_previous_application_data' has a wrong offset!");
static_assert(offsetof(FCAFlashbangCalculationData, M_multiplier_zero_g) == 0x00003C, "Member 'FCAFlashbangCalculationData::M_multiplier_zero_g' has a wrong offset!");

// ScriptStruct keaton.CADialogueAnimNotifyResponseData
// 0x0010 (0x0018 - 0x0008)
struct FCADialogueAnimNotifyResponseData final : public FTableRowBase
{
public:
	class FName                                   ResponseName;                                      // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADialogueAnimNotifyResponseData) == 0x000008, "Wrong alignment on FCADialogueAnimNotifyResponseData");
static_assert(sizeof(FCADialogueAnimNotifyResponseData) == 0x000018, "Wrong size on FCADialogueAnimNotifyResponseData");
static_assert(offsetof(FCADialogueAnimNotifyResponseData, ResponseName) == 0x000008, "Member 'FCADialogueAnimNotifyResponseData::ResponseName' has a wrong offset!");

// ScriptStruct keaton.CARadialStorageSlots
// 0x0020 (0x0020 - 0x0000)
struct FCARadialStorageSlots final
{
public:
	TArray<class FName>                           M_keys;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           M_values;                                          // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCARadialStorageSlots) == 0x000008, "Wrong alignment on FCARadialStorageSlots");
static_assert(sizeof(FCARadialStorageSlots) == 0x000020, "Wrong size on FCARadialStorageSlots");
static_assert(offsetof(FCARadialStorageSlots, M_keys) == 0x000000, "Member 'FCARadialStorageSlots::M_keys' has a wrong offset!");
static_assert(offsetof(FCARadialStorageSlots, M_values) == 0x000010, "Member 'FCARadialStorageSlots::M_values' has a wrong offset!");

// ScriptStruct keaton.CARadialStorage
// 0x0018 (0x0018 - 0x0000)
struct FCARadialStorage final
{
public:
	TArray<struct FCARadialStorageSlots>          M_slots;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCARadialStorage) == 0x000008, "Wrong alignment on FCARadialStorage");
static_assert(sizeof(FCARadialStorage) == 0x000018, "Wrong size on FCARadialStorage");
static_assert(offsetof(FCARadialStorage, M_slots) == 0x000000, "Member 'FCARadialStorage::M_slots' has a wrong offset!");

// ScriptStruct keaton.CAResultModifierTableRow
// 0x0018 (0x0020 - 0x0008)
struct FCAResultModifierTableRow final : public FTableRowBase
{
public:
	TArray<int32>                                 M_rank_bonuses;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_xp_base_reward;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_xp_reward_multiplier;                            // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAResultModifierTableRow) == 0x000008, "Wrong alignment on FCAResultModifierTableRow");
static_assert(sizeof(FCAResultModifierTableRow) == 0x000020, "Wrong size on FCAResultModifierTableRow");
static_assert(offsetof(FCAResultModifierTableRow, M_rank_bonuses) == 0x000008, "Member 'FCAResultModifierTableRow::M_rank_bonuses' has a wrong offset!");
static_assert(offsetof(FCAResultModifierTableRow, M_xp_base_reward) == 0x000018, "Member 'FCAResultModifierTableRow::M_xp_base_reward' has a wrong offset!");
static_assert(offsetof(FCAResultModifierTableRow, M_xp_reward_multiplier) == 0x00001C, "Member 'FCAResultModifierTableRow::M_xp_reward_multiplier' has a wrong offset!");

// ScriptStruct keaton.CAServicesPlayerCurrency
// 0x0048 (0x0048 - 0x0000)
struct FCAServicesPlayerCurrency final
{
public:
	struct FCAGameDatabaseRowHandle               M_handle;                                          // 0x0000(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int64                                         M_quantity;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         M_services_item_id;                                // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_services_key;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_services_name;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAServicesPlayerCurrency) == 0x000008, "Wrong alignment on FCAServicesPlayerCurrency");
static_assert(sizeof(FCAServicesPlayerCurrency) == 0x000048, "Wrong size on FCAServicesPlayerCurrency");
static_assert(offsetof(FCAServicesPlayerCurrency, M_handle) == 0x000000, "Member 'FCAServicesPlayerCurrency::M_handle' has a wrong offset!");
static_assert(offsetof(FCAServicesPlayerCurrency, M_quantity) == 0x000018, "Member 'FCAServicesPlayerCurrency::M_quantity' has a wrong offset!");
static_assert(offsetof(FCAServicesPlayerCurrency, M_services_item_id) == 0x000020, "Member 'FCAServicesPlayerCurrency::M_services_item_id' has a wrong offset!");
static_assert(offsetof(FCAServicesPlayerCurrency, M_services_key) == 0x000028, "Member 'FCAServicesPlayerCurrency::M_services_key' has a wrong offset!");
static_assert(offsetof(FCAServicesPlayerCurrency, M_services_name) == 0x000038, "Member 'FCAServicesPlayerCurrency::M_services_name' has a wrong offset!");

// ScriptStruct keaton.CAAnimInstance_Component_Locomotion
// 0x0060 (0x0070 - 0x0010)
struct FCAAnimInstance_Component_Locomotion final : public FCAAnimInstance_Component
{
public:
	uint8                                         Pad_10[0x14];                                      // 0x0010(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_previous_velocity;                               // 0x0024(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_previous_acceleration;                           // 0x0030(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_previous_angular_velocity;                       // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_previous_strafing_angle;                         // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_strafing_angle;                                  // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_angular_velocity;                                // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_last_velocity_in_previous_state;                 // 0x004C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_speed_ratio;                                 // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_locomotion_speed;                                // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_locomotion_yaw;                                  // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_moving;                                       // 0x0064(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_was_moving;                                      // 0x0065(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_sprinting;                                    // 0x0066(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_walk_jog_run;                                 // 0x0067(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_sliding;                                      // 0x0068(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_traversing;                                   // 0x0069(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAnimInstance_Component_Locomotion) == 0x000008, "Wrong alignment on FCAAnimInstance_Component_Locomotion");
static_assert(sizeof(FCAAnimInstance_Component_Locomotion) == 0x000070, "Wrong size on FCAAnimInstance_Component_Locomotion");
static_assert(offsetof(FCAAnimInstance_Component_Locomotion, M_previous_velocity) == 0x000024, "Member 'FCAAnimInstance_Component_Locomotion::M_previous_velocity' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Locomotion, M_previous_acceleration) == 0x000030, "Member 'FCAAnimInstance_Component_Locomotion::M_previous_acceleration' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Locomotion, M_previous_angular_velocity) == 0x00003C, "Member 'FCAAnimInstance_Component_Locomotion::M_previous_angular_velocity' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Locomotion, M_previous_strafing_angle) == 0x000040, "Member 'FCAAnimInstance_Component_Locomotion::M_previous_strafing_angle' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Locomotion, M_strafing_angle) == 0x000044, "Member 'FCAAnimInstance_Component_Locomotion::M_strafing_angle' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Locomotion, M_angular_velocity) == 0x000048, "Member 'FCAAnimInstance_Component_Locomotion::M_angular_velocity' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Locomotion, M_last_velocity_in_previous_state) == 0x00004C, "Member 'FCAAnimInstance_Component_Locomotion::M_last_velocity_in_previous_state' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Locomotion, M_max_speed_ratio) == 0x000058, "Member 'FCAAnimInstance_Component_Locomotion::M_max_speed_ratio' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Locomotion, M_locomotion_speed) == 0x00005C, "Member 'FCAAnimInstance_Component_Locomotion::M_locomotion_speed' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Locomotion, M_locomotion_yaw) == 0x000060, "Member 'FCAAnimInstance_Component_Locomotion::M_locomotion_yaw' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Locomotion, M_is_moving) == 0x000064, "Member 'FCAAnimInstance_Component_Locomotion::M_is_moving' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Locomotion, M_was_moving) == 0x000065, "Member 'FCAAnimInstance_Component_Locomotion::M_was_moving' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Locomotion, M_is_sprinting) == 0x000066, "Member 'FCAAnimInstance_Component_Locomotion::M_is_sprinting' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Locomotion, M_is_walk_jog_run) == 0x000067, "Member 'FCAAnimInstance_Component_Locomotion::M_is_walk_jog_run' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Locomotion, M_is_sliding) == 0x000068, "Member 'FCAAnimInstance_Component_Locomotion::M_is_sliding' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Locomotion, M_is_traversing) == 0x000069, "Member 'FCAAnimInstance_Component_Locomotion::M_is_traversing' has a wrong offset!");

// ScriptStruct keaton.PlayerScore
// 0x0090 (0x0090 - 0x0000)
struct FPlayerScore final
{
public:
	int32                                         M_score;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_health;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_downed_health;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_dynamic_max_health;                              // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_health_segment_cap;                              // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_num_health_segments;                             // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_armour_name;                                     // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_armour;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_armour;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_armour_pieces;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_max_armour_pieces;                               // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_armour_segment_cap;                              // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_num_armour_segments;                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_accumulated_loot_from_players;                   // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_accumulated_loot_from_environment;               // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_can_respawn;                                     // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_spectating;                                   // 0x0045(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_respawn_timestamp;                               // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_ability_availability;                            // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_ability_name;                                    // 0x0050(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerMatchState                             M_match_state;                                     // 0x005C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAThresholdState                             M_threshold_state;                                 // 0x005D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_last_reviver_name;                               // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_death_timestamp;                                 // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_death_counter;                                   // 0x0074(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x1B];                                      // 0x0075(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerScore) == 0x000008, "Wrong alignment on FPlayerScore");
static_assert(sizeof(FPlayerScore) == 0x000090, "Wrong size on FPlayerScore");
static_assert(offsetof(FPlayerScore, M_score) == 0x000000, "Member 'FPlayerScore::M_score' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_health) == 0x000004, "Member 'FPlayerScore::M_health' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_downed_health) == 0x000008, "Member 'FPlayerScore::M_downed_health' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_dynamic_max_health) == 0x00000C, "Member 'FPlayerScore::M_dynamic_max_health' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_health_segment_cap) == 0x000010, "Member 'FPlayerScore::M_health_segment_cap' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_num_health_segments) == 0x000014, "Member 'FPlayerScore::M_num_health_segments' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_armour_name) == 0x000018, "Member 'FPlayerScore::M_armour_name' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_armour) == 0x000024, "Member 'FPlayerScore::M_armour' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_max_armour) == 0x000028, "Member 'FPlayerScore::M_max_armour' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_armour_pieces) == 0x00002C, "Member 'FPlayerScore::M_armour_pieces' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_max_armour_pieces) == 0x000030, "Member 'FPlayerScore::M_max_armour_pieces' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_armour_segment_cap) == 0x000034, "Member 'FPlayerScore::M_armour_segment_cap' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_num_armour_segments) == 0x000038, "Member 'FPlayerScore::M_num_armour_segments' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_accumulated_loot_from_players) == 0x00003C, "Member 'FPlayerScore::M_accumulated_loot_from_players' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_accumulated_loot_from_environment) == 0x000040, "Member 'FPlayerScore::M_accumulated_loot_from_environment' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_can_respawn) == 0x000044, "Member 'FPlayerScore::M_can_respawn' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_is_spectating) == 0x000045, "Member 'FPlayerScore::M_is_spectating' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_respawn_timestamp) == 0x000048, "Member 'FPlayerScore::M_respawn_timestamp' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_ability_availability) == 0x00004C, "Member 'FPlayerScore::M_ability_availability' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_ability_name) == 0x000050, "Member 'FPlayerScore::M_ability_name' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_match_state) == 0x00005C, "Member 'FPlayerScore::M_match_state' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_threshold_state) == 0x00005D, "Member 'FPlayerScore::M_threshold_state' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_last_reviver_name) == 0x000060, "Member 'FPlayerScore::M_last_reviver_name' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_death_timestamp) == 0x000070, "Member 'FPlayerScore::M_death_timestamp' has a wrong offset!");
static_assert(offsetof(FPlayerScore, M_death_counter) == 0x000074, "Member 'FPlayerScore::M_death_counter' has a wrong offset!");

// ScriptStruct keaton.CAMovementErrorCorrectionModifier
// 0x0003 (0x0003 - 0x0000)
struct FCAMovementErrorCorrectionModifier final
{
public:
	bool                                          Is_enabled;                                        // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Should_ignore_movement_error_correction;           // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAMovementErrorCorrectionRequestType         Key_type;                                          // 0x0002(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMovementErrorCorrectionModifier) == 0x000001, "Wrong alignment on FCAMovementErrorCorrectionModifier");
static_assert(sizeof(FCAMovementErrorCorrectionModifier) == 0x000003, "Wrong size on FCAMovementErrorCorrectionModifier");
static_assert(offsetof(FCAMovementErrorCorrectionModifier, Is_enabled) == 0x000000, "Member 'FCAMovementErrorCorrectionModifier::Is_enabled' has a wrong offset!");
static_assert(offsetof(FCAMovementErrorCorrectionModifier, Should_ignore_movement_error_correction) == 0x000001, "Member 'FCAMovementErrorCorrectionModifier::Should_ignore_movement_error_correction' has a wrong offset!");
static_assert(offsetof(FCAMovementErrorCorrectionModifier, Key_type) == 0x000002, "Member 'FCAMovementErrorCorrectionModifier::Key_type' has a wrong offset!");

// ScriptStruct keaton.WeaponMuzzleAmmoData
// 0x000C (0x000C - 0x0000)
struct FWeaponMuzzleAmmoData final
{
public:
	int16                                         M_index;                                           // 0x0000(0x0002)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         M_ammo_count;                                      // 0x0002(0x0002)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        M_fire_count;                                      // 0x0004(0x0002)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        M_reload_count;                                    // 0x0006(0x0002)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_reload_ability_fails_due_to_full_clip;           // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponMuzzleAmmoData) == 0x000004, "Wrong alignment on FWeaponMuzzleAmmoData");
static_assert(sizeof(FWeaponMuzzleAmmoData) == 0x00000C, "Wrong size on FWeaponMuzzleAmmoData");
static_assert(offsetof(FWeaponMuzzleAmmoData, M_index) == 0x000000, "Member 'FWeaponMuzzleAmmoData::M_index' has a wrong offset!");
static_assert(offsetof(FWeaponMuzzleAmmoData, M_ammo_count) == 0x000002, "Member 'FWeaponMuzzleAmmoData::M_ammo_count' has a wrong offset!");
static_assert(offsetof(FWeaponMuzzleAmmoData, M_fire_count) == 0x000004, "Member 'FWeaponMuzzleAmmoData::M_fire_count' has a wrong offset!");
static_assert(offsetof(FWeaponMuzzleAmmoData, M_reload_count) == 0x000006, "Member 'FWeaponMuzzleAmmoData::M_reload_count' has a wrong offset!");
static_assert(offsetof(FWeaponMuzzleAmmoData, M_reload_ability_fails_due_to_full_clip) == 0x000008, "Member 'FWeaponMuzzleAmmoData::M_reload_ability_fails_due_to_full_clip' has a wrong offset!");

// ScriptStruct keaton.CAPrimaryMessagingData
// 0x00E0 (0x00E0 - 0x0000)
struct FCAPrimaryMessagingData final
{
public:
	class FName                                   M_type;                                            // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         M_enum_value;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_int_value;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_world_time;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_priority;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_immediate_messages_group_id;                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_string_value;                                    // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_name;                                            // 0x0038(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_text;                                            // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   M_subheader_text;                                  // 0x0060(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    M_row_handle;                                      // 0x0078(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UObject*                                M_object;                                          // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                M_other_object;                                    // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAInventoryItem*                       M_inventory_item;                                  // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_texture;                                         // 0x00A8(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 M_color;                                           // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPrimaryMessagingData) == 0x000008, "Wrong alignment on FCAPrimaryMessagingData");
static_assert(sizeof(FCAPrimaryMessagingData) == 0x0000E0, "Wrong size on FCAPrimaryMessagingData");
static_assert(offsetof(FCAPrimaryMessagingData, M_type) == 0x000000, "Member 'FCAPrimaryMessagingData::M_type' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessagingData, M_enum_value) == 0x000010, "Member 'FCAPrimaryMessagingData::M_enum_value' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessagingData, M_int_value) == 0x000014, "Member 'FCAPrimaryMessagingData::M_int_value' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessagingData, M_world_time) == 0x000018, "Member 'FCAPrimaryMessagingData::M_world_time' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessagingData, M_priority) == 0x00001C, "Member 'FCAPrimaryMessagingData::M_priority' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessagingData, M_immediate_messages_group_id) == 0x000020, "Member 'FCAPrimaryMessagingData::M_immediate_messages_group_id' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessagingData, M_string_value) == 0x000028, "Member 'FCAPrimaryMessagingData::M_string_value' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessagingData, M_name) == 0x000038, "Member 'FCAPrimaryMessagingData::M_name' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessagingData, M_text) == 0x000048, "Member 'FCAPrimaryMessagingData::M_text' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessagingData, M_subheader_text) == 0x000060, "Member 'FCAPrimaryMessagingData::M_subheader_text' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessagingData, M_row_handle) == 0x000078, "Member 'FCAPrimaryMessagingData::M_row_handle' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessagingData, M_object) == 0x000090, "Member 'FCAPrimaryMessagingData::M_object' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessagingData, M_other_object) == 0x000098, "Member 'FCAPrimaryMessagingData::M_other_object' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessagingData, M_inventory_item) == 0x0000A0, "Member 'FCAPrimaryMessagingData::M_inventory_item' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessagingData, M_texture) == 0x0000A8, "Member 'FCAPrimaryMessagingData::M_texture' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessagingData, M_color) == 0x0000D8, "Member 'FCAPrimaryMessagingData::M_color' has a wrong offset!");

// ScriptStruct keaton.RuleCampTypeCount
// 0x0010 (0x0010 - 0x0000)
struct FRuleCampTypeCount final
{
public:
	struct FGameplayTag                           M_camp_type;                                       // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_min_active_camps_in_group;                       // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_max_active_camps_in_group;                       // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRuleCampTypeCount) == 0x000004, "Wrong alignment on FRuleCampTypeCount");
static_assert(sizeof(FRuleCampTypeCount) == 0x000010, "Wrong size on FRuleCampTypeCount");
static_assert(offsetof(FRuleCampTypeCount, M_camp_type) == 0x000000, "Member 'FRuleCampTypeCount::M_camp_type' has a wrong offset!");
static_assert(offsetof(FRuleCampTypeCount, M_min_active_camps_in_group) == 0x00000C, "Member 'FRuleCampTypeCount::M_min_active_camps_in_group' has a wrong offset!");
static_assert(offsetof(FRuleCampTypeCount, M_max_active_camps_in_group) == 0x00000D, "Member 'FRuleCampTypeCount::M_max_active_camps_in_group' has a wrong offset!");

// ScriptStruct keaton.CAKDAStats
// 0x0018 (0x0018 - 0x0000)
struct FCAKDAStats final
{
public:
	class FName                                   M_user_id;                                         // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_kills;                                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_deaths;                                          // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_assists;                                         // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAKDAStats) == 0x000004, "Wrong alignment on FCAKDAStats");
static_assert(sizeof(FCAKDAStats) == 0x000018, "Wrong size on FCAKDAStats");
static_assert(offsetof(FCAKDAStats, M_user_id) == 0x000000, "Member 'FCAKDAStats::M_user_id' has a wrong offset!");
static_assert(offsetof(FCAKDAStats, M_kills) == 0x00000C, "Member 'FCAKDAStats::M_kills' has a wrong offset!");
static_assert(offsetof(FCAKDAStats, M_deaths) == 0x000010, "Member 'FCAKDAStats::M_deaths' has a wrong offset!");
static_assert(offsetof(FCAKDAStats, M_assists) == 0x000014, "Member 'FCAKDAStats::M_assists' has a wrong offset!");

// ScriptStruct keaton.CADebugMenuDelegatesCommon
// 0x0001 (0x0001 - 0x0000)
struct FCADebugMenuDelegatesCommon final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADebugMenuDelegatesCommon) == 0x000001, "Wrong alignment on FCADebugMenuDelegatesCommon");
static_assert(sizeof(FCADebugMenuDelegatesCommon) == 0x000001, "Wrong size on FCADebugMenuDelegatesCommon");

// ScriptStruct keaton.CAEquipageResponseData
// 0x0028 (0x0028 - 0x0000)
struct FCAEquipageResponseData final
{
public:
	class FName                                   M_name;                                            // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAEquippedStatus                             M_equipped_status;                                 // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              M_timestamp;                                       // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_services_id;                                     // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAEquipageResponseData) == 0x000008, "Wrong alignment on FCAEquipageResponseData");
static_assert(sizeof(FCAEquipageResponseData) == 0x000028, "Wrong size on FCAEquipageResponseData");
static_assert(offsetof(FCAEquipageResponseData, M_name) == 0x000000, "Member 'FCAEquipageResponseData::M_name' has a wrong offset!");
static_assert(offsetof(FCAEquipageResponseData, M_equipped_status) == 0x00000C, "Member 'FCAEquipageResponseData::M_equipped_status' has a wrong offset!");
static_assert(offsetof(FCAEquipageResponseData, M_timestamp) == 0x000010, "Member 'FCAEquipageResponseData::M_timestamp' has a wrong offset!");
static_assert(offsetof(FCAEquipageResponseData, M_services_id) == 0x000018, "Member 'FCAEquipageResponseData::M_services_id' has a wrong offset!");

// ScriptStruct keaton.CASetFloatDelegate
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FCASetFloatDelegate final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(float Value)>                  M_delegate_dynamic;                                // 0x0010(0x0014)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCASetFloatDelegate) == 0x000008, "Wrong alignment on FCASetFloatDelegate");
static_assert(sizeof(FCASetFloatDelegate) == 0x000028, "Wrong size on FCASetFloatDelegate");
static_assert(offsetof(FCASetFloatDelegate, M_delegate_dynamic) == 0x000010, "Member 'FCASetFloatDelegate::M_delegate_dynamic' has a wrong offset!");

// ScriptStruct keaton.CAMapEntityPayload
// 0x0070 (0x0070 - 0x0000)
struct FCAMapEntityPayload final
{
public:
	struct FVector_NetQuantize                    M_location;                                        // 0x0000(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              M_impact_normal;                                   // 0x000C(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          M_rotation_yaw;                                    // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_actor;                                           // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_enum_value;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bool_value;                                      // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_other_bool_value;                                // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x1];                                       // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_int_value;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_other_int_value;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_float_value;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_other_float_value;                               // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_ca_text_value;                                   // 0x0040(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMapEntityPayload) == 0x000008, "Wrong alignment on FCAMapEntityPayload");
static_assert(sizeof(FCAMapEntityPayload) == 0x000070, "Wrong size on FCAMapEntityPayload");
static_assert(offsetof(FCAMapEntityPayload, M_location) == 0x000000, "Member 'FCAMapEntityPayload::M_location' has a wrong offset!");
static_assert(offsetof(FCAMapEntityPayload, M_impact_normal) == 0x00000C, "Member 'FCAMapEntityPayload::M_impact_normal' has a wrong offset!");
static_assert(offsetof(FCAMapEntityPayload, M_rotation_yaw) == 0x000018, "Member 'FCAMapEntityPayload::M_rotation_yaw' has a wrong offset!");
static_assert(offsetof(FCAMapEntityPayload, M_actor) == 0x000020, "Member 'FCAMapEntityPayload::M_actor' has a wrong offset!");
static_assert(offsetof(FCAMapEntityPayload, M_enum_value) == 0x000028, "Member 'FCAMapEntityPayload::M_enum_value' has a wrong offset!");
static_assert(offsetof(FCAMapEntityPayload, M_bool_value) == 0x000029, "Member 'FCAMapEntityPayload::M_bool_value' has a wrong offset!");
static_assert(offsetof(FCAMapEntityPayload, M_other_bool_value) == 0x00002A, "Member 'FCAMapEntityPayload::M_other_bool_value' has a wrong offset!");
static_assert(offsetof(FCAMapEntityPayload, M_int_value) == 0x00002C, "Member 'FCAMapEntityPayload::M_int_value' has a wrong offset!");
static_assert(offsetof(FCAMapEntityPayload, M_other_int_value) == 0x000030, "Member 'FCAMapEntityPayload::M_other_int_value' has a wrong offset!");
static_assert(offsetof(FCAMapEntityPayload, M_float_value) == 0x000034, "Member 'FCAMapEntityPayload::M_float_value' has a wrong offset!");
static_assert(offsetof(FCAMapEntityPayload, M_other_float_value) == 0x000038, "Member 'FCAMapEntityPayload::M_other_float_value' has a wrong offset!");
static_assert(offsetof(FCAMapEntityPayload, M_ca_text_value) == 0x000040, "Member 'FCAMapEntityPayload::M_ca_text_value' has a wrong offset!");

// ScriptStruct keaton.CAMapEntityData
// 0x00B4 (0x00C0 - 0x000C)
struct FCAMapEntityData final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                M_owning_object;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_entity_name;                                     // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_unique_id;                                       // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAUIHUDEntityId                              M_entity_type;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_volatile;                                     // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCATeamID>                      M_teams_to_notify;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_players_to_notify;                               // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
	struct FCAMapEntityPayload                    M_payload;                                         // 0x0050(0x0070)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMapEntityData) == 0x000008, "Wrong alignment on FCAMapEntityData");
static_assert(sizeof(FCAMapEntityData) == 0x0000C0, "Wrong size on FCAMapEntityData");
static_assert(offsetof(FCAMapEntityData, M_owning_object) == 0x000010, "Member 'FCAMapEntityData::M_owning_object' has a wrong offset!");
static_assert(offsetof(FCAMapEntityData, M_entity_name) == 0x000018, "Member 'FCAMapEntityData::M_entity_name' has a wrong offset!");
static_assert(offsetof(FCAMapEntityData, M_unique_id) == 0x000024, "Member 'FCAMapEntityData::M_unique_id' has a wrong offset!");
static_assert(offsetof(FCAMapEntityData, M_entity_type) == 0x000028, "Member 'FCAMapEntityData::M_entity_type' has a wrong offset!");
static_assert(offsetof(FCAMapEntityData, M_is_volatile) == 0x000029, "Member 'FCAMapEntityData::M_is_volatile' has a wrong offset!");
static_assert(offsetof(FCAMapEntityData, M_teams_to_notify) == 0x000030, "Member 'FCAMapEntityData::M_teams_to_notify' has a wrong offset!");
static_assert(offsetof(FCAMapEntityData, M_players_to_notify) == 0x000040, "Member 'FCAMapEntityData::M_players_to_notify' has a wrong offset!");
static_assert(offsetof(FCAMapEntityData, M_payload) == 0x000050, "Member 'FCAMapEntityData::M_payload' has a wrong offset!");

// ScriptStruct keaton.CAMapEntitiesDataContainer
// 0x0010 (0x0118 - 0x0108)
struct FCAMapEntitiesDataContainer final : public FFastArraySerializer
{
public:
	TArray<struct FCAMapEntityData>               Items;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMapEntitiesDataContainer) == 0x000008, "Wrong alignment on FCAMapEntitiesDataContainer");
static_assert(sizeof(FCAMapEntitiesDataContainer) == 0x000118, "Wrong size on FCAMapEntitiesDataContainer");
static_assert(offsetof(FCAMapEntitiesDataContainer, Items) == 0x000108, "Member 'FCAMapEntitiesDataContainer::Items' has a wrong offset!");

// ScriptStruct keaton.ProjectileLaunchInputParams
// 0x0060 (0x0060 - 0x0000)
struct FProjectileLaunchInputParams final
{
public:
	float                                         M_launch_speed_override;                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_pitch_offset_for_players;                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACAProjectileBase>          M_projectile;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECCALaunchType                                M_launch_type;                                     // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0xF];                                       // 0x0011(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_fake_socket_transform;                           // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_allow_npc_accuracy_deviation;                    // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_optional_target_actor;                           // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileLaunchInputParams) == 0x000010, "Wrong alignment on FProjectileLaunchInputParams");
static_assert(sizeof(FProjectileLaunchInputParams) == 0x000060, "Wrong size on FProjectileLaunchInputParams");
static_assert(offsetof(FProjectileLaunchInputParams, M_launch_speed_override) == 0x000000, "Member 'FProjectileLaunchInputParams::M_launch_speed_override' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchInputParams, M_pitch_offset_for_players) == 0x000004, "Member 'FProjectileLaunchInputParams::M_pitch_offset_for_players' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchInputParams, M_projectile) == 0x000008, "Member 'FProjectileLaunchInputParams::M_projectile' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchInputParams, M_launch_type) == 0x000010, "Member 'FProjectileLaunchInputParams::M_launch_type' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchInputParams, M_fake_socket_transform) == 0x000020, "Member 'FProjectileLaunchInputParams::M_fake_socket_transform' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchInputParams, M_allow_npc_accuracy_deviation) == 0x000050, "Member 'FProjectileLaunchInputParams::M_allow_npc_accuracy_deviation' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchInputParams, M_optional_target_actor) == 0x000058, "Member 'FProjectileLaunchInputParams::M_optional_target_actor' has a wrong offset!");

// ScriptStruct keaton.CAGameplayEffectApplicator
// 0x0010 (0x0010 - 0x0000)
struct FCAGameplayEffectApplicator final
{
public:
	TArray<struct FCAEffectUser>                  M_EffectUsers;                                     // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCAGameplayEffectApplicator) == 0x000008, "Wrong alignment on FCAGameplayEffectApplicator");
static_assert(sizeof(FCAGameplayEffectApplicator) == 0x000010, "Wrong size on FCAGameplayEffectApplicator");
static_assert(offsetof(FCAGameplayEffectApplicator, M_EffectUsers) == 0x000000, "Member 'FCAGameplayEffectApplicator::M_EffectUsers' has a wrong offset!");

// ScriptStruct keaton.CAActivityRewardData
// 0x0048 (0x0048 - 0x0000)
struct FCAActivityRewardData final
{
public:
	class ACAActivityRewardBase*                  M_reward;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACAActivityRewardBase>      M_template;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAText                                M_reward_localized_name;                           // 0x0010(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             M_reward_icon;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAActivityRewardData) == 0x000008, "Wrong alignment on FCAActivityRewardData");
static_assert(sizeof(FCAActivityRewardData) == 0x000048, "Wrong size on FCAActivityRewardData");
static_assert(offsetof(FCAActivityRewardData, M_reward) == 0x000000, "Member 'FCAActivityRewardData::M_reward' has a wrong offset!");
static_assert(offsetof(FCAActivityRewardData, M_template) == 0x000008, "Member 'FCAActivityRewardData::M_template' has a wrong offset!");
static_assert(offsetof(FCAActivityRewardData, M_reward_localized_name) == 0x000010, "Member 'FCAActivityRewardData::M_reward_localized_name' has a wrong offset!");
static_assert(offsetof(FCAActivityRewardData, M_reward_icon) == 0x000040, "Member 'FCAActivityRewardData::M_reward_icon' has a wrong offset!");

// ScriptStruct keaton.CAWeaponPayloadAOE
// 0x0020 (0x0020 - 0x0000)
struct FCAWeaponPayloadAOE final
{
public:
	float                                         M_radius;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            M_gameplay_effect;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAWeaponPayloadAOE) == 0x000008, "Wrong alignment on FCAWeaponPayloadAOE");
static_assert(sizeof(FCAWeaponPayloadAOE) == 0x000020, "Wrong size on FCAWeaponPayloadAOE");
static_assert(offsetof(FCAWeaponPayloadAOE, M_radius) == 0x000000, "Member 'FCAWeaponPayloadAOE::M_radius' has a wrong offset!");
static_assert(offsetof(FCAWeaponPayloadAOE, M_gameplay_effect) == 0x000008, "Member 'FCAWeaponPayloadAOE::M_gameplay_effect' has a wrong offset!");

// ScriptStruct keaton.CAWeaponPayloadCameraShake
// 0x0018 (0x0018 - 0x0000)
struct FCAWeaponPayloadCameraShake final
{
public:
	float                                         M_radius;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_inner_radius;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_outer_radius;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_falloff;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        M_camera_shake;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAWeaponPayloadCameraShake) == 0x000008, "Wrong alignment on FCAWeaponPayloadCameraShake");
static_assert(sizeof(FCAWeaponPayloadCameraShake) == 0x000018, "Wrong size on FCAWeaponPayloadCameraShake");
static_assert(offsetof(FCAWeaponPayloadCameraShake, M_radius) == 0x000000, "Member 'FCAWeaponPayloadCameraShake::M_radius' has a wrong offset!");
static_assert(offsetof(FCAWeaponPayloadCameraShake, M_inner_radius) == 0x000004, "Member 'FCAWeaponPayloadCameraShake::M_inner_radius' has a wrong offset!");
static_assert(offsetof(FCAWeaponPayloadCameraShake, M_outer_radius) == 0x000008, "Member 'FCAWeaponPayloadCameraShake::M_outer_radius' has a wrong offset!");
static_assert(offsetof(FCAWeaponPayloadCameraShake, M_falloff) == 0x00000C, "Member 'FCAWeaponPayloadCameraShake::M_falloff' has a wrong offset!");
static_assert(offsetof(FCAWeaponPayloadCameraShake, M_camera_shake) == 0x000010, "Member 'FCAWeaponPayloadCameraShake::M_camera_shake' has a wrong offset!");

// ScriptStruct keaton.CAWeaponPayloadKnockback
// 0x0014 (0x0014 - 0x0000)
struct FCAWeaponPayloadKnockback final
{
public:
	float                                         M_magnitude;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_duration;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_blocked_by_tag;                                  // 0x0008(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAWeaponPayloadKnockback) == 0x000004, "Wrong alignment on FCAWeaponPayloadKnockback");
static_assert(sizeof(FCAWeaponPayloadKnockback) == 0x000014, "Wrong size on FCAWeaponPayloadKnockback");
static_assert(offsetof(FCAWeaponPayloadKnockback, M_magnitude) == 0x000000, "Member 'FCAWeaponPayloadKnockback::M_magnitude' has a wrong offset!");
static_assert(offsetof(FCAWeaponPayloadKnockback, M_duration) == 0x000004, "Member 'FCAWeaponPayloadKnockback::M_duration' has a wrong offset!");
static_assert(offsetof(FCAWeaponPayloadKnockback, M_blocked_by_tag) == 0x000008, "Member 'FCAWeaponPayloadKnockback::M_blocked_by_tag' has a wrong offset!");

// ScriptStruct keaton.CAWeaponPayload
// 0x0078 (0x0078 - 0x0000)
struct FCAWeaponPayload final
{
public:
	TArray<TSubclassOf<class AActor>>             M_actors_to_spawn;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    M_gameplay_effects_to_apply;                       // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          M_payload_gameplay_effects_deal_weapon_modified_damage; // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x17];                                      // 0x0021(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_aoe_gameplay_effects_deal_weapon_modified_damage; // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAWeaponPayloadAOE>            M_AOEs_to_apply;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAWeaponPayloadCameraShake>    M_camera_shakes_to_apply;                          // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAWeaponPayloadKnockback              M_knockback_to_apply;                              // 0x0060(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAWeaponPayload) == 0x000008, "Wrong alignment on FCAWeaponPayload");
static_assert(sizeof(FCAWeaponPayload) == 0x000078, "Wrong size on FCAWeaponPayload");
static_assert(offsetof(FCAWeaponPayload, M_actors_to_spawn) == 0x000000, "Member 'FCAWeaponPayload::M_actors_to_spawn' has a wrong offset!");
static_assert(offsetof(FCAWeaponPayload, M_gameplay_effects_to_apply) == 0x000010, "Member 'FCAWeaponPayload::M_gameplay_effects_to_apply' has a wrong offset!");
static_assert(offsetof(FCAWeaponPayload, M_payload_gameplay_effects_deal_weapon_modified_damage) == 0x000020, "Member 'FCAWeaponPayload::M_payload_gameplay_effects_deal_weapon_modified_damage' has a wrong offset!");
static_assert(offsetof(FCAWeaponPayload, M_aoe_gameplay_effects_deal_weapon_modified_damage) == 0x000038, "Member 'FCAWeaponPayload::M_aoe_gameplay_effects_deal_weapon_modified_damage' has a wrong offset!");
static_assert(offsetof(FCAWeaponPayload, M_AOEs_to_apply) == 0x000040, "Member 'FCAWeaponPayload::M_AOEs_to_apply' has a wrong offset!");
static_assert(offsetof(FCAWeaponPayload, M_camera_shakes_to_apply) == 0x000050, "Member 'FCAWeaponPayload::M_camera_shakes_to_apply' has a wrong offset!");
static_assert(offsetof(FCAWeaponPayload, M_knockback_to_apply) == 0x000060, "Member 'FCAWeaponPayload::M_knockback_to_apply' has a wrong offset!");

// ScriptStruct keaton.CAStoredProjectileData
// 0x0038 (0x0038 - 0x0000)
struct FCAStoredProjectileData final
{
public:
	TArray<struct FCAWeaponPayload>               Payloads;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCALevelUpMetadata*>             Metadatas;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class APawn*>                          Instigators;                                       // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAStoredProjectileData) == 0x000008, "Wrong alignment on FCAStoredProjectileData");
static_assert(sizeof(FCAStoredProjectileData) == 0x000038, "Wrong size on FCAStoredProjectileData");
static_assert(offsetof(FCAStoredProjectileData, Payloads) == 0x000000, "Member 'FCAStoredProjectileData::Payloads' has a wrong offset!");
static_assert(offsetof(FCAStoredProjectileData, Metadatas) == 0x000010, "Member 'FCAStoredProjectileData::Metadatas' has a wrong offset!");
static_assert(offsetof(FCAStoredProjectileData, Instigators) == 0x000020, "Member 'FCAStoredProjectileData::Instigators' has a wrong offset!");

// ScriptStruct keaton.CAFlashLevelDataRow
// 0x0028 (0x0030 - 0x0008)
struct FCAFlashLevelDataRow final : public FTableRowBase
{
public:
	float                                         M_view_angle;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_start_flash_distance;                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_end_flash_distance;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_flash_duration;                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_flash_duration;                              // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_UI_visible_at_percentage;                        // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            M_float_curve_flash_fade;                          // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            M_float_curve_flash_duration;                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFlashLevelDataRow) == 0x000008, "Wrong alignment on FCAFlashLevelDataRow");
static_assert(sizeof(FCAFlashLevelDataRow) == 0x000030, "Wrong size on FCAFlashLevelDataRow");
static_assert(offsetof(FCAFlashLevelDataRow, M_view_angle) == 0x000008, "Member 'FCAFlashLevelDataRow::M_view_angle' has a wrong offset!");
static_assert(offsetof(FCAFlashLevelDataRow, M_start_flash_distance) == 0x00000C, "Member 'FCAFlashLevelDataRow::M_start_flash_distance' has a wrong offset!");
static_assert(offsetof(FCAFlashLevelDataRow, M_end_flash_distance) == 0x000010, "Member 'FCAFlashLevelDataRow::M_end_flash_distance' has a wrong offset!");
static_assert(offsetof(FCAFlashLevelDataRow, M_min_flash_duration) == 0x000014, "Member 'FCAFlashLevelDataRow::M_min_flash_duration' has a wrong offset!");
static_assert(offsetof(FCAFlashLevelDataRow, M_max_flash_duration) == 0x000018, "Member 'FCAFlashLevelDataRow::M_max_flash_duration' has a wrong offset!");
static_assert(offsetof(FCAFlashLevelDataRow, M_UI_visible_at_percentage) == 0x00001C, "Member 'FCAFlashLevelDataRow::M_UI_visible_at_percentage' has a wrong offset!");
static_assert(offsetof(FCAFlashLevelDataRow, M_float_curve_flash_fade) == 0x000020, "Member 'FCAFlashLevelDataRow::M_float_curve_flash_fade' has a wrong offset!");
static_assert(offsetof(FCAFlashLevelDataRow, M_float_curve_flash_duration) == 0x000028, "Member 'FCAFlashLevelDataRow::M_float_curve_flash_duration' has a wrong offset!");

// ScriptStruct keaton.CAHUDDisguiseData
// 0x0018 (0x0018 - 0x0000)
struct FCAHUDDisguiseData final
{
public:
	struct FGameplayTag                           M_stolen_identifier_tag;                           // 0x0000(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_real_id_of_disguised_character;                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_real_id_of_copied_character;                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_health_fragments;                                // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDDisguiseData) == 0x000004, "Wrong alignment on FCAHUDDisguiseData");
static_assert(sizeof(FCAHUDDisguiseData) == 0x000018, "Wrong size on FCAHUDDisguiseData");
static_assert(offsetof(FCAHUDDisguiseData, M_stolen_identifier_tag) == 0x000000, "Member 'FCAHUDDisguiseData::M_stolen_identifier_tag' has a wrong offset!");
static_assert(offsetof(FCAHUDDisguiseData, M_real_id_of_disguised_character) == 0x00000C, "Member 'FCAHUDDisguiseData::M_real_id_of_disguised_character' has a wrong offset!");
static_assert(offsetof(FCAHUDDisguiseData, M_real_id_of_copied_character) == 0x000010, "Member 'FCAHUDDisguiseData::M_real_id_of_copied_character' has a wrong offset!");
static_assert(offsetof(FCAHUDDisguiseData, M_health_fragments) == 0x000014, "Member 'FCAHUDDisguiseData::M_health_fragments' has a wrong offset!");

// ScriptStruct keaton.KeyToScancode
// 0x0028 (0x0028 - 0x0000)
struct FKeyToScancode final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0020)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ScanCode;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKeyToScancode) == 0x000008, "Wrong alignment on FKeyToScancode");
static_assert(sizeof(FKeyToScancode) == 0x000028, "Wrong size on FKeyToScancode");
static_assert(offsetof(FKeyToScancode, Key) == 0x000000, "Member 'FKeyToScancode::Key' has a wrong offset!");
static_assert(offsetof(FKeyToScancode, ScanCode) == 0x000020, "Member 'FKeyToScancode::ScanCode' has a wrong offset!");

// ScriptStruct keaton.CAMenuNavigationButtonInfo
// 0x0040 (0x0040 - 0x0000)
struct FCAMenuNavigationButtonInfo final
{
public:
	class FName                                   M_navigation_item_id;                              // 0x0000(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_label;                                           // 0x0010(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMenuNavigationButtonInfo) == 0x000008, "Wrong alignment on FCAMenuNavigationButtonInfo");
static_assert(sizeof(FCAMenuNavigationButtonInfo) == 0x000040, "Wrong size on FCAMenuNavigationButtonInfo");
static_assert(offsetof(FCAMenuNavigationButtonInfo, M_navigation_item_id) == 0x000000, "Member 'FCAMenuNavigationButtonInfo::M_navigation_item_id' has a wrong offset!");
static_assert(offsetof(FCAMenuNavigationButtonInfo, M_label) == 0x000010, "Member 'FCAMenuNavigationButtonInfo::M_label' has a wrong offset!");

// ScriptStruct keaton.CATeleporterLocation
// 0x0020 (0x0020 - 0x0000)
struct FCATeleporterLocation final
{
public:
	struct FGameplayTag                           M_tag;                                             // 0x0000(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_weight;                                          // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_disable_if_exclusion_zone_in_range;              // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_active;                                       // 0x0014(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  M_actor;                                           // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATeleporterLocation) == 0x000004, "Wrong alignment on FCATeleporterLocation");
static_assert(sizeof(FCATeleporterLocation) == 0x000020, "Wrong size on FCATeleporterLocation");
static_assert(offsetof(FCATeleporterLocation, M_tag) == 0x000000, "Member 'FCATeleporterLocation::M_tag' has a wrong offset!");
static_assert(offsetof(FCATeleporterLocation, M_weight) == 0x00000C, "Member 'FCATeleporterLocation::M_weight' has a wrong offset!");
static_assert(offsetof(FCATeleporterLocation, M_disable_if_exclusion_zone_in_range) == 0x000010, "Member 'FCATeleporterLocation::M_disable_if_exclusion_zone_in_range' has a wrong offset!");
static_assert(offsetof(FCATeleporterLocation, M_is_active) == 0x000014, "Member 'FCATeleporterLocation::M_is_active' has a wrong offset!");
static_assert(offsetof(FCATeleporterLocation, M_actor) == 0x000018, "Member 'FCATeleporterLocation::M_actor' has a wrong offset!");

// ScriptStruct keaton.CATeamEncounter
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FCATeamEncounter final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCATeamEncounter) == 0x000008, "Wrong alignment on FCATeamEncounter");
static_assert(sizeof(FCATeamEncounter) == 0x000068, "Wrong size on FCATeamEncounter");

// ScriptStruct keaton.CAAbilityBindInfo
// 0x0010 (0x0010 - 0x0000)
struct FCAAbilityBindInfo final
{
public:
	ECAAbilityInputBinds                          M_command;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayAbility>           M_gameplay_ability_class;                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAbilityBindInfo) == 0x000008, "Wrong alignment on FCAAbilityBindInfo");
static_assert(sizeof(FCAAbilityBindInfo) == 0x000010, "Wrong size on FCAAbilityBindInfo");
static_assert(offsetof(FCAAbilityBindInfo, M_command) == 0x000000, "Member 'FCAAbilityBindInfo::M_command' has a wrong offset!");
static_assert(offsetof(FCAAbilityBindInfo, M_gameplay_ability_class) == 0x000008, "Member 'FCAAbilityBindInfo::M_gameplay_ability_class' has a wrong offset!");

// ScriptStruct keaton.HighlightSightRules
// 0x000C (0x000C - 0x0000)
struct FHighlightSightRules final
{
public:
	EHighlightLOS                                 M_LOS_rule;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_max_distance_to_viewer;                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_check_distance;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_highlight_when_being_spectated;                  // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHighlightSightRules) == 0x000004, "Wrong alignment on FHighlightSightRules");
static_assert(sizeof(FHighlightSightRules) == 0x00000C, "Wrong size on FHighlightSightRules");
static_assert(offsetof(FHighlightSightRules, M_LOS_rule) == 0x000000, "Member 'FHighlightSightRules::M_LOS_rule' has a wrong offset!");
static_assert(offsetof(FHighlightSightRules, M_max_distance_to_viewer) == 0x000004, "Member 'FHighlightSightRules::M_max_distance_to_viewer' has a wrong offset!");
static_assert(offsetof(FHighlightSightRules, M_check_distance) == 0x000008, "Member 'FHighlightSightRules::M_check_distance' has a wrong offset!");
static_assert(offsetof(FHighlightSightRules, M_highlight_when_being_spectated) == 0x000009, "Member 'FHighlightSightRules::M_highlight_when_being_spectated' has a wrong offset!");

// ScriptStruct keaton.HighlightTagsRules
// 0x0080 (0x0080 - 0x0000)
struct FHighlightTagsRules final
{
public:
	struct FGameplayTagRequirements               M_viewer_required_tags;                            // 0x0000(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               M_target_required_tags;                            // 0x0040(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHighlightTagsRules) == 0x000008, "Wrong alignment on FHighlightTagsRules");
static_assert(sizeof(FHighlightTagsRules) == 0x000080, "Wrong size on FHighlightTagsRules");
static_assert(offsetof(FHighlightTagsRules, M_viewer_required_tags) == 0x000000, "Member 'FHighlightTagsRules::M_viewer_required_tags' has a wrong offset!");
static_assert(offsetof(FHighlightTagsRules, M_target_required_tags) == 0x000040, "Member 'FHighlightTagsRules::M_target_required_tags' has a wrong offset!");

// ScriptStruct keaton.HighlightReplicatedInfo
// 0x0098 (0x0098 - 0x0000)
struct FHighlightReplicatedInfo final
{
public:
	TWeakObjectPtr<class AActor>                  M_actor;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAOutlineColor                               M_colour;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHighlightSightRules                   M_sight_rules;                                     // 0x000C(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FHighlightTagsRules                    M_tag_rules;                                       // 0x0018(0x0080)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHighlightReplicatedInfo) == 0x000008, "Wrong alignment on FHighlightReplicatedInfo");
static_assert(sizeof(FHighlightReplicatedInfo) == 0x000098, "Wrong size on FHighlightReplicatedInfo");
static_assert(offsetof(FHighlightReplicatedInfo, M_actor) == 0x000000, "Member 'FHighlightReplicatedInfo::M_actor' has a wrong offset!");
static_assert(offsetof(FHighlightReplicatedInfo, M_colour) == 0x000008, "Member 'FHighlightReplicatedInfo::M_colour' has a wrong offset!");
static_assert(offsetof(FHighlightReplicatedInfo, M_sight_rules) == 0x00000C, "Member 'FHighlightReplicatedInfo::M_sight_rules' has a wrong offset!");
static_assert(offsetof(FHighlightReplicatedInfo, M_tag_rules) == 0x000018, "Member 'FHighlightReplicatedInfo::M_tag_rules' has a wrong offset!");

// ScriptStruct keaton.TeamData
// 0x0030 (0x0030 - 0x0000)
struct FTeamData final
{
public:
	struct FCATeamID                              M_team_id;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_team_present;                                    // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_team_exited;                                     // 0x0005(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_team_wiped;                                      // 0x0006(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_team_can_respawn;                                // 0x0007(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_team_pending_respawn;                            // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_team_failed;                                     // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_team_success;                                    // 0x000A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_threshold_reached;                               // 0x000B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_threshold_passed;                                // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_team_alive;                                      // 0x000D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_team_has_executive_club_membership;              // 0x000E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_team_mission_score;                              // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_final_mission_score;                             // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_end_of_match_rank;                               // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_team_ranking;                                    // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_team_ranking_position;                           // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECARelativeTeamRanking                        M_team_ranking_relationship;                       // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_rank_timestamp_is_valid;                         // 0x0025(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_team_updated_when;                               // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_respawn_request_started;                         // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAThresholdState                             M_threshold_state;                                 // 0x002D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTeamData) == 0x000004, "Wrong alignment on FTeamData");
static_assert(sizeof(FTeamData) == 0x000030, "Wrong size on FTeamData");
static_assert(offsetof(FTeamData, M_team_id) == 0x000000, "Member 'FTeamData::M_team_id' has a wrong offset!");
static_assert(offsetof(FTeamData, M_team_present) == 0x000004, "Member 'FTeamData::M_team_present' has a wrong offset!");
static_assert(offsetof(FTeamData, M_team_exited) == 0x000005, "Member 'FTeamData::M_team_exited' has a wrong offset!");
static_assert(offsetof(FTeamData, M_team_wiped) == 0x000006, "Member 'FTeamData::M_team_wiped' has a wrong offset!");
static_assert(offsetof(FTeamData, M_team_can_respawn) == 0x000007, "Member 'FTeamData::M_team_can_respawn' has a wrong offset!");
static_assert(offsetof(FTeamData, M_team_pending_respawn) == 0x000008, "Member 'FTeamData::M_team_pending_respawn' has a wrong offset!");
static_assert(offsetof(FTeamData, M_team_failed) == 0x000009, "Member 'FTeamData::M_team_failed' has a wrong offset!");
static_assert(offsetof(FTeamData, M_team_success) == 0x00000A, "Member 'FTeamData::M_team_success' has a wrong offset!");
static_assert(offsetof(FTeamData, M_threshold_reached) == 0x00000B, "Member 'FTeamData::M_threshold_reached' has a wrong offset!");
static_assert(offsetof(FTeamData, M_threshold_passed) == 0x00000C, "Member 'FTeamData::M_threshold_passed' has a wrong offset!");
static_assert(offsetof(FTeamData, M_team_alive) == 0x00000D, "Member 'FTeamData::M_team_alive' has a wrong offset!");
static_assert(offsetof(FTeamData, M_team_has_executive_club_membership) == 0x00000E, "Member 'FTeamData::M_team_has_executive_club_membership' has a wrong offset!");
static_assert(offsetof(FTeamData, M_team_mission_score) == 0x000010, "Member 'FTeamData::M_team_mission_score' has a wrong offset!");
static_assert(offsetof(FTeamData, M_final_mission_score) == 0x000014, "Member 'FTeamData::M_final_mission_score' has a wrong offset!");
static_assert(offsetof(FTeamData, M_end_of_match_rank) == 0x000018, "Member 'FTeamData::M_end_of_match_rank' has a wrong offset!");
static_assert(offsetof(FTeamData, M_team_ranking) == 0x00001C, "Member 'FTeamData::M_team_ranking' has a wrong offset!");
static_assert(offsetof(FTeamData, M_team_ranking_position) == 0x000020, "Member 'FTeamData::M_team_ranking_position' has a wrong offset!");
static_assert(offsetof(FTeamData, M_team_ranking_relationship) == 0x000024, "Member 'FTeamData::M_team_ranking_relationship' has a wrong offset!");
static_assert(offsetof(FTeamData, M_rank_timestamp_is_valid) == 0x000025, "Member 'FTeamData::M_rank_timestamp_is_valid' has a wrong offset!");
static_assert(offsetof(FTeamData, M_team_updated_when) == 0x000028, "Member 'FTeamData::M_team_updated_when' has a wrong offset!");
static_assert(offsetof(FTeamData, M_respawn_request_started) == 0x00002C, "Member 'FTeamData::M_respawn_request_started' has a wrong offset!");
static_assert(offsetof(FTeamData, M_threshold_state) == 0x00002D, "Member 'FTeamData::M_threshold_state' has a wrong offset!");

// ScriptStruct keaton.AnimMontageDetails
// 0x0010 (0x0010 - 0x0000)
struct FAnimMontageDetails final
{
public:
	class UAnimMontage*                           M_montage;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimMontageDetails) == 0x000008, "Wrong alignment on FAnimMontageDetails");
static_assert(sizeof(FAnimMontageDetails) == 0x000010, "Wrong size on FAnimMontageDetails");
static_assert(offsetof(FAnimMontageDetails, M_montage) == 0x000000, "Member 'FAnimMontageDetails::M_montage' has a wrong offset!");

// ScriptStruct keaton.CAStateUser
// 0x0010 (0x0010 - 0x0000)
struct FCAStateUser final
{
public:
	class AActor*                                 M_Actor;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAUsableState*                         M_Usable;                                          // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAStateUser) == 0x000008, "Wrong alignment on FCAStateUser");
static_assert(sizeof(FCAStateUser) == 0x000010, "Wrong size on FCAStateUser");
static_assert(offsetof(FCAStateUser, M_Actor) == 0x000000, "Member 'FCAStateUser::M_Actor' has a wrong offset!");
static_assert(offsetof(FCAStateUser, M_Usable) == 0x000008, "Member 'FCAStateUser::M_Usable' has a wrong offset!");

// ScriptStruct keaton.EquipmentAnimsRuntime
// 0x0010 (0x0010 - 0x0000)
struct FEquipmentAnimsRuntime final
{
public:
	class UAnimMontage*                           M_pawn_anim;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_weapon_anim;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipmentAnimsRuntime) == 0x000008, "Wrong alignment on FEquipmentAnimsRuntime");
static_assert(sizeof(FEquipmentAnimsRuntime) == 0x000010, "Wrong size on FEquipmentAnimsRuntime");
static_assert(offsetof(FEquipmentAnimsRuntime, M_pawn_anim) == 0x000000, "Member 'FEquipmentAnimsRuntime::M_pawn_anim' has a wrong offset!");
static_assert(offsetof(FEquipmentAnimsRuntime, M_weapon_anim) == 0x000008, "Member 'FEquipmentAnimsRuntime::M_weapon_anim' has a wrong offset!");

// ScriptStruct keaton.CAWidgetViewRow
// 0x0028 (0x0030 - 0x0008)
struct FCAWidgetViewRow final : public FTableRowBase
{
public:
	TSubclassOf<class UCAWidgetViewWidget>        Widget_class;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Render_target_width;                               // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Render_target_height;                              // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Render_target_clear_colour;                        // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAWidgetViewRow) == 0x000008, "Wrong alignment on FCAWidgetViewRow");
static_assert(sizeof(FCAWidgetViewRow) == 0x000030, "Wrong size on FCAWidgetViewRow");
static_assert(offsetof(FCAWidgetViewRow, Widget_class) == 0x000008, "Member 'FCAWidgetViewRow::Widget_class' has a wrong offset!");
static_assert(offsetof(FCAWidgetViewRow, Material) == 0x000010, "Member 'FCAWidgetViewRow::Material' has a wrong offset!");
static_assert(offsetof(FCAWidgetViewRow, Render_target_width) == 0x000018, "Member 'FCAWidgetViewRow::Render_target_width' has a wrong offset!");
static_assert(offsetof(FCAWidgetViewRow, Render_target_height) == 0x00001C, "Member 'FCAWidgetViewRow::Render_target_height' has a wrong offset!");
static_assert(offsetof(FCAWidgetViewRow, Render_target_clear_colour) == 0x000020, "Member 'FCAWidgetViewRow::Render_target_clear_colour' has a wrong offset!");

// ScriptStruct keaton.CAStateTransitionDefinition
// 0x0098 (0x0098 - 0x0000)
struct FCAStateTransitionDefinition final
{
public:
	TSoftClassPtr<class UClass>                   TransitionClass;                                   // 0x0000(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               Requirements;                                      // 0x0030(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   OrTransition;                                      // 0x0070(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AndTransition;                                     // 0x007C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TransitionOnSuccess;                               // 0x0088(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAStateTransitionDefinition) == 0x000008, "Wrong alignment on FCAStateTransitionDefinition");
static_assert(sizeof(FCAStateTransitionDefinition) == 0x000098, "Wrong size on FCAStateTransitionDefinition");
static_assert(offsetof(FCAStateTransitionDefinition, TransitionClass) == 0x000000, "Member 'FCAStateTransitionDefinition::TransitionClass' has a wrong offset!");
static_assert(offsetof(FCAStateTransitionDefinition, Requirements) == 0x000030, "Member 'FCAStateTransitionDefinition::Requirements' has a wrong offset!");
static_assert(offsetof(FCAStateTransitionDefinition, OrTransition) == 0x000070, "Member 'FCAStateTransitionDefinition::OrTransition' has a wrong offset!");
static_assert(offsetof(FCAStateTransitionDefinition, AndTransition) == 0x00007C, "Member 'FCAStateTransitionDefinition::AndTransition' has a wrong offset!");
static_assert(offsetof(FCAStateTransitionDefinition, TransitionOnSuccess) == 0x000088, "Member 'FCAStateTransitionDefinition::TransitionOnSuccess' has a wrong offset!");

// ScriptStruct keaton.CAOverrideMaterial
// 0x0040 (0x0040 - 0x0000)
struct FCAOverrideMaterial final
{
public:
	class FName                                   M_material_slot_name;                              // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      M_override_material;                               // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAOverrideMaterial) == 0x000008, "Wrong alignment on FCAOverrideMaterial");
static_assert(sizeof(FCAOverrideMaterial) == 0x000040, "Wrong size on FCAOverrideMaterial");
static_assert(offsetof(FCAOverrideMaterial, M_material_slot_name) == 0x000000, "Member 'FCAOverrideMaterial::M_material_slot_name' has a wrong offset!");
static_assert(offsetof(FCAOverrideMaterial, M_override_material) == 0x000010, "Member 'FCAOverrideMaterial::M_override_material' has a wrong offset!");

// ScriptStruct keaton.CAPlayerCharacterAssets
// 0x00B0 (0x00B0 - 0x0000)
struct FCAPlayerCharacterAssets final
{
public:
	TSoftObjectPtr<class UCASpecialistPrimaryDataAsset> M_specialist_asset;                                // 0x0000(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        M_FP_mesh;                                         // 0x0030(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        M_TP_mesh;                                         // 0x0050(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        M_collapsed_TP_mesh;                               // 0x0070(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UCAInventoryItem>> M_loadout_inventory_items;                         // 0x0090(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FCAOverrideMaterial>            M_override_materials;                              // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPlayerCharacterAssets) == 0x000008, "Wrong alignment on FCAPlayerCharacterAssets");
static_assert(sizeof(FCAPlayerCharacterAssets) == 0x0000B0, "Wrong size on FCAPlayerCharacterAssets");
static_assert(offsetof(FCAPlayerCharacterAssets, M_specialist_asset) == 0x000000, "Member 'FCAPlayerCharacterAssets::M_specialist_asset' has a wrong offset!");
static_assert(offsetof(FCAPlayerCharacterAssets, M_FP_mesh) == 0x000030, "Member 'FCAPlayerCharacterAssets::M_FP_mesh' has a wrong offset!");
static_assert(offsetof(FCAPlayerCharacterAssets, M_TP_mesh) == 0x000050, "Member 'FCAPlayerCharacterAssets::M_TP_mesh' has a wrong offset!");
static_assert(offsetof(FCAPlayerCharacterAssets, M_collapsed_TP_mesh) == 0x000070, "Member 'FCAPlayerCharacterAssets::M_collapsed_TP_mesh' has a wrong offset!");
static_assert(offsetof(FCAPlayerCharacterAssets, M_loadout_inventory_items) == 0x000090, "Member 'FCAPlayerCharacterAssets::M_loadout_inventory_items' has a wrong offset!");
static_assert(offsetof(FCAPlayerCharacterAssets, M_override_materials) == 0x0000A0, "Member 'FCAPlayerCharacterAssets::M_override_materials' has a wrong offset!");

// ScriptStruct keaton.CAGameplayEffectContainer
// 0x0018 (0x0018 - 0x0000)
struct FCAGameplayEffectContainer final
{
public:
	TSubclassOf<class UCATargetType>              M_target_type;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    M_target_gameplay_effect_classes;                  // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAGameplayEffectContainer) == 0x000008, "Wrong alignment on FCAGameplayEffectContainer");
static_assert(sizeof(FCAGameplayEffectContainer) == 0x000018, "Wrong size on FCAGameplayEffectContainer");
static_assert(offsetof(FCAGameplayEffectContainer, M_target_type) == 0x000000, "Member 'FCAGameplayEffectContainer::M_target_type' has a wrong offset!");
static_assert(offsetof(FCAGameplayEffectContainer, M_target_gameplay_effect_classes) == 0x000008, "Member 'FCAGameplayEffectContainer::M_target_gameplay_effect_classes' has a wrong offset!");

// ScriptStruct keaton.CAUsableStateDefinition
// 0x00F8 (0x00F8 - 0x0000)
struct FCAUsableStateDefinition final
{
public:
	TSoftClassPtr<class UClass>                   StateClass;                                        // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCAGameplayAbilityUse>      UseAbility;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OverrideUsePriority;                               // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideHoldDuration;                              // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               OverrideUseInteraction;                            // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   AnchorNameToUse;                                   // 0x0058(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               OwnerRequirements;                                 // 0x0068(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               UserRequirements;                                  // 0x00A8(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          EvaluateTransitionStateRequirements;               // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TransitionOnComplete;                              // 0x00EC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAUsableStateDefinition) == 0x000008, "Wrong alignment on FCAUsableStateDefinition");
static_assert(sizeof(FCAUsableStateDefinition) == 0x0000F8, "Wrong size on FCAUsableStateDefinition");
static_assert(offsetof(FCAUsableStateDefinition, StateClass) == 0x000000, "Member 'FCAUsableStateDefinition::StateClass' has a wrong offset!");
static_assert(offsetof(FCAUsableStateDefinition, UseAbility) == 0x000030, "Member 'FCAUsableStateDefinition::UseAbility' has a wrong offset!");
static_assert(offsetof(FCAUsableStateDefinition, OverrideUsePriority) == 0x000038, "Member 'FCAUsableStateDefinition::OverrideUsePriority' has a wrong offset!");
static_assert(offsetof(FCAUsableStateDefinition, OverrideHoldDuration) == 0x00003C, "Member 'FCAUsableStateDefinition::OverrideHoldDuration' has a wrong offset!");
static_assert(offsetof(FCAUsableStateDefinition, OverrideUseInteraction) == 0x000040, "Member 'FCAUsableStateDefinition::OverrideUseInteraction' has a wrong offset!");
static_assert(offsetof(FCAUsableStateDefinition, AnchorNameToUse) == 0x000058, "Member 'FCAUsableStateDefinition::AnchorNameToUse' has a wrong offset!");
static_assert(offsetof(FCAUsableStateDefinition, OwnerRequirements) == 0x000068, "Member 'FCAUsableStateDefinition::OwnerRequirements' has a wrong offset!");
static_assert(offsetof(FCAUsableStateDefinition, UserRequirements) == 0x0000A8, "Member 'FCAUsableStateDefinition::UserRequirements' has a wrong offset!");
static_assert(offsetof(FCAUsableStateDefinition, EvaluateTransitionStateRequirements) == 0x0000E8, "Member 'FCAUsableStateDefinition::EvaluateTransitionStateRequirements' has a wrong offset!");
static_assert(offsetof(FCAUsableStateDefinition, TransitionOnComplete) == 0x0000EC, "Member 'FCAUsableStateDefinition::TransitionOnComplete' has a wrong offset!");

// ScriptStruct keaton.CAFiniteStateDefinition
// 0x01F8 (0x01F8 - 0x0000)
struct FCAFiniteStateDefinition final
{
public:
	TSoftClassPtr<class UClass>                   StateClass;                                        // 0x0000(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  StateTags;                                         // 0x0030(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               Requirements;                                      // 0x0050(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FName>                           AutomaticTransitions;                              // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ManuallyAvailableTransitions;                      // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FCAStateTransitionDefinition> ScriptedTransitions;                               // 0x00B0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FCAUsableStateDefinition> UsableStates;                                      // 0x0100(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          SingleUsableAbilityAtSameTime;                     // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            EffectToApplyToUsers;                              // 0x0158(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            EffectToApplyToOwner;                              // 0x0160(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCAGameplayAbility>         AbilityToGiveToUsers;                              // 0x0168(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyAllowClientAbilityActivation;                  // 0x0170(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequiresProcessing;                                // 0x0171(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ServerOnlyTransition;                              // 0x0172(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_173[0x1];                                      // 0x0173(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimationName;                                     // 0x0174(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StaticMeshName;                                    // 0x0180(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HoldAnimation;                                     // 0x018C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ResetAnimationOnSuspendedState;                    // 0x018D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMaxAnimationPositionOnStatePaused;              // 0x018E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F[0x1];                                      // 0x018F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               RequirementsForUsingMaxAnimationPositionOnStatePaused; // 0x0190(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         MaxAnimationPositionOnStatePaused;                 // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HoldEndFrame;                                      // 0x01D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D5[0x3];                                      // 0x01D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StateParameterLerpTime;                            // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EvaluateWhileSuspended;                            // 0x01DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DD[0x3];                                      // 0x01DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimationPlaySpeed;                                // 0x01E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertAnimationProgress;                           // 0x01E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E5[0x3];                                      // 0x01E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FiniteStateDuration;                               // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TransitionOnComplete;                              // 0x01EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFiniteStateDefinition) == 0x000008, "Wrong alignment on FCAFiniteStateDefinition");
static_assert(sizeof(FCAFiniteStateDefinition) == 0x0001F8, "Wrong size on FCAFiniteStateDefinition");
static_assert(offsetof(FCAFiniteStateDefinition, StateClass) == 0x000000, "Member 'FCAFiniteStateDefinition::StateClass' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, StateTags) == 0x000030, "Member 'FCAFiniteStateDefinition::StateTags' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, Requirements) == 0x000050, "Member 'FCAFiniteStateDefinition::Requirements' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, AutomaticTransitions) == 0x000090, "Member 'FCAFiniteStateDefinition::AutomaticTransitions' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, ManuallyAvailableTransitions) == 0x0000A0, "Member 'FCAFiniteStateDefinition::ManuallyAvailableTransitions' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, ScriptedTransitions) == 0x0000B0, "Member 'FCAFiniteStateDefinition::ScriptedTransitions' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, UsableStates) == 0x000100, "Member 'FCAFiniteStateDefinition::UsableStates' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, SingleUsableAbilityAtSameTime) == 0x000150, "Member 'FCAFiniteStateDefinition::SingleUsableAbilityAtSameTime' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, EffectToApplyToUsers) == 0x000158, "Member 'FCAFiniteStateDefinition::EffectToApplyToUsers' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, EffectToApplyToOwner) == 0x000160, "Member 'FCAFiniteStateDefinition::EffectToApplyToOwner' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, AbilityToGiveToUsers) == 0x000168, "Member 'FCAFiniteStateDefinition::AbilityToGiveToUsers' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, OnlyAllowClientAbilityActivation) == 0x000170, "Member 'FCAFiniteStateDefinition::OnlyAllowClientAbilityActivation' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, RequiresProcessing) == 0x000171, "Member 'FCAFiniteStateDefinition::RequiresProcessing' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, ServerOnlyTransition) == 0x000172, "Member 'FCAFiniteStateDefinition::ServerOnlyTransition' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, AnimationName) == 0x000174, "Member 'FCAFiniteStateDefinition::AnimationName' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, StaticMeshName) == 0x000180, "Member 'FCAFiniteStateDefinition::StaticMeshName' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, HoldAnimation) == 0x00018C, "Member 'FCAFiniteStateDefinition::HoldAnimation' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, ResetAnimationOnSuspendedState) == 0x00018D, "Member 'FCAFiniteStateDefinition::ResetAnimationOnSuspendedState' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, UseMaxAnimationPositionOnStatePaused) == 0x00018E, "Member 'FCAFiniteStateDefinition::UseMaxAnimationPositionOnStatePaused' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, RequirementsForUsingMaxAnimationPositionOnStatePaused) == 0x000190, "Member 'FCAFiniteStateDefinition::RequirementsForUsingMaxAnimationPositionOnStatePaused' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, MaxAnimationPositionOnStatePaused) == 0x0001D0, "Member 'FCAFiniteStateDefinition::MaxAnimationPositionOnStatePaused' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, HoldEndFrame) == 0x0001D4, "Member 'FCAFiniteStateDefinition::HoldEndFrame' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, StateParameterLerpTime) == 0x0001D8, "Member 'FCAFiniteStateDefinition::StateParameterLerpTime' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, EvaluateWhileSuspended) == 0x0001DC, "Member 'FCAFiniteStateDefinition::EvaluateWhileSuspended' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, AnimationPlaySpeed) == 0x0001E0, "Member 'FCAFiniteStateDefinition::AnimationPlaySpeed' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, InvertAnimationProgress) == 0x0001E4, "Member 'FCAFiniteStateDefinition::InvertAnimationProgress' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, FiniteStateDuration) == 0x0001E8, "Member 'FCAFiniteStateDefinition::FiniteStateDuration' has a wrong offset!");
static_assert(offsetof(FCAFiniteStateDefinition, TransitionOnComplete) == 0x0001EC, "Member 'FCAFiniteStateDefinition::TransitionOnComplete' has a wrong offset!");

// ScriptStruct keaton.CACurrencyAssetData
// 0x0098 (0x0098 - 0x0000)
struct FCACurrencyAssetData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_display_name;                                    // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_symbol;                                          // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_description;                                     // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_icon;                                            // 0x0058(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         M_quantity;                                        // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_currency_reward;                              // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCACurrencyAssetData) == 0x000008, "Wrong alignment on FCACurrencyAssetData");
static_assert(sizeof(FCACurrencyAssetData) == 0x000098, "Wrong size on FCACurrencyAssetData");
static_assert(offsetof(FCACurrencyAssetData, M_display_name) == 0x000010, "Member 'FCACurrencyAssetData::M_display_name' has a wrong offset!");
static_assert(offsetof(FCACurrencyAssetData, M_symbol) == 0x000028, "Member 'FCACurrencyAssetData::M_symbol' has a wrong offset!");
static_assert(offsetof(FCACurrencyAssetData, M_description) == 0x000040, "Member 'FCACurrencyAssetData::M_description' has a wrong offset!");
static_assert(offsetof(FCACurrencyAssetData, M_icon) == 0x000058, "Member 'FCACurrencyAssetData::M_icon' has a wrong offset!");
static_assert(offsetof(FCACurrencyAssetData, M_quantity) == 0x000088, "Member 'FCACurrencyAssetData::M_quantity' has a wrong offset!");
static_assert(offsetof(FCACurrencyAssetData, M_is_currency_reward) == 0x000090, "Member 'FCACurrencyAssetData::M_is_currency_reward' has a wrong offset!");

// ScriptStruct keaton.CARewardCategoryWeightData
// 0x0014 (0x0014 - 0x0000)
struct FCARewardCategoryWeightData final
{
public:
	struct FGameplayTag                           M_category_tag;                                    // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_category_weight;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_live_category_weight;                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARewardCategoryWeightData) == 0x000004, "Wrong alignment on FCARewardCategoryWeightData");
static_assert(sizeof(FCARewardCategoryWeightData) == 0x000014, "Wrong size on FCARewardCategoryWeightData");
static_assert(offsetof(FCARewardCategoryWeightData, M_category_tag) == 0x000000, "Member 'FCARewardCategoryWeightData::M_category_tag' has a wrong offset!");
static_assert(offsetof(FCARewardCategoryWeightData, M_category_weight) == 0x00000C, "Member 'FCARewardCategoryWeightData::M_category_weight' has a wrong offset!");
static_assert(offsetof(FCARewardCategoryWeightData, M_live_category_weight) == 0x000010, "Member 'FCARewardCategoryWeightData::M_live_category_weight' has a wrong offset!");

// ScriptStruct keaton.CAThemePackMultiplierData
// 0x0010 (0x0010 - 0x0000)
struct FCAThemePackMultiplierData final
{
public:
	struct FGameplayTag                           M_theme_pack_tag;                                  // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_multiplier_value;                                // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAThemePackMultiplierData) == 0x000004, "Wrong alignment on FCAThemePackMultiplierData");
static_assert(sizeof(FCAThemePackMultiplierData) == 0x000010, "Wrong size on FCAThemePackMultiplierData");
static_assert(offsetof(FCAThemePackMultiplierData, M_theme_pack_tag) == 0x000000, "Member 'FCAThemePackMultiplierData::M_theme_pack_tag' has a wrong offset!");
static_assert(offsetof(FCAThemePackMultiplierData, M_multiplier_value) == 0x00000C, "Member 'FCAThemePackMultiplierData::M_multiplier_value' has a wrong offset!");

// ScriptStruct keaton.CARewardTypeData
// 0x0098 (0x0098 - 0x0000)
struct FCARewardTypeData final
{
public:
	bool                                          M_enabled;                                         // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        M_reward;                                          // 0x0008(0x0020)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                M_reward_ptr;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_identifier_tag;                                  // 0x0030(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCARewardCategoryWeightData>    M_category_weights;                                // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_placement_tag;                                   // 0x0050(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAThemePackMultiplierData>     M_theme_pack_multipliers;                          // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_is_hero_loot;                                    // 0x0080(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_services_id;                                     // 0x0084(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_default_theme_pack_multiplier;                   // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCARewardTypeData) == 0x000008, "Wrong alignment on FCARewardTypeData");
static_assert(sizeof(FCARewardTypeData) == 0x000098, "Wrong size on FCARewardTypeData");
static_assert(offsetof(FCARewardTypeData, M_enabled) == 0x000000, "Member 'FCARewardTypeData::M_enabled' has a wrong offset!");
static_assert(offsetof(FCARewardTypeData, M_reward) == 0x000008, "Member 'FCARewardTypeData::M_reward' has a wrong offset!");
static_assert(offsetof(FCARewardTypeData, M_reward_ptr) == 0x000028, "Member 'FCARewardTypeData::M_reward_ptr' has a wrong offset!");
static_assert(offsetof(FCARewardTypeData, M_identifier_tag) == 0x000030, "Member 'FCARewardTypeData::M_identifier_tag' has a wrong offset!");
static_assert(offsetof(FCARewardTypeData, M_category_weights) == 0x000040, "Member 'FCARewardTypeData::M_category_weights' has a wrong offset!");
static_assert(offsetof(FCARewardTypeData, M_placement_tag) == 0x000050, "Member 'FCARewardTypeData::M_placement_tag' has a wrong offset!");
static_assert(offsetof(FCARewardTypeData, M_theme_pack_multipliers) == 0x000060, "Member 'FCARewardTypeData::M_theme_pack_multipliers' has a wrong offset!");
static_assert(offsetof(FCARewardTypeData, M_is_hero_loot) == 0x000080, "Member 'FCARewardTypeData::M_is_hero_loot' has a wrong offset!");
static_assert(offsetof(FCARewardTypeData, M_services_id) == 0x000084, "Member 'FCARewardTypeData::M_services_id' has a wrong offset!");
static_assert(offsetof(FCARewardTypeData, M_default_theme_pack_multiplier) == 0x000090, "Member 'FCARewardTypeData::M_default_theme_pack_multiplier' has a wrong offset!");

// ScriptStruct keaton.CASetIntDelegate
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FCASetIntDelegate final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCASetIntDelegate) == 0x000008, "Wrong alignment on FCASetIntDelegate");
static_assert(sizeof(FCASetIntDelegate) == 0x000028, "Wrong size on FCASetIntDelegate");

// ScriptStruct keaton.CAGetBoolDelegate
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FCAGetBoolDelegate final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAGetBoolDelegate) == 0x000008, "Wrong alignment on FCAGetBoolDelegate");
static_assert(sizeof(FCAGetBoolDelegate) == 0x000028, "Wrong size on FCAGetBoolDelegate");

// ScriptStruct keaton.MapZoneData
// 0x0020 (0x0020 - 0x0000)
struct FMapZoneData final
{
public:
	struct FVector_NetQuantize                    M_location;                                        // 0x0000(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAMapZoneType                                M_map_zone_type;                                   // 0x000C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_alerted;                                      // 0x000D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_looted;                                       // 0x000E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_zero_g_active;                                // 0x000F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECASupplyLevel                                M_supply_level;                                    // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_vault_entity_id;                                 // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAInventoryItem*                       M_hero_loot_item;                                  // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapZoneData) == 0x000008, "Wrong alignment on FMapZoneData");
static_assert(sizeof(FMapZoneData) == 0x000020, "Wrong size on FMapZoneData");
static_assert(offsetof(FMapZoneData, M_location) == 0x000000, "Member 'FMapZoneData::M_location' has a wrong offset!");
static_assert(offsetof(FMapZoneData, M_map_zone_type) == 0x00000C, "Member 'FMapZoneData::M_map_zone_type' has a wrong offset!");
static_assert(offsetof(FMapZoneData, M_is_alerted) == 0x00000D, "Member 'FMapZoneData::M_is_alerted' has a wrong offset!");
static_assert(offsetof(FMapZoneData, M_is_looted) == 0x00000E, "Member 'FMapZoneData::M_is_looted' has a wrong offset!");
static_assert(offsetof(FMapZoneData, M_is_zero_g_active) == 0x00000F, "Member 'FMapZoneData::M_is_zero_g_active' has a wrong offset!");
static_assert(offsetof(FMapZoneData, M_supply_level) == 0x000010, "Member 'FMapZoneData::M_supply_level' has a wrong offset!");
static_assert(offsetof(FMapZoneData, M_vault_entity_id) == 0x000014, "Member 'FMapZoneData::M_vault_entity_id' has a wrong offset!");
static_assert(offsetof(FMapZoneData, M_hero_loot_item) == 0x000018, "Member 'FMapZoneData::M_hero_loot_item' has a wrong offset!");

// ScriptStruct keaton.CAHUDIconsInTextTableRow
// 0x0010 (0x0018 - 0x0008)
struct FCAHUDIconsInTextTableRow final : public FTableRowBase
{
public:
	class FString                                 M_icon_character;                                  // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDIconsInTextTableRow) == 0x000008, "Wrong alignment on FCAHUDIconsInTextTableRow");
static_assert(sizeof(FCAHUDIconsInTextTableRow) == 0x000018, "Wrong size on FCAHUDIconsInTextTableRow");
static_assert(offsetof(FCAHUDIconsInTextTableRow, M_icon_character) == 0x000008, "Member 'FCAHUDIconsInTextTableRow::M_icon_character' has a wrong offset!");

// ScriptStruct keaton.CAStateMachineStatus
// 0x003C (0x003C - 0x0000)
struct FCAStateMachineStatus final
{
public:
	class FName                                   M_CurrentState;                                    // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_PendingState;                                    // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_PreviousState;                                   // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_CurrentStartTime;                                // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_PendingStartTime;                                // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_PlaybackPosition;                                // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_StateParameter;                                  // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_UsableProgress;                                  // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsSuspended;                                     // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsEnabled;                                       // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_ResetCurrentState;                               // 0x003A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAStateMachineStatus) == 0x000004, "Wrong alignment on FCAStateMachineStatus");
static_assert(sizeof(FCAStateMachineStatus) == 0x00003C, "Wrong size on FCAStateMachineStatus");
static_assert(offsetof(FCAStateMachineStatus, M_CurrentState) == 0x000000, "Member 'FCAStateMachineStatus::M_CurrentState' has a wrong offset!");
static_assert(offsetof(FCAStateMachineStatus, M_PendingState) == 0x00000C, "Member 'FCAStateMachineStatus::M_PendingState' has a wrong offset!");
static_assert(offsetof(FCAStateMachineStatus, M_PreviousState) == 0x000018, "Member 'FCAStateMachineStatus::M_PreviousState' has a wrong offset!");
static_assert(offsetof(FCAStateMachineStatus, M_CurrentStartTime) == 0x000024, "Member 'FCAStateMachineStatus::M_CurrentStartTime' has a wrong offset!");
static_assert(offsetof(FCAStateMachineStatus, M_PendingStartTime) == 0x000028, "Member 'FCAStateMachineStatus::M_PendingStartTime' has a wrong offset!");
static_assert(offsetof(FCAStateMachineStatus, M_PlaybackPosition) == 0x00002C, "Member 'FCAStateMachineStatus::M_PlaybackPosition' has a wrong offset!");
static_assert(offsetof(FCAStateMachineStatus, M_StateParameter) == 0x000030, "Member 'FCAStateMachineStatus::M_StateParameter' has a wrong offset!");
static_assert(offsetof(FCAStateMachineStatus, M_UsableProgress) == 0x000034, "Member 'FCAStateMachineStatus::M_UsableProgress' has a wrong offset!");
static_assert(offsetof(FCAStateMachineStatus, M_IsSuspended) == 0x000038, "Member 'FCAStateMachineStatus::M_IsSuspended' has a wrong offset!");
static_assert(offsetof(FCAStateMachineStatus, M_IsEnabled) == 0x000039, "Member 'FCAStateMachineStatus::M_IsEnabled' has a wrong offset!");
static_assert(offsetof(FCAStateMachineStatus, M_ResetCurrentState) == 0x00003A, "Member 'FCAStateMachineStatus::M_ResetCurrentState' has a wrong offset!");

// ScriptStruct keaton.CAAnchorTransforms
// 0x0010 (0x0010 - 0x0000)
struct FCAAnchorTransforms final
{
public:
	TArray<struct FTransform>                     LocalTransforms;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAnchorTransforms) == 0x000008, "Wrong alignment on FCAAnchorTransforms");
static_assert(sizeof(FCAAnchorTransforms) == 0x000010, "Wrong size on FCAAnchorTransforms");
static_assert(offsetof(FCAAnchorTransforms, LocalTransforms) == 0x000000, "Member 'FCAAnchorTransforms::LocalTransforms' has a wrong offset!");

// ScriptStruct keaton.CANiagaraName
// 0x0004 (0x0004 - 0x0000)
struct FCANiagaraName final
{
public:
	int32                                         Internal_rep;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANiagaraName) == 0x000004, "Wrong alignment on FCANiagaraName");
static_assert(sizeof(FCANiagaraName) == 0x000004, "Wrong size on FCANiagaraName");
static_assert(offsetof(FCANiagaraName, Internal_rep) == 0x000000, "Member 'FCANiagaraName::Internal_rep' has a wrong offset!");

// ScriptStruct keaton.CARewardDistributionTableEntry
// 0x0018 (0x0018 - 0x0000)
struct FCARewardDistributionTableEntry final
{
public:
	struct FDataTableRowHandle                    M_reward_distribution;                             // 0x0000(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARewardDistributionTableEntry) == 0x000008, "Wrong alignment on FCARewardDistributionTableEntry");
static_assert(sizeof(FCARewardDistributionTableEntry) == 0x000018, "Wrong size on FCARewardDistributionTableEntry");
static_assert(offsetof(FCARewardDistributionTableEntry, M_reward_distribution) == 0x000000, "Member 'FCARewardDistributionTableEntry::M_reward_distribution' has a wrong offset!");

// ScriptStruct keaton.CAHUDInteractionItemData
// 0x0070 (0x0070 - 0x0000)
struct FCAHUDInteractionItemData final
{
public:
	ECAUseInteractableType                        M_type;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_key_label;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             M_key_icon;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_prompt;                                          // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   M_prompt_when_unavailable;                         // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          M_non_interactable;                                // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_held_interaction;                                // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_unavailable;                                     // 0x0052(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x1];                                       // 0x0053(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_progress;                                        // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_action_name;                                     // 0x0058(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_interaction_started_audio_event;                 // 0x0064(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_interaction_success_audio_event;                 // 0x0068(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_interaction_fail_audio_event;                    // 0x006C(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDInteractionItemData) == 0x000008, "Wrong alignment on FCAHUDInteractionItemData");
static_assert(sizeof(FCAHUDInteractionItemData) == 0x000070, "Wrong size on FCAHUDInteractionItemData");
static_assert(offsetof(FCAHUDInteractionItemData, M_type) == 0x000000, "Member 'FCAHUDInteractionItemData::M_type' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionItemData, M_key_label) == 0x000008, "Member 'FCAHUDInteractionItemData::M_key_label' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionItemData, M_key_icon) == 0x000018, "Member 'FCAHUDInteractionItemData::M_key_icon' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionItemData, M_prompt) == 0x000020, "Member 'FCAHUDInteractionItemData::M_prompt' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionItemData, M_prompt_when_unavailable) == 0x000038, "Member 'FCAHUDInteractionItemData::M_prompt_when_unavailable' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionItemData, M_non_interactable) == 0x000050, "Member 'FCAHUDInteractionItemData::M_non_interactable' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionItemData, M_held_interaction) == 0x000051, "Member 'FCAHUDInteractionItemData::M_held_interaction' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionItemData, M_unavailable) == 0x000052, "Member 'FCAHUDInteractionItemData::M_unavailable' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionItemData, M_progress) == 0x000054, "Member 'FCAHUDInteractionItemData::M_progress' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionItemData, M_action_name) == 0x000058, "Member 'FCAHUDInteractionItemData::M_action_name' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionItemData, M_interaction_started_audio_event) == 0x000064, "Member 'FCAHUDInteractionItemData::M_interaction_started_audio_event' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionItemData, M_interaction_success_audio_event) == 0x000068, "Member 'FCAHUDInteractionItemData::M_interaction_success_audio_event' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionItemData, M_interaction_fail_audio_event) == 0x00006C, "Member 'FCAHUDInteractionItemData::M_interaction_fail_audio_event' has a wrong offset!");

// ScriptStruct keaton.NamedBooleanArray
// 0x0010 (0x0118 - 0x0108)
struct FNamedBooleanArray final : public FFastArraySerializer
{
public:
	TArray<struct FNamedBooleanEntry>             Items;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNamedBooleanArray) == 0x000008, "Wrong alignment on FNamedBooleanArray");
static_assert(sizeof(FNamedBooleanArray) == 0x000118, "Wrong size on FNamedBooleanArray");
static_assert(offsetof(FNamedBooleanArray, Items) == 0x000108, "Member 'FNamedBooleanArray::Items' has a wrong offset!");

// ScriptStruct keaton.CANavMeshAnalyserTaskNPCPathData
// 0x0060 (0x0060 - 0x0000)
struct FCANavMeshAnalyserTaskNPCPathData final
{
public:
	class UEnvQuery*                              Npc_path_preprocess_query;                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACAJob>                     Job_class;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Number_of_paths_per_security_area;                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   Job_tags;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Min_wait_duration;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max_wait_duration;                                 // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Only_set_wait_duration_on_path_extremes;           // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Max_npcs_on_path;                                  // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Number_of_jobs_per_path;                           // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECAJobRotation>                        Job_rotation_preferences;                          // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Max_distance_between_path_nodes;                   // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min_distance_to_other_paths;                       // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bind_paths_by_height_priority;                     // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANavMeshAnalyserTaskNPCPathData) == 0x000008, "Wrong alignment on FCANavMeshAnalyserTaskNPCPathData");
static_assert(sizeof(FCANavMeshAnalyserTaskNPCPathData) == 0x000060, "Wrong size on FCANavMeshAnalyserTaskNPCPathData");
static_assert(offsetof(FCANavMeshAnalyserTaskNPCPathData, Npc_path_preprocess_query) == 0x000000, "Member 'FCANavMeshAnalyserTaskNPCPathData::Npc_path_preprocess_query' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskNPCPathData, Job_class) == 0x000008, "Member 'FCANavMeshAnalyserTaskNPCPathData::Job_class' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskNPCPathData, Number_of_paths_per_security_area) == 0x000010, "Member 'FCANavMeshAnalyserTaskNPCPathData::Number_of_paths_per_security_area' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskNPCPathData, Job_tags) == 0x000018, "Member 'FCANavMeshAnalyserTaskNPCPathData::Job_tags' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskNPCPathData, Min_wait_duration) == 0x000028, "Member 'FCANavMeshAnalyserTaskNPCPathData::Min_wait_duration' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskNPCPathData, Max_wait_duration) == 0x00002C, "Member 'FCANavMeshAnalyserTaskNPCPathData::Max_wait_duration' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskNPCPathData, Only_set_wait_duration_on_path_extremes) == 0x000030, "Member 'FCANavMeshAnalyserTaskNPCPathData::Only_set_wait_duration_on_path_extremes' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskNPCPathData, Max_npcs_on_path) == 0x000034, "Member 'FCANavMeshAnalyserTaskNPCPathData::Max_npcs_on_path' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskNPCPathData, Number_of_jobs_per_path) == 0x000038, "Member 'FCANavMeshAnalyserTaskNPCPathData::Number_of_jobs_per_path' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskNPCPathData, Job_rotation_preferences) == 0x000040, "Member 'FCANavMeshAnalyserTaskNPCPathData::Job_rotation_preferences' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskNPCPathData, Max_distance_between_path_nodes) == 0x000050, "Member 'FCANavMeshAnalyserTaskNPCPathData::Max_distance_between_path_nodes' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskNPCPathData, Min_distance_to_other_paths) == 0x000054, "Member 'FCANavMeshAnalyserTaskNPCPathData::Min_distance_to_other_paths' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskNPCPathData, bind_paths_by_height_priority) == 0x000058, "Member 'FCANavMeshAnalyserTaskNPCPathData::bind_paths_by_height_priority' has a wrong offset!");

// ScriptStruct keaton.CARewardDistributionIdentifierMappingData
// 0x0048 (0x0050 - 0x0008)
struct FCARewardDistributionIdentifierMappingData final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCARewardDistributionTableEntry> M_reward_distributions;                            // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    M_reward_distribution_grouping;                    // 0x0028(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   M_theme_pack_tags;                                 // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARewardDistributionIdentifierMappingData) == 0x000008, "Wrong alignment on FCARewardDistributionIdentifierMappingData");
static_assert(sizeof(FCARewardDistributionIdentifierMappingData) == 0x000050, "Wrong size on FCARewardDistributionIdentifierMappingData");
static_assert(offsetof(FCARewardDistributionIdentifierMappingData, M_reward_distributions) == 0x000018, "Member 'FCARewardDistributionIdentifierMappingData::M_reward_distributions' has a wrong offset!");
static_assert(offsetof(FCARewardDistributionIdentifierMappingData, M_reward_distribution_grouping) == 0x000028, "Member 'FCARewardDistributionIdentifierMappingData::M_reward_distribution_grouping' has a wrong offset!");
static_assert(offsetof(FCARewardDistributionIdentifierMappingData, M_theme_pack_tags) == 0x000040, "Member 'FCARewardDistributionIdentifierMappingData::M_theme_pack_tags' has a wrong offset!");

// ScriptStruct keaton.NamedFloatArray
// 0x0010 (0x0118 - 0x0108)
struct FNamedFloatArray final : public FFastArraySerializer
{
public:
	TArray<struct FNamedFloatEntry>               Items;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNamedFloatArray) == 0x000008, "Wrong alignment on FNamedFloatArray");
static_assert(sizeof(FNamedFloatArray) == 0x000118, "Wrong size on FNamedFloatArray");
static_assert(offsetof(FNamedFloatArray, Items) == 0x000108, "Member 'FNamedFloatArray::Items' has a wrong offset!");

// ScriptStruct keaton.CAEquipmentAbilitySpecHandles
// 0x0020 (0x0020 - 0x0000)
struct FCAEquipmentAbilitySpecHandles final
{
public:
	struct FGameplayAbilitySpecHandle             M_primary;                                         // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             M_secondary;                                       // 0x0004(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             M_tertiary;                                        // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             M_mode_switch;                                     // 0x000C(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayAbilitySpecHandle>     M_additional_abilities;                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAEquipmentAbilitySpecHandles) == 0x000008, "Wrong alignment on FCAEquipmentAbilitySpecHandles");
static_assert(sizeof(FCAEquipmentAbilitySpecHandles) == 0x000020, "Wrong size on FCAEquipmentAbilitySpecHandles");
static_assert(offsetof(FCAEquipmentAbilitySpecHandles, M_primary) == 0x000000, "Member 'FCAEquipmentAbilitySpecHandles::M_primary' has a wrong offset!");
static_assert(offsetof(FCAEquipmentAbilitySpecHandles, M_secondary) == 0x000004, "Member 'FCAEquipmentAbilitySpecHandles::M_secondary' has a wrong offset!");
static_assert(offsetof(FCAEquipmentAbilitySpecHandles, M_tertiary) == 0x000008, "Member 'FCAEquipmentAbilitySpecHandles::M_tertiary' has a wrong offset!");
static_assert(offsetof(FCAEquipmentAbilitySpecHandles, M_mode_switch) == 0x00000C, "Member 'FCAEquipmentAbilitySpecHandles::M_mode_switch' has a wrong offset!");
static_assert(offsetof(FCAEquipmentAbilitySpecHandles, M_additional_abilities) == 0x000010, "Member 'FCAEquipmentAbilitySpecHandles::M_additional_abilities' has a wrong offset!");

// ScriptStruct keaton.CAForceFeedback_EffectSet
// 0x0018 (0x0018 - 0x0000)
struct FCAForceFeedback_EffectSet final
{
public:
	class UForceFeedbackEffect*                   M_2_motor_FX;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   M_4_motor_FX;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundWave*                             M_PS5_soundwave_FX;                                // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAForceFeedback_EffectSet) == 0x000008, "Wrong alignment on FCAForceFeedback_EffectSet");
static_assert(sizeof(FCAForceFeedback_EffectSet) == 0x000018, "Wrong size on FCAForceFeedback_EffectSet");
static_assert(offsetof(FCAForceFeedback_EffectSet, M_2_motor_FX) == 0x000000, "Member 'FCAForceFeedback_EffectSet::M_2_motor_FX' has a wrong offset!");
static_assert(offsetof(FCAForceFeedback_EffectSet, M_4_motor_FX) == 0x000008, "Member 'FCAForceFeedback_EffectSet::M_4_motor_FX' has a wrong offset!");
static_assert(offsetof(FCAForceFeedback_EffectSet, M_PS5_soundwave_FX) == 0x000010, "Member 'FCAForceFeedback_EffectSet::M_PS5_soundwave_FX' has a wrong offset!");

// ScriptStruct keaton.CAForceFeedbackItem
// 0x0028 (0x0028 - 0x0000)
struct FCAForceFeedbackItem final
{
public:
	struct FGameplayTag                           M_tag;                                             // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAForceFeedback_EffectSet             M_effects;                                         // 0x0010(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAForceFeedbackItem) == 0x000008, "Wrong alignment on FCAForceFeedbackItem");
static_assert(sizeof(FCAForceFeedbackItem) == 0x000028, "Wrong size on FCAForceFeedbackItem");
static_assert(offsetof(FCAForceFeedbackItem, M_tag) == 0x000000, "Member 'FCAForceFeedbackItem::M_tag' has a wrong offset!");
static_assert(offsetof(FCAForceFeedbackItem, M_effects) == 0x000010, "Member 'FCAForceFeedbackItem::M_effects' has a wrong offset!");

// ScriptStruct keaton.FrontEndPropData
// 0x0080 (0x0080 - 0x0000)
struct FFrontEndPropData final
{
public:
	class FName                                   M_prop_name;                                       // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 M_prop_class;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_bone_name;                                       // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      M_prop_opening_anim_sequence;                      // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_prop_loop_anim_sequence;                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_prop_spawn_offset;                               // 0x0040(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_should_loop_opening_anim;                        // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0xF];                                       // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFrontEndPropData) == 0x000010, "Wrong alignment on FFrontEndPropData");
static_assert(sizeof(FFrontEndPropData) == 0x000080, "Wrong size on FFrontEndPropData");
static_assert(offsetof(FFrontEndPropData, M_prop_name) == 0x000000, "Member 'FFrontEndPropData::M_prop_name' has a wrong offset!");
static_assert(offsetof(FFrontEndPropData, M_prop_class) == 0x000010, "Member 'FFrontEndPropData::M_prop_class' has a wrong offset!");
static_assert(offsetof(FFrontEndPropData, M_bone_name) == 0x000018, "Member 'FFrontEndPropData::M_bone_name' has a wrong offset!");
static_assert(offsetof(FFrontEndPropData, M_prop_opening_anim_sequence) == 0x000028, "Member 'FFrontEndPropData::M_prop_opening_anim_sequence' has a wrong offset!");
static_assert(offsetof(FFrontEndPropData, M_prop_loop_anim_sequence) == 0x000030, "Member 'FFrontEndPropData::M_prop_loop_anim_sequence' has a wrong offset!");
static_assert(offsetof(FFrontEndPropData, M_prop_spawn_offset) == 0x000040, "Member 'FFrontEndPropData::M_prop_spawn_offset' has a wrong offset!");
static_assert(offsetof(FFrontEndPropData, M_should_loop_opening_anim) == 0x000070, "Member 'FFrontEndPropData::M_should_loop_opening_anim' has a wrong offset!");

// ScriptStruct keaton.FrontEndFidgetAnimationData
// 0x0060 (0x0060 - 0x0000)
struct FFrontEndFidgetAnimationData final
{
public:
	class UAnimSequence*                          M_fidget_anim_sequence;                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UAnimSequenceBase*>   M_prop_fidget_anim;                                // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         M_blend_in_time;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_blend_out_time;                                  // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFrontEndFidgetAnimationData) == 0x000008, "Wrong alignment on FFrontEndFidgetAnimationData");
static_assert(sizeof(FFrontEndFidgetAnimationData) == 0x000060, "Wrong size on FFrontEndFidgetAnimationData");
static_assert(offsetof(FFrontEndFidgetAnimationData, M_fidget_anim_sequence) == 0x000000, "Member 'FFrontEndFidgetAnimationData::M_fidget_anim_sequence' has a wrong offset!");
static_assert(offsetof(FFrontEndFidgetAnimationData, M_prop_fidget_anim) == 0x000008, "Member 'FFrontEndFidgetAnimationData::M_prop_fidget_anim' has a wrong offset!");
static_assert(offsetof(FFrontEndFidgetAnimationData, M_blend_in_time) == 0x000058, "Member 'FFrontEndFidgetAnimationData::M_blend_in_time' has a wrong offset!");
static_assert(offsetof(FFrontEndFidgetAnimationData, M_blend_out_time) == 0x00005C, "Member 'FFrontEndFidgetAnimationData::M_blend_out_time' has a wrong offset!");

// ScriptStruct keaton.FrontEndAnimationData
// 0x0050 (0x0050 - 0x0000)
struct FFrontEndAnimationData final
{
public:
	class UAnimSequenceBase*                      M_opening_anim_sequence;                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_loop_anim_sequence;                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFrontEndPropData>              M_props_list_to_spawn;                             // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_fidget_min_wait_cycles;                          // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_fidget_max_wait_cycles;                          // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFrontEndFidgetAnimationData>   M_fidget_animation_data;                           // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_current_cycle;                                   // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFrontEndFidgetAnimationData>   M_available_fidget_animations;                     // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFrontEndAnimationData) == 0x000008, "Wrong alignment on FFrontEndAnimationData");
static_assert(sizeof(FFrontEndAnimationData) == 0x000050, "Wrong size on FFrontEndAnimationData");
static_assert(offsetof(FFrontEndAnimationData, M_opening_anim_sequence) == 0x000000, "Member 'FFrontEndAnimationData::M_opening_anim_sequence' has a wrong offset!");
static_assert(offsetof(FFrontEndAnimationData, M_loop_anim_sequence) == 0x000008, "Member 'FFrontEndAnimationData::M_loop_anim_sequence' has a wrong offset!");
static_assert(offsetof(FFrontEndAnimationData, M_props_list_to_spawn) == 0x000010, "Member 'FFrontEndAnimationData::M_props_list_to_spawn' has a wrong offset!");
static_assert(offsetof(FFrontEndAnimationData, M_fidget_min_wait_cycles) == 0x000020, "Member 'FFrontEndAnimationData::M_fidget_min_wait_cycles' has a wrong offset!");
static_assert(offsetof(FFrontEndAnimationData, M_fidget_max_wait_cycles) == 0x000024, "Member 'FFrontEndAnimationData::M_fidget_max_wait_cycles' has a wrong offset!");
static_assert(offsetof(FFrontEndAnimationData, M_fidget_animation_data) == 0x000028, "Member 'FFrontEndAnimationData::M_fidget_animation_data' has a wrong offset!");
static_assert(offsetof(FFrontEndAnimationData, M_current_cycle) == 0x000038, "Member 'FFrontEndAnimationData::M_current_cycle' has a wrong offset!");
static_assert(offsetof(FFrontEndAnimationData, M_available_fidget_animations) == 0x000040, "Member 'FFrontEndAnimationData::M_available_fidget_animations' has a wrong offset!");

// ScriptStruct keaton.CAMenuNavigationGroup
// 0x0080 (0x0080 - 0x0000)
struct FCAMenuNavigationGroup final
{
public:
	ECANavigationIndices                          M_navigation_index;                                // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_non_transition_menu;                             // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAGameDatabaseRowHandle               M_parent_menu_data_handle;                         // 0x0004(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAUITransitionDefinition              M_parent_internal_transition;                      // 0x001C(0x0018)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAMenuNavigationItem>          M_menu_items;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_mediator;                                        // 0x0048(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_expand_header;                                   // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMenuNavigationGroup) == 0x000008, "Wrong alignment on FCAMenuNavigationGroup");
static_assert(sizeof(FCAMenuNavigationGroup) == 0x000080, "Wrong size on FCAMenuNavigationGroup");
static_assert(offsetof(FCAMenuNavigationGroup, M_navigation_index) == 0x000000, "Member 'FCAMenuNavigationGroup::M_navigation_index' has a wrong offset!");
static_assert(offsetof(FCAMenuNavigationGroup, M_non_transition_menu) == 0x000001, "Member 'FCAMenuNavigationGroup::M_non_transition_menu' has a wrong offset!");
static_assert(offsetof(FCAMenuNavigationGroup, M_parent_menu_data_handle) == 0x000004, "Member 'FCAMenuNavigationGroup::M_parent_menu_data_handle' has a wrong offset!");
static_assert(offsetof(FCAMenuNavigationGroup, M_parent_internal_transition) == 0x00001C, "Member 'FCAMenuNavigationGroup::M_parent_internal_transition' has a wrong offset!");
static_assert(offsetof(FCAMenuNavigationGroup, M_menu_items) == 0x000038, "Member 'FCAMenuNavigationGroup::M_menu_items' has a wrong offset!");
static_assert(offsetof(FCAMenuNavigationGroup, M_mediator) == 0x000048, "Member 'FCAMenuNavigationGroup::M_mediator' has a wrong offset!");
static_assert(offsetof(FCAMenuNavigationGroup, M_expand_header) == 0x000078, "Member 'FCAMenuNavigationGroup::M_expand_header' has a wrong offset!");

// ScriptStruct keaton.CAChildActors
// 0x0018 (0x0018 - 0x0000)
struct FCAChildActors final
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Anchors;                                           // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAChildActors) == 0x000008, "Wrong alignment on FCAChildActors");
static_assert(sizeof(FCAChildActors) == 0x000018, "Wrong size on FCAChildActors");
static_assert(offsetof(FCAChildActors, ActorClass) == 0x000000, "Member 'FCAChildActors::ActorClass' has a wrong offset!");
static_assert(offsetof(FCAChildActors, Anchors) == 0x000008, "Member 'FCAChildActors::Anchors' has a wrong offset!");

// ScriptStruct keaton.CALayerEffectVariant
// 0x0020 (0x0020 - 0x0000)
struct FCALayerEffectVariant final
{
public:
	class FName                                   Identifier;                                        // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     Material;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Hide_mesh_underneath;                              // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCALayerEffectVariant) == 0x000008, "Wrong alignment on FCALayerEffectVariant");
static_assert(sizeof(FCALayerEffectVariant) == 0x000020, "Wrong size on FCALayerEffectVariant");
static_assert(offsetof(FCALayerEffectVariant, Identifier) == 0x000000, "Member 'FCALayerEffectVariant::Identifier' has a wrong offset!");
static_assert(offsetof(FCALayerEffectVariant, Material) == 0x000010, "Member 'FCALayerEffectVariant::Material' has a wrong offset!");
static_assert(offsetof(FCALayerEffectVariant, Hide_mesh_underneath) == 0x000018, "Member 'FCALayerEffectVariant::Hide_mesh_underneath' has a wrong offset!");

// ScriptStruct keaton.CALayerEffectRow
// 0x0030 (0x0038 - 0x0008)
struct FCALayerEffectRow final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     Material;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Hide_mesh_underneath;                              // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCALayerEffectVariant>          Variants;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALayerEffectRow) == 0x000008, "Wrong alignment on FCALayerEffectRow");
static_assert(sizeof(FCALayerEffectRow) == 0x000038, "Wrong size on FCALayerEffectRow");
static_assert(offsetof(FCALayerEffectRow, Name) == 0x000008, "Member 'FCALayerEffectRow::Name' has a wrong offset!");
static_assert(offsetof(FCALayerEffectRow, Material) == 0x000018, "Member 'FCALayerEffectRow::Material' has a wrong offset!");
static_assert(offsetof(FCALayerEffectRow, Hide_mesh_underneath) == 0x000020, "Member 'FCALayerEffectRow::Hide_mesh_underneath' has a wrong offset!");
static_assert(offsetof(FCALayerEffectRow, Variants) == 0x000028, "Member 'FCALayerEffectRow::Variants' has a wrong offset!");

// ScriptStruct keaton.CAMissingLimbsData
// 0x0018 (0x0018 - 0x0000)
struct FCAMissingLimbsData final
{
public:
	uint32                                        M_amputated_limbs_mask;                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_disabled_bones_indices;                          // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMissingLimbsData) == 0x000008, "Wrong alignment on FCAMissingLimbsData");
static_assert(sizeof(FCAMissingLimbsData) == 0x000018, "Wrong size on FCAMissingLimbsData");
static_assert(offsetof(FCAMissingLimbsData, M_amputated_limbs_mask) == 0x000000, "Member 'FCAMissingLimbsData::M_amputated_limbs_mask' has a wrong offset!");
static_assert(offsetof(FCAMissingLimbsData, M_disabled_bones_indices) == 0x000008, "Member 'FCAMissingLimbsData::M_disabled_bones_indices' has a wrong offset!");

// ScriptStruct keaton.HitReactionDatabase
// 0x0010 (0x0010 - 0x0000)
struct FHitReactionDatabase final
{
public:
	TArray<struct FHitReactionEntry>              M_entries;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitReactionDatabase) == 0x000008, "Wrong alignment on FHitReactionDatabase");
static_assert(sizeof(FHitReactionDatabase) == 0x000010, "Wrong size on FHitReactionDatabase");
static_assert(offsetof(FHitReactionDatabase, M_entries) == 0x000000, "Member 'FHitReactionDatabase::M_entries' has a wrong offset!");

// ScriptStruct keaton.CAPredictedDamageDoneDataType
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FCAPredictedDamageDoneDataType final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPredictedDamageDoneDataType) == 0x000004, "Wrong alignment on FCAPredictedDamageDoneDataType");
static_assert(sizeof(FCAPredictedDamageDoneDataType) == 0x00000C, "Wrong size on FCAPredictedDamageDoneDataType");

// ScriptStruct keaton.InstantHitImpactMetaData
// 0x0030 (0x0030 - 0x0000)
struct FInstantHitImpactMetaData final
{
public:
	struct FGameplayTag                           M_hit_location_ID;                                 // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  M_owning_actor;                                    // 0x000C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAPredictedDamageDoneDataType> M_damage_done;                                     // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         M_server_time;                                     // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInstantHitImpactMetaData) == 0x000008, "Wrong alignment on FInstantHitImpactMetaData");
static_assert(sizeof(FInstantHitImpactMetaData) == 0x000030, "Wrong size on FInstantHitImpactMetaData");
static_assert(offsetof(FInstantHitImpactMetaData, M_hit_location_ID) == 0x000000, "Member 'FInstantHitImpactMetaData::M_hit_location_ID' has a wrong offset!");
static_assert(offsetof(FInstantHitImpactMetaData, M_owning_actor) == 0x00000C, "Member 'FInstantHitImpactMetaData::M_owning_actor' has a wrong offset!");
static_assert(offsetof(FInstantHitImpactMetaData, M_damage_done) == 0x000018, "Member 'FInstantHitImpactMetaData::M_damage_done' has a wrong offset!");
static_assert(offsetof(FInstantHitImpactMetaData, M_server_time) == 0x000028, "Member 'FInstantHitImpactMetaData::M_server_time' has a wrong offset!");

// ScriptStruct keaton.CAGameplayAbilityTargetData_SingleTargetHit
// 0x0038 (0x00D8 - 0x00A0)
struct FCAGameplayAbilityTargetData_SingleTargetHit final : public FGameplayAbilityTargetData_SingleTargetHit
{
public:
	struct FInstantHitImpactMetaData              M_impact_meta_data;                                // 0x00A0(0x0030)(NativeAccessSpecifierPublic)
	bool                                          M_from_slave;                                      // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAGameplayAbilityTargetData_SingleTargetHit) == 0x000008, "Wrong alignment on FCAGameplayAbilityTargetData_SingleTargetHit");
static_assert(sizeof(FCAGameplayAbilityTargetData_SingleTargetHit) == 0x0000D8, "Wrong size on FCAGameplayAbilityTargetData_SingleTargetHit");
static_assert(offsetof(FCAGameplayAbilityTargetData_SingleTargetHit, M_impact_meta_data) == 0x0000A0, "Member 'FCAGameplayAbilityTargetData_SingleTargetHit::M_impact_meta_data' has a wrong offset!");
static_assert(offsetof(FCAGameplayAbilityTargetData_SingleTargetHit, M_from_slave) == 0x0000D0, "Member 'FCAGameplayAbilityTargetData_SingleTargetHit::M_from_slave' has a wrong offset!");

// ScriptStruct keaton.CAFastPathLevelStreamerLoadingTime
// 0x0018 (0x0018 - 0x0000)
struct FCAFastPathLevelStreamerLoadingTime final
{
public:
	class FString                                 Level_name;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Elapsed_time;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Timed_out;                                         // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAFastPathLevelStreamerLoadingTime) == 0x000008, "Wrong alignment on FCAFastPathLevelStreamerLoadingTime");
static_assert(sizeof(FCAFastPathLevelStreamerLoadingTime) == 0x000018, "Wrong size on FCAFastPathLevelStreamerLoadingTime");
static_assert(offsetof(FCAFastPathLevelStreamerLoadingTime, Level_name) == 0x000000, "Member 'FCAFastPathLevelStreamerLoadingTime::Level_name' has a wrong offset!");
static_assert(offsetof(FCAFastPathLevelStreamerLoadingTime, Elapsed_time) == 0x000010, "Member 'FCAFastPathLevelStreamerLoadingTime::Elapsed_time' has a wrong offset!");
static_assert(offsetof(FCAFastPathLevelStreamerLoadingTime, Timed_out) == 0x000014, "Member 'FCAFastPathLevelStreamerLoadingTime::Timed_out' has a wrong offset!");

// ScriptStruct keaton.CAFeatureTemplateOverride
// 0x0020 (0x0020 - 0x0000)
struct FCAFeatureTemplateOverride final
{
public:
	struct FFeatureKeyItem                        FeatureKey;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCADataTableRowHandle                  Template;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFeatureTemplateOverride) == 0x000008, "Wrong alignment on FCAFeatureTemplateOverride");
static_assert(sizeof(FCAFeatureTemplateOverride) == 0x000020, "Wrong size on FCAFeatureTemplateOverride");
static_assert(offsetof(FCAFeatureTemplateOverride, FeatureKey) == 0x000000, "Member 'FCAFeatureTemplateOverride::FeatureKey' has a wrong offset!");
static_assert(offsetof(FCAFeatureTemplateOverride, Template) == 0x000008, "Member 'FCAFeatureTemplateOverride::Template' has a wrong offset!");

// ScriptStruct keaton.CAMuzzleData
// 0x0010 (0x0010 - 0x0000)
struct FCAMuzzleData final
{
public:
	class UCAWeaponMuzzleComponent*               M_weapon_muzzle_component;                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMuzzleData) == 0x000008, "Wrong alignment on FCAMuzzleData");
static_assert(sizeof(FCAMuzzleData) == 0x000010, "Wrong size on FCAMuzzleData");
static_assert(offsetof(FCAMuzzleData, M_weapon_muzzle_component) == 0x000000, "Member 'FCAMuzzleData::M_weapon_muzzle_component' has a wrong offset!");

// ScriptStruct keaton.CAAnimInstance_Component_Audio
// 0x0040 (0x0050 - 0x0010)
struct FCAAnimInstance_Component_Audio final : public FCAAnimInstance_Component
{
public:
	struct FCAAudioEventType                      M_in_event;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_out_event;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_in_threshold;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_out_threshold;                                   // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x30];                                      // 0x0020(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAnimInstance_Component_Audio) == 0x000008, "Wrong alignment on FCAAnimInstance_Component_Audio");
static_assert(sizeof(FCAAnimInstance_Component_Audio) == 0x000050, "Wrong size on FCAAnimInstance_Component_Audio");
static_assert(offsetof(FCAAnimInstance_Component_Audio, M_in_event) == 0x000010, "Member 'FCAAnimInstance_Component_Audio::M_in_event' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Audio, M_out_event) == 0x000014, "Member 'FCAAnimInstance_Component_Audio::M_out_event' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Audio, M_in_threshold) == 0x000018, "Member 'FCAAnimInstance_Component_Audio::M_in_threshold' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Audio, M_out_threshold) == 0x00001C, "Member 'FCAAnimInstance_Component_Audio::M_out_threshold' has a wrong offset!");

// ScriptStruct keaton.CAUIEventData
// 0x0080 (0x0080 - 0x0000)
struct FCAUIEventData final
{
public:
	ECAUIEventType                                M_event_type;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                M_payload;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_name;                                            // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_switch;                                          // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_index;                                           // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_float;                                           // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_text;                                            // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 M_string;                                          // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAText                                M_localisable_text;                                // 0x0050(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAUIEventData) == 0x000008, "Wrong alignment on FCAUIEventData");
static_assert(sizeof(FCAUIEventData) == 0x000080, "Wrong size on FCAUIEventData");
static_assert(offsetof(FCAUIEventData, M_event_type) == 0x000000, "Member 'FCAUIEventData::M_event_type' has a wrong offset!");
static_assert(offsetof(FCAUIEventData, M_payload) == 0x000008, "Member 'FCAUIEventData::M_payload' has a wrong offset!");
static_assert(offsetof(FCAUIEventData, M_name) == 0x000010, "Member 'FCAUIEventData::M_name' has a wrong offset!");
static_assert(offsetof(FCAUIEventData, M_switch) == 0x00001C, "Member 'FCAUIEventData::M_switch' has a wrong offset!");
static_assert(offsetof(FCAUIEventData, M_index) == 0x000020, "Member 'FCAUIEventData::M_index' has a wrong offset!");
static_assert(offsetof(FCAUIEventData, M_float) == 0x000024, "Member 'FCAUIEventData::M_float' has a wrong offset!");
static_assert(offsetof(FCAUIEventData, M_text) == 0x000028, "Member 'FCAUIEventData::M_text' has a wrong offset!");
static_assert(offsetof(FCAUIEventData, M_string) == 0x000040, "Member 'FCAUIEventData::M_string' has a wrong offset!");
static_assert(offsetof(FCAUIEventData, M_localisable_text) == 0x000050, "Member 'FCAUIEventData::M_localisable_text' has a wrong offset!");

// ScriptStruct keaton.CAPlatformSpecificOptionText
// 0x0038 (0x0038 - 0x0000)
struct FCAPlatformSpecificOptionText final
{
public:
	struct FCAText                                M_option_text;                                     // 0x0000(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAUIFlags                             M_flags;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPlatformSpecificOptionText) == 0x000008, "Wrong alignment on FCAPlatformSpecificOptionText");
static_assert(sizeof(FCAPlatformSpecificOptionText) == 0x000038, "Wrong size on FCAPlatformSpecificOptionText");
static_assert(offsetof(FCAPlatformSpecificOptionText, M_option_text) == 0x000000, "Member 'FCAPlatformSpecificOptionText::M_option_text' has a wrong offset!");
static_assert(offsetof(FCAPlatformSpecificOptionText, M_flags) == 0x000030, "Member 'FCAPlatformSpecificOptionText::M_flags' has a wrong offset!");

// ScriptStruct keaton.CADialogueData
// 0x01F0 (0x01F0 - 0x0000)
struct FCADialogueData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_title;                                           // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCAText                                M_message;                                         // 0x0038(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_appear_audio;                                    // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_confirm_text;                                    // 0x0070(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_confirm_audio;                                   // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_cancel_text;                                     // 0x00A8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_cancel_audio;                                    // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_third_option_text;                               // 0x00E0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FCAPlatformSpecificOptionText>  M_third_option_platform_specific_texts;            // 0x0110(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 M_guid;                                            // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_add_to_notification_history;                     // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_screen_time;                                     // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_show_avatar;                                     // 0x013C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D[0xAB];                                     // 0x013D(0x00AB)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                M_payload;                                         // 0x01E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADialogueData) == 0x000008, "Wrong alignment on FCADialogueData");
static_assert(sizeof(FCADialogueData) == 0x0001F0, "Wrong size on FCADialogueData");
static_assert(offsetof(FCADialogueData, M_title) == 0x000008, "Member 'FCADialogueData::M_title' has a wrong offset!");
static_assert(offsetof(FCADialogueData, M_message) == 0x000038, "Member 'FCADialogueData::M_message' has a wrong offset!");
static_assert(offsetof(FCADialogueData, M_appear_audio) == 0x000068, "Member 'FCADialogueData::M_appear_audio' has a wrong offset!");
static_assert(offsetof(FCADialogueData, M_confirm_text) == 0x000070, "Member 'FCADialogueData::M_confirm_text' has a wrong offset!");
static_assert(offsetof(FCADialogueData, M_confirm_audio) == 0x0000A0, "Member 'FCADialogueData::M_confirm_audio' has a wrong offset!");
static_assert(offsetof(FCADialogueData, M_cancel_text) == 0x0000A8, "Member 'FCADialogueData::M_cancel_text' has a wrong offset!");
static_assert(offsetof(FCADialogueData, M_cancel_audio) == 0x0000D8, "Member 'FCADialogueData::M_cancel_audio' has a wrong offset!");
static_assert(offsetof(FCADialogueData, M_third_option_text) == 0x0000E0, "Member 'FCADialogueData::M_third_option_text' has a wrong offset!");
static_assert(offsetof(FCADialogueData, M_third_option_platform_specific_texts) == 0x000110, "Member 'FCADialogueData::M_third_option_platform_specific_texts' has a wrong offset!");
static_assert(offsetof(FCADialogueData, M_guid) == 0x000120, "Member 'FCADialogueData::M_guid' has a wrong offset!");
static_assert(offsetof(FCADialogueData, M_add_to_notification_history) == 0x000130, "Member 'FCADialogueData::M_add_to_notification_history' has a wrong offset!");
static_assert(offsetof(FCADialogueData, M_screen_time) == 0x000138, "Member 'FCADialogueData::M_screen_time' has a wrong offset!");
static_assert(offsetof(FCADialogueData, M_show_avatar) == 0x00013C, "Member 'FCADialogueData::M_show_avatar' has a wrong offset!");
static_assert(offsetof(FCADialogueData, M_payload) == 0x0001E8, "Member 'FCADialogueData::M_payload' has a wrong offset!");

// ScriptStruct keaton.NPCRegisteredPosition
// 0x0018 (0x0018 - 0x0000)
struct FNPCRegisteredPosition
{
public:
	class AActor*                                 M_registered_npc;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_location;                                        // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCRegisteredPosition) == 0x000008, "Wrong alignment on FNPCRegisteredPosition");
static_assert(sizeof(FNPCRegisteredPosition) == 0x000018, "Wrong size on FNPCRegisteredPosition");
static_assert(offsetof(FNPCRegisteredPosition, M_registered_npc) == 0x000000, "Member 'FNPCRegisteredPosition::M_registered_npc' has a wrong offset!");
static_assert(offsetof(FNPCRegisteredPosition, M_location) == 0x000008, "Member 'FNPCRegisteredPosition::M_location' has a wrong offset!");

// ScriptStruct keaton.NPCRegisteredStayAwayPosition
// 0x0008 (0x0020 - 0x0018)
struct FNPCRegisteredStayAwayPosition final : public FNPCRegisteredPosition
{
public:
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCRegisteredStayAwayPosition) == 0x000008, "Wrong alignment on FNPCRegisteredStayAwayPosition");
static_assert(sizeof(FNPCRegisteredStayAwayPosition) == 0x000020, "Wrong size on FNPCRegisteredStayAwayPosition");

// ScriptStruct keaton.CATeamStats
// 0x0020 (0x0020 - 0x0000)
struct FCATeamStats final
{
public:
	TArray<struct FCAPlayerStats>                 M_player_stats;                                    // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_loot_stats;                                      // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATeamStats) == 0x000008, "Wrong alignment on FCATeamStats");
static_assert(sizeof(FCATeamStats) == 0x000020, "Wrong size on FCATeamStats");
static_assert(offsetof(FCATeamStats, M_player_stats) == 0x000000, "Member 'FCATeamStats::M_player_stats' has a wrong offset!");
static_assert(offsetof(FCATeamStats, M_loot_stats) == 0x000010, "Member 'FCATeamStats::M_loot_stats' has a wrong offset!");

// ScriptStruct keaton.CAPostGameInfo
// 0x0048 (0x0048 - 0x0000)
struct FCAPostGameInfo final
{
public:
	ECAEndGameReason                              M_end_game_reason;                                 // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_success;                                         // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_match_complete;                                  // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_team_rank;                                       // 0x0003(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAClientConnection>            M_disconnected_teammates_history;                  // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCAKDAStats>                    M_kda_stats;                                       // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCATeamStats                           M_team_stats;                                      // 0x0028(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPostGameInfo) == 0x000008, "Wrong alignment on FCAPostGameInfo");
static_assert(sizeof(FCAPostGameInfo) == 0x000048, "Wrong size on FCAPostGameInfo");
static_assert(offsetof(FCAPostGameInfo, M_end_game_reason) == 0x000000, "Member 'FCAPostGameInfo::M_end_game_reason' has a wrong offset!");
static_assert(offsetof(FCAPostGameInfo, M_success) == 0x000001, "Member 'FCAPostGameInfo::M_success' has a wrong offset!");
static_assert(offsetof(FCAPostGameInfo, M_match_complete) == 0x000002, "Member 'FCAPostGameInfo::M_match_complete' has a wrong offset!");
static_assert(offsetof(FCAPostGameInfo, M_team_rank) == 0x000003, "Member 'FCAPostGameInfo::M_team_rank' has a wrong offset!");
static_assert(offsetof(FCAPostGameInfo, M_disconnected_teammates_history) == 0x000008, "Member 'FCAPostGameInfo::M_disconnected_teammates_history' has a wrong offset!");
static_assert(offsetof(FCAPostGameInfo, M_kda_stats) == 0x000018, "Member 'FCAPostGameInfo::M_kda_stats' has a wrong offset!");
static_assert(offsetof(FCAPostGameInfo, M_team_stats) == 0x000028, "Member 'FCAPostGameInfo::M_team_stats' has a wrong offset!");

// ScriptStruct keaton.SysAreaSensorState
// 0x0004 (0x0004 - 0x0000)
struct FSysAreaSensorState final
{
public:
	int8                                          M_zero_gravity_count;                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          M_security_elevated_count;                         // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          M_security_breach_count;                           // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          M_security_lockdown_count;                         // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSysAreaSensorState) == 0x000001, "Wrong alignment on FSysAreaSensorState");
static_assert(sizeof(FSysAreaSensorState) == 0x000004, "Wrong size on FSysAreaSensorState");
static_assert(offsetof(FSysAreaSensorState, M_zero_gravity_count) == 0x000000, "Member 'FSysAreaSensorState::M_zero_gravity_count' has a wrong offset!");
static_assert(offsetof(FSysAreaSensorState, M_security_elevated_count) == 0x000001, "Member 'FSysAreaSensorState::M_security_elevated_count' has a wrong offset!");
static_assert(offsetof(FSysAreaSensorState, M_security_breach_count) == 0x000002, "Member 'FSysAreaSensorState::M_security_breach_count' has a wrong offset!");
static_assert(offsetof(FSysAreaSensorState, M_security_lockdown_count) == 0x000003, "Member 'FSysAreaSensorState::M_security_lockdown_count' has a wrong offset!");

// ScriptStruct keaton.CALoadoutSlots
// 0x0040 (0x0040 - 0x0000)
struct FCALoadoutSlots final
{
public:
	TArray<class FName>                           M_item_names;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_skin_names;                                      // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_cosmetic_names;                                  // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_perks_names;                                     // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALoadoutSlots) == 0x000008, "Wrong alignment on FCALoadoutSlots");
static_assert(sizeof(FCALoadoutSlots) == 0x000040, "Wrong size on FCALoadoutSlots");
static_assert(offsetof(FCALoadoutSlots, M_item_names) == 0x000000, "Member 'FCALoadoutSlots::M_item_names' has a wrong offset!");
static_assert(offsetof(FCALoadoutSlots, M_skin_names) == 0x000010, "Member 'FCALoadoutSlots::M_skin_names' has a wrong offset!");
static_assert(offsetof(FCALoadoutSlots, M_cosmetic_names) == 0x000020, "Member 'FCALoadoutSlots::M_cosmetic_names' has a wrong offset!");
static_assert(offsetof(FCALoadoutSlots, M_perks_names) == 0x000030, "Member 'FCALoadoutSlots::M_perks_names' has a wrong offset!");

// ScriptStruct keaton.CALoadoutEquipageResponseData
// 0x0060 (0x0060 - 0x0000)
struct FCALoadoutEquipageResponseData final
{
public:
	struct FCALoadoutSlots                        M_loadout;                                         // 0x0000(0x0040)(NativeAccessSpecifierPublic)
	ECAEquippedStatus                             M_equipped_status;                                 // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              M_timestamp;                                       // 0x0048(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_services_id;                                     // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALoadoutEquipageResponseData) == 0x000008, "Wrong alignment on FCALoadoutEquipageResponseData");
static_assert(sizeof(FCALoadoutEquipageResponseData) == 0x000060, "Wrong size on FCALoadoutEquipageResponseData");
static_assert(offsetof(FCALoadoutEquipageResponseData, M_loadout) == 0x000000, "Member 'FCALoadoutEquipageResponseData::M_loadout' has a wrong offset!");
static_assert(offsetof(FCALoadoutEquipageResponseData, M_equipped_status) == 0x000040, "Member 'FCALoadoutEquipageResponseData::M_equipped_status' has a wrong offset!");
static_assert(offsetof(FCALoadoutEquipageResponseData, M_timestamp) == 0x000048, "Member 'FCALoadoutEquipageResponseData::M_timestamp' has a wrong offset!");
static_assert(offsetof(FCALoadoutEquipageResponseData, M_services_id) == 0x000050, "Member 'FCALoadoutEquipageResponseData::M_services_id' has a wrong offset!");

// ScriptStruct keaton.CANPCGrenadeAbilityData
// 0x0048 (0x0048 - 0x0000)
struct FCANPCGrenadeAbilityData final
{
public:
	bool                                          M_use_spline_grenade;                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACAProjectileBase>          M_projectile;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACAProjectileBase>          M_spline_projectile;                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_launch_offset_local;                             // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_launch_speed;                                    // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_gravity_scale;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_try_throw_cooldown;                              // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_failed_throw_cooldown;                           // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_try_throw_min_range;                             // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_try_throw_max_range;                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_spline_speed_factor;                             // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_spline_arc_param;                                // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCGrenadeAbilityData) == 0x000008, "Wrong alignment on FCANPCGrenadeAbilityData");
static_assert(sizeof(FCANPCGrenadeAbilityData) == 0x000048, "Wrong size on FCANPCGrenadeAbilityData");
static_assert(offsetof(FCANPCGrenadeAbilityData, M_use_spline_grenade) == 0x000000, "Member 'FCANPCGrenadeAbilityData::M_use_spline_grenade' has a wrong offset!");
static_assert(offsetof(FCANPCGrenadeAbilityData, M_projectile) == 0x000008, "Member 'FCANPCGrenadeAbilityData::M_projectile' has a wrong offset!");
static_assert(offsetof(FCANPCGrenadeAbilityData, M_spline_projectile) == 0x000010, "Member 'FCANPCGrenadeAbilityData::M_spline_projectile' has a wrong offset!");
static_assert(offsetof(FCANPCGrenadeAbilityData, M_launch_offset_local) == 0x000018, "Member 'FCANPCGrenadeAbilityData::M_launch_offset_local' has a wrong offset!");
static_assert(offsetof(FCANPCGrenadeAbilityData, M_launch_speed) == 0x000024, "Member 'FCANPCGrenadeAbilityData::M_launch_speed' has a wrong offset!");
static_assert(offsetof(FCANPCGrenadeAbilityData, M_gravity_scale) == 0x000028, "Member 'FCANPCGrenadeAbilityData::M_gravity_scale' has a wrong offset!");
static_assert(offsetof(FCANPCGrenadeAbilityData, M_try_throw_cooldown) == 0x00002C, "Member 'FCANPCGrenadeAbilityData::M_try_throw_cooldown' has a wrong offset!");
static_assert(offsetof(FCANPCGrenadeAbilityData, M_failed_throw_cooldown) == 0x000030, "Member 'FCANPCGrenadeAbilityData::M_failed_throw_cooldown' has a wrong offset!");
static_assert(offsetof(FCANPCGrenadeAbilityData, M_try_throw_min_range) == 0x000034, "Member 'FCANPCGrenadeAbilityData::M_try_throw_min_range' has a wrong offset!");
static_assert(offsetof(FCANPCGrenadeAbilityData, M_try_throw_max_range) == 0x000038, "Member 'FCANPCGrenadeAbilityData::M_try_throw_max_range' has a wrong offset!");
static_assert(offsetof(FCANPCGrenadeAbilityData, M_spline_speed_factor) == 0x00003C, "Member 'FCANPCGrenadeAbilityData::M_spline_speed_factor' has a wrong offset!");
static_assert(offsetof(FCANPCGrenadeAbilityData, M_spline_arc_param) == 0x000040, "Member 'FCANPCGrenadeAbilityData::M_spline_arc_param' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_Slide_ProfileSetElt
// 0x0008 (0x0008 - 0x0000)
struct FCAMovementData_Slide_ProfileSetElt final
{
public:
	float                                         M_time;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_speed;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMovementData_Slide_ProfileSetElt) == 0x000004, "Wrong alignment on FCAMovementData_Slide_ProfileSetElt");
static_assert(sizeof(FCAMovementData_Slide_ProfileSetElt) == 0x000008, "Wrong size on FCAMovementData_Slide_ProfileSetElt");
static_assert(offsetof(FCAMovementData_Slide_ProfileSetElt, M_time) == 0x000000, "Member 'FCAMovementData_Slide_ProfileSetElt::M_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide_ProfileSetElt, M_speed) == 0x000004, "Member 'FCAMovementData_Slide_ProfileSetElt::M_speed' has a wrong offset!");

// ScriptStruct keaton.CAPurchaseOption
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FCAPurchaseOption final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPurchaseOption) == 0x000008, "Wrong alignment on FCAPurchaseOption");
static_assert(sizeof(FCAPurchaseOption) == 0x000040, "Wrong size on FCAPurchaseOption");

// ScriptStruct keaton.CAAnimInstance_Component_FP_Bank_Layer
// 0x0000 (0x0010 - 0x0010)
struct FCAAnimInstance_Component_FP_Bank_Layer final : public FCAAnimInstance_Component
{
};
static_assert(alignof(FCAAnimInstance_Component_FP_Bank_Layer) == 0x000008, "Wrong alignment on FCAAnimInstance_Component_FP_Bank_Layer");
static_assert(sizeof(FCAAnimInstance_Component_FP_Bank_Layer) == 0x000010, "Wrong size on FCAAnimInstance_Component_FP_Bank_Layer");

// ScriptStruct keaton.CAGetStringDelegate
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FCAGetStringDelegate final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAGetStringDelegate) == 0x000008, "Wrong alignment on FCAGetStringDelegate");
static_assert(sizeof(FCAGetStringDelegate) == 0x000028, "Wrong size on FCAGetStringDelegate");

// ScriptStruct keaton.CAPlayerProgressItem
// 0x0010 (0x001C - 0x000C)
struct FCAPlayerProgressItem final : public FFastArraySerializerItem
{
public:
	class FName                                   ChallengeId;                                       // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Progress;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPlayerProgressItem) == 0x000004, "Wrong alignment on FCAPlayerProgressItem");
static_assert(sizeof(FCAPlayerProgressItem) == 0x00001C, "Wrong size on FCAPlayerProgressItem");
static_assert(offsetof(FCAPlayerProgressItem, ChallengeId) == 0x00000C, "Member 'FCAPlayerProgressItem::ChallengeId' has a wrong offset!");
static_assert(offsetof(FCAPlayerProgressItem, Progress) == 0x000018, "Member 'FCAPlayerProgressItem::Progress' has a wrong offset!");

// ScriptStruct keaton.CABattleId
// 0x0018 (0x0018 - 0x0000)
struct FCABattleId final
{
public:
	class FString                                 Id;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        Timestamp;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCABattleId) == 0x000008, "Wrong alignment on FCABattleId");
static_assert(sizeof(FCABattleId) == 0x000018, "Wrong size on FCABattleId");
static_assert(offsetof(FCABattleId, Id) == 0x000000, "Member 'FCABattleId::Id' has a wrong offset!");
static_assert(offsetof(FCABattleId, Timestamp) == 0x000010, "Member 'FCABattleId::Timestamp' has a wrong offset!");

// ScriptStruct keaton.SysSensorEventDataBase
// 0x0010 (0x0010 - 0x0000)
struct FSysSensorEventDataBase final
{
public:
	class AActor*                                 M_instigator;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESysSensorEventType                           M_previous_event_type;                             // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESysSensorEventType                           M_current_event_type;                              // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_percentage;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSysSensorEventDataBase) == 0x000008, "Wrong alignment on FSysSensorEventDataBase");
static_assert(sizeof(FSysSensorEventDataBase) == 0x000010, "Wrong size on FSysSensorEventDataBase");
static_assert(offsetof(FSysSensorEventDataBase, M_instigator) == 0x000000, "Member 'FSysSensorEventDataBase::M_instigator' has a wrong offset!");
static_assert(offsetof(FSysSensorEventDataBase, M_previous_event_type) == 0x000008, "Member 'FSysSensorEventDataBase::M_previous_event_type' has a wrong offset!");
static_assert(offsetof(FSysSensorEventDataBase, M_current_event_type) == 0x000009, "Member 'FSysSensorEventDataBase::M_current_event_type' has a wrong offset!");
static_assert(offsetof(FSysSensorEventDataBase, M_percentage) == 0x00000C, "Member 'FSysSensorEventDataBase::M_percentage' has a wrong offset!");

// ScriptStruct keaton.CAFragGrenadeBounceData
// 0x0070 (0x0070 - 0x0000)
struct FCAFragGrenadeBounceData final
{
public:
	int32                                         bounce_num;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAGameplayEffectContainer             M_zero_g_effect_container;                         // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCAGameplayEffectContainer             M_one_g_effect_container;                          // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSubclassOf<class ACAExplosionEffect>         M_explosion_effect;                                // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    M_row_handle_zg_radius;                            // 0x0040(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    M_row_handle_1g_radius;                            // 0x0058(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFragGrenadeBounceData) == 0x000008, "Wrong alignment on FCAFragGrenadeBounceData");
static_assert(sizeof(FCAFragGrenadeBounceData) == 0x000070, "Wrong size on FCAFragGrenadeBounceData");
static_assert(offsetof(FCAFragGrenadeBounceData, bounce_num) == 0x000000, "Member 'FCAFragGrenadeBounceData::bounce_num' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeBounceData, M_zero_g_effect_container) == 0x000008, "Member 'FCAFragGrenadeBounceData::M_zero_g_effect_container' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeBounceData, M_one_g_effect_container) == 0x000020, "Member 'FCAFragGrenadeBounceData::M_one_g_effect_container' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeBounceData, M_explosion_effect) == 0x000038, "Member 'FCAFragGrenadeBounceData::M_explosion_effect' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeBounceData, M_row_handle_zg_radius) == 0x000040, "Member 'FCAFragGrenadeBounceData::M_row_handle_zg_radius' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeBounceData, M_row_handle_1g_radius) == 0x000058, "Member 'FCAFragGrenadeBounceData::M_row_handle_1g_radius' has a wrong offset!");

// ScriptStruct keaton.UserInteractionInfo
// 0x0008 (0x0008 - 0x0000)
struct FUserInteractionInfo final
{
public:
	class AActor*                                 M_user;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUserInteractionInfo) == 0x000008, "Wrong alignment on FUserInteractionInfo");
static_assert(sizeof(FUserInteractionInfo) == 0x000008, "Wrong size on FUserInteractionInfo");
static_assert(offsetof(FUserInteractionInfo, M_user) == 0x000000, "Member 'FUserInteractionInfo::M_user' has a wrong offset!");

// ScriptStruct keaton.CAAlignmentPoint
// 0x0020 (0x0020 - 0x0000)
struct FCAAlignmentPoint final
{
public:
	ECAAlignmentPosition                          M_alignment_position;                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_modes_allowed;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_mode_uses_alignment_transform;                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_mode_allows_multiple_sources;                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        M_alignment_point_blob_spawn_locations;            // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAlignmentPoint) == 0x000008, "Wrong alignment on FCAAlignmentPoint");
static_assert(sizeof(FCAAlignmentPoint) == 0x000020, "Wrong size on FCAAlignmentPoint");
static_assert(offsetof(FCAAlignmentPoint, M_alignment_position) == 0x000000, "Member 'FCAAlignmentPoint::M_alignment_position' has a wrong offset!");
static_assert(offsetof(FCAAlignmentPoint, M_modes_allowed) == 0x000004, "Member 'FCAAlignmentPoint::M_modes_allowed' has a wrong offset!");
static_assert(offsetof(FCAAlignmentPoint, M_mode_uses_alignment_transform) == 0x000008, "Member 'FCAAlignmentPoint::M_mode_uses_alignment_transform' has a wrong offset!");
static_assert(offsetof(FCAAlignmentPoint, M_mode_allows_multiple_sources) == 0x00000C, "Member 'FCAAlignmentPoint::M_mode_allows_multiple_sources' has a wrong offset!");
static_assert(offsetof(FCAAlignmentPoint, M_alignment_point_blob_spawn_locations) == 0x000010, "Member 'FCAAlignmentPoint::M_alignment_point_blob_spawn_locations' has a wrong offset!");

// ScriptStruct keaton.CAPrimaryMessageTypesTableRow
// 0x00C8 (0x00D0 - 0x0008)
struct FCAPrimaryMessageTypesTableRow final : public FTableRowBase
{
public:
	class FName                                   M_type;                                            // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAHUDPrimaryMessageQueueType                 M_queue_type;                                      // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_immediate_messages_group_id;                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_disabled;                                     // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCAHUDPrimaryMessageBase>   M_widget_class;                                    // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAText                                M_header;                                          // 0x0028(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCAText                                M_sub_header;                                      // 0x0058(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             M_icon;                                            // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             M_secondary_icon;                                  // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_timeout_time;                                    // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_priority;                                        // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           M_primary_color;                                   // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           M_secondary_color;                                 // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_audio_event;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   M_announcer_dialogue_trigger_name;                 // 0x00C4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPrimaryMessageTypesTableRow) == 0x000008, "Wrong alignment on FCAPrimaryMessageTypesTableRow");
static_assert(sizeof(FCAPrimaryMessageTypesTableRow) == 0x0000D0, "Wrong size on FCAPrimaryMessageTypesTableRow");
static_assert(offsetof(FCAPrimaryMessageTypesTableRow, M_type) == 0x000008, "Member 'FCAPrimaryMessageTypesTableRow::M_type' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessageTypesTableRow, M_queue_type) == 0x000014, "Member 'FCAPrimaryMessageTypesTableRow::M_queue_type' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessageTypesTableRow, M_immediate_messages_group_id) == 0x000018, "Member 'FCAPrimaryMessageTypesTableRow::M_immediate_messages_group_id' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessageTypesTableRow, M_is_disabled) == 0x00001C, "Member 'FCAPrimaryMessageTypesTableRow::M_is_disabled' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessageTypesTableRow, M_widget_class) == 0x000020, "Member 'FCAPrimaryMessageTypesTableRow::M_widget_class' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessageTypesTableRow, M_header) == 0x000028, "Member 'FCAPrimaryMessageTypesTableRow::M_header' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessageTypesTableRow, M_sub_header) == 0x000058, "Member 'FCAPrimaryMessageTypesTableRow::M_sub_header' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessageTypesTableRow, M_icon) == 0x000088, "Member 'FCAPrimaryMessageTypesTableRow::M_icon' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessageTypesTableRow, M_secondary_icon) == 0x000090, "Member 'FCAPrimaryMessageTypesTableRow::M_secondary_icon' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessageTypesTableRow, M_timeout_time) == 0x000098, "Member 'FCAPrimaryMessageTypesTableRow::M_timeout_time' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessageTypesTableRow, M_priority) == 0x00009C, "Member 'FCAPrimaryMessageTypesTableRow::M_priority' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessageTypesTableRow, M_primary_color) == 0x0000A0, "Member 'FCAPrimaryMessageTypesTableRow::M_primary_color' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessageTypesTableRow, M_secondary_color) == 0x0000B0, "Member 'FCAPrimaryMessageTypesTableRow::M_secondary_color' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessageTypesTableRow, M_audio_event) == 0x0000C0, "Member 'FCAPrimaryMessageTypesTableRow::M_audio_event' has a wrong offset!");
static_assert(offsetof(FCAPrimaryMessageTypesTableRow, M_announcer_dialogue_trigger_name) == 0x0000C4, "Member 'FCAPrimaryMessageTypesTableRow::M_announcer_dialogue_trigger_name' has a wrong offset!");

// ScriptStruct keaton.SysSensorCallbackDataBase
// 0x0001 (0x0001 - 0x0000)
struct FSysSensorCallbackDataBase final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSysSensorCallbackDataBase) == 0x000001, "Wrong alignment on FSysSensorCallbackDataBase");
static_assert(sizeof(FSysSensorCallbackDataBase) == 0x000001, "Wrong size on FSysSensorCallbackDataBase");

// ScriptStruct keaton.CAMessageOfTheDay
// 0x0120 (0x0120 - 0x0000)
struct FCAMessageOfTheDay final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              M_start_time;                                      // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_heading;                                         // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_p1;                                              // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_p2;                                              // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_p3;                                              // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_p4;                                              // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_p5;                                              // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_p6;                                              // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_p7;                                              // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_p8;                                              // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_p9;                                              // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_p10;                                             // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_header_image;                                    // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMessageOfTheDay) == 0x000008, "Wrong alignment on FCAMessageOfTheDay");
static_assert(sizeof(FCAMessageOfTheDay) == 0x000120, "Wrong size on FCAMessageOfTheDay");
static_assert(offsetof(FCAMessageOfTheDay, M_start_time) == 0x000050, "Member 'FCAMessageOfTheDay::M_start_time' has a wrong offset!");
static_assert(offsetof(FCAMessageOfTheDay, M_heading) == 0x000060, "Member 'FCAMessageOfTheDay::M_heading' has a wrong offset!");
static_assert(offsetof(FCAMessageOfTheDay, M_p1) == 0x000070, "Member 'FCAMessageOfTheDay::M_p1' has a wrong offset!");
static_assert(offsetof(FCAMessageOfTheDay, M_p2) == 0x000080, "Member 'FCAMessageOfTheDay::M_p2' has a wrong offset!");
static_assert(offsetof(FCAMessageOfTheDay, M_p3) == 0x000090, "Member 'FCAMessageOfTheDay::M_p3' has a wrong offset!");
static_assert(offsetof(FCAMessageOfTheDay, M_p4) == 0x0000A0, "Member 'FCAMessageOfTheDay::M_p4' has a wrong offset!");
static_assert(offsetof(FCAMessageOfTheDay, M_p5) == 0x0000B0, "Member 'FCAMessageOfTheDay::M_p5' has a wrong offset!");
static_assert(offsetof(FCAMessageOfTheDay, M_p6) == 0x0000C0, "Member 'FCAMessageOfTheDay::M_p6' has a wrong offset!");
static_assert(offsetof(FCAMessageOfTheDay, M_p7) == 0x0000D0, "Member 'FCAMessageOfTheDay::M_p7' has a wrong offset!");
static_assert(offsetof(FCAMessageOfTheDay, M_p8) == 0x0000E0, "Member 'FCAMessageOfTheDay::M_p8' has a wrong offset!");
static_assert(offsetof(FCAMessageOfTheDay, M_p9) == 0x0000F0, "Member 'FCAMessageOfTheDay::M_p9' has a wrong offset!");
static_assert(offsetof(FCAMessageOfTheDay, M_p10) == 0x000100, "Member 'FCAMessageOfTheDay::M_p10' has a wrong offset!");
static_assert(offsetof(FCAMessageOfTheDay, M_header_image) == 0x000110, "Member 'FCAMessageOfTheDay::M_header_image' has a wrong offset!");

// ScriptStruct keaton.CARedirectEffectApplicator
// 0x0038 (0x0038 - 0x0000)
struct FCARedirectEffectApplicator final
{
public:
	TSoftObjectPtr<class AActor>                  M_RedirectTargetOnTrigger;                         // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            M_EffectToApplyOnTrigger;                          // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARedirectEffectApplicator) == 0x000008, "Wrong alignment on FCARedirectEffectApplicator");
static_assert(sizeof(FCARedirectEffectApplicator) == 0x000038, "Wrong size on FCARedirectEffectApplicator");
static_assert(offsetof(FCARedirectEffectApplicator, M_RedirectTargetOnTrigger) == 0x000000, "Member 'FCARedirectEffectApplicator::M_RedirectTargetOnTrigger' has a wrong offset!");
static_assert(offsetof(FCARedirectEffectApplicator, M_EffectToApplyOnTrigger) == 0x000030, "Member 'FCARedirectEffectApplicator::M_EffectToApplyOnTrigger' has a wrong offset!");

// ScriptStruct keaton.CACustomisationActor
// 0x0018 (0x0018 - 0x0000)
struct FCACustomisationActor final
{
public:
	TSubclassOf<class AActor>                     M_actor;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_socket_name;                                     // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCACustomisationActor) == 0x000008, "Wrong alignment on FCACustomisationActor");
static_assert(sizeof(FCACustomisationActor) == 0x000018, "Wrong size on FCACustomisationActor");
static_assert(offsetof(FCACustomisationActor, M_actor) == 0x000000, "Member 'FCACustomisationActor::M_actor' has a wrong offset!");
static_assert(offsetof(FCACustomisationActor, M_socket_name) == 0x000008, "Member 'FCACustomisationActor::M_socket_name' has a wrong offset!");

// ScriptStruct keaton.PredictedProjectileID
// 0x0020 (0x0020 - 0x0000)
struct FPredictedProjectileID final
{
public:
	struct FGameplayAbilitySpecHandle             M_spec_handle;                                     // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         M_ability_original_prediction_key;                 // 0x0008(0x0010)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_count_for_current_activation;                    // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPredictedProjectileID) == 0x000008, "Wrong alignment on FPredictedProjectileID");
static_assert(sizeof(FPredictedProjectileID) == 0x000020, "Wrong size on FPredictedProjectileID");
static_assert(offsetof(FPredictedProjectileID, M_spec_handle) == 0x000000, "Member 'FPredictedProjectileID::M_spec_handle' has a wrong offset!");
static_assert(offsetof(FPredictedProjectileID, M_ability_original_prediction_key) == 0x000008, "Member 'FPredictedProjectileID::M_ability_original_prediction_key' has a wrong offset!");
static_assert(offsetof(FPredictedProjectileID, M_count_for_current_activation) == 0x000018, "Member 'FPredictedProjectileID::M_count_for_current_activation' has a wrong offset!");

// ScriptStruct keaton.CAMatchResultTypeCategories
// 0x0070 (0x0078 - 0x0008)
struct FCAMatchResultTypeCategories final : public FTableRowBase
{
public:
	class FName                                   M_reward_type_category;                            // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_category_label;                                  // 0x0018(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_category_icon;                                   // 0x0048(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMatchResultTypeCategories) == 0x000008, "Wrong alignment on FCAMatchResultTypeCategories");
static_assert(sizeof(FCAMatchResultTypeCategories) == 0x000078, "Wrong size on FCAMatchResultTypeCategories");
static_assert(offsetof(FCAMatchResultTypeCategories, M_reward_type_category) == 0x000008, "Member 'FCAMatchResultTypeCategories::M_reward_type_category' has a wrong offset!");
static_assert(offsetof(FCAMatchResultTypeCategories, M_category_label) == 0x000018, "Member 'FCAMatchResultTypeCategories::M_category_label' has a wrong offset!");
static_assert(offsetof(FCAMatchResultTypeCategories, M_category_icon) == 0x000048, "Member 'FCAMatchResultTypeCategories::M_category_icon' has a wrong offset!");

// ScriptStruct keaton.CANPCTaskGroupMotivationActivationPhaseArray
// 0x0018 (0x0018 - 0x0000)
struct FCANPCTaskGroupMotivationActivationPhaseArray final
{
public:
	TArray<class UCAMotivationActivationPhase*>   M_motivation_activation_phases;                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCTaskGroupMotivationActivationPhaseArray) == 0x000008, "Wrong alignment on FCANPCTaskGroupMotivationActivationPhaseArray");
static_assert(sizeof(FCANPCTaskGroupMotivationActivationPhaseArray) == 0x000018, "Wrong size on FCANPCTaskGroupMotivationActivationPhaseArray");
static_assert(offsetof(FCANPCTaskGroupMotivationActivationPhaseArray, M_motivation_activation_phases) == 0x000000, "Member 'FCANPCTaskGroupMotivationActivationPhaseArray::M_motivation_activation_phases' has a wrong offset!");

// ScriptStruct keaton.CAWaveMotivationActivationPhaseArray
// 0x0010 (0x0010 - 0x0000)
struct FCAWaveMotivationActivationPhaseArray final
{
public:
	TArray<struct FCANPCTaskGroupMotivationActivationPhaseArray> M_npc_task_group_motivation_activation_phases;     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAWaveMotivationActivationPhaseArray) == 0x000008, "Wrong alignment on FCAWaveMotivationActivationPhaseArray");
static_assert(sizeof(FCAWaveMotivationActivationPhaseArray) == 0x000010, "Wrong size on FCAWaveMotivationActivationPhaseArray");
static_assert(offsetof(FCAWaveMotivationActivationPhaseArray, M_npc_task_group_motivation_activation_phases) == 0x000000, "Member 'FCAWaveMotivationActivationPhaseArray::M_npc_task_group_motivation_activation_phases' has a wrong offset!");

// ScriptStruct keaton.CAWaveGroupMotivationActivationPhaseArray
// 0x0010 (0x0010 - 0x0000)
struct FCAWaveGroupMotivationActivationPhaseArray final
{
public:
	TArray<struct FCAWaveMotivationActivationPhaseArray> M_wave_motivation_activation_phases;               // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAWaveGroupMotivationActivationPhaseArray) == 0x000008, "Wrong alignment on FCAWaveGroupMotivationActivationPhaseArray");
static_assert(sizeof(FCAWaveGroupMotivationActivationPhaseArray) == 0x000010, "Wrong size on FCAWaveGroupMotivationActivationPhaseArray");
static_assert(offsetof(FCAWaveGroupMotivationActivationPhaseArray, M_wave_motivation_activation_phases) == 0x000000, "Member 'FCAWaveGroupMotivationActivationPhaseArray::M_wave_motivation_activation_phases' has a wrong offset!");

// ScriptStruct keaton.CAOriginalSourceInfo
// 0x0018 (0x0018 - 0x0000)
struct FCAOriginalSourceInfo final
{
public:
	TArray<TSoftClassPtr<class UClass>>           M_classes;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          M_must_be_target;                                  // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAOriginalSourceInfo) == 0x000008, "Wrong alignment on FCAOriginalSourceInfo");
static_assert(sizeof(FCAOriginalSourceInfo) == 0x000018, "Wrong size on FCAOriginalSourceInfo");
static_assert(offsetof(FCAOriginalSourceInfo, M_classes) == 0x000000, "Member 'FCAOriginalSourceInfo::M_classes' has a wrong offset!");
static_assert(offsetof(FCAOriginalSourceInfo, M_must_be_target) == 0x000010, "Member 'FCAOriginalSourceInfo::M_must_be_target' has a wrong offset!");

// ScriptStruct keaton.CAVanTeamData
// 0x0050 (0x0050 - 0x0000)
struct FCAVanTeamData final
{
public:
	struct FCATeamID                              M_team_id;                                         // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_currently_active_member;                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_current_count;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_starting_count;                                  // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECALobbyState                                 M_current_lobby_state;                             // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_size_limit;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_num_members;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_limited;                                      // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_team_members;                                    // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_ping_colours;                                    // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_excluded_specialists;                            // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAVanTeamData) == 0x000008, "Wrong alignment on FCAVanTeamData");
static_assert(sizeof(FCAVanTeamData) == 0x000050, "Wrong size on FCAVanTeamData");
static_assert(offsetof(FCAVanTeamData, M_team_id) == 0x000000, "Member 'FCAVanTeamData::M_team_id' has a wrong offset!");
static_assert(offsetof(FCAVanTeamData, M_currently_active_member) == 0x000004, "Member 'FCAVanTeamData::M_currently_active_member' has a wrong offset!");
static_assert(offsetof(FCAVanTeamData, M_current_count) == 0x000008, "Member 'FCAVanTeamData::M_current_count' has a wrong offset!");
static_assert(offsetof(FCAVanTeamData, M_starting_count) == 0x00000C, "Member 'FCAVanTeamData::M_starting_count' has a wrong offset!");
static_assert(offsetof(FCAVanTeamData, M_current_lobby_state) == 0x000010, "Member 'FCAVanTeamData::M_current_lobby_state' has a wrong offset!");
static_assert(offsetof(FCAVanTeamData, M_size_limit) == 0x000014, "Member 'FCAVanTeamData::M_size_limit' has a wrong offset!");
static_assert(offsetof(FCAVanTeamData, M_num_members) == 0x000018, "Member 'FCAVanTeamData::M_num_members' has a wrong offset!");
static_assert(offsetof(FCAVanTeamData, M_is_limited) == 0x00001C, "Member 'FCAVanTeamData::M_is_limited' has a wrong offset!");
static_assert(offsetof(FCAVanTeamData, M_team_members) == 0x000020, "Member 'FCAVanTeamData::M_team_members' has a wrong offset!");
static_assert(offsetof(FCAVanTeamData, M_ping_colours) == 0x000030, "Member 'FCAVanTeamData::M_ping_colours' has a wrong offset!");
static_assert(offsetof(FCAVanTeamData, M_excluded_specialists) == 0x000040, "Member 'FCAVanTeamData::M_excluded_specialists' has a wrong offset!");

// ScriptStruct keaton.CAExoticWeaponReloadStats
// 0x0058 (0x0058 - 0x0000)
struct FCAExoticWeaponReloadStats final
{
public:
	float                                         M_reload_duration;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_does_full_clip_reload;                           // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_clip_size;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_has_infinite_ammo;                               // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCAInventoryItem>        M_inventory_item_ammo_type;                        // 0x0010(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACAAmmoBase>                M_ammo_type;                                       // 0x0040(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_on_weapon_out_of_ammo_tag;                       // 0x0048(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAExoticWeaponReloadStats) == 0x000008, "Wrong alignment on FCAExoticWeaponReloadStats");
static_assert(sizeof(FCAExoticWeaponReloadStats) == 0x000058, "Wrong size on FCAExoticWeaponReloadStats");
static_assert(offsetof(FCAExoticWeaponReloadStats, M_reload_duration) == 0x000000, "Member 'FCAExoticWeaponReloadStats::M_reload_duration' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponReloadStats, M_does_full_clip_reload) == 0x000004, "Member 'FCAExoticWeaponReloadStats::M_does_full_clip_reload' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponReloadStats, M_clip_size) == 0x000008, "Member 'FCAExoticWeaponReloadStats::M_clip_size' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponReloadStats, M_has_infinite_ammo) == 0x00000C, "Member 'FCAExoticWeaponReloadStats::M_has_infinite_ammo' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponReloadStats, M_inventory_item_ammo_type) == 0x000010, "Member 'FCAExoticWeaponReloadStats::M_inventory_item_ammo_type' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponReloadStats, M_ammo_type) == 0x000040, "Member 'FCAExoticWeaponReloadStats::M_ammo_type' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponReloadStats, M_on_weapon_out_of_ammo_tag) == 0x000048, "Member 'FCAExoticWeaponReloadStats::M_on_weapon_out_of_ammo_tag' has a wrong offset!");

// ScriptStruct keaton.CAPlayerProfile
// 0x0001 (0x0001 - 0x0000)
struct FCAPlayerProfile final
{
public:
	bool                                          M_profile_loaded;                                  // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPlayerProfile) == 0x000001, "Wrong alignment on FCAPlayerProfile");
static_assert(sizeof(FCAPlayerProfile) == 0x000001, "Wrong size on FCAPlayerProfile");
static_assert(offsetof(FCAPlayerProfile, M_profile_loaded) == 0x000000, "Member 'FCAPlayerProfile::M_profile_loaded' has a wrong offset!");

// ScriptStruct keaton.CANavMeshAnalyserTaskClassData
// 0x0010 (0x0010 - 0x0000)
struct FCANavMeshAnalyserTaskClassData
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavArea>                   Nav_area_class;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANavMeshAnalyserTaskClassData) == 0x000008, "Wrong alignment on FCANavMeshAnalyserTaskClassData");
static_assert(sizeof(FCANavMeshAnalyserTaskClassData) == 0x000010, "Wrong size on FCANavMeshAnalyserTaskClassData");
static_assert(offsetof(FCANavMeshAnalyserTaskClassData, Nav_area_class) == 0x000008, "Member 'FCANavMeshAnalyserTaskClassData::Nav_area_class' has a wrong offset!");

// ScriptStruct keaton.CANavMeshAnalyserTaskVaultClassData
// 0x0008 (0x0018 - 0x0010)
struct FCANavMeshAnalyserTaskVaultClassData final : public FCANavMeshAnalyserTaskClassData
{
public:
	float                                         Vault_jump_max_height;                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Vault_drop_max_height;                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANavMeshAnalyserTaskVaultClassData) == 0x000008, "Wrong alignment on FCANavMeshAnalyserTaskVaultClassData");
static_assert(sizeof(FCANavMeshAnalyserTaskVaultClassData) == 0x000018, "Wrong size on FCANavMeshAnalyserTaskVaultClassData");
static_assert(offsetof(FCANavMeshAnalyserTaskVaultClassData, Vault_jump_max_height) == 0x000010, "Member 'FCANavMeshAnalyserTaskVaultClassData::Vault_jump_max_height' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskVaultClassData, Vault_drop_max_height) == 0x000014, "Member 'FCANavMeshAnalyserTaskVaultClassData::Vault_drop_max_height' has a wrong offset!");

// ScriptStruct keaton.CAServicesItemEvent
// 0x0020 (0x0028 - 0x0008)
struct FCAServicesItemEvent final : public FTableRowBase
{
public:
	struct FCAGameDatabaseRowHandle               M_handle;                                          // 0x0008(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         M_quantity;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAServicesItemEvent) == 0x000008, "Wrong alignment on FCAServicesItemEvent");
static_assert(sizeof(FCAServicesItemEvent) == 0x000028, "Wrong size on FCAServicesItemEvent");
static_assert(offsetof(FCAServicesItemEvent, M_handle) == 0x000008, "Member 'FCAServicesItemEvent::M_handle' has a wrong offset!");
static_assert(offsetof(FCAServicesItemEvent, M_quantity) == 0x000020, "Member 'FCAServicesItemEvent::M_quantity' has a wrong offset!");

// ScriptStruct keaton.CAMapIconData
// 0x00D0 (0x00D0 - 0x0000)
struct FCAMapIconData final
{
public:
	int32                                         M_marker_id;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAUIHUDEntityId                              M_entity_id;                                       // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAUIHUDEntityType                            M_entity_type;                                     // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_volatile;                                     // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAMapEntityPayload                    M_payload;                                         // 0x0008(0x0070)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class UCAHUDMapIconBase>          M_map_icon_class;                                  // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             M_map_icon_texture;                                // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              M_map_icon_size;                                   // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              M_map_icon_offset;                                 // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           M_icon_color;                                      // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             M_spatial_marker_texture;                          // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCAHUDSpatialMarkerBase>    M_spatial_marker_class;                            // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_disable_rotation;                                // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_ignore_minimap_rotation;                         // 0x00B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_interactable;                                 // 0x00BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_always_clamp_position;                           // 0x00BB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_always_show_distance;                            // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAHUDClampingStyle                           M_clamping_rule;                                   // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_z_order;                                         // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_hidden_by_inf_level;                          // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_affected_by_player_height_diff;                  // 0x00C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_override_texture;                                // 0x00CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB[0x5];                                       // 0x00CB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMapIconData) == 0x000008, "Wrong alignment on FCAMapIconData");
static_assert(sizeof(FCAMapIconData) == 0x0000D0, "Wrong size on FCAMapIconData");
static_assert(offsetof(FCAMapIconData, M_marker_id) == 0x000000, "Member 'FCAMapIconData::M_marker_id' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_entity_id) == 0x000004, "Member 'FCAMapIconData::M_entity_id' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_entity_type) == 0x000005, "Member 'FCAMapIconData::M_entity_type' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_is_volatile) == 0x000006, "Member 'FCAMapIconData::M_is_volatile' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_payload) == 0x000008, "Member 'FCAMapIconData::M_payload' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_map_icon_class) == 0x000078, "Member 'FCAMapIconData::M_map_icon_class' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_map_icon_texture) == 0x000080, "Member 'FCAMapIconData::M_map_icon_texture' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_map_icon_size) == 0x000088, "Member 'FCAMapIconData::M_map_icon_size' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_map_icon_offset) == 0x000090, "Member 'FCAMapIconData::M_map_icon_offset' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_icon_color) == 0x000098, "Member 'FCAMapIconData::M_icon_color' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_spatial_marker_texture) == 0x0000A8, "Member 'FCAMapIconData::M_spatial_marker_texture' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_spatial_marker_class) == 0x0000B0, "Member 'FCAMapIconData::M_spatial_marker_class' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_disable_rotation) == 0x0000B8, "Member 'FCAMapIconData::M_disable_rotation' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_ignore_minimap_rotation) == 0x0000B9, "Member 'FCAMapIconData::M_ignore_minimap_rotation' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_is_interactable) == 0x0000BA, "Member 'FCAMapIconData::M_is_interactable' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_always_clamp_position) == 0x0000BB, "Member 'FCAMapIconData::M_always_clamp_position' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_always_show_distance) == 0x0000BC, "Member 'FCAMapIconData::M_always_show_distance' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_clamping_rule) == 0x0000C0, "Member 'FCAMapIconData::M_clamping_rule' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_z_order) == 0x0000C4, "Member 'FCAMapIconData::M_z_order' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_is_hidden_by_inf_level) == 0x0000C8, "Member 'FCAMapIconData::M_is_hidden_by_inf_level' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_affected_by_player_height_diff) == 0x0000C9, "Member 'FCAMapIconData::M_affected_by_player_height_diff' has a wrong offset!");
static_assert(offsetof(FCAMapIconData, M_override_texture) == 0x0000CA, "Member 'FCAMapIconData::M_override_texture' has a wrong offset!");

// ScriptStruct keaton.CACelebrationInfo
// 0x0028 (0x0028 - 0x0000)
struct FCACelebrationInfo final
{
public:
	class FName                                   M_name;                                            // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_previous_rank;                                   // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_claimed_rank;                                    // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAServicesItemEvent>           M_notifications;                                   // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACelebrationInfo) == 0x000008, "Wrong alignment on FCACelebrationInfo");
static_assert(sizeof(FCACelebrationInfo) == 0x000028, "Wrong size on FCACelebrationInfo");
static_assert(offsetof(FCACelebrationInfo, M_name) == 0x000000, "Member 'FCACelebrationInfo::M_name' has a wrong offset!");
static_assert(offsetof(FCACelebrationInfo, M_previous_rank) == 0x00000C, "Member 'FCACelebrationInfo::M_previous_rank' has a wrong offset!");
static_assert(offsetof(FCACelebrationInfo, M_claimed_rank) == 0x000010, "Member 'FCACelebrationInfo::M_claimed_rank' has a wrong offset!");
static_assert(offsetof(FCACelebrationInfo, M_notifications) == 0x000018, "Member 'FCACelebrationInfo::M_notifications' has a wrong offset!");

// ScriptStruct keaton.CACelebrationUIData
// 0x0048 (0x0048 - 0x0000)
struct FCACelebrationUIData final
{
public:
	bool                                          M_is_major;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_GUID;                                            // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAServicesNotificationType                   M_type;                                            // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCACelebrationInfo                     M_info;                                            // 0x0020(0x0028)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACelebrationUIData) == 0x000008, "Wrong alignment on FCACelebrationUIData");
static_assert(sizeof(FCACelebrationUIData) == 0x000048, "Wrong size on FCACelebrationUIData");
static_assert(offsetof(FCACelebrationUIData, M_is_major) == 0x000000, "Member 'FCACelebrationUIData::M_is_major' has a wrong offset!");
static_assert(offsetof(FCACelebrationUIData, M_GUID) == 0x000008, "Member 'FCACelebrationUIData::M_GUID' has a wrong offset!");
static_assert(offsetof(FCACelebrationUIData, M_type) == 0x000018, "Member 'FCACelebrationUIData::M_type' has a wrong offset!");
static_assert(offsetof(FCACelebrationUIData, M_info) == 0x000020, "Member 'FCACelebrationUIData::M_info' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_MagBootsFall
// 0x0040 (0x0050 - 0x0010)
struct FCAMovementData_MagBootsFall final : public FCAMovementModeData
{
public:
	float                                         M_max_fall_height;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_attract_to_ground_horizontal_deceleration;       // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_attract_to_ground_gravity_scale;                 // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_attract_to_ground_air_control;                   // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_cancelation_should_lerp;                         // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_cancelation_lerp_min_descent_angle;              // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_cancelation_lerp_max_descent_allowed_angle;      // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_cancelation_lerp_max_descent_target_angle;       // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_cancelation_lerp_min_descent_factor;             // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_cancelation_lerp_max_descent_factor;             // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_cancelation_max_speed;                           // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_cancelation_simple_angle_scalar;                 // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_attachment_min_time;                             // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_always_fall_on_steep_walls;                      // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_attachment_incline;                              // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementData_MagBootsFall) == 0x000008, "Wrong alignment on FCAMovementData_MagBootsFall");
static_assert(sizeof(FCAMovementData_MagBootsFall) == 0x000050, "Wrong size on FCAMovementData_MagBootsFall");
static_assert(offsetof(FCAMovementData_MagBootsFall, M_max_fall_height) == 0x000010, "Member 'FCAMovementData_MagBootsFall::M_max_fall_height' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBootsFall, M_attract_to_ground_horizontal_deceleration) == 0x000014, "Member 'FCAMovementData_MagBootsFall::M_attract_to_ground_horizontal_deceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBootsFall, M_attract_to_ground_gravity_scale) == 0x000018, "Member 'FCAMovementData_MagBootsFall::M_attract_to_ground_gravity_scale' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBootsFall, M_attract_to_ground_air_control) == 0x00001C, "Member 'FCAMovementData_MagBootsFall::M_attract_to_ground_air_control' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBootsFall, M_cancelation_should_lerp) == 0x000020, "Member 'FCAMovementData_MagBootsFall::M_cancelation_should_lerp' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBootsFall, M_cancelation_lerp_min_descent_angle) == 0x000024, "Member 'FCAMovementData_MagBootsFall::M_cancelation_lerp_min_descent_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBootsFall, M_cancelation_lerp_max_descent_allowed_angle) == 0x000028, "Member 'FCAMovementData_MagBootsFall::M_cancelation_lerp_max_descent_allowed_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBootsFall, M_cancelation_lerp_max_descent_target_angle) == 0x00002C, "Member 'FCAMovementData_MagBootsFall::M_cancelation_lerp_max_descent_target_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBootsFall, M_cancelation_lerp_min_descent_factor) == 0x000030, "Member 'FCAMovementData_MagBootsFall::M_cancelation_lerp_min_descent_factor' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBootsFall, M_cancelation_lerp_max_descent_factor) == 0x000034, "Member 'FCAMovementData_MagBootsFall::M_cancelation_lerp_max_descent_factor' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBootsFall, M_cancelation_max_speed) == 0x000038, "Member 'FCAMovementData_MagBootsFall::M_cancelation_max_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBootsFall, M_cancelation_simple_angle_scalar) == 0x00003C, "Member 'FCAMovementData_MagBootsFall::M_cancelation_simple_angle_scalar' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBootsFall, M_attachment_min_time) == 0x000040, "Member 'FCAMovementData_MagBootsFall::M_attachment_min_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBootsFall, M_always_fall_on_steep_walls) == 0x000044, "Member 'FCAMovementData_MagBootsFall::M_always_fall_on_steep_walls' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBootsFall, M_attachment_incline) == 0x000048, "Member 'FCAMovementData_MagBootsFall::M_attachment_incline' has a wrong offset!");

// ScriptStruct keaton.CADialogueFactMap
// 0x0008 (0x0008 - 0x0000)
struct FCADialogueFactMap final
{
public:
	struct FCAHashableString                      Fact;                                              // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAHashableString                      Value;                                             // 0x0004(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADialogueFactMap) == 0x000004, "Wrong alignment on FCADialogueFactMap");
static_assert(sizeof(FCADialogueFactMap) == 0x000008, "Wrong size on FCADialogueFactMap");
static_assert(offsetof(FCADialogueFactMap, Fact) == 0x000000, "Member 'FCADialogueFactMap::Fact' has a wrong offset!");
static_assert(offsetof(FCADialogueFactMap, Value) == 0x000004, "Member 'FCADialogueFactMap::Value' has a wrong offset!");

// ScriptStruct keaton.CAHUDAbilityUpateData
// 0x000C (0x000C - 0x0000)
struct FCAHUDAbilityUpateData final
{
public:
	float                                         M_progress;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_swap_to_number;                                  // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_play_pulse_anim;                                 // 0x0005(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_desired_colour_idx;                              // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDAbilityUpateData) == 0x000004, "Wrong alignment on FCAHUDAbilityUpateData");
static_assert(sizeof(FCAHUDAbilityUpateData) == 0x00000C, "Wrong size on FCAHUDAbilityUpateData");
static_assert(offsetof(FCAHUDAbilityUpateData, M_progress) == 0x000000, "Member 'FCAHUDAbilityUpateData::M_progress' has a wrong offset!");
static_assert(offsetof(FCAHUDAbilityUpateData, M_swap_to_number) == 0x000004, "Member 'FCAHUDAbilityUpateData::M_swap_to_number' has a wrong offset!");
static_assert(offsetof(FCAHUDAbilityUpateData, M_play_pulse_anim) == 0x000005, "Member 'FCAHUDAbilityUpateData::M_play_pulse_anim' has a wrong offset!");
static_assert(offsetof(FCAHUDAbilityUpateData, M_desired_colour_idx) == 0x000008, "Member 'FCAHUDAbilityUpateData::M_desired_colour_idx' has a wrong offset!");

// ScriptStruct keaton.CADamageHistoryInstance
// 0x00D8 (0x00D8 - 0x0000)
struct FCADamageHistoryInstance final
{
public:
	struct FCAText                                M_display_name;                                    // 0x0000(0x0030)(NativeAccessSpecifierPublic)
	class FText                                   M_unlocalised_display_name;                        // 0x0030(0x0018)(NativeAccessSpecifierPublic)
	float                                         M_damage;                                          // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_team_id;                                         // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_ui_image;                                        // 0x0050(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_instigator_class;                                // 0x0080(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADamageHistoryInstance) == 0x000008, "Wrong alignment on FCADamageHistoryInstance");
static_assert(sizeof(FCADamageHistoryInstance) == 0x0000D8, "Wrong size on FCADamageHistoryInstance");
static_assert(offsetof(FCADamageHistoryInstance, M_display_name) == 0x000000, "Member 'FCADamageHistoryInstance::M_display_name' has a wrong offset!");
static_assert(offsetof(FCADamageHistoryInstance, M_unlocalised_display_name) == 0x000030, "Member 'FCADamageHistoryInstance::M_unlocalised_display_name' has a wrong offset!");
static_assert(offsetof(FCADamageHistoryInstance, M_damage) == 0x000048, "Member 'FCADamageHistoryInstance::M_damage' has a wrong offset!");
static_assert(offsetof(FCADamageHistoryInstance, M_team_id) == 0x00004C, "Member 'FCADamageHistoryInstance::M_team_id' has a wrong offset!");
static_assert(offsetof(FCADamageHistoryInstance, M_ui_image) == 0x000050, "Member 'FCADamageHistoryInstance::M_ui_image' has a wrong offset!");
static_assert(offsetof(FCADamageHistoryInstance, M_instigator_class) == 0x000080, "Member 'FCADamageHistoryInstance::M_instigator_class' has a wrong offset!");

// ScriptStruct keaton.CANetworkedPlayerDeathUIData
// 0x0010 (0x0010 - 0x0000)
struct FCANetworkedPlayerDeathUIData final
{
public:
	class AActor*                                 M_instigator_actor;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_last_teammate;                                // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANetworkedPlayerDeathUIData) == 0x000008, "Wrong alignment on FCANetworkedPlayerDeathUIData");
static_assert(sizeof(FCANetworkedPlayerDeathUIData) == 0x000010, "Wrong size on FCANetworkedPlayerDeathUIData");
static_assert(offsetof(FCANetworkedPlayerDeathUIData, M_instigator_actor) == 0x000000, "Member 'FCANetworkedPlayerDeathUIData::M_instigator_actor' has a wrong offset!");
static_assert(offsetof(FCANetworkedPlayerDeathUIData, M_is_last_teammate) == 0x000008, "Member 'FCANetworkedPlayerDeathUIData::M_is_last_teammate' has a wrong offset!");

// ScriptStruct keaton.CAArcLensPingData
// 0x0088 (0x0088 - 0x0000)
struct FCAArcLensPingData final
{
public:
	int32                                         M_player_id;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_owner_id;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_pickup_item_name;                                // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_loot_convertible;                             // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAUIHUDEntityId                              M_entity_type;                                     // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_entity_id;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_ping_location;                                   // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              M_trace_impact_normal;                             // 0x0028(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pinged_actor;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAArcLensPingType                            M_ping_type;                                       // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAPingContext                                M_ping_context;                                    // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAUIHUDEntityId                              M_ping_id;                                         // 0x0042(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x1];                                       // 0x0043(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_ping_order;                                      // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_static_ping;                                  // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_row_id;                                          // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_audio_event_name;                                // 0x0060(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_ping_audio_event;                                // 0x006C(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_2d_ping_audio_event;                             // 0x0070(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   M_dialogue_name;                                   // 0x0074(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_should_play_dialogue;                            // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAArcLensPingData) == 0x000008, "Wrong alignment on FCAArcLensPingData");
static_assert(sizeof(FCAArcLensPingData) == 0x000088, "Wrong size on FCAArcLensPingData");
static_assert(offsetof(FCAArcLensPingData, M_player_id) == 0x000000, "Member 'FCAArcLensPingData::M_player_id' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_owner_id) == 0x000004, "Member 'FCAArcLensPingData::M_owner_id' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_pickup_item_name) == 0x000008, "Member 'FCAArcLensPingData::M_pickup_item_name' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_is_loot_convertible) == 0x000014, "Member 'FCAArcLensPingData::M_is_loot_convertible' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_entity_type) == 0x000015, "Member 'FCAArcLensPingData::M_entity_type' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_entity_id) == 0x000018, "Member 'FCAArcLensPingData::M_entity_id' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_ping_location) == 0x00001C, "Member 'FCAArcLensPingData::M_ping_location' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_trace_impact_normal) == 0x000028, "Member 'FCAArcLensPingData::M_trace_impact_normal' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_pinged_actor) == 0x000038, "Member 'FCAArcLensPingData::M_pinged_actor' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_ping_type) == 0x000040, "Member 'FCAArcLensPingData::M_ping_type' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_ping_context) == 0x000041, "Member 'FCAArcLensPingData::M_ping_context' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_ping_id) == 0x000042, "Member 'FCAArcLensPingData::M_ping_id' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_ping_order) == 0x000044, "Member 'FCAArcLensPingData::M_ping_order' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_is_static_ping) == 0x000048, "Member 'FCAArcLensPingData::M_is_static_ping' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_row_id) == 0x000050, "Member 'FCAArcLensPingData::M_row_id' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_audio_event_name) == 0x000060, "Member 'FCAArcLensPingData::M_audio_event_name' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_ping_audio_event) == 0x00006C, "Member 'FCAArcLensPingData::M_ping_audio_event' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_2d_ping_audio_event) == 0x000070, "Member 'FCAArcLensPingData::M_2d_ping_audio_event' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_dialogue_name) == 0x000074, "Member 'FCAArcLensPingData::M_dialogue_name' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingData, M_should_play_dialogue) == 0x000080, "Member 'FCAArcLensPingData::M_should_play_dialogue' has a wrong offset!");

// ScriptStruct keaton.CAExoticWeaponFireStats
// 0x0040 (0x0040 - 0x0000)
struct FCAExoticWeaponFireStats final
{
public:
	bool                                          M_is_full_auto;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_uses_loop_fire_animation;                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fire_rate;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fire_cooldown;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_secondary_ability_requires_ammo;                 // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_weapon_range;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_point_blank_range;                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_charge_duration;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_weapon_noise_range;                              // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_start_trace_vertical_offset;                     // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAGameplayEffectContainer             M_effects_container;                               // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAExoticWeaponFireStats) == 0x000008, "Wrong alignment on FCAExoticWeaponFireStats");
static_assert(sizeof(FCAExoticWeaponFireStats) == 0x000040, "Wrong size on FCAExoticWeaponFireStats");
static_assert(offsetof(FCAExoticWeaponFireStats, M_is_full_auto) == 0x000000, "Member 'FCAExoticWeaponFireStats::M_is_full_auto' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponFireStats, M_uses_loop_fire_animation) == 0x000001, "Member 'FCAExoticWeaponFireStats::M_uses_loop_fire_animation' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponFireStats, M_fire_rate) == 0x000004, "Member 'FCAExoticWeaponFireStats::M_fire_rate' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponFireStats, M_fire_cooldown) == 0x000008, "Member 'FCAExoticWeaponFireStats::M_fire_cooldown' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponFireStats, M_secondary_ability_requires_ammo) == 0x00000C, "Member 'FCAExoticWeaponFireStats::M_secondary_ability_requires_ammo' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponFireStats, M_weapon_range) == 0x000010, "Member 'FCAExoticWeaponFireStats::M_weapon_range' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponFireStats, M_point_blank_range) == 0x000014, "Member 'FCAExoticWeaponFireStats::M_point_blank_range' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponFireStats, M_charge_duration) == 0x000018, "Member 'FCAExoticWeaponFireStats::M_charge_duration' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponFireStats, M_weapon_noise_range) == 0x00001C, "Member 'FCAExoticWeaponFireStats::M_weapon_noise_range' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponFireStats, M_start_trace_vertical_offset) == 0x000020, "Member 'FCAExoticWeaponFireStats::M_start_trace_vertical_offset' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponFireStats, M_effects_container) == 0x000028, "Member 'FCAExoticWeaponFireStats::M_effects_container' has a wrong offset!");

// ScriptStruct keaton.EquipmentAnims
// 0x0060 (0x0060 - 0x0000)
struct FEquipmentAnims final
{
public:
	TSoftObjectPtr<class UAnimMontage>            M_pawn_anim;                                       // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            M_weapon_anim;                                     // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipmentAnims) == 0x000008, "Wrong alignment on FEquipmentAnims");
static_assert(sizeof(FEquipmentAnims) == 0x000060, "Wrong size on FEquipmentAnims");
static_assert(offsetof(FEquipmentAnims, M_pawn_anim) == 0x000000, "Member 'FEquipmentAnims::M_pawn_anim' has a wrong offset!");
static_assert(offsetof(FEquipmentAnims, M_weapon_anim) == 0x000030, "Member 'FEquipmentAnims::M_weapon_anim' has a wrong offset!");

// ScriptStruct keaton.CAExoticWeaponAnimations
// 0x0208 (0x0208 - 0x0000)
struct FCAExoticWeaponAnimations final
{
public:
	struct FEquipmentAnims                        M_fire_anim;                                       // 0x0000(0x0060)(Edit, NativeAccessSpecifierPublic)
	float                                         M_fire_anim_play_rate;                             // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEquipmentAnims                        M_reload_anim;                                     // 0x0068(0x0060)(Edit, NativeAccessSpecifierPublic)
	float                                         M_reload_anim_play_rate;                           // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEquipmentAnims                        M_charge_anim;                                     // 0x00D0(0x0060)(Edit, NativeAccessSpecifierPublic)
	float                                         M_charge_anim_play_rate;                           // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEquipmentAnims                        M_equip_anim;                                      // 0x0138(0x0060)(Edit, NativeAccessSpecifierPublic)
	float                                         M_equip_anim_play_rate;                            // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEquipmentAnims                        M_unequip_anim;                                    // 0x01A0(0x0060)(Edit, NativeAccessSpecifierPublic)
	float                                         M_unequip_anim_play_rate;                          // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAExoticWeaponAnimations) == 0x000008, "Wrong alignment on FCAExoticWeaponAnimations");
static_assert(sizeof(FCAExoticWeaponAnimations) == 0x000208, "Wrong size on FCAExoticWeaponAnimations");
static_assert(offsetof(FCAExoticWeaponAnimations, M_fire_anim) == 0x000000, "Member 'FCAExoticWeaponAnimations::M_fire_anim' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponAnimations, M_fire_anim_play_rate) == 0x000060, "Member 'FCAExoticWeaponAnimations::M_fire_anim_play_rate' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponAnimations, M_reload_anim) == 0x000068, "Member 'FCAExoticWeaponAnimations::M_reload_anim' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponAnimations, M_reload_anim_play_rate) == 0x0000C8, "Member 'FCAExoticWeaponAnimations::M_reload_anim_play_rate' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponAnimations, M_charge_anim) == 0x0000D0, "Member 'FCAExoticWeaponAnimations::M_charge_anim' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponAnimations, M_charge_anim_play_rate) == 0x000130, "Member 'FCAExoticWeaponAnimations::M_charge_anim_play_rate' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponAnimations, M_equip_anim) == 0x000138, "Member 'FCAExoticWeaponAnimations::M_equip_anim' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponAnimations, M_equip_anim_play_rate) == 0x000198, "Member 'FCAExoticWeaponAnimations::M_equip_anim_play_rate' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponAnimations, M_unequip_anim) == 0x0001A0, "Member 'FCAExoticWeaponAnimations::M_unequip_anim' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponAnimations, M_unequip_anim_play_rate) == 0x000200, "Member 'FCAExoticWeaponAnimations::M_unequip_anim_play_rate' has a wrong offset!");

// ScriptStruct keaton.CAExoticWeaponStatsRow
// 0x02A8 (0x02B0 - 0x0008)
struct FCAExoticWeaponStatsRow final : public FTableRowBase
{
public:
	struct FCAExoticWeaponFireStats               M_fire_stats;                                      // 0x0008(0x0040)(Edit, NativeAccessSpecifierPublic)
	struct FCAExoticWeaponReloadStats             M_reload_stats;                                    // 0x0048(0x0058)(Edit, NativeAccessSpecifierPublic)
	float                                         M_NPC_desired_attack_range;                        // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAExoticWeaponAnimations              M_animations;                                      // 0x00A8(0x0208)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAExoticWeaponStatsRow) == 0x000008, "Wrong alignment on FCAExoticWeaponStatsRow");
static_assert(sizeof(FCAExoticWeaponStatsRow) == 0x0002B0, "Wrong size on FCAExoticWeaponStatsRow");
static_assert(offsetof(FCAExoticWeaponStatsRow, M_fire_stats) == 0x000008, "Member 'FCAExoticWeaponStatsRow::M_fire_stats' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponStatsRow, M_reload_stats) == 0x000048, "Member 'FCAExoticWeaponStatsRow::M_reload_stats' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponStatsRow, M_NPC_desired_attack_range) == 0x0000A0, "Member 'FCAExoticWeaponStatsRow::M_NPC_desired_attack_range' has a wrong offset!");
static_assert(offsetof(FCAExoticWeaponStatsRow, M_animations) == 0x0000A8, "Member 'FCAExoticWeaponStatsRow::M_animations' has a wrong offset!");

// ScriptStruct keaton.CARewardAssets
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x08) FCARewardAssets final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCARewardAssets) == 0x000008, "Wrong alignment on FCARewardAssets");
static_assert(sizeof(FCARewardAssets) == 0x000090, "Wrong size on FCARewardAssets");

// ScriptStruct keaton.CATextChatMessage
// 0x0050 (0x0050 - 0x0000)
struct FCATextChatMessage final
{
public:
	int32                                         M_sender_id;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_sender_name;                                     // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           M_sender_color;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              M_timestamp;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_lifespan;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATextChatChannel                            M_channel;                                         // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_message;                                         // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          M_is_system_message;                               // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCATextChatMessage) == 0x000008, "Wrong alignment on FCATextChatMessage");
static_assert(sizeof(FCATextChatMessage) == 0x000050, "Wrong size on FCATextChatMessage");
static_assert(offsetof(FCATextChatMessage, M_sender_id) == 0x000000, "Member 'FCATextChatMessage::M_sender_id' has a wrong offset!");
static_assert(offsetof(FCATextChatMessage, M_sender_name) == 0x000004, "Member 'FCATextChatMessage::M_sender_name' has a wrong offset!");
static_assert(offsetof(FCATextChatMessage, M_sender_color) == 0x000010, "Member 'FCATextChatMessage::M_sender_color' has a wrong offset!");
static_assert(offsetof(FCATextChatMessage, M_timestamp) == 0x000020, "Member 'FCATextChatMessage::M_timestamp' has a wrong offset!");
static_assert(offsetof(FCATextChatMessage, M_lifespan) == 0x000028, "Member 'FCATextChatMessage::M_lifespan' has a wrong offset!");
static_assert(offsetof(FCATextChatMessage, M_channel) == 0x00002C, "Member 'FCATextChatMessage::M_channel' has a wrong offset!");
static_assert(offsetof(FCATextChatMessage, M_message) == 0x000030, "Member 'FCATextChatMessage::M_message' has a wrong offset!");
static_assert(offsetof(FCATextChatMessage, M_is_system_message) == 0x000048, "Member 'FCATextChatMessage::M_is_system_message' has a wrong offset!");

// ScriptStruct keaton.CACosmeticDefinitionBaseTableRow
// 0x0138 (0x0140 - 0x0008)
struct FCACosmeticDefinitionBaseTableRow : public FTableRowBase
{
public:
	struct FFeatureKeyItem                        M_base_feature;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	ECAReleaseState                               M_release_state;                                   // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_display_name;                                    // 0x0010(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_owner_display_name;                              // 0x0040(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_description;                                     // 0x0070(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_thumbnail;                                       // 0x00A0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           M_FP_mesh;                                         // 0x00D0(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           M_TP_mesh;                                         // 0x0100(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAOverrideMaterial>            M_override_materials;                              // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACosmeticDefinitionBaseTableRow) == 0x000008, "Wrong alignment on FCACosmeticDefinitionBaseTableRow");
static_assert(sizeof(FCACosmeticDefinitionBaseTableRow) == 0x000140, "Wrong size on FCACosmeticDefinitionBaseTableRow");
static_assert(offsetof(FCACosmeticDefinitionBaseTableRow, M_base_feature) == 0x000008, "Member 'FCACosmeticDefinitionBaseTableRow::M_base_feature' has a wrong offset!");
static_assert(offsetof(FCACosmeticDefinitionBaseTableRow, M_release_state) == 0x00000C, "Member 'FCACosmeticDefinitionBaseTableRow::M_release_state' has a wrong offset!");
static_assert(offsetof(FCACosmeticDefinitionBaseTableRow, M_display_name) == 0x000010, "Member 'FCACosmeticDefinitionBaseTableRow::M_display_name' has a wrong offset!");
static_assert(offsetof(FCACosmeticDefinitionBaseTableRow, M_owner_display_name) == 0x000040, "Member 'FCACosmeticDefinitionBaseTableRow::M_owner_display_name' has a wrong offset!");
static_assert(offsetof(FCACosmeticDefinitionBaseTableRow, M_description) == 0x000070, "Member 'FCACosmeticDefinitionBaseTableRow::M_description' has a wrong offset!");
static_assert(offsetof(FCACosmeticDefinitionBaseTableRow, M_thumbnail) == 0x0000A0, "Member 'FCACosmeticDefinitionBaseTableRow::M_thumbnail' has a wrong offset!");
static_assert(offsetof(FCACosmeticDefinitionBaseTableRow, M_FP_mesh) == 0x0000D0, "Member 'FCACosmeticDefinitionBaseTableRow::M_FP_mesh' has a wrong offset!");
static_assert(offsetof(FCACosmeticDefinitionBaseTableRow, M_TP_mesh) == 0x000100, "Member 'FCACosmeticDefinitionBaseTableRow::M_TP_mesh' has a wrong offset!");
static_assert(offsetof(FCACosmeticDefinitionBaseTableRow, M_override_materials) == 0x000130, "Member 'FCACosmeticDefinitionBaseTableRow::M_override_materials' has a wrong offset!");

// ScriptStruct keaton.CASampleManagerConfig
// 0x0008 (0x0010 - 0x0008)
struct FCASampleManagerConfig final : public FTableRowBase
{
public:
	uint32                                        SampleRate;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCASampleManagerConfig) == 0x000008, "Wrong alignment on FCASampleManagerConfig");
static_assert(sizeof(FCASampleManagerConfig) == 0x000010, "Wrong size on FCASampleManagerConfig");
static_assert(offsetof(FCASampleManagerConfig, SampleRate) == 0x000008, "Member 'FCASampleManagerConfig::SampleRate' has a wrong offset!");

// ScriptStruct keaton.CAInstantHitInfo
// 0x0030 (0x0030 - 0x0000)
struct FCAInstantHitInfo final
{
public:
	uint8                                         M_FX_index;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    M_origin;                                          // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              M_shoot_dir;                                       // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_actor_hit;                                       // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_fired_from_slave;                                // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAInstantHitInfo) == 0x000008, "Wrong alignment on FCAInstantHitInfo");
static_assert(sizeof(FCAInstantHitInfo) == 0x000030, "Wrong size on FCAInstantHitInfo");
static_assert(offsetof(FCAInstantHitInfo, M_FX_index) == 0x000000, "Member 'FCAInstantHitInfo::M_FX_index' has a wrong offset!");
static_assert(offsetof(FCAInstantHitInfo, M_origin) == 0x000004, "Member 'FCAInstantHitInfo::M_origin' has a wrong offset!");
static_assert(offsetof(FCAInstantHitInfo, M_shoot_dir) == 0x000010, "Member 'FCAInstantHitInfo::M_shoot_dir' has a wrong offset!");
static_assert(offsetof(FCAInstantHitInfo, M_actor_hit) == 0x000020, "Member 'FCAInstantHitInfo::M_actor_hit' has a wrong offset!");
static_assert(offsetof(FCAInstantHitInfo, M_fired_from_slave) == 0x000028, "Member 'FCAInstantHitInfo::M_fired_from_slave' has a wrong offset!");

// ScriptStruct keaton.SkeletalMeshSpawnParam
// 0x0060 (0x0060 - 0x0000)
struct FSkeletalMeshSpawnParam final
{
public:
	class FName                                   M_bone_name;                                       // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_offset;                                          // 0x0010(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   M_collision_profile;                               // 0x0040(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          M_skeletal_mesh;                                   // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_parent_material;                             // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkeletalMeshSpawnParam) == 0x000010, "Wrong alignment on FSkeletalMeshSpawnParam");
static_assert(sizeof(FSkeletalMeshSpawnParam) == 0x000060, "Wrong size on FSkeletalMeshSpawnParam");
static_assert(offsetof(FSkeletalMeshSpawnParam, M_bone_name) == 0x000000, "Member 'FSkeletalMeshSpawnParam::M_bone_name' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshSpawnParam, M_offset) == 0x000010, "Member 'FSkeletalMeshSpawnParam::M_offset' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshSpawnParam, M_collision_profile) == 0x000040, "Member 'FSkeletalMeshSpawnParam::M_collision_profile' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshSpawnParam, M_skeletal_mesh) == 0x000050, "Member 'FSkeletalMeshSpawnParam::M_skeletal_mesh' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshSpawnParam, M_use_parent_material) == 0x000058, "Member 'FSkeletalMeshSpawnParam::M_use_parent_material' has a wrong offset!");

// ScriptStruct keaton.CANPCCountChangeRecordArray
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FCANPCCountChangeRecordArray final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCCountChangeRecordArray) == 0x000008, "Wrong alignment on FCANPCCountChangeRecordArray");
static_assert(sizeof(FCANPCCountChangeRecordArray) == 0x000010, "Wrong size on FCANPCCountChangeRecordArray");

// ScriptStruct keaton.StaticMeshSpawnParam
// 0x0070 (0x0070 - 0x0000)
struct FStaticMeshSpawnParam final
{
public:
	class FName                                   M_bone_name;                                       // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_offset;                                          // 0x0010(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   M_collision_profile;                               // 0x0040(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            M_static_mesh;                                     // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AStaticMeshActor*>               M_spawned_actors;                                  // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStaticMeshSpawnParam) == 0x000010, "Wrong alignment on FStaticMeshSpawnParam");
static_assert(sizeof(FStaticMeshSpawnParam) == 0x000070, "Wrong size on FStaticMeshSpawnParam");
static_assert(offsetof(FStaticMeshSpawnParam, M_bone_name) == 0x000000, "Member 'FStaticMeshSpawnParam::M_bone_name' has a wrong offset!");
static_assert(offsetof(FStaticMeshSpawnParam, M_offset) == 0x000010, "Member 'FStaticMeshSpawnParam::M_offset' has a wrong offset!");
static_assert(offsetof(FStaticMeshSpawnParam, M_collision_profile) == 0x000040, "Member 'FStaticMeshSpawnParam::M_collision_profile' has a wrong offset!");
static_assert(offsetof(FStaticMeshSpawnParam, M_static_mesh) == 0x000050, "Member 'FStaticMeshSpawnParam::M_static_mesh' has a wrong offset!");
static_assert(offsetof(FStaticMeshSpawnParam, M_spawned_actors) == 0x000058, "Member 'FStaticMeshSpawnParam::M_spawned_actors' has a wrong offset!");

// ScriptStruct keaton.ExtractionActorInfo
// 0x00C8 (0x00C8 - 0x0000)
struct FExtractionActorInfo final
{
public:
	class AActor*                                 ExtractionActor;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExtractionAreaState                          ExtractionState;                                   // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExtractionProgress;                                // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtractionDuration;                                // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtractionEndTime;                                 // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableWhenNoAuthorisedTeams;                      // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExtractionMapIconVisibility                  Visibility;                                        // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FCATeamID>                        Authorised;                                        // 0x0020(0x0050)(NativeAccessSpecifierPublic)
	TSet<class APawn*>                            Users;                                             // 0x0070(0x0050)(NativeAccessSpecifierPublic)
	struct FCATeamID                              CurrentCapturingTeam;                              // 0x00C0(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExtractionActorInfo) == 0x000008, "Wrong alignment on FExtractionActorInfo");
static_assert(sizeof(FExtractionActorInfo) == 0x0000C8, "Wrong size on FExtractionActorInfo");
static_assert(offsetof(FExtractionActorInfo, ExtractionActor) == 0x000000, "Member 'FExtractionActorInfo::ExtractionActor' has a wrong offset!");
static_assert(offsetof(FExtractionActorInfo, ExtractionState) == 0x000008, "Member 'FExtractionActorInfo::ExtractionState' has a wrong offset!");
static_assert(offsetof(FExtractionActorInfo, ExtractionProgress) == 0x00000C, "Member 'FExtractionActorInfo::ExtractionProgress' has a wrong offset!");
static_assert(offsetof(FExtractionActorInfo, ExtractionDuration) == 0x000010, "Member 'FExtractionActorInfo::ExtractionDuration' has a wrong offset!");
static_assert(offsetof(FExtractionActorInfo, ExtractionEndTime) == 0x000014, "Member 'FExtractionActorInfo::ExtractionEndTime' has a wrong offset!");
static_assert(offsetof(FExtractionActorInfo, DisableWhenNoAuthorisedTeams) == 0x000018, "Member 'FExtractionActorInfo::DisableWhenNoAuthorisedTeams' has a wrong offset!");
static_assert(offsetof(FExtractionActorInfo, Visibility) == 0x000019, "Member 'FExtractionActorInfo::Visibility' has a wrong offset!");
static_assert(offsetof(FExtractionActorInfo, Authorised) == 0x000020, "Member 'FExtractionActorInfo::Authorised' has a wrong offset!");
static_assert(offsetof(FExtractionActorInfo, Users) == 0x000070, "Member 'FExtractionActorInfo::Users' has a wrong offset!");
static_assert(offsetof(FExtractionActorInfo, CurrentCapturingTeam) == 0x0000C0, "Member 'FExtractionActorInfo::CurrentCapturingTeam' has a wrong offset!");

// ScriptStruct keaton.CAAudioProxyRTPCParams
// 0x0008 (0x0008 - 0x0000)
struct FCAAudioProxyRTPCParams final
{
public:
	uint32                                        Name;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAudioProxyRTPCParams) == 0x000004, "Wrong alignment on FCAAudioProxyRTPCParams");
static_assert(sizeof(FCAAudioProxyRTPCParams) == 0x000008, "Wrong size on FCAAudioProxyRTPCParams");
static_assert(offsetof(FCAAudioProxyRTPCParams, Name) == 0x000000, "Member 'FCAAudioProxyRTPCParams::Name' has a wrong offset!");
static_assert(offsetof(FCAAudioProxyRTPCParams, Value) == 0x000004, "Member 'FCAAudioProxyRTPCParams::Value' has a wrong offset!");

// ScriptStruct keaton.CAAudioInstigatorParams
// 0x0008 (0x0008 - 0x0000)
struct FCAAudioInstigatorParams final
{
public:
	uint32                                        Controller;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Weapon;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAudioInstigatorParams) == 0x000004, "Wrong alignment on FCAAudioInstigatorParams");
static_assert(sizeof(FCAAudioInstigatorParams) == 0x000008, "Wrong size on FCAAudioInstigatorParams");
static_assert(offsetof(FCAAudioInstigatorParams, Controller) == 0x000000, "Member 'FCAAudioInstigatorParams::Controller' has a wrong offset!");
static_assert(offsetof(FCAAudioInstigatorParams, Weapon) == 0x000004, "Member 'FCAAudioInstigatorParams::Weapon' has a wrong offset!");

// ScriptStruct keaton.CAAudioUpdateRTPCParams
// 0x0010 (0x0010 - 0x0000)
struct FCAAudioUpdateRTPCParams final
{
public:
	struct FCAAudioProxyRTPCParams                M_rtpc;                                            // 0x0000(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioInstigatorParams               M_instigator;                                      // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAudioUpdateRTPCParams) == 0x000004, "Wrong alignment on FCAAudioUpdateRTPCParams");
static_assert(sizeof(FCAAudioUpdateRTPCParams) == 0x000010, "Wrong size on FCAAudioUpdateRTPCParams");
static_assert(offsetof(FCAAudioUpdateRTPCParams, M_rtpc) == 0x000000, "Member 'FCAAudioUpdateRTPCParams::M_rtpc' has a wrong offset!");
static_assert(offsetof(FCAAudioUpdateRTPCParams, M_instigator) == 0x000008, "Member 'FCAAudioUpdateRTPCParams::M_instigator' has a wrong offset!");

// ScriptStruct keaton.CAAttackManagerSetup
// 0x00B0 (0x00B0 - 0x0000)
struct FCAAttackManagerSetup final
{
public:
	float                                         M_max_delta_between_aim_and_shoot_rotation_yaw;    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_delta_between_aim_and_shoot_rotation_pitch;  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_tracking_aim;                                // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_tracking_aim_rotation_speed;                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_tracking_aim_hold_start;                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_tracking_aim_hold_duration;                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_hit_chance;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_hit_chance;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_increase_hit_chance_per_second_while_shooting;   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_decrease_hit_chance_per_second_while_not_shooting; // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_delay_before_decrease_kicks_in;                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_how_much_to_miss_by;                             // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_target_is_sliding_penalty;                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_target_is_sprinting_penalty;                     // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_target_is_zero_g_penalty;                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_target_moving_penalty;                           // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_target_moving_penalty_velocity_threshold;        // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_target_facing_away_penalty;                      // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_projectile_target_point_offset_body;             // 0x0048(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_projectile_target_point_offset_head;             // 0x0054(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, float>              M_gameplay_tag_penalties;                          // 0x0060(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAttackManagerSetup) == 0x000008, "Wrong alignment on FCAAttackManagerSetup");
static_assert(sizeof(FCAAttackManagerSetup) == 0x0000B0, "Wrong size on FCAAttackManagerSetup");
static_assert(offsetof(FCAAttackManagerSetup, M_max_delta_between_aim_and_shoot_rotation_yaw) == 0x000000, "Member 'FCAAttackManagerSetup::M_max_delta_between_aim_and_shoot_rotation_yaw' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_max_delta_between_aim_and_shoot_rotation_pitch) == 0x000004, "Member 'FCAAttackManagerSetup::M_max_delta_between_aim_and_shoot_rotation_pitch' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_use_tracking_aim) == 0x000008, "Member 'FCAAttackManagerSetup::M_use_tracking_aim' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_tracking_aim_rotation_speed) == 0x00000C, "Member 'FCAAttackManagerSetup::M_tracking_aim_rotation_speed' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_tracking_aim_hold_start) == 0x000010, "Member 'FCAAttackManagerSetup::M_tracking_aim_hold_start' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_tracking_aim_hold_duration) == 0x000014, "Member 'FCAAttackManagerSetup::M_tracking_aim_hold_duration' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_min_hit_chance) == 0x000018, "Member 'FCAAttackManagerSetup::M_min_hit_chance' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_max_hit_chance) == 0x00001C, "Member 'FCAAttackManagerSetup::M_max_hit_chance' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_increase_hit_chance_per_second_while_shooting) == 0x000020, "Member 'FCAAttackManagerSetup::M_increase_hit_chance_per_second_while_shooting' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_decrease_hit_chance_per_second_while_not_shooting) == 0x000024, "Member 'FCAAttackManagerSetup::M_decrease_hit_chance_per_second_while_not_shooting' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_delay_before_decrease_kicks_in) == 0x000028, "Member 'FCAAttackManagerSetup::M_delay_before_decrease_kicks_in' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_how_much_to_miss_by) == 0x00002C, "Member 'FCAAttackManagerSetup::M_how_much_to_miss_by' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_target_is_sliding_penalty) == 0x000030, "Member 'FCAAttackManagerSetup::M_target_is_sliding_penalty' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_target_is_sprinting_penalty) == 0x000034, "Member 'FCAAttackManagerSetup::M_target_is_sprinting_penalty' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_target_is_zero_g_penalty) == 0x000038, "Member 'FCAAttackManagerSetup::M_target_is_zero_g_penalty' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_target_moving_penalty) == 0x00003C, "Member 'FCAAttackManagerSetup::M_target_moving_penalty' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_target_moving_penalty_velocity_threshold) == 0x000040, "Member 'FCAAttackManagerSetup::M_target_moving_penalty_velocity_threshold' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_target_facing_away_penalty) == 0x000044, "Member 'FCAAttackManagerSetup::M_target_facing_away_penalty' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_projectile_target_point_offset_body) == 0x000048, "Member 'FCAAttackManagerSetup::M_projectile_target_point_offset_body' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_projectile_target_point_offset_head) == 0x000054, "Member 'FCAAttackManagerSetup::M_projectile_target_point_offset_head' has a wrong offset!");
static_assert(offsetof(FCAAttackManagerSetup, M_gameplay_tag_penalties) == 0x000060, "Member 'FCAAttackManagerSetup::M_gameplay_tag_penalties' has a wrong offset!");

// ScriptStruct keaton.CAFlashbangBounceData
// 0x0020 (0x0020 - 0x0000)
struct FCAFlashbangBounceData final
{
public:
	int32                                         M_bounce_number;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_override_level_flash_parameters;                 // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             M_bounce_flash_impact_parameters;                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACAExplosionEffect>         M_explosion_effect;                                // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_override_multipliers;                            // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_multiplier_zero_g;                               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFlashbangBounceData) == 0x000008, "Wrong alignment on FCAFlashbangBounceData");
static_assert(sizeof(FCAFlashbangBounceData) == 0x000020, "Wrong size on FCAFlashbangBounceData");
static_assert(offsetof(FCAFlashbangBounceData, M_bounce_number) == 0x000000, "Member 'FCAFlashbangBounceData::M_bounce_number' has a wrong offset!");
static_assert(offsetof(FCAFlashbangBounceData, M_override_level_flash_parameters) == 0x000004, "Member 'FCAFlashbangBounceData::M_override_level_flash_parameters' has a wrong offset!");
static_assert(offsetof(FCAFlashbangBounceData, M_bounce_flash_impact_parameters) == 0x000008, "Member 'FCAFlashbangBounceData::M_bounce_flash_impact_parameters' has a wrong offset!");
static_assert(offsetof(FCAFlashbangBounceData, M_explosion_effect) == 0x000010, "Member 'FCAFlashbangBounceData::M_explosion_effect' has a wrong offset!");
static_assert(offsetof(FCAFlashbangBounceData, M_override_multipliers) == 0x000018, "Member 'FCAFlashbangBounceData::M_override_multipliers' has a wrong offset!");
static_assert(offsetof(FCAFlashbangBounceData, M_multiplier_zero_g) == 0x00001C, "Member 'FCAFlashbangBounceData::M_multiplier_zero_g' has a wrong offset!");

// ScriptStruct keaton.EquipmentControllerConfiguration
// 0x0038 (0x0038 - 0x0000)
struct FEquipmentControllerConfiguration final
{
public:
	TSubclassOf<class UCAEquipmentController>     M_equipment_controller_class;                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCAGameplayAbility>         M_primary_ability_class;                           // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCAGameplayAbility>         M_secondary_ability_class;                         // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCAGameplayAbility>         M_tertiary_ability_class;                          // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCAGameplayAbility>         M_mode_switch_ability_class;                       // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UCAGameplayAbility>> M_additional_abilities;                            // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipmentControllerConfiguration) == 0x000008, "Wrong alignment on FEquipmentControllerConfiguration");
static_assert(sizeof(FEquipmentControllerConfiguration) == 0x000038, "Wrong size on FEquipmentControllerConfiguration");
static_assert(offsetof(FEquipmentControllerConfiguration, M_equipment_controller_class) == 0x000000, "Member 'FEquipmentControllerConfiguration::M_equipment_controller_class' has a wrong offset!");
static_assert(offsetof(FEquipmentControllerConfiguration, M_primary_ability_class) == 0x000008, "Member 'FEquipmentControllerConfiguration::M_primary_ability_class' has a wrong offset!");
static_assert(offsetof(FEquipmentControllerConfiguration, M_secondary_ability_class) == 0x000010, "Member 'FEquipmentControllerConfiguration::M_secondary_ability_class' has a wrong offset!");
static_assert(offsetof(FEquipmentControllerConfiguration, M_tertiary_ability_class) == 0x000018, "Member 'FEquipmentControllerConfiguration::M_tertiary_ability_class' has a wrong offset!");
static_assert(offsetof(FEquipmentControllerConfiguration, M_mode_switch_ability_class) == 0x000020, "Member 'FEquipmentControllerConfiguration::M_mode_switch_ability_class' has a wrong offset!");
static_assert(offsetof(FEquipmentControllerConfiguration, M_additional_abilities) == 0x000028, "Member 'FEquipmentControllerConfiguration::M_additional_abilities' has a wrong offset!");

// ScriptStruct keaton.AttributeInitialisationInfo
// 0x0048 (0x0048 - 0x0000)
struct FAttributeInitialisationInfo final
{
public:
	struct FDataTableRowHandle                    HealthSetInitialisation;                           // 0x0000(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    CaptureSetInitialisation;                          // 0x0018(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    EffectsSetInitialisation;                          // 0x0030(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributeInitialisationInfo) == 0x000008, "Wrong alignment on FAttributeInitialisationInfo");
static_assert(sizeof(FAttributeInitialisationInfo) == 0x000048, "Wrong size on FAttributeInitialisationInfo");
static_assert(offsetof(FAttributeInitialisationInfo, HealthSetInitialisation) == 0x000000, "Member 'FAttributeInitialisationInfo::HealthSetInitialisation' has a wrong offset!");
static_assert(offsetof(FAttributeInitialisationInfo, CaptureSetInitialisation) == 0x000018, "Member 'FAttributeInitialisationInfo::CaptureSetInitialisation' has a wrong offset!");
static_assert(offsetof(FAttributeInitialisationInfo, EffectsSetInitialisation) == 0x000030, "Member 'FAttributeInitialisationInfo::EffectsSetInitialisation' has a wrong offset!");

// ScriptStruct keaton.CAAIHasMotivationData
// 0x0010 (0x0010 - 0x0000)
struct FCAAIHasMotivationData final
{
public:
	struct FGameplayTag                           M_motivation_tag;                                  // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_invert_condition;                                // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAIHasMotivationData) == 0x000004, "Wrong alignment on FCAAIHasMotivationData");
static_assert(sizeof(FCAAIHasMotivationData) == 0x000010, "Wrong size on FCAAIHasMotivationData");
static_assert(offsetof(FCAAIHasMotivationData, M_motivation_tag) == 0x000000, "Member 'FCAAIHasMotivationData::M_motivation_tag' has a wrong offset!");
static_assert(offsetof(FCAAIHasMotivationData, M_invert_condition) == 0x00000C, "Member 'FCAAIHasMotivationData::M_invert_condition' has a wrong offset!");

// ScriptStruct keaton.CAServicesFixedReward
// 0x0020 (0x0020 - 0x0000)
struct FCAServicesFixedReward final
{
public:
	struct FCAGameDatabaseRowHandle               M_handle;                                          // 0x0000(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int64                                         M_quantity;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAServicesFixedReward) == 0x000008, "Wrong alignment on FCAServicesFixedReward");
static_assert(sizeof(FCAServicesFixedReward) == 0x000020, "Wrong size on FCAServicesFixedReward");
static_assert(offsetof(FCAServicesFixedReward, M_handle) == 0x000000, "Member 'FCAServicesFixedReward::M_handle' has a wrong offset!");
static_assert(offsetof(FCAServicesFixedReward, M_quantity) == 0x000018, "Member 'FCAServicesFixedReward::M_quantity' has a wrong offset!");

// ScriptStruct keaton.CAAITargetDistanceCheckData
// 0x0008 (0x0008 - 0x0000)
struct FCAAITargetDistanceCheckData final
{
public:
	ECATargetDistanceCheckTest                    M_test;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECADistanceType                               M_distance_type;                                   // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECADistanceCheckTestValue                     M_distance_check_test_value;                       // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_test_value;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAITargetDistanceCheckData) == 0x000004, "Wrong alignment on FCAAITargetDistanceCheckData");
static_assert(sizeof(FCAAITargetDistanceCheckData) == 0x000008, "Wrong size on FCAAITargetDistanceCheckData");
static_assert(offsetof(FCAAITargetDistanceCheckData, M_test) == 0x000000, "Member 'FCAAITargetDistanceCheckData::M_test' has a wrong offset!");
static_assert(offsetof(FCAAITargetDistanceCheckData, M_distance_type) == 0x000001, "Member 'FCAAITargetDistanceCheckData::M_distance_type' has a wrong offset!");
static_assert(offsetof(FCAAITargetDistanceCheckData, M_distance_check_test_value) == 0x000002, "Member 'FCAAITargetDistanceCheckData::M_distance_check_test_value' has a wrong offset!");
static_assert(offsetof(FCAAITargetDistanceCheckData, M_test_value) == 0x000004, "Member 'FCAAITargetDistanceCheckData::M_test_value' has a wrong offset!");

// ScriptStruct keaton.CAAIDistanceCheckData
// 0x0008 (0x0008 - 0x0000)
struct FCAAIDistanceCheckData final
{
public:
	ECAFromSourceLocation                         M_source_location;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAToTargetLocation                           M_target_location;                                 // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECADistCheckTestValue                         M_distance_check_test_value;                       // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_test_value;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAIDistanceCheckData) == 0x000004, "Wrong alignment on FCAAIDistanceCheckData");
static_assert(sizeof(FCAAIDistanceCheckData) == 0x000008, "Wrong size on FCAAIDistanceCheckData");
static_assert(offsetof(FCAAIDistanceCheckData, M_source_location) == 0x000000, "Member 'FCAAIDistanceCheckData::M_source_location' has a wrong offset!");
static_assert(offsetof(FCAAIDistanceCheckData, M_target_location) == 0x000001, "Member 'FCAAIDistanceCheckData::M_target_location' has a wrong offset!");
static_assert(offsetof(FCAAIDistanceCheckData, M_distance_check_test_value) == 0x000002, "Member 'FCAAIDistanceCheckData::M_distance_check_test_value' has a wrong offset!");
static_assert(offsetof(FCAAIDistanceCheckData, M_test_value) == 0x000004, "Member 'FCAAIDistanceCheckData::M_test_value' has a wrong offset!");

// ScriptStruct keaton.CAStaticMeshWithSequenceTag
// 0x0018 (0x0018 - 0x0000)
struct FCAStaticMeshWithSequenceTag final
{
public:
	class UStaticMesh*                            M_static_mesh;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_sequence_tag;                                    // 0x0008(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAStaticMeshWithSequenceTag) == 0x000008, "Wrong alignment on FCAStaticMeshWithSequenceTag");
static_assert(sizeof(FCAStaticMeshWithSequenceTag) == 0x000018, "Wrong size on FCAStaticMeshWithSequenceTag");
static_assert(offsetof(FCAStaticMeshWithSequenceTag, M_static_mesh) == 0x000000, "Member 'FCAStaticMeshWithSequenceTag::M_static_mesh' has a wrong offset!");
static_assert(offsetof(FCAStaticMeshWithSequenceTag, M_sequence_tag) == 0x000008, "Member 'FCAStaticMeshWithSequenceTag::M_sequence_tag' has a wrong offset!");

// ScriptStruct keaton.CAAIVariableCheckData
// 0x0014 (0x0014 - 0x0000)
struct FCAAIVariableCheckData final
{
public:
	ECAVariableToCheck                            M_variable_to_check;                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_special_to_check;                                // 0x0004(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_invert_condition;                                // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAIVariableCheckData) == 0x000004, "Wrong alignment on FCAAIVariableCheckData");
static_assert(sizeof(FCAAIVariableCheckData) == 0x000014, "Wrong size on FCAAIVariableCheckData");
static_assert(offsetof(FCAAIVariableCheckData, M_variable_to_check) == 0x000000, "Member 'FCAAIVariableCheckData::M_variable_to_check' has a wrong offset!");
static_assert(offsetof(FCAAIVariableCheckData, M_special_to_check) == 0x000004, "Member 'FCAAIVariableCheckData::M_special_to_check' has a wrong offset!");
static_assert(offsetof(FCAAIVariableCheckData, M_invert_condition) == 0x000010, "Member 'FCAAIVariableCheckData::M_invert_condition' has a wrong offset!");

// ScriptStruct keaton.CAAIGetTimeSinceData
// 0x0008 (0x0008 - 0x0000)
struct FCAAIGetTimeSinceData final
{
public:
	ECATimeSince                                  M_time_since;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArithmeticKeyOperation                       M_operation;                                       // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATimeSinceTestValue                         M_time_since_test_value;                           // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_seconds;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAIGetTimeSinceData) == 0x000004, "Wrong alignment on FCAAIGetTimeSinceData");
static_assert(sizeof(FCAAIGetTimeSinceData) == 0x000008, "Wrong size on FCAAIGetTimeSinceData");
static_assert(offsetof(FCAAIGetTimeSinceData, M_time_since) == 0x000000, "Member 'FCAAIGetTimeSinceData::M_time_since' has a wrong offset!");
static_assert(offsetof(FCAAIGetTimeSinceData, M_operation) == 0x000001, "Member 'FCAAIGetTimeSinceData::M_operation' has a wrong offset!");
static_assert(offsetof(FCAAIGetTimeSinceData, M_time_since_test_value) == 0x000002, "Member 'FCAAIGetTimeSinceData::M_time_since_test_value' has a wrong offset!");
static_assert(offsetof(FCAAIGetTimeSinceData, M_seconds) == 0x000004, "Member 'FCAAIGetTimeSinceData::M_seconds' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_Ladder
// 0x0050 (0x0060 - 0x0010)
struct FCAMovementData_Ladder final : public FCAMovementModeData
{
public:
	uint8                                         Pad_10[0x4];                                       // 0x0010(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_capsule_half_height;                             // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_vertical_acceleration;                           // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fast_climb_speed;                                // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_camera_yaw_range;                                // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_camera_pitch_min;                                // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_camera_pitch_max;                                // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_facing_test_angle;                               // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_stick_push_towards_ladder_angle;                 // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_jump_on_vertical_attach_speed;                   // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_look_up_pitch_threshold;                         // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_auto_climb_up_distance;                          // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_camera_rotation_speed;                           // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_auto_climb_down_distance;                        // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_look_down_pitch_threshold;                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_maximum_try_time;                                // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_auto_dismount_distance_from_top;                 // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_auto_dismount_distance_from_bottom;              // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_jump_off_max_speed;                              // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_air_control_from_ladder;                         // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMovementData_Ladder) == 0x000008, "Wrong alignment on FCAMovementData_Ladder");
static_assert(sizeof(FCAMovementData_Ladder) == 0x000060, "Wrong size on FCAMovementData_Ladder");
static_assert(offsetof(FCAMovementData_Ladder, M_capsule_half_height) == 0x000014, "Member 'FCAMovementData_Ladder::M_capsule_half_height' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Ladder, M_vertical_acceleration) == 0x000018, "Member 'FCAMovementData_Ladder::M_vertical_acceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Ladder, M_fast_climb_speed) == 0x00001C, "Member 'FCAMovementData_Ladder::M_fast_climb_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Ladder, M_camera_yaw_range) == 0x000020, "Member 'FCAMovementData_Ladder::M_camera_yaw_range' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Ladder, M_camera_pitch_min) == 0x000024, "Member 'FCAMovementData_Ladder::M_camera_pitch_min' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Ladder, M_camera_pitch_max) == 0x000028, "Member 'FCAMovementData_Ladder::M_camera_pitch_max' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Ladder, M_facing_test_angle) == 0x00002C, "Member 'FCAMovementData_Ladder::M_facing_test_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Ladder, M_stick_push_towards_ladder_angle) == 0x000030, "Member 'FCAMovementData_Ladder::M_stick_push_towards_ladder_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Ladder, M_jump_on_vertical_attach_speed) == 0x000034, "Member 'FCAMovementData_Ladder::M_jump_on_vertical_attach_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Ladder, M_look_up_pitch_threshold) == 0x000038, "Member 'FCAMovementData_Ladder::M_look_up_pitch_threshold' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Ladder, M_auto_climb_up_distance) == 0x00003C, "Member 'FCAMovementData_Ladder::M_auto_climb_up_distance' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Ladder, M_camera_rotation_speed) == 0x000040, "Member 'FCAMovementData_Ladder::M_camera_rotation_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Ladder, M_auto_climb_down_distance) == 0x000044, "Member 'FCAMovementData_Ladder::M_auto_climb_down_distance' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Ladder, M_look_down_pitch_threshold) == 0x000048, "Member 'FCAMovementData_Ladder::M_look_down_pitch_threshold' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Ladder, M_maximum_try_time) == 0x00004C, "Member 'FCAMovementData_Ladder::M_maximum_try_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Ladder, M_auto_dismount_distance_from_top) == 0x000050, "Member 'FCAMovementData_Ladder::M_auto_dismount_distance_from_top' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Ladder, M_auto_dismount_distance_from_bottom) == 0x000054, "Member 'FCAMovementData_Ladder::M_auto_dismount_distance_from_bottom' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Ladder, M_jump_off_max_speed) == 0x000058, "Member 'FCAMovementData_Ladder::M_jump_off_max_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Ladder, M_air_control_from_ladder) == 0x00005C, "Member 'FCAMovementData_Ladder::M_air_control_from_ladder' has a wrong offset!");

// ScriptStruct keaton.ReplicatedGameplayTagsBitmask
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FReplicatedGameplayTagsBitmask final
{
public:
	int16                                         M_Version;                                         // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2[0x2E];                                       // 0x0002(0x002E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicatedGameplayTagsBitmask) == 0x000008, "Wrong alignment on FReplicatedGameplayTagsBitmask");
static_assert(sizeof(FReplicatedGameplayTagsBitmask) == 0x000030, "Wrong size on FReplicatedGameplayTagsBitmask");
static_assert(offsetof(FReplicatedGameplayTagsBitmask, M_Version) == 0x000000, "Member 'FReplicatedGameplayTagsBitmask::M_Version' has a wrong offset!");

// ScriptStruct keaton.CAHUDWeaponTexturesTableRow
// 0x0008 (0x0010 - 0x0008)
struct FCAHUDWeaponTexturesTableRow final : public FTableRowBase
{
public:
	class UTexture2D*                             M_weapon_texture;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDWeaponTexturesTableRow) == 0x000008, "Wrong alignment on FCAHUDWeaponTexturesTableRow");
static_assert(sizeof(FCAHUDWeaponTexturesTableRow) == 0x000010, "Wrong size on FCAHUDWeaponTexturesTableRow");
static_assert(offsetof(FCAHUDWeaponTexturesTableRow, M_weapon_texture) == 0x000008, "Member 'FCAHUDWeaponTexturesTableRow::M_weapon_texture' has a wrong offset!");

// ScriptStruct keaton.CASocialProfile
// 0x0038 (0x0038 - 0x0000)
struct FCASocialProfile final
{
public:
	int64                                         M_player_level;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         M_prestige_level;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_current_platform;                                // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_equipped_avatar;                                 // 0x0020(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASocialProfile) == 0x000008, "Wrong alignment on FCASocialProfile");
static_assert(sizeof(FCASocialProfile) == 0x000038, "Wrong size on FCASocialProfile");
static_assert(offsetof(FCASocialProfile, M_player_level) == 0x000000, "Member 'FCASocialProfile::M_player_level' has a wrong offset!");
static_assert(offsetof(FCASocialProfile, M_prestige_level) == 0x000008, "Member 'FCASocialProfile::M_prestige_level' has a wrong offset!");
static_assert(offsetof(FCASocialProfile, M_current_platform) == 0x000010, "Member 'FCASocialProfile::M_current_platform' has a wrong offset!");
static_assert(offsetof(FCASocialProfile, M_equipped_avatar) == 0x000020, "Member 'FCASocialProfile::M_equipped_avatar' has a wrong offset!");

// ScriptStruct keaton.CAAbilitySystemGameplayTagInitialiser
// 0x0018 (0x0018 - 0x0000)
struct FCAAbilitySystemGameplayTagInitialiser final
{
public:
	struct FDataTableRowHandle                    GameplayTagEntry;                                  // 0x0000(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAbilitySystemGameplayTagInitialiser) == 0x000008, "Wrong alignment on FCAAbilitySystemGameplayTagInitialiser");
static_assert(sizeof(FCAAbilitySystemGameplayTagInitialiser) == 0x000018, "Wrong size on FCAAbilitySystemGameplayTagInitialiser");
static_assert(offsetof(FCAAbilitySystemGameplayTagInitialiser, GameplayTagEntry) == 0x000000, "Member 'FCAAbilitySystemGameplayTagInitialiser::GameplayTagEntry' has a wrong offset!");

// ScriptStruct keaton.ExtractionInProgressTriggerData
// 0x0010 (0x0010 - 0x0000)
struct FExtractionInProgressTriggerData final
{
public:
	float                                         M_extraction_progress;                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_trigger_tag;                                     // 0x0004(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExtractionInProgressTriggerData) == 0x000004, "Wrong alignment on FExtractionInProgressTriggerData");
static_assert(sizeof(FExtractionInProgressTriggerData) == 0x000010, "Wrong size on FExtractionInProgressTriggerData");
static_assert(offsetof(FExtractionInProgressTriggerData, M_extraction_progress) == 0x000000, "Member 'FExtractionInProgressTriggerData::M_extraction_progress' has a wrong offset!");
static_assert(offsetof(FExtractionInProgressTriggerData, M_trigger_tag) == 0x000004, "Member 'FExtractionInProgressTriggerData::M_trigger_tag' has a wrong offset!");

// ScriptStruct keaton.CAPlayerCardStatData
// 0x0098 (0x0098 - 0x0000)
struct FCAPlayerCardStatData final
{
public:
	struct FCAText                                M_stat_name;                                       // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_suffix;                                          // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_stat_icon;                                       // 0x0060(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_stat_value;                                      // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPlayerCardStatData) == 0x000008, "Wrong alignment on FCAPlayerCardStatData");
static_assert(sizeof(FCAPlayerCardStatData) == 0x000098, "Wrong size on FCAPlayerCardStatData");
static_assert(offsetof(FCAPlayerCardStatData, M_stat_name) == 0x000000, "Member 'FCAPlayerCardStatData::M_stat_name' has a wrong offset!");
static_assert(offsetof(FCAPlayerCardStatData, M_suffix) == 0x000030, "Member 'FCAPlayerCardStatData::M_suffix' has a wrong offset!");
static_assert(offsetof(FCAPlayerCardStatData, M_stat_icon) == 0x000060, "Member 'FCAPlayerCardStatData::M_stat_icon' has a wrong offset!");
static_assert(offsetof(FCAPlayerCardStatData, M_stat_value) == 0x000090, "Member 'FCAPlayerCardStatData::M_stat_value' has a wrong offset!");

// ScriptStruct keaton.CAAbilitySystemGameplayTagConfig
// 0x0060 (0x0068 - 0x0008)
struct FCAAbilitySystemGameplayTagConfig final : public FTableRowBase
{
public:
	struct FGameplayTagContainer                  PersistentTags;                                    // 0x0008(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ReplicatedTags;                                    // 0x0028(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  WhitelistedTags;                                   // 0x0048(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAbilitySystemGameplayTagConfig) == 0x000008, "Wrong alignment on FCAAbilitySystemGameplayTagConfig");
static_assert(sizeof(FCAAbilitySystemGameplayTagConfig) == 0x000068, "Wrong size on FCAAbilitySystemGameplayTagConfig");
static_assert(offsetof(FCAAbilitySystemGameplayTagConfig, PersistentTags) == 0x000008, "Member 'FCAAbilitySystemGameplayTagConfig::PersistentTags' has a wrong offset!");
static_assert(offsetof(FCAAbilitySystemGameplayTagConfig, ReplicatedTags) == 0x000028, "Member 'FCAAbilitySystemGameplayTagConfig::ReplicatedTags' has a wrong offset!");
static_assert(offsetof(FCAAbilitySystemGameplayTagConfig, WhitelistedTags) == 0x000048, "Member 'FCAAbilitySystemGameplayTagConfig::WhitelistedTags' has a wrong offset!");

// ScriptStruct keaton.LevelLoadInfo
// 0x0020 (0x0020 - 0x0000)
struct FLevelLoadInfo final
{
public:
	class FString                                 M_level_name;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        M_load_time_s;                                     // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_merged_kit_pieces;                               // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelLoadInfo) == 0x000008, "Wrong alignment on FLevelLoadInfo");
static_assert(sizeof(FLevelLoadInfo) == 0x000020, "Wrong size on FLevelLoadInfo");
static_assert(offsetof(FLevelLoadInfo, M_level_name) == 0x000000, "Member 'FLevelLoadInfo::M_level_name' has a wrong offset!");
static_assert(offsetof(FLevelLoadInfo, M_load_time_s) == 0x000010, "Member 'FLevelLoadInfo::M_load_time_s' has a wrong offset!");
static_assert(offsetof(FLevelLoadInfo, M_merged_kit_pieces) == 0x000018, "Member 'FLevelLoadInfo::M_merged_kit_pieces' has a wrong offset!");

// ScriptStruct keaton.CAAttributeModCallbackRecord
// 0x02F0 (0x02F0 - 0x0000)
struct FCAAttributeModCallbackRecord final
{
public:
	struct FGameplayEffectSpec                    M_spec;                                            // 0x0000(0x0298)(NativeAccessSpecifierPublic)
	struct FGameplayModifierEvaluatedData         M_mod;                                             // 0x0298(0x0050)(NativeAccessSpecifierPublic)
	float                                         M_new_value;                                       // 0x02E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_old_value;                                       // 0x02EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAttributeModCallbackRecord) == 0x000008, "Wrong alignment on FCAAttributeModCallbackRecord");
static_assert(sizeof(FCAAttributeModCallbackRecord) == 0x0002F0, "Wrong size on FCAAttributeModCallbackRecord");
static_assert(offsetof(FCAAttributeModCallbackRecord, M_spec) == 0x000000, "Member 'FCAAttributeModCallbackRecord::M_spec' has a wrong offset!");
static_assert(offsetof(FCAAttributeModCallbackRecord, M_mod) == 0x000298, "Member 'FCAAttributeModCallbackRecord::M_mod' has a wrong offset!");
static_assert(offsetof(FCAAttributeModCallbackRecord, M_new_value) == 0x0002E8, "Member 'FCAAttributeModCallbackRecord::M_new_value' has a wrong offset!");
static_assert(offsetof(FCAAttributeModCallbackRecord, M_old_value) == 0x0002EC, "Member 'FCAAttributeModCallbackRecord::M_old_value' has a wrong offset!");

// ScriptStruct keaton.CATargetingSchemeInfo
// 0x0038 (0x0038 - 0x0000)
struct FCATargetingSchemeInfo final
{
public:
	class ACATargetingScheme*                     M_scheme;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tag;                                             // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayAbilitySpecHandle>     M_ability_users;                                   // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCATargetingSchemeInfo) == 0x000008, "Wrong alignment on FCATargetingSchemeInfo");
static_assert(sizeof(FCATargetingSchemeInfo) == 0x000038, "Wrong size on FCATargetingSchemeInfo");
static_assert(offsetof(FCATargetingSchemeInfo, M_scheme) == 0x000000, "Member 'FCATargetingSchemeInfo::M_scheme' has a wrong offset!");
static_assert(offsetof(FCATargetingSchemeInfo, M_tag) == 0x000008, "Member 'FCATargetingSchemeInfo::M_tag' has a wrong offset!");
static_assert(offsetof(FCATargetingSchemeInfo, M_ability_users) == 0x000018, "Member 'FCATargetingSchemeInfo::M_ability_users' has a wrong offset!");

// ScriptStruct keaton.CAObtainableOption
// 0x0040 (0x0040 - 0x0000)
struct FCAObtainableOption final
{
public:
	ECAObtainableType                             M_type;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_services_event;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_handle;                                          // 0x0018(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int64                                         M_quantity;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_obtainable;                                   // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAObtainableOption) == 0x000008, "Wrong alignment on FCAObtainableOption");
static_assert(sizeof(FCAObtainableOption) == 0x000040, "Wrong size on FCAObtainableOption");
static_assert(offsetof(FCAObtainableOption, M_type) == 0x000000, "Member 'FCAObtainableOption::M_type' has a wrong offset!");
static_assert(offsetof(FCAObtainableOption, M_services_event) == 0x000008, "Member 'FCAObtainableOption::M_services_event' has a wrong offset!");
static_assert(offsetof(FCAObtainableOption, M_handle) == 0x000018, "Member 'FCAObtainableOption::M_handle' has a wrong offset!");
static_assert(offsetof(FCAObtainableOption, M_quantity) == 0x000030, "Member 'FCAObtainableOption::M_quantity' has a wrong offset!");
static_assert(offsetof(FCAObtainableOption, M_is_obtainable) == 0x000038, "Member 'FCAObtainableOption::M_is_obtainable' has a wrong offset!");

// ScriptStruct keaton.CAManagedGameplayTagData
// 0x0014 (0x0014 - 0x0000)
struct FCAManagedGameplayTagData final
{
public:
	ECAPlayerAbilityMode                          M_mode;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_tag;                                             // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAManagedGaplayAbilityTagType                M_type;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAManagedGameplayTagData) == 0x000004, "Wrong alignment on FCAManagedGameplayTagData");
static_assert(sizeof(FCAManagedGameplayTagData) == 0x000014, "Wrong size on FCAManagedGameplayTagData");
static_assert(offsetof(FCAManagedGameplayTagData, M_mode) == 0x000000, "Member 'FCAManagedGameplayTagData::M_mode' has a wrong offset!");
static_assert(offsetof(FCAManagedGameplayTagData, M_tag) == 0x000004, "Member 'FCAManagedGameplayTagData::M_tag' has a wrong offset!");
static_assert(offsetof(FCAManagedGameplayTagData, M_type) == 0x000010, "Member 'FCAManagedGameplayTagData::M_type' has a wrong offset!");

// ScriptStruct keaton.MontageTaskData
// 0x0028 (0x0028 - 0x0000)
struct FMontageTaskData final
{
public:
	class UAnimMontage*                           M_anim_montage;                                    // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_play_rate;                                       // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_start_section;                                   // 0x000C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_anim_root_motion_translation_scale;              // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_start_time_seconds;                              // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_montage_priority;                                // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_enable_interrupt_event_after_blend_out;          // 0x0024(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMontageTaskData) == 0x000008, "Wrong alignment on FMontageTaskData");
static_assert(sizeof(FMontageTaskData) == 0x000028, "Wrong size on FMontageTaskData");
static_assert(offsetof(FMontageTaskData, M_anim_montage) == 0x000000, "Member 'FMontageTaskData::M_anim_montage' has a wrong offset!");
static_assert(offsetof(FMontageTaskData, M_play_rate) == 0x000008, "Member 'FMontageTaskData::M_play_rate' has a wrong offset!");
static_assert(offsetof(FMontageTaskData, M_start_section) == 0x00000C, "Member 'FMontageTaskData::M_start_section' has a wrong offset!");
static_assert(offsetof(FMontageTaskData, M_anim_root_motion_translation_scale) == 0x000018, "Member 'FMontageTaskData::M_anim_root_motion_translation_scale' has a wrong offset!");
static_assert(offsetof(FMontageTaskData, M_start_time_seconds) == 0x00001C, "Member 'FMontageTaskData::M_start_time_seconds' has a wrong offset!");
static_assert(offsetof(FMontageTaskData, M_montage_priority) == 0x000020, "Member 'FMontageTaskData::M_montage_priority' has a wrong offset!");
static_assert(offsetof(FMontageTaskData, M_enable_interrupt_event_after_blend_out) == 0x000024, "Member 'FMontageTaskData::M_enable_interrupt_event_after_blend_out' has a wrong offset!");

// ScriptStruct keaton.CASubCapsuleData
// 0x0018 (0x0018 - 0x0000)
struct FCASubCapsuleData final
{
public:
	struct FVector                                M_offset;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_pitch;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_radius;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_half_height;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASubCapsuleData) == 0x000004, "Wrong alignment on FCASubCapsuleData");
static_assert(sizeof(FCASubCapsuleData) == 0x000018, "Wrong size on FCASubCapsuleData");
static_assert(offsetof(FCASubCapsuleData, M_offset) == 0x000000, "Member 'FCASubCapsuleData::M_offset' has a wrong offset!");
static_assert(offsetof(FCASubCapsuleData, M_pitch) == 0x00000C, "Member 'FCASubCapsuleData::M_pitch' has a wrong offset!");
static_assert(offsetof(FCASubCapsuleData, M_radius) == 0x000010, "Member 'FCASubCapsuleData::M_radius' has a wrong offset!");
static_assert(offsetof(FCASubCapsuleData, M_half_height) == 0x000014, "Member 'FCASubCapsuleData::M_half_height' has a wrong offset!");

// ScriptStruct keaton.CAActionData
// 0x0058 (0x0058 - 0x0000)
struct FCAActionData final
{
public:
	class FName                                   M_action;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputEvent                                   M_input_event;                                     // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_hold_time;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_hold_time;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_controller_only;                                 // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAUIFlags                             M_flags;                                           // 0x001C(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAFTUEFlags                           M_ftue;                                            // 0x0024(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAGameDatabaseRowHandle               M_keyboard_database_row_handle;                    // 0x0028(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_controller_database_row_handle;                  // 0x0040(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAActionData) == 0x000004, "Wrong alignment on FCAActionData");
static_assert(sizeof(FCAActionData) == 0x000058, "Wrong size on FCAActionData");
static_assert(offsetof(FCAActionData, M_action) == 0x000000, "Member 'FCAActionData::M_action' has a wrong offset!");
static_assert(offsetof(FCAActionData, M_input_event) == 0x00000C, "Member 'FCAActionData::M_input_event' has a wrong offset!");
static_assert(offsetof(FCAActionData, M_hold_time) == 0x000010, "Member 'FCAActionData::M_hold_time' has a wrong offset!");
static_assert(offsetof(FCAActionData, M_max_hold_time) == 0x000014, "Member 'FCAActionData::M_max_hold_time' has a wrong offset!");
static_assert(offsetof(FCAActionData, M_controller_only) == 0x000018, "Member 'FCAActionData::M_controller_only' has a wrong offset!");
static_assert(offsetof(FCAActionData, M_flags) == 0x00001C, "Member 'FCAActionData::M_flags' has a wrong offset!");
static_assert(offsetof(FCAActionData, M_ftue) == 0x000024, "Member 'FCAActionData::M_ftue' has a wrong offset!");
static_assert(offsetof(FCAActionData, M_keyboard_database_row_handle) == 0x000028, "Member 'FCAActionData::M_keyboard_database_row_handle' has a wrong offset!");
static_assert(offsetof(FCAActionData, M_controller_database_row_handle) == 0x000040, "Member 'FCAActionData::M_controller_database_row_handle' has a wrong offset!");

// ScriptStruct keaton.CAActionBindingData
// 0x00F8 (0x00F8 - 0x0000)
struct FCAActionBindingData final
{
public:
	struct FCAText                                M_label;                                           // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAActionData                          M_action_data;                                     // 0x0030(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_display_in_menu_bar;                             // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAUIEventType                                M_event_type;                                      // 0x0089(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAUIEventMapping                      M_ui_event_type;                                   // 0x0090(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAActionBindingData) == 0x000008, "Wrong alignment on FCAActionBindingData");
static_assert(sizeof(FCAActionBindingData) == 0x0000F8, "Wrong size on FCAActionBindingData");
static_assert(offsetof(FCAActionBindingData, M_label) == 0x000000, "Member 'FCAActionBindingData::M_label' has a wrong offset!");
static_assert(offsetof(FCAActionBindingData, M_action_data) == 0x000030, "Member 'FCAActionBindingData::M_action_data' has a wrong offset!");
static_assert(offsetof(FCAActionBindingData, M_display_in_menu_bar) == 0x000088, "Member 'FCAActionBindingData::M_display_in_menu_bar' has a wrong offset!");
static_assert(offsetof(FCAActionBindingData, M_event_type) == 0x000089, "Member 'FCAActionBindingData::M_event_type' has a wrong offset!");
static_assert(offsetof(FCAActionBindingData, M_ui_event_type) == 0x000090, "Member 'FCAActionBindingData::M_ui_event_type' has a wrong offset!");

// ScriptStruct keaton.CAActionBindingContext
// 0x0018 (0x0020 - 0x0008)
struct FCAActionBindingContext final : public FTableRowBase
{
public:
	bool                                          M_consume;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_priority;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAActionBindingData>           M_menu_items;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAActionBindingContext) == 0x000008, "Wrong alignment on FCAActionBindingContext");
static_assert(sizeof(FCAActionBindingContext) == 0x000020, "Wrong size on FCAActionBindingContext");
static_assert(offsetof(FCAActionBindingContext, M_consume) == 0x000008, "Member 'FCAActionBindingContext::M_consume' has a wrong offset!");
static_assert(offsetof(FCAActionBindingContext, M_priority) == 0x00000C, "Member 'FCAActionBindingContext::M_priority' has a wrong offset!");
static_assert(offsetof(FCAActionBindingContext, M_menu_items) == 0x000010, "Member 'FCAActionBindingContext::M_menu_items' has a wrong offset!");

// ScriptStruct keaton.CANotificationRequest
// 0x0018 (0x0018 - 0x0000)
struct FCANotificationRequest final
{
public:
	struct FCAGameDatabaseTypedRowHandle          M_handle;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	ECADisplaySlot                                M_dismiss_focus_slot;                              // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_guid;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANotificationRequest) == 0x000008, "Wrong alignment on FCANotificationRequest");
static_assert(sizeof(FCANotificationRequest) == 0x000018, "Wrong size on FCANotificationRequest");
static_assert(offsetof(FCANotificationRequest, M_handle) == 0x000000, "Member 'FCANotificationRequest::M_handle' has a wrong offset!");
static_assert(offsetof(FCANotificationRequest, M_dismiss_focus_slot) == 0x000004, "Member 'FCANotificationRequest::M_dismiss_focus_slot' has a wrong offset!");
static_assert(offsetof(FCANotificationRequest, M_guid) == 0x000008, "Member 'FCANotificationRequest::M_guid' has a wrong offset!");

// ScriptStruct keaton.CAOptionNavigationData
// 0x0038 (0x0038 - 0x0000)
struct FCAOptionNavigationData final
{
public:
	struct FCAGameDatabaseRowHandle               M_menu_data_handle;                                // 0x0000(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   M_navigation_id;                                   // 0x0018(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCAMenuGroup*                           M_menu_group;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAOptionNavigationData) == 0x000008, "Wrong alignment on FCAOptionNavigationData");
static_assert(sizeof(FCAOptionNavigationData) == 0x000038, "Wrong size on FCAOptionNavigationData");
static_assert(offsetof(FCAOptionNavigationData, M_menu_data_handle) == 0x000000, "Member 'FCAOptionNavigationData::M_menu_data_handle' has a wrong offset!");
static_assert(offsetof(FCAOptionNavigationData, M_navigation_id) == 0x000018, "Member 'FCAOptionNavigationData::M_navigation_id' has a wrong offset!");
static_assert(offsetof(FCAOptionNavigationData, M_menu_group) == 0x000028, "Member 'FCAOptionNavigationData::M_menu_group' has a wrong offset!");

// ScriptStruct keaton.WeaponChargeData
// 0x0008 (0x0008 - 0x0000)
struct FWeaponChargeData final
{
public:
	float                                         M_start_charge_time;                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_charge_duration;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponChargeData) == 0x000004, "Wrong alignment on FWeaponChargeData");
static_assert(sizeof(FWeaponChargeData) == 0x000008, "Wrong size on FWeaponChargeData");
static_assert(offsetof(FWeaponChargeData, M_start_charge_time) == 0x000000, "Member 'FWeaponChargeData::M_start_charge_time' has a wrong offset!");
static_assert(offsetof(FWeaponChargeData, M_charge_duration) == 0x000004, "Member 'FWeaponChargeData::M_charge_duration' has a wrong offset!");

// ScriptStruct keaton.CAViewCone
// 0x0040 (0x0048 - 0x0008)
struct FCAViewCone final : public FTableRowBase
{
public:
	float                                         M_view_angle_max;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_view_angle_close;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_view_range_close;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_view_angle_medium;                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_view_range_medium;                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_view_angle_long;                                 // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_view_max_height;                                 // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sight_scalar_close;                              // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sight_scalar_long;                               // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sight_scalar_blend_rate;                         // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_view_offset_pitch;                               // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_view_offset_yaw;                                 // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_view_offset_position;                            // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAViewConeActiveType                         M_active_type;                                     // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAViewCone) == 0x000008, "Wrong alignment on FCAViewCone");
static_assert(sizeof(FCAViewCone) == 0x000048, "Wrong size on FCAViewCone");
static_assert(offsetof(FCAViewCone, M_view_angle_max) == 0x000008, "Member 'FCAViewCone::M_view_angle_max' has a wrong offset!");
static_assert(offsetof(FCAViewCone, M_view_angle_close) == 0x00000C, "Member 'FCAViewCone::M_view_angle_close' has a wrong offset!");
static_assert(offsetof(FCAViewCone, M_view_range_close) == 0x000010, "Member 'FCAViewCone::M_view_range_close' has a wrong offset!");
static_assert(offsetof(FCAViewCone, M_view_angle_medium) == 0x000014, "Member 'FCAViewCone::M_view_angle_medium' has a wrong offset!");
static_assert(offsetof(FCAViewCone, M_view_range_medium) == 0x000018, "Member 'FCAViewCone::M_view_range_medium' has a wrong offset!");
static_assert(offsetof(FCAViewCone, M_view_angle_long) == 0x00001C, "Member 'FCAViewCone::M_view_angle_long' has a wrong offset!");
static_assert(offsetof(FCAViewCone, M_view_max_height) == 0x000020, "Member 'FCAViewCone::M_view_max_height' has a wrong offset!");
static_assert(offsetof(FCAViewCone, M_sight_scalar_close) == 0x000024, "Member 'FCAViewCone::M_sight_scalar_close' has a wrong offset!");
static_assert(offsetof(FCAViewCone, M_sight_scalar_long) == 0x000028, "Member 'FCAViewCone::M_sight_scalar_long' has a wrong offset!");
static_assert(offsetof(FCAViewCone, M_sight_scalar_blend_rate) == 0x00002C, "Member 'FCAViewCone::M_sight_scalar_blend_rate' has a wrong offset!");
static_assert(offsetof(FCAViewCone, M_view_offset_pitch) == 0x000030, "Member 'FCAViewCone::M_view_offset_pitch' has a wrong offset!");
static_assert(offsetof(FCAViewCone, M_view_offset_yaw) == 0x000034, "Member 'FCAViewCone::M_view_offset_yaw' has a wrong offset!");
static_assert(offsetof(FCAViewCone, M_view_offset_position) == 0x000038, "Member 'FCAViewCone::M_view_offset_position' has a wrong offset!");
static_assert(offsetof(FCAViewCone, M_active_type) == 0x000044, "Member 'FCAViewCone::M_active_type' has a wrong offset!");

// ScriptStruct keaton.CAAdrenalineJunkieBuffRequest
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FCAAdrenalineJunkieBuffRequest final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAdrenalineJunkieBuffRequest) == 0x000004, "Wrong alignment on FCAAdrenalineJunkieBuffRequest");
static_assert(sizeof(FCAAdrenalineJunkieBuffRequest) == 0x000010, "Wrong size on FCAAdrenalineJunkieBuffRequest");

// ScriptStruct keaton.CAReplicatedBitArray
// 0x0018 (0x0018 - 0x0000)
struct FCAReplicatedBitArray final
{
public:
	TArray<uint32>                                M_bits;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint16                                        M_num;                                             // 0x0010(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAReplicatedBitArray) == 0x000008, "Wrong alignment on FCAReplicatedBitArray");
static_assert(sizeof(FCAReplicatedBitArray) == 0x000018, "Wrong size on FCAReplicatedBitArray");
static_assert(offsetof(FCAReplicatedBitArray, M_bits) == 0x000000, "Member 'FCAReplicatedBitArray::M_bits' has a wrong offset!");
static_assert(offsetof(FCAReplicatedBitArray, M_num) == 0x000010, "Member 'FCAReplicatedBitArray::M_num' has a wrong offset!");

// ScriptStruct keaton.CAFoamReplicatedOffset
// 0x0004 (0x0004 - 0x0000)
struct FCAFoamReplicatedOffset final
{
public:
	int8                                          M_mesh_index;                                      // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          M_offset_x;                                        // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          M_offset_y;                                        // 0x0002(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          M_offset_z;                                        // 0x0003(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFoamReplicatedOffset) == 0x000001, "Wrong alignment on FCAFoamReplicatedOffset");
static_assert(sizeof(FCAFoamReplicatedOffset) == 0x000004, "Wrong size on FCAFoamReplicatedOffset");
static_assert(offsetof(FCAFoamReplicatedOffset, M_mesh_index) == 0x000000, "Member 'FCAFoamReplicatedOffset::M_mesh_index' has a wrong offset!");
static_assert(offsetof(FCAFoamReplicatedOffset, M_offset_x) == 0x000001, "Member 'FCAFoamReplicatedOffset::M_offset_x' has a wrong offset!");
static_assert(offsetof(FCAFoamReplicatedOffset, M_offset_y) == 0x000002, "Member 'FCAFoamReplicatedOffset::M_offset_y' has a wrong offset!");
static_assert(offsetof(FCAFoamReplicatedOffset, M_offset_z) == 0x000003, "Member 'FCAFoamReplicatedOffset::M_offset_z' has a wrong offset!");

// ScriptStruct keaton.CAFoamStatus
// 0x0040 (0x0040 - 0x0000)
struct FCAFoamStatus final
{
public:
	struct FCAReplicatedBitArray                  M_ActiveFoamArray;                                 // 0x0000(0x0018)(Transient, NativeAccessSpecifierPrivate)
	struct FCAReplicatedBitArray                  M_BlockedFoamArray;                                // 0x0018(0x0018)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FCAFoamReplicatedOffset>        M_FoamBlobsOffsets;                                // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCAFoamStatus) == 0x000008, "Wrong alignment on FCAFoamStatus");
static_assert(sizeof(FCAFoamStatus) == 0x000040, "Wrong size on FCAFoamStatus");
static_assert(offsetof(FCAFoamStatus, M_ActiveFoamArray) == 0x000000, "Member 'FCAFoamStatus::M_ActiveFoamArray' has a wrong offset!");
static_assert(offsetof(FCAFoamStatus, M_BlockedFoamArray) == 0x000018, "Member 'FCAFoamStatus::M_BlockedFoamArray' has a wrong offset!");
static_assert(offsetof(FCAFoamStatus, M_FoamBlobsOffsets) == 0x000030, "Member 'FCAFoamStatus::M_FoamBlobsOffsets' has a wrong offset!");

// ScriptStruct keaton.CAUseAbilityConfig
// 0x00E0 (0x00E8 - 0x0008)
struct FCAUseAbilityConfig final : public FTableRowBase
{
public:
	int32                                         Global_priority;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Cancel_on_input_released;                          // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Required_input_duration;                           // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Persistent_hold_progress;                          // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Cancel_on_damage_taken;                            // 0x0015(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Cancel_on_focus_lost;                              // 0x0016(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Use_range;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Start_animation_during_input;                      // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ability_ends_completes_on_input_complete;          // 0x001D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_single_user_ability;                            // 0x001E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_remote_ability;                                 // 0x001F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAAbilityInputBinds                          Input_binding;                                     // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAGameDatabaseRowHandle               Interaction_row_handle;                            // 0x0024(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ECAUseInteractableType                        Interaction_type;                                  // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  Ability_tags;                                      // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Cancel_if_added_tags;                              // 0x0060(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          Check_for_obstruction;                             // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Obstruction_box_dimensions;                        // 0x0084(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Obstruction_box_euler_rotation;                    // 0x0090(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Obstruction_box_offset;                            // 0x009C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Obstruction_trace_channel;                         // 0x00A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Debug_obstruction_check;                           // 0x00B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Check_capsule_line_of_sight;                       // 0x00B5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B6[0x2];                                       // 0x00B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Line_of_sight_capsule_half_height;                 // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Line_of_sight_capsule_radius;                      // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Capsule_line_of_sight_end_offset;                  // 0x00C0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Capsule_line_of_sight_trace_channel;               // 0x00CC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Debug_capsule_line_of_sight_check;                 // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Check_height_is_in_threshold;                      // 0x00D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x2];                                       // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Maximum_height_difference;                         // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Check_height_object_offset;                        // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Debug_height_check;                                // 0x00E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAUseAbilityConfig) == 0x000008, "Wrong alignment on FCAUseAbilityConfig");
static_assert(sizeof(FCAUseAbilityConfig) == 0x0000E8, "Wrong size on FCAUseAbilityConfig");
static_assert(offsetof(FCAUseAbilityConfig, Global_priority) == 0x000008, "Member 'FCAUseAbilityConfig::Global_priority' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Cancel_on_input_released) == 0x00000C, "Member 'FCAUseAbilityConfig::Cancel_on_input_released' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Required_input_duration) == 0x000010, "Member 'FCAUseAbilityConfig::Required_input_duration' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Persistent_hold_progress) == 0x000014, "Member 'FCAUseAbilityConfig::Persistent_hold_progress' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Cancel_on_damage_taken) == 0x000015, "Member 'FCAUseAbilityConfig::Cancel_on_damage_taken' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Cancel_on_focus_lost) == 0x000016, "Member 'FCAUseAbilityConfig::Cancel_on_focus_lost' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Use_range) == 0x000018, "Member 'FCAUseAbilityConfig::Use_range' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Start_animation_during_input) == 0x00001C, "Member 'FCAUseAbilityConfig::Start_animation_during_input' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Ability_ends_completes_on_input_complete) == 0x00001D, "Member 'FCAUseAbilityConfig::Ability_ends_completes_on_input_complete' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Is_single_user_ability) == 0x00001E, "Member 'FCAUseAbilityConfig::Is_single_user_ability' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Is_remote_ability) == 0x00001F, "Member 'FCAUseAbilityConfig::Is_remote_ability' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Input_binding) == 0x000020, "Member 'FCAUseAbilityConfig::Input_binding' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Interaction_row_handle) == 0x000024, "Member 'FCAUseAbilityConfig::Interaction_row_handle' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Interaction_type) == 0x00003C, "Member 'FCAUseAbilityConfig::Interaction_type' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Ability_tags) == 0x000040, "Member 'FCAUseAbilityConfig::Ability_tags' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Cancel_if_added_tags) == 0x000060, "Member 'FCAUseAbilityConfig::Cancel_if_added_tags' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Check_for_obstruction) == 0x000080, "Member 'FCAUseAbilityConfig::Check_for_obstruction' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Obstruction_box_dimensions) == 0x000084, "Member 'FCAUseAbilityConfig::Obstruction_box_dimensions' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Obstruction_box_euler_rotation) == 0x000090, "Member 'FCAUseAbilityConfig::Obstruction_box_euler_rotation' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Obstruction_box_offset) == 0x00009C, "Member 'FCAUseAbilityConfig::Obstruction_box_offset' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Obstruction_trace_channel) == 0x0000A8, "Member 'FCAUseAbilityConfig::Obstruction_trace_channel' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Debug_obstruction_check) == 0x0000B4, "Member 'FCAUseAbilityConfig::Debug_obstruction_check' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Check_capsule_line_of_sight) == 0x0000B5, "Member 'FCAUseAbilityConfig::Check_capsule_line_of_sight' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Line_of_sight_capsule_half_height) == 0x0000B8, "Member 'FCAUseAbilityConfig::Line_of_sight_capsule_half_height' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Line_of_sight_capsule_radius) == 0x0000BC, "Member 'FCAUseAbilityConfig::Line_of_sight_capsule_radius' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Capsule_line_of_sight_end_offset) == 0x0000C0, "Member 'FCAUseAbilityConfig::Capsule_line_of_sight_end_offset' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Capsule_line_of_sight_trace_channel) == 0x0000CC, "Member 'FCAUseAbilityConfig::Capsule_line_of_sight_trace_channel' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Debug_capsule_line_of_sight_check) == 0x0000D8, "Member 'FCAUseAbilityConfig::Debug_capsule_line_of_sight_check' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Check_height_is_in_threshold) == 0x0000D9, "Member 'FCAUseAbilityConfig::Check_height_is_in_threshold' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Maximum_height_difference) == 0x0000DC, "Member 'FCAUseAbilityConfig::Maximum_height_difference' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Check_height_object_offset) == 0x0000E0, "Member 'FCAUseAbilityConfig::Check_height_object_offset' has a wrong offset!");
static_assert(offsetof(FCAUseAbilityConfig, Debug_height_check) == 0x0000E4, "Member 'FCAUseAbilityConfig::Debug_height_check' has a wrong offset!");

// ScriptStruct keaton.CARewardWeightData
// 0x0030 (0x0030 - 0x0000)
struct FCARewardWeightData final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                M_reward_ptr;                                      // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCARewardWeightData) == 0x000008, "Wrong alignment on FCARewardWeightData");
static_assert(sizeof(FCARewardWeightData) == 0x000030, "Wrong size on FCARewardWeightData");
static_assert(offsetof(FCARewardWeightData, M_reward_ptr) == 0x000020, "Member 'FCARewardWeightData::M_reward_ptr' has a wrong offset!");

// ScriptStruct keaton.CAAdrenalineJunkieVFXSet
// 0x0068 (0x0068 - 0x0000)
struct FCAAdrenalineJunkieVFXSet final
{
public:
	TSubclassOf<class ACAWeapon>                  M_weapon_class;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCAWeaponVFXSet>         M_base_vfx_set;                                    // 0x0008(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCAWeaponVFXSet>         M_damage_buff_vfx_set;                             // 0x0038(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAdrenalineJunkieVFXSet) == 0x000008, "Wrong alignment on FCAAdrenalineJunkieVFXSet");
static_assert(sizeof(FCAAdrenalineJunkieVFXSet) == 0x000068, "Wrong size on FCAAdrenalineJunkieVFXSet");
static_assert(offsetof(FCAAdrenalineJunkieVFXSet, M_weapon_class) == 0x000000, "Member 'FCAAdrenalineJunkieVFXSet::M_weapon_class' has a wrong offset!");
static_assert(offsetof(FCAAdrenalineJunkieVFXSet, M_base_vfx_set) == 0x000008, "Member 'FCAAdrenalineJunkieVFXSet::M_base_vfx_set' has a wrong offset!");
static_assert(offsetof(FCAAdrenalineJunkieVFXSet, M_damage_buff_vfx_set) == 0x000038, "Member 'FCAAdrenalineJunkieVFXSet::M_damage_buff_vfx_set' has a wrong offset!");

// ScriptStruct keaton.DebugPlayerStatus
// 0x0020 (0x0020 - 0x0000)
struct FDebugPlayerStatus final
{
public:
	class ACAPlayerState*                         Player;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Player_name;                                       // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EClientInitStage                              Init_stage;                                        // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugPlayerStatus) == 0x000008, "Wrong alignment on FDebugPlayerStatus");
static_assert(sizeof(FDebugPlayerStatus) == 0x000020, "Wrong size on FDebugPlayerStatus");
static_assert(offsetof(FDebugPlayerStatus, Player) == 0x000000, "Member 'FDebugPlayerStatus::Player' has a wrong offset!");
static_assert(offsetof(FDebugPlayerStatus, Player_name) == 0x000008, "Member 'FDebugPlayerStatus::Player_name' has a wrong offset!");
static_assert(offsetof(FDebugPlayerStatus, Init_stage) == 0x000018, "Member 'FDebugPlayerStatus::Init_stage' has a wrong offset!");

// ScriptStruct keaton.TeleportValidationData
// 0x0028 (0x0028 - 0x0000)
struct FTeleportValidationData final
{
public:
	bool                                          Use_world_z_extent;                                // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Check_grounded;                                    // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Ground_range;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Check_other_dynamic_objects;                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Check_static_geometry;                             // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Sweep_z_offset;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Overlap_range;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             Dynamic_object_classes_to_check;                   // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeleportValidationData) == 0x000008, "Wrong alignment on FTeleportValidationData");
static_assert(sizeof(FTeleportValidationData) == 0x000028, "Wrong size on FTeleportValidationData");
static_assert(offsetof(FTeleportValidationData, Use_world_z_extent) == 0x000000, "Member 'FTeleportValidationData::Use_world_z_extent' has a wrong offset!");
static_assert(offsetof(FTeleportValidationData, Check_grounded) == 0x000001, "Member 'FTeleportValidationData::Check_grounded' has a wrong offset!");
static_assert(offsetof(FTeleportValidationData, Ground_range) == 0x000004, "Member 'FTeleportValidationData::Ground_range' has a wrong offset!");
static_assert(offsetof(FTeleportValidationData, Check_other_dynamic_objects) == 0x000008, "Member 'FTeleportValidationData::Check_other_dynamic_objects' has a wrong offset!");
static_assert(offsetof(FTeleportValidationData, Check_static_geometry) == 0x000009, "Member 'FTeleportValidationData::Check_static_geometry' has a wrong offset!");
static_assert(offsetof(FTeleportValidationData, Sweep_z_offset) == 0x00000C, "Member 'FTeleportValidationData::Sweep_z_offset' has a wrong offset!");
static_assert(offsetof(FTeleportValidationData, Overlap_range) == 0x000010, "Member 'FTeleportValidationData::Overlap_range' has a wrong offset!");
static_assert(offsetof(FTeleportValidationData, Dynamic_object_classes_to_check) == 0x000018, "Member 'FTeleportValidationData::Dynamic_object_classes_to_check' has a wrong offset!");

// ScriptStruct keaton.CAPreProcessedFlyingGridData
// 0x0060 (0x0068 - 0x0008)
struct FCAPreProcessedFlyingGridData final : public FTableRowBase
{
public:
	bool                                          M_has_generated_grids;                             // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_cell_size;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_max_search_nodes;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   M_box;                                             // 0x0014(0x001C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                M_cell_extent;                                     // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_grid_size_X;                                     // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_grid_size_Y;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_grid_size_Z;                                     // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_origin;                                          // 0x0048(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_cells;                                           // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPreProcessedFlyingGridData) == 0x000008, "Wrong alignment on FCAPreProcessedFlyingGridData");
static_assert(sizeof(FCAPreProcessedFlyingGridData) == 0x000068, "Wrong size on FCAPreProcessedFlyingGridData");
static_assert(offsetof(FCAPreProcessedFlyingGridData, M_has_generated_grids) == 0x000008, "Member 'FCAPreProcessedFlyingGridData::M_has_generated_grids' has a wrong offset!");
static_assert(offsetof(FCAPreProcessedFlyingGridData, M_cell_size) == 0x00000C, "Member 'FCAPreProcessedFlyingGridData::M_cell_size' has a wrong offset!");
static_assert(offsetof(FCAPreProcessedFlyingGridData, M_max_search_nodes) == 0x000010, "Member 'FCAPreProcessedFlyingGridData::M_max_search_nodes' has a wrong offset!");
static_assert(offsetof(FCAPreProcessedFlyingGridData, M_box) == 0x000014, "Member 'FCAPreProcessedFlyingGridData::M_box' has a wrong offset!");
static_assert(offsetof(FCAPreProcessedFlyingGridData, M_cell_extent) == 0x000030, "Member 'FCAPreProcessedFlyingGridData::M_cell_extent' has a wrong offset!");
static_assert(offsetof(FCAPreProcessedFlyingGridData, M_grid_size_X) == 0x00003C, "Member 'FCAPreProcessedFlyingGridData::M_grid_size_X' has a wrong offset!");
static_assert(offsetof(FCAPreProcessedFlyingGridData, M_grid_size_Y) == 0x000040, "Member 'FCAPreProcessedFlyingGridData::M_grid_size_Y' has a wrong offset!");
static_assert(offsetof(FCAPreProcessedFlyingGridData, M_grid_size_Z) == 0x000044, "Member 'FCAPreProcessedFlyingGridData::M_grid_size_Z' has a wrong offset!");
static_assert(offsetof(FCAPreProcessedFlyingGridData, M_origin) == 0x000048, "Member 'FCAPreProcessedFlyingGridData::M_origin' has a wrong offset!");
static_assert(offsetof(FCAPreProcessedFlyingGridData, M_cells) == 0x000058, "Member 'FCAPreProcessedFlyingGridData::M_cells' has a wrong offset!");

// ScriptStruct keaton.CAHUDHealthBarVisibilityPerFOV
// 0x0003 (0x0003 - 0x0000)
struct FCAHUDHealthBarVisibilityPerFOV final
{
public:
	ECAFovLevel                                   M_fov_level;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_emoji_visible;                                // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_health_bar_visible;                           // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDHealthBarVisibilityPerFOV) == 0x000001, "Wrong alignment on FCAHUDHealthBarVisibilityPerFOV");
static_assert(sizeof(FCAHUDHealthBarVisibilityPerFOV) == 0x000003, "Wrong size on FCAHUDHealthBarVisibilityPerFOV");
static_assert(offsetof(FCAHUDHealthBarVisibilityPerFOV, M_fov_level) == 0x000000, "Member 'FCAHUDHealthBarVisibilityPerFOV::M_fov_level' has a wrong offset!");
static_assert(offsetof(FCAHUDHealthBarVisibilityPerFOV, M_is_emoji_visible) == 0x000001, "Member 'FCAHUDHealthBarVisibilityPerFOV::M_is_emoji_visible' has a wrong offset!");
static_assert(offsetof(FCAHUDHealthBarVisibilityPerFOV, M_is_health_bar_visible) == 0x000002, "Member 'FCAHUDHealthBarVisibilityPerFOV::M_is_health_bar_visible' has a wrong offset!");

// ScriptStruct keaton.CAHUDHealthBarRow
// 0x0018 (0x0020 - 0x0008)
struct FCAHUDHealthBarRow final : public FTableRowBase
{
public:
	ECAHUDDistanceLevel                           M_distance_level;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAHUDHealthBarVisibilityPerFOV> M_health_bar_visibility_data;                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDHealthBarRow) == 0x000008, "Wrong alignment on FCAHUDHealthBarRow");
static_assert(sizeof(FCAHUDHealthBarRow) == 0x000020, "Wrong size on FCAHUDHealthBarRow");
static_assert(offsetof(FCAHUDHealthBarRow, M_distance_level) == 0x000008, "Member 'FCAHUDHealthBarRow::M_distance_level' has a wrong offset!");
static_assert(offsetof(FCAHUDHealthBarRow, M_health_bar_visibility_data) == 0x000010, "Member 'FCAHUDHealthBarRow::M_health_bar_visibility_data' has a wrong offset!");

// ScriptStruct keaton.CAVaultActorData
// 0x0080 (0x0088 - 0x0008)
struct FCAVaultActorData final : public FTableRowBase
{
public:
	bool                                          ShutterOverride;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxCapture;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             DecalMesh;                                         // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecurityLevel;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInstance>       Material;                                          // 0x0048(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreachingUpgrade1Multiplier;                       // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreachingUpgrade2Multiplier;                       // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreachingUpgrade3Multiplier;                       // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAVaultActorData) == 0x000008, "Wrong alignment on FCAVaultActorData");
static_assert(sizeof(FCAVaultActorData) == 0x000088, "Wrong size on FCAVaultActorData");
static_assert(offsetof(FCAVaultActorData, ShutterOverride) == 0x000008, "Member 'FCAVaultActorData::ShutterOverride' has a wrong offset!");
static_assert(offsetof(FCAVaultActorData, MaxCapture) == 0x00000C, "Member 'FCAVaultActorData::MaxCapture' has a wrong offset!");
static_assert(offsetof(FCAVaultActorData, DecalMesh) == 0x000010, "Member 'FCAVaultActorData::DecalMesh' has a wrong offset!");
static_assert(offsetof(FCAVaultActorData, SecurityLevel) == 0x000040, "Member 'FCAVaultActorData::SecurityLevel' has a wrong offset!");
static_assert(offsetof(FCAVaultActorData, Material) == 0x000048, "Member 'FCAVaultActorData::Material' has a wrong offset!");
static_assert(offsetof(FCAVaultActorData, BreachingUpgrade1Multiplier) == 0x000078, "Member 'FCAVaultActorData::BreachingUpgrade1Multiplier' has a wrong offset!");
static_assert(offsetof(FCAVaultActorData, BreachingUpgrade2Multiplier) == 0x00007C, "Member 'FCAVaultActorData::BreachingUpgrade2Multiplier' has a wrong offset!");
static_assert(offsetof(FCAVaultActorData, BreachingUpgrade3Multiplier) == 0x000080, "Member 'FCAVaultActorData::BreachingUpgrade3Multiplier' has a wrong offset!");

// ScriptStruct keaton.CAEQSPreProcessedDataItem
// 0x0010 (0x0010 - 0x0000)
struct FCAEQSPreProcessedDataItem final
{
public:
	struct FVector                                Result_location;                                   // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result_score;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAEQSPreProcessedDataItem) == 0x000004, "Wrong alignment on FCAEQSPreProcessedDataItem");
static_assert(sizeof(FCAEQSPreProcessedDataItem) == 0x000010, "Wrong size on FCAEQSPreProcessedDataItem");
static_assert(offsetof(FCAEQSPreProcessedDataItem, Result_location) == 0x000000, "Member 'FCAEQSPreProcessedDataItem::Result_location' has a wrong offset!");
static_assert(offsetof(FCAEQSPreProcessedDataItem, Result_score) == 0x00000C, "Member 'FCAEQSPreProcessedDataItem::Result_score' has a wrong offset!");

// ScriptStruct keaton.CAEQSPreProcessedData
// 0x0018 (0x0018 - 0x0000)
struct FCAEQSPreProcessedData final
{
public:
	class UEnvQuery*                              M_preprocessed_query;                              // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAEQSPreProcessedDataItem>     M_preprocessed_query_results;                      // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAEQSPreProcessedData) == 0x000008, "Wrong alignment on FCAEQSPreProcessedData");
static_assert(sizeof(FCAEQSPreProcessedData) == 0x000018, "Wrong size on FCAEQSPreProcessedData");
static_assert(offsetof(FCAEQSPreProcessedData, M_preprocessed_query) == 0x000000, "Member 'FCAEQSPreProcessedData::M_preprocessed_query' has a wrong offset!");
static_assert(offsetof(FCAEQSPreProcessedData, M_preprocessed_query_results) == 0x000008, "Member 'FCAEQSPreProcessedData::M_preprocessed_query_results' has a wrong offset!");

// ScriptStruct keaton.CACoverData
// 0x003C (0x003C - 0x0000)
struct FCACoverData final
{
public:
	struct FBoxSphereBounds                       bounds;                                            // 0x0000(0x001C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x001C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0028(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          b_low_cover;                                       // 0x0034(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          b_high_cover;                                      // 0x0035(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          b_left_corner_high_cover;                          // 0x0036(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          b_left_corner_low_cover;                           // 0x0037(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          b_right_corner_high_cover;                         // 0x0038(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          b_right_corner_low_cover;                          // 0x0039(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCACoverData) == 0x000004, "Wrong alignment on FCACoverData");
static_assert(sizeof(FCACoverData) == 0x00003C, "Wrong size on FCACoverData");
static_assert(offsetof(FCACoverData, bounds) == 0x000000, "Member 'FCACoverData::bounds' has a wrong offset!");
static_assert(offsetof(FCACoverData, Location) == 0x00001C, "Member 'FCACoverData::Location' has a wrong offset!");
static_assert(offsetof(FCACoverData, Direction) == 0x000028, "Member 'FCACoverData::Direction' has a wrong offset!");
static_assert(offsetof(FCACoverData, b_low_cover) == 0x000034, "Member 'FCACoverData::b_low_cover' has a wrong offset!");
static_assert(offsetof(FCACoverData, b_high_cover) == 0x000035, "Member 'FCACoverData::b_high_cover' has a wrong offset!");
static_assert(offsetof(FCACoverData, b_left_corner_high_cover) == 0x000036, "Member 'FCACoverData::b_left_corner_high_cover' has a wrong offset!");
static_assert(offsetof(FCACoverData, b_left_corner_low_cover) == 0x000037, "Member 'FCACoverData::b_left_corner_low_cover' has a wrong offset!");
static_assert(offsetof(FCACoverData, b_right_corner_high_cover) == 0x000038, "Member 'FCACoverData::b_right_corner_high_cover' has a wrong offset!");
static_assert(offsetof(FCACoverData, b_right_corner_low_cover) == 0x000039, "Member 'FCACoverData::b_right_corner_low_cover' has a wrong offset!");

// ScriptStruct keaton.CAAIPortalGraphNode
// 0x00A0 (0x00A0 - 0x0000)
struct FCAAIPortalGraphNode final
{
public:
	int32                                         M_id;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_type;                                            // 0x0008(0x0030)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_node_location;                                   // 0x0038(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_true_node_location;                              // 0x0044(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_front_location;                                  // 0x0050(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_true_front_location;                             // 0x005C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_back_location;                                   // 0x0068(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_true_back_location;                              // 0x0074(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_priority;                                        // 0x0080(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_blocked;                                      // 0x0084(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_width;                                           // 0x0088(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_height;                                          // 0x008C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_front_room_id;                                   // 0x0090(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_back_room_id;                                    // 0x0098(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAIPortalGraphNode) == 0x000008, "Wrong alignment on FCAAIPortalGraphNode");
static_assert(sizeof(FCAAIPortalGraphNode) == 0x0000A0, "Wrong size on FCAAIPortalGraphNode");
static_assert(offsetof(FCAAIPortalGraphNode, M_id) == 0x000000, "Member 'FCAAIPortalGraphNode::M_id' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphNode, M_type) == 0x000008, "Member 'FCAAIPortalGraphNode::M_type' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphNode, M_node_location) == 0x000038, "Member 'FCAAIPortalGraphNode::M_node_location' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphNode, M_true_node_location) == 0x000044, "Member 'FCAAIPortalGraphNode::M_true_node_location' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphNode, M_front_location) == 0x000050, "Member 'FCAAIPortalGraphNode::M_front_location' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphNode, M_true_front_location) == 0x00005C, "Member 'FCAAIPortalGraphNode::M_true_front_location' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphNode, M_back_location) == 0x000068, "Member 'FCAAIPortalGraphNode::M_back_location' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphNode, M_true_back_location) == 0x000074, "Member 'FCAAIPortalGraphNode::M_true_back_location' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphNode, M_priority) == 0x000080, "Member 'FCAAIPortalGraphNode::M_priority' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphNode, M_is_blocked) == 0x000084, "Member 'FCAAIPortalGraphNode::M_is_blocked' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphNode, M_width) == 0x000088, "Member 'FCAAIPortalGraphNode::M_width' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphNode, M_height) == 0x00008C, "Member 'FCAAIPortalGraphNode::M_height' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphNode, M_front_room_id) == 0x000090, "Member 'FCAAIPortalGraphNode::M_front_room_id' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphNode, M_back_room_id) == 0x000098, "Member 'FCAAIPortalGraphNode::M_back_room_id' has a wrong offset!");

// ScriptStruct keaton.CANPCMissionObjectiveNode
// 0x0080 (0x0080 - 0x0000)
struct FCANPCMissionObjectiveNode final
{
public:
	int32                                         M_id;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_type;                                            // 0x0008(0x0030)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAMissionObjectiveTypeEnum                   M_type_enum;                                       // 0x0038(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_node_location;                                   // 0x003C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_front_location;                                  // 0x0048(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_back_location;                                   // 0x0054(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_on_navmesh;                                   // 0x0060(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_width;                                           // 0x0064(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_height;                                          // 0x0068(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_enclosed_objective;                           // 0x006C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_affects_ai_portal_graph;                         // 0x006D(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E[0x2];                                       // 0x006E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_average_distance_to_security_area_boundary;      // 0x0070(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_room_id;                                         // 0x0074(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCMissionObjectiveNode) == 0x000008, "Wrong alignment on FCANPCMissionObjectiveNode");
static_assert(sizeof(FCANPCMissionObjectiveNode) == 0x000080, "Wrong size on FCANPCMissionObjectiveNode");
static_assert(offsetof(FCANPCMissionObjectiveNode, M_id) == 0x000000, "Member 'FCANPCMissionObjectiveNode::M_id' has a wrong offset!");
static_assert(offsetof(FCANPCMissionObjectiveNode, M_type) == 0x000008, "Member 'FCANPCMissionObjectiveNode::M_type' has a wrong offset!");
static_assert(offsetof(FCANPCMissionObjectiveNode, M_type_enum) == 0x000038, "Member 'FCANPCMissionObjectiveNode::M_type_enum' has a wrong offset!");
static_assert(offsetof(FCANPCMissionObjectiveNode, M_node_location) == 0x00003C, "Member 'FCANPCMissionObjectiveNode::M_node_location' has a wrong offset!");
static_assert(offsetof(FCANPCMissionObjectiveNode, M_front_location) == 0x000048, "Member 'FCANPCMissionObjectiveNode::M_front_location' has a wrong offset!");
static_assert(offsetof(FCANPCMissionObjectiveNode, M_back_location) == 0x000054, "Member 'FCANPCMissionObjectiveNode::M_back_location' has a wrong offset!");
static_assert(offsetof(FCANPCMissionObjectiveNode, M_is_on_navmesh) == 0x000060, "Member 'FCANPCMissionObjectiveNode::M_is_on_navmesh' has a wrong offset!");
static_assert(offsetof(FCANPCMissionObjectiveNode, M_width) == 0x000064, "Member 'FCANPCMissionObjectiveNode::M_width' has a wrong offset!");
static_assert(offsetof(FCANPCMissionObjectiveNode, M_height) == 0x000068, "Member 'FCANPCMissionObjectiveNode::M_height' has a wrong offset!");
static_assert(offsetof(FCANPCMissionObjectiveNode, M_is_enclosed_objective) == 0x00006C, "Member 'FCANPCMissionObjectiveNode::M_is_enclosed_objective' has a wrong offset!");
static_assert(offsetof(FCANPCMissionObjectiveNode, M_affects_ai_portal_graph) == 0x00006D, "Member 'FCANPCMissionObjectiveNode::M_affects_ai_portal_graph' has a wrong offset!");
static_assert(offsetof(FCANPCMissionObjectiveNode, M_average_distance_to_security_area_boundary) == 0x000070, "Member 'FCANPCMissionObjectiveNode::M_average_distance_to_security_area_boundary' has a wrong offset!");
static_assert(offsetof(FCANPCMissionObjectiveNode, M_room_id) == 0x000074, "Member 'FCANPCMissionObjectiveNode::M_room_id' has a wrong offset!");

// ScriptStruct keaton.CAAIPortalGraphRoom
// 0x0058 (0x0058 - 0x0000)
struct FCAAIPortalGraphRoom final
{
public:
	int32                                         M_id;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_mission_objectives;                              // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_portals;                                         // 0x0018(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FVector                                M_average_location;                                // 0x0028(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_sub_graph_id;                                    // 0x0034(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAAIPortalGraphRoomType                      M_room_type;                                       // 0x0038(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_blocked_room;                                 // 0x0039(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x1E];                                      // 0x003A(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAIPortalGraphRoom) == 0x000008, "Wrong alignment on FCAAIPortalGraphRoom");
static_assert(sizeof(FCAAIPortalGraphRoom) == 0x000058, "Wrong size on FCAAIPortalGraphRoom");
static_assert(offsetof(FCAAIPortalGraphRoom, M_id) == 0x000000, "Member 'FCAAIPortalGraphRoom::M_id' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphRoom, M_mission_objectives) == 0x000008, "Member 'FCAAIPortalGraphRoom::M_mission_objectives' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphRoom, M_portals) == 0x000018, "Member 'FCAAIPortalGraphRoom::M_portals' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphRoom, M_average_location) == 0x000028, "Member 'FCAAIPortalGraphRoom::M_average_location' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphRoom, M_sub_graph_id) == 0x000034, "Member 'FCAAIPortalGraphRoom::M_sub_graph_id' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphRoom, M_room_type) == 0x000038, "Member 'FCAAIPortalGraphRoom::M_room_type' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphRoom, M_is_blocked_room) == 0x000039, "Member 'FCAAIPortalGraphRoom::M_is_blocked_room' has a wrong offset!");

// ScriptStruct keaton.CAAIPortalGraphPreProcessedData
// 0x0030 (0x0038 - 0x0008)
struct FCAAIPortalGraphPreProcessedData final : public FTableRowBase
{
public:
	TArray<struct FCAAIPortalGraphNode>           M_portal_nodes;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FCANPCMissionObjectiveNode>     M_mission_objective_nodes;                         // 0x0018(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FCAAIPortalGraphRoom>           M_rooms;                                           // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAIPortalGraphPreProcessedData) == 0x000008, "Wrong alignment on FCAAIPortalGraphPreProcessedData");
static_assert(sizeof(FCAAIPortalGraphPreProcessedData) == 0x000038, "Wrong size on FCAAIPortalGraphPreProcessedData");
static_assert(offsetof(FCAAIPortalGraphPreProcessedData, M_portal_nodes) == 0x000008, "Member 'FCAAIPortalGraphPreProcessedData::M_portal_nodes' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphPreProcessedData, M_mission_objective_nodes) == 0x000018, "Member 'FCAAIPortalGraphPreProcessedData::M_mission_objective_nodes' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphPreProcessedData, M_rooms) == 0x000028, "Member 'FCAAIPortalGraphPreProcessedData::M_rooms' has a wrong offset!");

// ScriptStruct keaton.CAPreProcessedAreaData
// 0x0068 (0x0070 - 0x0008)
struct FCAPreProcessedAreaData final : public FTableRowBase
{
public:
	class FName                                   M_security_module_name;                            // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_security_module_id;                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAEQSPreProcessedData>         M_eqs_preprocessed_data;                           // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCACoverData>                   M_cover_data;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCAAIPortalGraphPreProcessedData       M_ai_portal_graph_data;                            // 0x0038(0x0038)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPreProcessedAreaData) == 0x000008, "Wrong alignment on FCAPreProcessedAreaData");
static_assert(sizeof(FCAPreProcessedAreaData) == 0x000070, "Wrong size on FCAPreProcessedAreaData");
static_assert(offsetof(FCAPreProcessedAreaData, M_security_module_name) == 0x000008, "Member 'FCAPreProcessedAreaData::M_security_module_name' has a wrong offset!");
static_assert(offsetof(FCAPreProcessedAreaData, M_security_module_id) == 0x000014, "Member 'FCAPreProcessedAreaData::M_security_module_id' has a wrong offset!");
static_assert(offsetof(FCAPreProcessedAreaData, M_eqs_preprocessed_data) == 0x000018, "Member 'FCAPreProcessedAreaData::M_eqs_preprocessed_data' has a wrong offset!");
static_assert(offsetof(FCAPreProcessedAreaData, M_cover_data) == 0x000028, "Member 'FCAPreProcessedAreaData::M_cover_data' has a wrong offset!");
static_assert(offsetof(FCAPreProcessedAreaData, M_ai_portal_graph_data) == 0x000038, "Member 'FCAPreProcessedAreaData::M_ai_portal_graph_data' has a wrong offset!");

// ScriptStruct keaton.CAFireModeStatsTableData
// 0x0050 (0x0050 - 0x0000)
struct FCAFireModeStatsTableData final
{
public:
	bool                                          M_is_selectable;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAWeaponPayload>               M_payloads;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         M_crosshair_index;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_crosshair_index_in_ads_optional;                 // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fire_crosshair_radius_up_multiplier;             // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fire_crosshair_up_animation_time;                // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fire_crosshair_down_animation_speed_multiplier;  // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fire_crosshair_minimum_animation_radius;         // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_crosshair_up_multiplier_in_hipfire;              // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFCAFireType                                  M_fire_type;                                       // 0x0034(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_shots_per_press;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_pellets_per_shot;                                // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCAGameplayAbility>         M_primary_ability_override;                        // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCAGameplayAbility>         M_secondary_ability_override;                      // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFireModeStatsTableData) == 0x000008, "Wrong alignment on FCAFireModeStatsTableData");
static_assert(sizeof(FCAFireModeStatsTableData) == 0x000050, "Wrong size on FCAFireModeStatsTableData");
static_assert(offsetof(FCAFireModeStatsTableData, M_is_selectable) == 0x000000, "Member 'FCAFireModeStatsTableData::M_is_selectable' has a wrong offset!");
static_assert(offsetof(FCAFireModeStatsTableData, M_payloads) == 0x000008, "Member 'FCAFireModeStatsTableData::M_payloads' has a wrong offset!");
static_assert(offsetof(FCAFireModeStatsTableData, M_crosshair_index) == 0x000018, "Member 'FCAFireModeStatsTableData::M_crosshair_index' has a wrong offset!");
static_assert(offsetof(FCAFireModeStatsTableData, M_crosshair_index_in_ads_optional) == 0x00001C, "Member 'FCAFireModeStatsTableData::M_crosshair_index_in_ads_optional' has a wrong offset!");
static_assert(offsetof(FCAFireModeStatsTableData, M_fire_crosshair_radius_up_multiplier) == 0x000020, "Member 'FCAFireModeStatsTableData::M_fire_crosshair_radius_up_multiplier' has a wrong offset!");
static_assert(offsetof(FCAFireModeStatsTableData, M_fire_crosshair_up_animation_time) == 0x000024, "Member 'FCAFireModeStatsTableData::M_fire_crosshair_up_animation_time' has a wrong offset!");
static_assert(offsetof(FCAFireModeStatsTableData, M_fire_crosshair_down_animation_speed_multiplier) == 0x000028, "Member 'FCAFireModeStatsTableData::M_fire_crosshair_down_animation_speed_multiplier' has a wrong offset!");
static_assert(offsetof(FCAFireModeStatsTableData, M_fire_crosshair_minimum_animation_radius) == 0x00002C, "Member 'FCAFireModeStatsTableData::M_fire_crosshair_minimum_animation_radius' has a wrong offset!");
static_assert(offsetof(FCAFireModeStatsTableData, M_crosshair_up_multiplier_in_hipfire) == 0x000030, "Member 'FCAFireModeStatsTableData::M_crosshair_up_multiplier_in_hipfire' has a wrong offset!");
static_assert(offsetof(FCAFireModeStatsTableData, M_fire_type) == 0x000034, "Member 'FCAFireModeStatsTableData::M_fire_type' has a wrong offset!");
static_assert(offsetof(FCAFireModeStatsTableData, M_shots_per_press) == 0x000038, "Member 'FCAFireModeStatsTableData::M_shots_per_press' has a wrong offset!");
static_assert(offsetof(FCAFireModeStatsTableData, M_pellets_per_shot) == 0x00003C, "Member 'FCAFireModeStatsTableData::M_pellets_per_shot' has a wrong offset!");
static_assert(offsetof(FCAFireModeStatsTableData, M_primary_ability_override) == 0x000040, "Member 'FCAFireModeStatsTableData::M_primary_ability_override' has a wrong offset!");
static_assert(offsetof(FCAFireModeStatsTableData, M_secondary_ability_override) == 0x000048, "Member 'FCAFireModeStatsTableData::M_secondary_ability_override' has a wrong offset!");

// ScriptStruct keaton.CAImpactEffectRow
// 0x0058 (0x0060 - 0x0008)
struct FCAImpactEffectRow final : public FTableRowBase
{
public:
	class UNiagaraSystem*                         Niagara_system_template;                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Cascade_system_template;                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Single_particle_system_per_cluster;                // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attach_cascade_system;                             // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Spawn_delay;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Glancing_threshold_degrees_range;                  // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Glancing_decal_material;                           // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Glancing_decal_sub_uv_frame_count;                 // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Glancing_decal_width_range;                        // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Glancing_decal_length_range;                       // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     Non_glancing_decal_material;                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Non_glancing_decal_sub_uv_frame_count;             // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Non_glancing_decal_uniform_size_range;             // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAAudioSwitchValueType                Audio_material_switch_override;                    // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAImpactEffectRow) == 0x000008, "Wrong alignment on FCAImpactEffectRow");
static_assert(sizeof(FCAImpactEffectRow) == 0x000060, "Wrong size on FCAImpactEffectRow");
static_assert(offsetof(FCAImpactEffectRow, Niagara_system_template) == 0x000008, "Member 'FCAImpactEffectRow::Niagara_system_template' has a wrong offset!");
static_assert(offsetof(FCAImpactEffectRow, Cascade_system_template) == 0x000010, "Member 'FCAImpactEffectRow::Cascade_system_template' has a wrong offset!");
static_assert(offsetof(FCAImpactEffectRow, Single_particle_system_per_cluster) == 0x000018, "Member 'FCAImpactEffectRow::Single_particle_system_per_cluster' has a wrong offset!");
static_assert(offsetof(FCAImpactEffectRow, Attach_cascade_system) == 0x000019, "Member 'FCAImpactEffectRow::Attach_cascade_system' has a wrong offset!");
static_assert(offsetof(FCAImpactEffectRow, Spawn_delay) == 0x00001C, "Member 'FCAImpactEffectRow::Spawn_delay' has a wrong offset!");
static_assert(offsetof(FCAImpactEffectRow, Glancing_threshold_degrees_range) == 0x000020, "Member 'FCAImpactEffectRow::Glancing_threshold_degrees_range' has a wrong offset!");
static_assert(offsetof(FCAImpactEffectRow, Glancing_decal_material) == 0x000028, "Member 'FCAImpactEffectRow::Glancing_decal_material' has a wrong offset!");
static_assert(offsetof(FCAImpactEffectRow, Glancing_decal_sub_uv_frame_count) == 0x000030, "Member 'FCAImpactEffectRow::Glancing_decal_sub_uv_frame_count' has a wrong offset!");
static_assert(offsetof(FCAImpactEffectRow, Glancing_decal_width_range) == 0x000034, "Member 'FCAImpactEffectRow::Glancing_decal_width_range' has a wrong offset!");
static_assert(offsetof(FCAImpactEffectRow, Glancing_decal_length_range) == 0x00003C, "Member 'FCAImpactEffectRow::Glancing_decal_length_range' has a wrong offset!");
static_assert(offsetof(FCAImpactEffectRow, Non_glancing_decal_material) == 0x000048, "Member 'FCAImpactEffectRow::Non_glancing_decal_material' has a wrong offset!");
static_assert(offsetof(FCAImpactEffectRow, Non_glancing_decal_sub_uv_frame_count) == 0x000050, "Member 'FCAImpactEffectRow::Non_glancing_decal_sub_uv_frame_count' has a wrong offset!");
static_assert(offsetof(FCAImpactEffectRow, Non_glancing_decal_uniform_size_range) == 0x000054, "Member 'FCAImpactEffectRow::Non_glancing_decal_uniform_size_range' has a wrong offset!");
static_assert(offsetof(FCAImpactEffectRow, Audio_material_switch_override) == 0x00005C, "Member 'FCAImpactEffectRow::Audio_material_switch_override' has a wrong offset!");

// ScriptStruct keaton.CAGetFloatDelegate
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FCAGetFloatDelegate final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAGetFloatDelegate) == 0x000008, "Wrong alignment on FCAGetFloatDelegate");
static_assert(sizeof(FCAGetFloatDelegate) == 0x000028, "Wrong size on FCAGetFloatDelegate");

// ScriptStruct keaton.CAReplicatedProgressArray
// 0x0020 (0x0128 - 0x0108)
struct FCAReplicatedProgressArray final : public FFastArraySerializer
{
public:
	TArray<struct FCAPlayerProgressItem>          Items;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnProgressListChanged;                             // 0x0118(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAReplicatedProgressArray) == 0x000008, "Wrong alignment on FCAReplicatedProgressArray");
static_assert(sizeof(FCAReplicatedProgressArray) == 0x000128, "Wrong size on FCAReplicatedProgressArray");
static_assert(offsetof(FCAReplicatedProgressArray, Items) == 0x000108, "Member 'FCAReplicatedProgressArray::Items' has a wrong offset!");
static_assert(offsetof(FCAReplicatedProgressArray, OnProgressListChanged) == 0x000118, "Member 'FCAReplicatedProgressArray::OnProgressListChanged' has a wrong offset!");

// ScriptStruct keaton.CAPlayerColorTableRow
// 0x0030 (0x0038 - 0x0008)
struct FCAPlayerColorTableRow final : public FTableRowBase
{
public:
	int32                                         M_player_index;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               Colour_handle;                                     // 0x000C(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x14];                                      // 0x0024(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPlayerColorTableRow) == 0x000008, "Wrong alignment on FCAPlayerColorTableRow");
static_assert(sizeof(FCAPlayerColorTableRow) == 0x000038, "Wrong size on FCAPlayerColorTableRow");
static_assert(offsetof(FCAPlayerColorTableRow, M_player_index) == 0x000008, "Member 'FCAPlayerColorTableRow::M_player_index' has a wrong offset!");
static_assert(offsetof(FCAPlayerColorTableRow, Colour_handle) == 0x00000C, "Member 'FCAPlayerColorTableRow::Colour_handle' has a wrong offset!");

// ScriptStruct keaton.EquipmentAbilitySetup
// 0x0030 (0x0030 - 0x0000)
struct FEquipmentAbilitySetup final
{
public:
	TSoftClassPtr<class UClass>                   M_equipment_class;                                 // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipmentAbilitySetup) == 0x000008, "Wrong alignment on FEquipmentAbilitySetup");
static_assert(sizeof(FEquipmentAbilitySetup) == 0x000030, "Wrong size on FEquipmentAbilitySetup");
static_assert(offsetof(FEquipmentAbilitySetup, M_equipment_class) == 0x000000, "Member 'FEquipmentAbilitySetup::M_equipment_class' has a wrong offset!");

// ScriptStruct keaton.CAFireModeNode
// 0x0038 (0x0038 - 0x0000)
struct FCAFireModeNode final
{
public:
	class UCAFireModeStatsDataAsset*              M_fire_mode_data;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCABulletStatsDataAsset*                M_fire_type_data;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAShotPatternStatsDataAsset*           M_shot_pattern_data;                               // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAWeaponFireModeAdditionalDataAsset*   M_fire_mode_additional_data;                       // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAWeaponFireModeAnimationDataAsset*    M_fire_mode_animation_data;                        // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAWeaponFireModeAudioDataAsset*        M_fire_mode_audio_data;                            // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAWeaponFireModeEffectsDataAsset*      M_fire_mode_effects_data;                          // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFireModeNode) == 0x000008, "Wrong alignment on FCAFireModeNode");
static_assert(sizeof(FCAFireModeNode) == 0x000038, "Wrong size on FCAFireModeNode");
static_assert(offsetof(FCAFireModeNode, M_fire_mode_data) == 0x000000, "Member 'FCAFireModeNode::M_fire_mode_data' has a wrong offset!");
static_assert(offsetof(FCAFireModeNode, M_fire_type_data) == 0x000008, "Member 'FCAFireModeNode::M_fire_type_data' has a wrong offset!");
static_assert(offsetof(FCAFireModeNode, M_shot_pattern_data) == 0x000010, "Member 'FCAFireModeNode::M_shot_pattern_data' has a wrong offset!");
static_assert(offsetof(FCAFireModeNode, M_fire_mode_additional_data) == 0x000018, "Member 'FCAFireModeNode::M_fire_mode_additional_data' has a wrong offset!");
static_assert(offsetof(FCAFireModeNode, M_fire_mode_animation_data) == 0x000020, "Member 'FCAFireModeNode::M_fire_mode_animation_data' has a wrong offset!");
static_assert(offsetof(FCAFireModeNode, M_fire_mode_audio_data) == 0x000028, "Member 'FCAFireModeNode::M_fire_mode_audio_data' has a wrong offset!");
static_assert(offsetof(FCAFireModeNode, M_fire_mode_effects_data) == 0x000030, "Member 'FCAFireModeNode::M_fire_mode_effects_data' has a wrong offset!");

// ScriptStruct keaton.CAAITeamToTeamEncounter
// 0x00D0 (0x00D0 - 0x0000)
struct FCAAITeamToTeamEncounter final
{
public:
	class ACACharacter_MainPlayer*                M_encounter_initiator;                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FCAPlayerEncounterRecord> M_team_1_data;                                     // 0x0030(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, struct FCAPlayerEncounterRecord> M_team_2_data;                                     // 0x0080(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAITeamToTeamEncounter) == 0x000008, "Wrong alignment on FCAAITeamToTeamEncounter");
static_assert(sizeof(FCAAITeamToTeamEncounter) == 0x0000D0, "Wrong size on FCAAITeamToTeamEncounter");
static_assert(offsetof(FCAAITeamToTeamEncounter, M_encounter_initiator) == 0x000000, "Member 'FCAAITeamToTeamEncounter::M_encounter_initiator' has a wrong offset!");
static_assert(offsetof(FCAAITeamToTeamEncounter, M_team_1_data) == 0x000030, "Member 'FCAAITeamToTeamEncounter::M_team_1_data' has a wrong offset!");
static_assert(offsetof(FCAAITeamToTeamEncounter, M_team_2_data) == 0x000080, "Member 'FCAAITeamToTeamEncounter::M_team_2_data' has a wrong offset!");

// ScriptStruct keaton.CANPCLoDData
// 0x0028 (0x0028 - 0x0000)
struct FCANPCLoDData final
{
public:
	class ACACharacter_NPC*                       M_npc;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x20];                                       // 0x0008(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCLoDData) == 0x000008, "Wrong alignment on FCANPCLoDData");
static_assert(sizeof(FCANPCLoDData) == 0x000028, "Wrong size on FCANPCLoDData");
static_assert(offsetof(FCANPCLoDData, M_npc) == 0x000000, "Member 'FCANPCLoDData::M_npc' has a wrong offset!");

// ScriptStruct keaton.TargetingSchemePair
// 0x0018 (0x0018 - 0x0000)
struct FTargetingSchemePair final
{
public:
	TSubclassOf<class ACATargetingScheme>         M_scheme_class;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tag;                                             // 0x0008(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTargetingSchemePair) == 0x000008, "Wrong alignment on FTargetingSchemePair");
static_assert(sizeof(FTargetingSchemePair) == 0x000018, "Wrong size on FTargetingSchemePair");
static_assert(offsetof(FTargetingSchemePair, M_scheme_class) == 0x000000, "Member 'FTargetingSchemePair::M_scheme_class' has a wrong offset!");
static_assert(offsetof(FTargetingSchemePair, M_tag) == 0x000008, "Member 'FTargetingSchemePair::M_tag' has a wrong offset!");

// ScriptStruct keaton.CAAILoDSettings
// 0x0060 (0x0060 - 0x0000)
struct FCAAILoDSettings final
{
public:
	bool                                          M_enable_ai_level_of_detail;                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 M_ai_level_of_detail_threshold_distances;          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         M_ai_lod_update_interval;                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ai_lod_max_tick_time_limit;                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ai_lod_min_tick_time_limit;                      // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ai_lod_tick_time_limit_step;                     // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_min_npc_count_processed_per_tick;                // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_initial_non_ai_lod_duration;                     // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_lod_before_game_starts;                          // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_on_npc_creation_non_ai_lod_duration;             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        M_global_ai_lod_data_path;                         // 0x0038(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ai_lod_debug_range_threshold;                    // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAILoDSettings) == 0x000008, "Wrong alignment on FCAAILoDSettings");
static_assert(sizeof(FCAAILoDSettings) == 0x000060, "Wrong size on FCAAILoDSettings");
static_assert(offsetof(FCAAILoDSettings, M_enable_ai_level_of_detail) == 0x000000, "Member 'FCAAILoDSettings::M_enable_ai_level_of_detail' has a wrong offset!");
static_assert(offsetof(FCAAILoDSettings, M_ai_level_of_detail_threshold_distances) == 0x000008, "Member 'FCAAILoDSettings::M_ai_level_of_detail_threshold_distances' has a wrong offset!");
static_assert(offsetof(FCAAILoDSettings, M_ai_lod_update_interval) == 0x000018, "Member 'FCAAILoDSettings::M_ai_lod_update_interval' has a wrong offset!");
static_assert(offsetof(FCAAILoDSettings, M_ai_lod_max_tick_time_limit) == 0x00001C, "Member 'FCAAILoDSettings::M_ai_lod_max_tick_time_limit' has a wrong offset!");
static_assert(offsetof(FCAAILoDSettings, M_ai_lod_min_tick_time_limit) == 0x000020, "Member 'FCAAILoDSettings::M_ai_lod_min_tick_time_limit' has a wrong offset!");
static_assert(offsetof(FCAAILoDSettings, M_ai_lod_tick_time_limit_step) == 0x000024, "Member 'FCAAILoDSettings::M_ai_lod_tick_time_limit_step' has a wrong offset!");
static_assert(offsetof(FCAAILoDSettings, M_min_npc_count_processed_per_tick) == 0x000028, "Member 'FCAAILoDSettings::M_min_npc_count_processed_per_tick' has a wrong offset!");
static_assert(offsetof(FCAAILoDSettings, M_initial_non_ai_lod_duration) == 0x00002C, "Member 'FCAAILoDSettings::M_initial_non_ai_lod_duration' has a wrong offset!");
static_assert(offsetof(FCAAILoDSettings, M_lod_before_game_starts) == 0x000030, "Member 'FCAAILoDSettings::M_lod_before_game_starts' has a wrong offset!");
static_assert(offsetof(FCAAILoDSettings, M_on_npc_creation_non_ai_lod_duration) == 0x000034, "Member 'FCAAILoDSettings::M_on_npc_creation_non_ai_lod_duration' has a wrong offset!");
static_assert(offsetof(FCAAILoDSettings, M_global_ai_lod_data_path) == 0x000038, "Member 'FCAAILoDSettings::M_global_ai_lod_data_path' has a wrong offset!");
static_assert(offsetof(FCAAILoDSettings, M_ai_lod_debug_range_threshold) == 0x000058, "Member 'FCAAILoDSettings::M_ai_lod_debug_range_threshold' has a wrong offset!");

// ScriptStruct keaton.CASetByCallerWithMagnitude
// 0x0010 (0x0010 - 0x0000)
struct FCASetByCallerWithMagnitude final
{
public:
	struct FGameplayTag                           M_set_by_caller_tag;                               // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_magnitude;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASetByCallerWithMagnitude) == 0x000004, "Wrong alignment on FCASetByCallerWithMagnitude");
static_assert(sizeof(FCASetByCallerWithMagnitude) == 0x000010, "Wrong size on FCASetByCallerWithMagnitude");
static_assert(offsetof(FCASetByCallerWithMagnitude, M_set_by_caller_tag) == 0x000000, "Member 'FCASetByCallerWithMagnitude::M_set_by_caller_tag' has a wrong offset!");
static_assert(offsetof(FCASetByCallerWithMagnitude, M_magnitude) == 0x00000C, "Member 'FCASetByCallerWithMagnitude::M_magnitude' has a wrong offset!");

// ScriptStruct keaton.CAEffectWithSetByCallerTags
// 0x0040 (0x0040 - 0x0000)
struct FCAEffectWithSetByCallerTags final
{
public:
	TSoftClassPtr<class UClass>                   M_effect_to_apply;                                 // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCASetByCallerWithMagnitude>    M_set_by_caller_tags_with_magnitudes;              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAEffectWithSetByCallerTags) == 0x000008, "Wrong alignment on FCAEffectWithSetByCallerTags");
static_assert(sizeof(FCAEffectWithSetByCallerTags) == 0x000040, "Wrong size on FCAEffectWithSetByCallerTags");
static_assert(offsetof(FCAEffectWithSetByCallerTags, M_effect_to_apply) == 0x000000, "Member 'FCAEffectWithSetByCallerTags::M_effect_to_apply' has a wrong offset!");
static_assert(offsetof(FCAEffectWithSetByCallerTags, M_set_by_caller_tags_with_magnitudes) == 0x000030, "Member 'FCAEffectWithSetByCallerTags::M_set_by_caller_tags_with_magnitudes' has a wrong offset!");

// ScriptStruct keaton.CASlotLevelDefinition
// 0x0010 (0x0010 - 0x0000)
struct FCASlotLevelDefinition final
{
public:
	struct FGameplayTag                           M_slot_tag;                                        // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_max_level;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASlotLevelDefinition) == 0x000004, "Wrong alignment on FCASlotLevelDefinition");
static_assert(sizeof(FCASlotLevelDefinition) == 0x000010, "Wrong size on FCASlotLevelDefinition");
static_assert(offsetof(FCASlotLevelDefinition, M_slot_tag) == 0x000000, "Member 'FCASlotLevelDefinition::M_slot_tag' has a wrong offset!");
static_assert(offsetof(FCASlotLevelDefinition, M_max_level) == 0x00000C, "Member 'FCASlotLevelDefinition::M_max_level' has a wrong offset!");

// ScriptStruct keaton.CASecurityModuleData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FCASecurityModuleData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCASecurityModuleData) == 0x000008, "Wrong alignment on FCASecurityModuleData");
static_assert(sizeof(FCASecurityModuleData) == 0x000010, "Wrong size on FCASecurityModuleData");

// ScriptStruct keaton.CACustomisationItem
// 0x0040 (0x0040 - 0x0000)
struct FCACustomisationItem final
{
public:
	struct FSoftObjectPath                        M_customisation_option;                            // 0x0000(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        M_colour_palette;                                  // 0x0020(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACustomisationItem) == 0x000008, "Wrong alignment on FCACustomisationItem");
static_assert(sizeof(FCACustomisationItem) == 0x000040, "Wrong size on FCACustomisationItem");
static_assert(offsetof(FCACustomisationItem, M_customisation_option) == 0x000000, "Member 'FCACustomisationItem::M_customisation_option' has a wrong offset!");
static_assert(offsetof(FCACustomisationItem, M_colour_palette) == 0x000020, "Member 'FCACustomisationItem::M_colour_palette' has a wrong offset!");

// ScriptStruct keaton.CustomisationOptions
// 0x0010 (0x0010 - 0x0000)
struct FCustomisationOptions final
{
public:
	TArray<struct FCACustomisationItem>           M_options;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomisationOptions) == 0x000008, "Wrong alignment on FCustomisationOptions");
static_assert(sizeof(FCustomisationOptions) == 0x000010, "Wrong size on FCustomisationOptions");
static_assert(offsetof(FCustomisationOptions, M_options) == 0x000000, "Member 'FCustomisationOptions::M_options' has a wrong offset!");

// ScriptStruct keaton.CASecurityAreaData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FCASecurityAreaData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCASecurityAreaData) == 0x000008, "Wrong alignment on FCASecurityAreaData");
static_assert(sizeof(FCASecurityAreaData) == 0x000008, "Wrong size on FCASecurityAreaData");

// ScriptStruct keaton.CAAimAssist
// 0x03B8 (0x03B8 - 0x0000)
struct alignas(0x08) FCAAimAssist final
{
public:
	uint8                                         Pad_0[0x3B8];                                      // 0x0000(0x03B8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAimAssist) == 0x000008, "Wrong alignment on FCAAimAssist");
static_assert(sizeof(FCAAimAssist) == 0x0003B8, "Wrong size on FCAAimAssist");

// ScriptStruct keaton.PadDeadZone
// 0x0010 (0x0010 - 0x0000)
struct FPadDeadZone final
{
public:
	float                                         M_inner;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_outer;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_radial_inner;                                    // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_radial_outer;                                    // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPadDeadZone) == 0x000004, "Wrong alignment on FPadDeadZone");
static_assert(sizeof(FPadDeadZone) == 0x000010, "Wrong size on FPadDeadZone");
static_assert(offsetof(FPadDeadZone, M_inner) == 0x000000, "Member 'FPadDeadZone::M_inner' has a wrong offset!");
static_assert(offsetof(FPadDeadZone, M_outer) == 0x000004, "Member 'FPadDeadZone::M_outer' has a wrong offset!");
static_assert(offsetof(FPadDeadZone, M_radial_inner) == 0x000008, "Member 'FPadDeadZone::M_radial_inner' has a wrong offset!");
static_assert(offsetof(FPadDeadZone, M_radial_outer) == 0x00000C, "Member 'FPadDeadZone::M_radial_outer' has a wrong offset!");

// ScriptStruct keaton.CAAimAssist_BaseTable
// 0x0028 (0x0030 - 0x0008)
struct FCAAimAssist_BaseTable : public FTableRowBase
{
public:
	struct FDataTableRowHandle                    M_rules;                                           // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_is_zero_g;                                       // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAimAssist_TargetType                         M_target_type;                                     // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_win32;                                           // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_XBOne;                                           // 0x002B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_XBSX;                                            // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_PS4;                                             // 0x002D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_PS5;                                             // 0x002E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F[0x1];                                       // 0x002F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAimAssist_BaseTable) == 0x000008, "Wrong alignment on FCAAimAssist_BaseTable");
static_assert(sizeof(FCAAimAssist_BaseTable) == 0x000030, "Wrong size on FCAAimAssist_BaseTable");
static_assert(offsetof(FCAAimAssist_BaseTable, M_rules) == 0x000008, "Member 'FCAAimAssist_BaseTable::M_rules' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_BaseTable, M_is_zero_g) == 0x000028, "Member 'FCAAimAssist_BaseTable::M_is_zero_g' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_BaseTable, M_target_type) == 0x000029, "Member 'FCAAimAssist_BaseTable::M_target_type' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_BaseTable, M_win32) == 0x00002A, "Member 'FCAAimAssist_BaseTable::M_win32' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_BaseTable, M_XBOne) == 0x00002B, "Member 'FCAAimAssist_BaseTable::M_XBOne' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_BaseTable, M_XBSX) == 0x00002C, "Member 'FCAAimAssist_BaseTable::M_XBSX' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_BaseTable, M_PS4) == 0x00002D, "Member 'FCAAimAssist_BaseTable::M_PS4' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_BaseTable, M_PS5) == 0x00002E, "Member 'FCAAimAssist_BaseTable::M_PS5' has a wrong offset!");

// ScriptStruct keaton.CAAimAssist_BulletMagnetism_RangeScaling
// 0x000C (0x000C - 0x0000)
struct FCAAimAssist_BulletMagnetism_RangeScaling final
{
public:
	float                                         M_range;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_size;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_critical_hit_size;                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAimAssist_BulletMagnetism_RangeScaling) == 0x000004, "Wrong alignment on FCAAimAssist_BulletMagnetism_RangeScaling");
static_assert(sizeof(FCAAimAssist_BulletMagnetism_RangeScaling) == 0x00000C, "Wrong size on FCAAimAssist_BulletMagnetism_RangeScaling");
static_assert(offsetof(FCAAimAssist_BulletMagnetism_RangeScaling, M_range) == 0x000000, "Member 'FCAAimAssist_BulletMagnetism_RangeScaling::M_range' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_BulletMagnetism_RangeScaling, M_size) == 0x000004, "Member 'FCAAimAssist_BulletMagnetism_RangeScaling::M_size' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_BulletMagnetism_RangeScaling, M_critical_hit_size) == 0x000008, "Member 'FCAAimAssist_BulletMagnetism_RangeScaling::M_critical_hit_size' has a wrong offset!");

// ScriptStruct keaton.CAAimAssist_BulletMagnetism_WeaponArchetypeData
// 0x0010 (0x0010 - 0x0000)
struct FCAAimAssist_BulletMagnetism_WeaponArchetypeData final
{
public:
	TArray<struct FCAAimAssist_BulletMagnetism_RangeScaling> M_range_scaling;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAimAssist_BulletMagnetism_WeaponArchetypeData) == 0x000008, "Wrong alignment on FCAAimAssist_BulletMagnetism_WeaponArchetypeData");
static_assert(sizeof(FCAAimAssist_BulletMagnetism_WeaponArchetypeData) == 0x000010, "Wrong size on FCAAimAssist_BulletMagnetism_WeaponArchetypeData");
static_assert(offsetof(FCAAimAssist_BulletMagnetism_WeaponArchetypeData, M_range_scaling) == 0x000000, "Member 'FCAAimAssist_BulletMagnetism_WeaponArchetypeData::M_range_scaling' has a wrong offset!");

// ScriptStruct keaton.CAAimAssist_BulletMagnetismData
// 0x0060 (0x0090 - 0x0030)
struct FCAAimAssist_BulletMagnetismData final : public FCAAimAssist_BaseTable
{
public:
	TMap<struct FGameplayTag, struct FCAAimAssist_BulletMagnetism_WeaponArchetypeData> M_weapon_archetype_data;                           // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_prioritize_critical_hits_over_body;              // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_penetration;                                     // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_enabled;                                         // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAimAssist_BulletMagnetismData) == 0x000008, "Wrong alignment on FCAAimAssist_BulletMagnetismData");
static_assert(sizeof(FCAAimAssist_BulletMagnetismData) == 0x000090, "Wrong size on FCAAimAssist_BulletMagnetismData");
static_assert(offsetof(FCAAimAssist_BulletMagnetismData, M_weapon_archetype_data) == 0x000030, "Member 'FCAAimAssist_BulletMagnetismData::M_weapon_archetype_data' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_BulletMagnetismData, M_prioritize_critical_hits_over_body) == 0x000080, "Member 'FCAAimAssist_BulletMagnetismData::M_prioritize_critical_hits_over_body' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_BulletMagnetismData, M_penetration) == 0x000084, "Member 'FCAAimAssist_BulletMagnetismData::M_penetration' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_BulletMagnetismData, M_enabled) == 0x000088, "Member 'FCAAimAssist_BulletMagnetismData::M_enabled' has a wrong offset!");

// ScriptStruct keaton.TargetingParametersHitScan
// 0x0018 (0x0018 - 0x0000)
struct FTargetingParametersHitScan final
{
public:
	struct FVector                                M_target_direction;                                // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_trace_start_position;                            // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetingParametersHitScan) == 0x000004, "Wrong alignment on FTargetingParametersHitScan");
static_assert(sizeof(FTargetingParametersHitScan) == 0x000018, "Wrong size on FTargetingParametersHitScan");
static_assert(offsetof(FTargetingParametersHitScan, M_target_direction) == 0x000000, "Member 'FTargetingParametersHitScan::M_target_direction' has a wrong offset!");
static_assert(offsetof(FTargetingParametersHitScan, M_trace_start_position) == 0x00000C, "Member 'FTargetingParametersHitScan::M_trace_start_position' has a wrong offset!");

// ScriptStruct keaton.CAAimAssist_RotationTable_Elt
// 0x0010 (0x0010 - 0x0000)
struct FCAAimAssist_RotationTable_Elt final
{
public:
	float                                         M_yaw_factor_normal;                               // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_pitch_factor_normal;                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_yaw_factor_ADS;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_pitch_factor_ADS;                                // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAimAssist_RotationTable_Elt) == 0x000004, "Wrong alignment on FCAAimAssist_RotationTable_Elt");
static_assert(sizeof(FCAAimAssist_RotationTable_Elt) == 0x000010, "Wrong size on FCAAimAssist_RotationTable_Elt");
static_assert(offsetof(FCAAimAssist_RotationTable_Elt, M_yaw_factor_normal) == 0x000000, "Member 'FCAAimAssist_RotationTable_Elt::M_yaw_factor_normal' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_RotationTable_Elt, M_pitch_factor_normal) == 0x000004, "Member 'FCAAimAssist_RotationTable_Elt::M_pitch_factor_normal' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_RotationTable_Elt, M_yaw_factor_ADS) == 0x000008, "Member 'FCAAimAssist_RotationTable_Elt::M_yaw_factor_ADS' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_RotationTable_Elt, M_pitch_factor_ADS) == 0x00000C, "Member 'FCAAimAssist_RotationTable_Elt::M_pitch_factor_ADS' has a wrong offset!");

// ScriptStruct keaton.CAAimAssist_FactorPair
// 0x0008 (0x0008 - 0x0000)
struct FCAAimAssist_FactorPair final
{
public:
	float                                         M_multiply;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_add;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAimAssist_FactorPair) == 0x000004, "Wrong alignment on FCAAimAssist_FactorPair");
static_assert(sizeof(FCAAimAssist_FactorPair) == 0x000008, "Wrong size on FCAAimAssist_FactorPair");
static_assert(offsetof(FCAAimAssist_FactorPair, M_multiply) == 0x000000, "Member 'FCAAimAssist_FactorPair::M_multiply' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_FactorPair, M_add) == 0x000004, "Member 'FCAAimAssist_FactorPair::M_add' has a wrong offset!");

// ScriptStruct keaton.CAAimAssist_RotationTable_RangeScaling
// 0x0018 (0x0018 - 0x0000)
struct FCAAimAssist_RotationTable_RangeScaling final
{
public:
	float                                         M_far_range;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_near_range;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAAimAssist_FactorPair                M_far_rotation_value;                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAimAssist_FactorPair                M_near_rotation_value;                             // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAimAssist_RotationTable_RangeScaling) == 0x000004, "Wrong alignment on FCAAimAssist_RotationTable_RangeScaling");
static_assert(sizeof(FCAAimAssist_RotationTable_RangeScaling) == 0x000018, "Wrong size on FCAAimAssist_RotationTable_RangeScaling");
static_assert(offsetof(FCAAimAssist_RotationTable_RangeScaling, M_far_range) == 0x000000, "Member 'FCAAimAssist_RotationTable_RangeScaling::M_far_range' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_RotationTable_RangeScaling, M_near_range) == 0x000004, "Member 'FCAAimAssist_RotationTable_RangeScaling::M_near_range' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_RotationTable_RangeScaling, M_far_rotation_value) == 0x000008, "Member 'FCAAimAssist_RotationTable_RangeScaling::M_far_rotation_value' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_RotationTable_RangeScaling, M_near_rotation_value) == 0x000010, "Member 'FCAAimAssist_RotationTable_RangeScaling::M_near_rotation_value' has a wrong offset!");

// ScriptStruct keaton.CAAimAssist_Stickyness
// 0x0014 (0x0014 - 0x0000)
struct FCAAimAssist_Stickyness final
{
public:
	EAimAssist_CrosshairAreaType                  M_over_lap_rule;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_min_time;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_time;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAAimAssist_FactorPair                M_value;                                           // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAimAssist_Stickyness) == 0x000004, "Wrong alignment on FCAAimAssist_Stickyness");
static_assert(sizeof(FCAAimAssist_Stickyness) == 0x000014, "Wrong size on FCAAimAssist_Stickyness");
static_assert(offsetof(FCAAimAssist_Stickyness, M_over_lap_rule) == 0x000000, "Member 'FCAAimAssist_Stickyness::M_over_lap_rule' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_Stickyness, M_min_time) == 0x000004, "Member 'FCAAimAssist_Stickyness::M_min_time' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_Stickyness, M_max_time) == 0x000008, "Member 'FCAAimAssist_Stickyness::M_max_time' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_Stickyness, M_value) == 0x00000C, "Member 'FCAAimAssist_Stickyness::M_value' has a wrong offset!");

// ScriptStruct keaton.CAAimAssist_RotationTable_WeaponArchetypeData
// 0x003C (0x003C - 0x0000)
struct FCAAimAssist_RotationTable_WeaponArchetypeData final
{
public:
	struct FCAAimAssist_RotationTable_Elt         M_scale;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAimAssist_RotationTable_RangeScaling M_range_scaling;                                   // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAimAssist_Stickyness                M_sticky;                                          // 0x0028(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAimAssist_RotationTable_WeaponArchetypeData) == 0x000004, "Wrong alignment on FCAAimAssist_RotationTable_WeaponArchetypeData");
static_assert(sizeof(FCAAimAssist_RotationTable_WeaponArchetypeData) == 0x00003C, "Wrong size on FCAAimAssist_RotationTable_WeaponArchetypeData");
static_assert(offsetof(FCAAimAssist_RotationTable_WeaponArchetypeData, M_scale) == 0x000000, "Member 'FCAAimAssist_RotationTable_WeaponArchetypeData::M_scale' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_RotationTable_WeaponArchetypeData, M_range_scaling) == 0x000010, "Member 'FCAAimAssist_RotationTable_WeaponArchetypeData::M_range_scaling' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_RotationTable_WeaponArchetypeData, M_sticky) == 0x000028, "Member 'FCAAimAssist_RotationTable_WeaponArchetypeData::M_sticky' has a wrong offset!");

// ScriptStruct keaton.CAAimAssist_RotationTable
// 0x0070 (0x00A0 - 0x0030)
struct FCAAimAssist_RotationTable final : public FCAAimAssist_BaseTable
{
public:
	TMap<struct FGameplayTag, struct FCAAimAssist_RotationTable_WeaponArchetypeData> M_weapon_archetype_data;                           // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_pitch_cutoff_horizontal_range;                   // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_pitch_cutoff_vertical_range;                     // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_contra_rotation_timer;                       // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_smoothing_time;                                  // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_yaw;                                         // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_pitch;                                       // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_step_smoothing_blend_speed;                      // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_smooth_capsule_size_changes;                     // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAimAssist_RotationTable) == 0x000008, "Wrong alignment on FCAAimAssist_RotationTable");
static_assert(sizeof(FCAAimAssist_RotationTable) == 0x0000A0, "Wrong size on FCAAimAssist_RotationTable");
static_assert(offsetof(FCAAimAssist_RotationTable, M_weapon_archetype_data) == 0x000030, "Member 'FCAAimAssist_RotationTable::M_weapon_archetype_data' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_RotationTable, M_pitch_cutoff_horizontal_range) == 0x000080, "Member 'FCAAimAssist_RotationTable::M_pitch_cutoff_horizontal_range' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_RotationTable, M_pitch_cutoff_vertical_range) == 0x000084, "Member 'FCAAimAssist_RotationTable::M_pitch_cutoff_vertical_range' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_RotationTable, M_max_contra_rotation_timer) == 0x000088, "Member 'FCAAimAssist_RotationTable::M_max_contra_rotation_timer' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_RotationTable, M_smoothing_time) == 0x00008C, "Member 'FCAAimAssist_RotationTable::M_smoothing_time' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_RotationTable, M_max_yaw) == 0x000090, "Member 'FCAAimAssist_RotationTable::M_max_yaw' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_RotationTable, M_max_pitch) == 0x000094, "Member 'FCAAimAssist_RotationTable::M_max_pitch' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_RotationTable, M_step_smoothing_blend_speed) == 0x000098, "Member 'FCAAimAssist_RotationTable::M_step_smoothing_blend_speed' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_RotationTable, M_smooth_capsule_size_changes) == 0x00009C, "Member 'FCAAimAssist_RotationTable::M_smooth_capsule_size_changes' has a wrong offset!");

// ScriptStruct keaton.CANavMeshAnalyserTaskTypeData
// 0x0038 (0x0038 - 0x0000)
struct FCANavMeshAnalyserTaskTypeData
{
public:
	float                                         Nav_link_proxy_backstep_min_height;                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Nav_link_proxy_backstep_max_height;                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Nav_link_proxy_min_backstep_distance;              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Nav_link_proxy_max_backstep_distance;              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Nav_link_proxy_backstep_distance_variable_step;    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Nav_link_proxy_lower_backstep_distance_variable_limit; // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Nav_link_proxy_upper_backstep_distance_variable_limit; // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ANavLinkProxy>              Nav_link_proxy_class;                              // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Nav_mesh_clearance_radius;                         // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Clearance_radius;                                  // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Own_type_clearance_radius;                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max_added_link_height;                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANavMeshAnalyserTaskTypeData) == 0x000008, "Wrong alignment on FCANavMeshAnalyserTaskTypeData");
static_assert(sizeof(FCANavMeshAnalyserTaskTypeData) == 0x000038, "Wrong size on FCANavMeshAnalyserTaskTypeData");
static_assert(offsetof(FCANavMeshAnalyserTaskTypeData, Nav_link_proxy_backstep_min_height) == 0x000000, "Member 'FCANavMeshAnalyserTaskTypeData::Nav_link_proxy_backstep_min_height' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskTypeData, Nav_link_proxy_backstep_max_height) == 0x000004, "Member 'FCANavMeshAnalyserTaskTypeData::Nav_link_proxy_backstep_max_height' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskTypeData, Nav_link_proxy_min_backstep_distance) == 0x000008, "Member 'FCANavMeshAnalyserTaskTypeData::Nav_link_proxy_min_backstep_distance' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskTypeData, Nav_link_proxy_max_backstep_distance) == 0x00000C, "Member 'FCANavMeshAnalyserTaskTypeData::Nav_link_proxy_max_backstep_distance' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskTypeData, Nav_link_proxy_backstep_distance_variable_step) == 0x000010, "Member 'FCANavMeshAnalyserTaskTypeData::Nav_link_proxy_backstep_distance_variable_step' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskTypeData, Nav_link_proxy_lower_backstep_distance_variable_limit) == 0x000014, "Member 'FCANavMeshAnalyserTaskTypeData::Nav_link_proxy_lower_backstep_distance_variable_limit' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskTypeData, Nav_link_proxy_upper_backstep_distance_variable_limit) == 0x000018, "Member 'FCANavMeshAnalyserTaskTypeData::Nav_link_proxy_upper_backstep_distance_variable_limit' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskTypeData, Nav_link_proxy_class) == 0x000020, "Member 'FCANavMeshAnalyserTaskTypeData::Nav_link_proxy_class' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskTypeData, Nav_mesh_clearance_radius) == 0x000028, "Member 'FCANavMeshAnalyserTaskTypeData::Nav_mesh_clearance_radius' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskTypeData, Clearance_radius) == 0x00002C, "Member 'FCANavMeshAnalyserTaskTypeData::Clearance_radius' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskTypeData, Own_type_clearance_radius) == 0x000030, "Member 'FCANavMeshAnalyserTaskTypeData::Own_type_clearance_radius' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskTypeData, Max_added_link_height) == 0x000034, "Member 'FCANavMeshAnalyserTaskTypeData::Max_added_link_height' has a wrong offset!");

// ScriptStruct keaton.CAPlayerSummaryData
// 0x0088 (0x0088 - 0x0000)
struct FCAPlayerSummaryData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             M_avatar_texture;                                  // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x70];                                      // 0x0018(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPlayerSummaryData) == 0x000008, "Wrong alignment on FCAPlayerSummaryData");
static_assert(sizeof(FCAPlayerSummaryData) == 0x000088, "Wrong size on FCAPlayerSummaryData");
static_assert(offsetof(FCAPlayerSummaryData, M_avatar_texture) == 0x000010, "Member 'FCAPlayerSummaryData::M_avatar_texture' has a wrong offset!");

// ScriptStruct keaton.TeleportExclusionZone
// 0x0014 (0x0014 - 0x0000)
struct FTeleportExclusionZone final
{
public:
	uint16                                        M_id;                                              // 0x0000(0x0002)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    M_location;                                        // 0x0004(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint16                                        M_radius;                                          // 0x0010(0x0002)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTeleportExclusionZone) == 0x000004, "Wrong alignment on FTeleportExclusionZone");
static_assert(sizeof(FTeleportExclusionZone) == 0x000014, "Wrong size on FTeleportExclusionZone");
static_assert(offsetof(FTeleportExclusionZone, M_id) == 0x000000, "Member 'FTeleportExclusionZone::M_id' has a wrong offset!");
static_assert(offsetof(FTeleportExclusionZone, M_location) == 0x000004, "Member 'FTeleportExclusionZone::M_location' has a wrong offset!");
static_assert(offsetof(FTeleportExclusionZone, M_radius) == 0x000010, "Member 'FTeleportExclusionZone::M_radius' has a wrong offset!");

// ScriptStruct keaton.CAHUDThreatIndicatorRow
// 0x0038 (0x0040 - 0x0008)
struct FCAHUDThreatIndicatorRow final : public FTableRowBase
{
public:
	bool                                          M_is_threat_indicator_used;                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_has_damage_range;                                // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_show_teammate_indicator;                         // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_should_arrow_always_be_visible;                  // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              M_icon_texture;                                    // 0x0010(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDThreatIndicatorRow) == 0x000008, "Wrong alignment on FCAHUDThreatIndicatorRow");
static_assert(sizeof(FCAHUDThreatIndicatorRow) == 0x000040, "Wrong size on FCAHUDThreatIndicatorRow");
static_assert(offsetof(FCAHUDThreatIndicatorRow, M_is_threat_indicator_used) == 0x000008, "Member 'FCAHUDThreatIndicatorRow::M_is_threat_indicator_used' has a wrong offset!");
static_assert(offsetof(FCAHUDThreatIndicatorRow, M_has_damage_range) == 0x000009, "Member 'FCAHUDThreatIndicatorRow::M_has_damage_range' has a wrong offset!");
static_assert(offsetof(FCAHUDThreatIndicatorRow, M_show_teammate_indicator) == 0x00000A, "Member 'FCAHUDThreatIndicatorRow::M_show_teammate_indicator' has a wrong offset!");
static_assert(offsetof(FCAHUDThreatIndicatorRow, M_should_arrow_always_be_visible) == 0x00000B, "Member 'FCAHUDThreatIndicatorRow::M_should_arrow_always_be_visible' has a wrong offset!");
static_assert(offsetof(FCAHUDThreatIndicatorRow, M_icon_texture) == 0x000010, "Member 'FCAHUDThreatIndicatorRow::M_icon_texture' has a wrong offset!");

// ScriptStruct keaton.CAVariableValue
// 0x0018 (0x0018 - 0x0000)
struct FCAVariableValue final
{
public:
	struct FCAGameDatabaseTypedRowHandle          Variable;                                          // 0x0000(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ECADialogueVariableOperator                   Comparison;                                        // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Value;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAVariableValue) == 0x000008, "Wrong alignment on FCAVariableValue");
static_assert(sizeof(FCAVariableValue) == 0x000018, "Wrong size on FCAVariableValue");
static_assert(offsetof(FCAVariableValue, Variable) == 0x000000, "Member 'FCAVariableValue::Variable' has a wrong offset!");
static_assert(offsetof(FCAVariableValue, Comparison) == 0x000004, "Member 'FCAVariableValue::Comparison' has a wrong offset!");
static_assert(offsetof(FCAVariableValue, Value) == 0x000008, "Member 'FCAVariableValue::Value' has a wrong offset!");

// ScriptStruct keaton.CAAIPortalType
// 0x0038 (0x0038 - 0x0000)
struct FCAAIPortalType final
{
public:
	TSoftClassPtr<class UClass>                   M_portal_type;                                     // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_priority;                                        // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_blocked;                                      // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_modified_portal_bounding_box;                // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_rotate_front_and_back;                           // 0x0036(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37[0x1];                                       // 0x0037(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAIPortalType) == 0x000008, "Wrong alignment on FCAAIPortalType");
static_assert(sizeof(FCAAIPortalType) == 0x000038, "Wrong size on FCAAIPortalType");
static_assert(offsetof(FCAAIPortalType, M_portal_type) == 0x000000, "Member 'FCAAIPortalType::M_portal_type' has a wrong offset!");
static_assert(offsetof(FCAAIPortalType, M_priority) == 0x000030, "Member 'FCAAIPortalType::M_priority' has a wrong offset!");
static_assert(offsetof(FCAAIPortalType, M_is_blocked) == 0x000034, "Member 'FCAAIPortalType::M_is_blocked' has a wrong offset!");
static_assert(offsetof(FCAAIPortalType, M_use_modified_portal_bounding_box) == 0x000035, "Member 'FCAAIPortalType::M_use_modified_portal_bounding_box' has a wrong offset!");
static_assert(offsetof(FCAAIPortalType, M_rotate_front_and_back) == 0x000036, "Member 'FCAAIPortalType::M_rotate_front_and_back' has a wrong offset!");

// ScriptStruct keaton.CAAimAssist_FrictionTable_Elt
// 0x0018 (0x0018 - 0x0000)
struct FCAAimAssist_FrictionTable_Elt final
{
public:
	float                                         M_yaw_normal;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_yaw_ADS;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_pitch_normal;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_pitch_ADS;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_blend_time_increase;                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_blend_time_decrease;                             // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAimAssist_FrictionTable_Elt) == 0x000004, "Wrong alignment on FCAAimAssist_FrictionTable_Elt");
static_assert(sizeof(FCAAimAssist_FrictionTable_Elt) == 0x000018, "Wrong size on FCAAimAssist_FrictionTable_Elt");
static_assert(offsetof(FCAAimAssist_FrictionTable_Elt, M_yaw_normal) == 0x000000, "Member 'FCAAimAssist_FrictionTable_Elt::M_yaw_normal' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_FrictionTable_Elt, M_yaw_ADS) == 0x000004, "Member 'FCAAimAssist_FrictionTable_Elt::M_yaw_ADS' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_FrictionTable_Elt, M_pitch_normal) == 0x000008, "Member 'FCAAimAssist_FrictionTable_Elt::M_pitch_normal' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_FrictionTable_Elt, M_pitch_ADS) == 0x00000C, "Member 'FCAAimAssist_FrictionTable_Elt::M_pitch_ADS' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_FrictionTable_Elt, M_blend_time_increase) == 0x000010, "Member 'FCAAimAssist_FrictionTable_Elt::M_blend_time_increase' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_FrictionTable_Elt, M_blend_time_decrease) == 0x000014, "Member 'FCAAimAssist_FrictionTable_Elt::M_blend_time_decrease' has a wrong offset!");

// ScriptStruct keaton.CAAimAssist_FrictionTable
// 0x0058 (0x0088 - 0x0030)
struct FCAAimAssist_FrictionTable final : public FCAAimAssist_BaseTable
{
public:
	float                                         M_turn_speed_ignore_friction;                      // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAAimAssist_FrictionTable_Elt         M_outer_friction_factors;                          // 0x0034(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAimAssist_FrictionTable_Elt         M_inner_friction_factors;                          // 0x004C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_blend_time_no_target;                            // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAAimAssist_Stickyness                M_sticky;                                          // 0x0068(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAimAssist_FactorPair                M_rotation_bonus;                                  // 0x007C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAimAssist_FrictionTable) == 0x000008, "Wrong alignment on FCAAimAssist_FrictionTable");
static_assert(sizeof(FCAAimAssist_FrictionTable) == 0x000088, "Wrong size on FCAAimAssist_FrictionTable");
static_assert(offsetof(FCAAimAssist_FrictionTable, M_turn_speed_ignore_friction) == 0x000030, "Member 'FCAAimAssist_FrictionTable::M_turn_speed_ignore_friction' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_FrictionTable, M_outer_friction_factors) == 0x000034, "Member 'FCAAimAssist_FrictionTable::M_outer_friction_factors' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_FrictionTable, M_inner_friction_factors) == 0x00004C, "Member 'FCAAimAssist_FrictionTable::M_inner_friction_factors' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_FrictionTable, M_blend_time_no_target) == 0x000064, "Member 'FCAAimAssist_FrictionTable::M_blend_time_no_target' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_FrictionTable, M_sticky) == 0x000068, "Member 'FCAAimAssist_FrictionTable::M_sticky' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_FrictionTable, M_rotation_bonus) == 0x00007C, "Member 'FCAAimAssist_FrictionTable::M_rotation_bonus' has a wrong offset!");

// ScriptStruct keaton.CAProfileLevelUIData
// 0x0010 (0x0010 - 0x0000)
struct FCAProfileLevelUIData final
{
public:
	int32                                         Profile_level;                                     // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_max_level;                                      // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level_minimum_xp;                                  // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level_maximum_xp;                                  // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAProfileLevelUIData) == 0x000004, "Wrong alignment on FCAProfileLevelUIData");
static_assert(sizeof(FCAProfileLevelUIData) == 0x000010, "Wrong size on FCAProfileLevelUIData");
static_assert(offsetof(FCAProfileLevelUIData, Profile_level) == 0x000000, "Member 'FCAProfileLevelUIData::Profile_level' has a wrong offset!");
static_assert(offsetof(FCAProfileLevelUIData, Is_max_level) == 0x000004, "Member 'FCAProfileLevelUIData::Is_max_level' has a wrong offset!");
static_assert(offsetof(FCAProfileLevelUIData, Level_minimum_xp) == 0x000008, "Member 'FCAProfileLevelUIData::Level_minimum_xp' has a wrong offset!");
static_assert(offsetof(FCAProfileLevelUIData, Level_maximum_xp) == 0x00000C, "Member 'FCAProfileLevelUIData::Level_maximum_xp' has a wrong offset!");

// ScriptStruct keaton.CAPelletPatternData
// 0x0010 (0x0018 - 0x0008)
struct FCAPelletPatternData final : public FTableRowBase
{
public:
	float                                         M_pellet_x;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_pellet_y;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_spread_x;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_spread_y;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPelletPatternData) == 0x000008, "Wrong alignment on FCAPelletPatternData");
static_assert(sizeof(FCAPelletPatternData) == 0x000018, "Wrong size on FCAPelletPatternData");
static_assert(offsetof(FCAPelletPatternData, M_pellet_x) == 0x000008, "Member 'FCAPelletPatternData::M_pellet_x' has a wrong offset!");
static_assert(offsetof(FCAPelletPatternData, M_pellet_y) == 0x00000C, "Member 'FCAPelletPatternData::M_pellet_y' has a wrong offset!");
static_assert(offsetof(FCAPelletPatternData, M_max_spread_x) == 0x000010, "Member 'FCAPelletPatternData::M_max_spread_x' has a wrong offset!");
static_assert(offsetof(FCAPelletPatternData, M_max_spread_y) == 0x000014, "Member 'FCAPelletPatternData::M_max_spread_y' has a wrong offset!");

// ScriptStruct keaton.CAAimAssist_RangePair
// 0x0008 (0x0008 - 0x0000)
struct FCAAimAssist_RangePair final
{
public:
	float                                         M_range_hipfire;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_range_ADS;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAimAssist_RangePair) == 0x000004, "Wrong alignment on FCAAimAssist_RangePair");
static_assert(sizeof(FCAAimAssist_RangePair) == 0x000008, "Wrong size on FCAAimAssist_RangePair");
static_assert(offsetof(FCAAimAssist_RangePair, M_range_hipfire) == 0x000000, "Member 'FCAAimAssist_RangePair::M_range_hipfire' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_RangePair, M_range_ADS) == 0x000004, "Member 'FCAAimAssist_RangePair::M_range_ADS' has a wrong offset!");

// ScriptStruct keaton.CAAimAssist_TargetGatheringRules
// 0x00A8 (0x00B0 - 0x0008)
struct FCAAimAssist_TargetGatheringRules final : public FTableRowBase
{
public:
	EAimAssistShape                               M_shape;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FCAAimAssist_RangePair> M_range_set;                                       // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_overshoot_range;                                 // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_overlap_radius;                                  // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_outer_radius;                                    // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_inner_radius;                                    // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_character_raycast_bones;                         // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_base_score;                                      // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_range_multiplier;                                // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_facing_tolerance;                                // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_facing_bonus;                                    // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_current_target_time;                             // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_current_target_bonus;                            // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_outer_overlap_penalty;                           // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_downed_penalty;                                  // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_penalty;                                         // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_lost_focus_overrun_time;                         // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_concealed_by_geometry_follow_time;               // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAimAssist_TargetGatheringRules) == 0x000008, "Wrong alignment on FCAAimAssist_TargetGatheringRules");
static_assert(sizeof(FCAAimAssist_TargetGatheringRules) == 0x0000B0, "Wrong size on FCAAimAssist_TargetGatheringRules");
static_assert(offsetof(FCAAimAssist_TargetGatheringRules, M_shape) == 0x000008, "Member 'FCAAimAssist_TargetGatheringRules::M_shape' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_TargetGatheringRules, M_range_set) == 0x000010, "Member 'FCAAimAssist_TargetGatheringRules::M_range_set' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_TargetGatheringRules, M_overshoot_range) == 0x000060, "Member 'FCAAimAssist_TargetGatheringRules::M_overshoot_range' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_TargetGatheringRules, M_overlap_radius) == 0x000064, "Member 'FCAAimAssist_TargetGatheringRules::M_overlap_radius' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_TargetGatheringRules, M_outer_radius) == 0x000068, "Member 'FCAAimAssist_TargetGatheringRules::M_outer_radius' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_TargetGatheringRules, M_inner_radius) == 0x00006C, "Member 'FCAAimAssist_TargetGatheringRules::M_inner_radius' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_TargetGatheringRules, M_character_raycast_bones) == 0x000070, "Member 'FCAAimAssist_TargetGatheringRules::M_character_raycast_bones' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_TargetGatheringRules, M_base_score) == 0x000080, "Member 'FCAAimAssist_TargetGatheringRules::M_base_score' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_TargetGatheringRules, M_range_multiplier) == 0x000084, "Member 'FCAAimAssist_TargetGatheringRules::M_range_multiplier' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_TargetGatheringRules, M_facing_tolerance) == 0x000088, "Member 'FCAAimAssist_TargetGatheringRules::M_facing_tolerance' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_TargetGatheringRules, M_facing_bonus) == 0x00008C, "Member 'FCAAimAssist_TargetGatheringRules::M_facing_bonus' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_TargetGatheringRules, M_current_target_time) == 0x000090, "Member 'FCAAimAssist_TargetGatheringRules::M_current_target_time' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_TargetGatheringRules, M_current_target_bonus) == 0x000094, "Member 'FCAAimAssist_TargetGatheringRules::M_current_target_bonus' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_TargetGatheringRules, M_outer_overlap_penalty) == 0x000098, "Member 'FCAAimAssist_TargetGatheringRules::M_outer_overlap_penalty' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_TargetGatheringRules, M_downed_penalty) == 0x00009C, "Member 'FCAAimAssist_TargetGatheringRules::M_downed_penalty' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_TargetGatheringRules, M_penalty) == 0x0000A0, "Member 'FCAAimAssist_TargetGatheringRules::M_penalty' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_TargetGatheringRules, M_lost_focus_overrun_time) == 0x0000A4, "Member 'FCAAimAssist_TargetGatheringRules::M_lost_focus_overrun_time' has a wrong offset!");
static_assert(offsetof(FCAAimAssist_TargetGatheringRules, M_concealed_by_geometry_follow_time) == 0x0000A8, "Member 'FCAAimAssist_TargetGatheringRules::M_concealed_by_geometry_follow_time' has a wrong offset!");

// ScriptStruct keaton.CAExtractionOptions
// 0x0060 (0x0060 - 0x0000)
struct FCAExtractionOptions final
{
public:
	float                                         M_threshold_value;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_extraction_boarding_time_in_seconds;             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_extraction_boarding_time_in_seconds_when_single_team_left; // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_capture_rate;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_decapture_rate;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_capture_decay_rate;                              // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_mission_extraction_trigger_1_threshold;          // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_mission_extraction_trigger_2_threshold;          // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_extraction_activation_value;                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_show_extraction_areas_hud_and_map_icons_to_all_teams_always; // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_allow_multiple_teams_extraction_at_same_time;    // 0x0025(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_allow_same_team_multiple_extractions;            // 0x0026(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_lock_all_extractions_zones_after_first_activation; // 0x0027(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_restart_extraction_progress_on_occupying_team_wiped; // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_disable_already_activated_area_when_no_authorised_teams; // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_match_end_invulnerability_effect;                // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAExtractionOptions) == 0x000008, "Wrong alignment on FCAExtractionOptions");
static_assert(sizeof(FCAExtractionOptions) == 0x000060, "Wrong size on FCAExtractionOptions");
static_assert(offsetof(FCAExtractionOptions, M_threshold_value) == 0x000000, "Member 'FCAExtractionOptions::M_threshold_value' has a wrong offset!");
static_assert(offsetof(FCAExtractionOptions, M_extraction_boarding_time_in_seconds) == 0x000004, "Member 'FCAExtractionOptions::M_extraction_boarding_time_in_seconds' has a wrong offset!");
static_assert(offsetof(FCAExtractionOptions, M_extraction_boarding_time_in_seconds_when_single_team_left) == 0x000008, "Member 'FCAExtractionOptions::M_extraction_boarding_time_in_seconds_when_single_team_left' has a wrong offset!");
static_assert(offsetof(FCAExtractionOptions, M_capture_rate) == 0x00000C, "Member 'FCAExtractionOptions::M_capture_rate' has a wrong offset!");
static_assert(offsetof(FCAExtractionOptions, M_decapture_rate) == 0x000010, "Member 'FCAExtractionOptions::M_decapture_rate' has a wrong offset!");
static_assert(offsetof(FCAExtractionOptions, M_capture_decay_rate) == 0x000014, "Member 'FCAExtractionOptions::M_capture_decay_rate' has a wrong offset!");
static_assert(offsetof(FCAExtractionOptions, M_mission_extraction_trigger_1_threshold) == 0x000018, "Member 'FCAExtractionOptions::M_mission_extraction_trigger_1_threshold' has a wrong offset!");
static_assert(offsetof(FCAExtractionOptions, M_mission_extraction_trigger_2_threshold) == 0x00001C, "Member 'FCAExtractionOptions::M_mission_extraction_trigger_2_threshold' has a wrong offset!");
static_assert(offsetof(FCAExtractionOptions, M_extraction_activation_value) == 0x000020, "Member 'FCAExtractionOptions::M_extraction_activation_value' has a wrong offset!");
static_assert(offsetof(FCAExtractionOptions, M_show_extraction_areas_hud_and_map_icons_to_all_teams_always) == 0x000024, "Member 'FCAExtractionOptions::M_show_extraction_areas_hud_and_map_icons_to_all_teams_always' has a wrong offset!");
static_assert(offsetof(FCAExtractionOptions, M_allow_multiple_teams_extraction_at_same_time) == 0x000025, "Member 'FCAExtractionOptions::M_allow_multiple_teams_extraction_at_same_time' has a wrong offset!");
static_assert(offsetof(FCAExtractionOptions, M_allow_same_team_multiple_extractions) == 0x000026, "Member 'FCAExtractionOptions::M_allow_same_team_multiple_extractions' has a wrong offset!");
static_assert(offsetof(FCAExtractionOptions, M_lock_all_extractions_zones_after_first_activation) == 0x000027, "Member 'FCAExtractionOptions::M_lock_all_extractions_zones_after_first_activation' has a wrong offset!");
static_assert(offsetof(FCAExtractionOptions, M_restart_extraction_progress_on_occupying_team_wiped) == 0x000028, "Member 'FCAExtractionOptions::M_restart_extraction_progress_on_occupying_team_wiped' has a wrong offset!");
static_assert(offsetof(FCAExtractionOptions, M_disable_already_activated_area_when_no_authorised_teams) == 0x000029, "Member 'FCAExtractionOptions::M_disable_already_activated_area_when_no_authorised_teams' has a wrong offset!");
static_assert(offsetof(FCAExtractionOptions, M_match_end_invulnerability_effect) == 0x000030, "Member 'FCAExtractionOptions::M_match_end_invulnerability_effect' has a wrong offset!");

// ScriptStruct keaton.CASpawnRequest
// 0x0040 (0x0040 - 0x0000)
struct FCASpawnRequest final
{
public:
	TSubclassOf<class AActor>                     M_actor_class;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_transform;                                       // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASpawnRequest) == 0x000010, "Wrong alignment on FCASpawnRequest");
static_assert(sizeof(FCASpawnRequest) == 0x000040, "Wrong size on FCASpawnRequest");
static_assert(offsetof(FCASpawnRequest, M_actor_class) == 0x000000, "Member 'FCASpawnRequest::M_actor_class' has a wrong offset!");
static_assert(offsetof(FCASpawnRequest, M_transform) == 0x000010, "Member 'FCASpawnRequest::M_transform' has a wrong offset!");

// ScriptStruct keaton.CADialogueVariantWrapper
// 0x0018 (0x0018 - 0x0000)
struct FCADialogueVariantWrapper final
{
public:
	float                                         M_float_val;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_int_val;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_name_val;                                        // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECADialogueVariantType                        M_type;                                            // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADialogueVariantWrapper) == 0x000004, "Wrong alignment on FCADialogueVariantWrapper");
static_assert(sizeof(FCADialogueVariantWrapper) == 0x000018, "Wrong size on FCADialogueVariantWrapper");
static_assert(offsetof(FCADialogueVariantWrapper, M_float_val) == 0x000000, "Member 'FCADialogueVariantWrapper::M_float_val' has a wrong offset!");
static_assert(offsetof(FCADialogueVariantWrapper, M_int_val) == 0x000004, "Member 'FCADialogueVariantWrapper::M_int_val' has a wrong offset!");
static_assert(offsetof(FCADialogueVariantWrapper, M_name_val) == 0x000008, "Member 'FCADialogueVariantWrapper::M_name_val' has a wrong offset!");
static_assert(offsetof(FCADialogueVariantWrapper, M_type) == 0x000014, "Member 'FCADialogueVariantWrapper::M_type' has a wrong offset!");

// ScriptStruct keaton.RuleForcedCampTypeInGroup
// 0x001C (0x001C - 0x0000)
struct FRuleForcedCampTypeInGroup final
{
public:
	struct FGameplayTag                           M_group;                                           // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_camp_type;                                       // 0x000C(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_num_to_assign;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuleForcedCampTypeInGroup) == 0x000004, "Wrong alignment on FRuleForcedCampTypeInGroup");
static_assert(sizeof(FRuleForcedCampTypeInGroup) == 0x00001C, "Wrong size on FRuleForcedCampTypeInGroup");
static_assert(offsetof(FRuleForcedCampTypeInGroup, M_group) == 0x000000, "Member 'FRuleForcedCampTypeInGroup::M_group' has a wrong offset!");
static_assert(offsetof(FRuleForcedCampTypeInGroup, M_camp_type) == 0x00000C, "Member 'FRuleForcedCampTypeInGroup::M_camp_type' has a wrong offset!");
static_assert(offsetof(FRuleForcedCampTypeInGroup, M_num_to_assign) == 0x000018, "Member 'FRuleForcedCampTypeInGroup::M_num_to_assign' has a wrong offset!");

// ScriptStruct keaton.CAAimManagerSetup
// 0x0008 (0x0008 - 0x0000)
struct FCAAimManagerSetup final
{
public:
	float                                         M_rotation_speed_combat;                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_rotation_speed_idle;                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAimManagerSetup) == 0x000004, "Wrong alignment on FCAAimManagerSetup");
static_assert(sizeof(FCAAimManagerSetup) == 0x000008, "Wrong size on FCAAimManagerSetup");
static_assert(offsetof(FCAAimManagerSetup, M_rotation_speed_combat) == 0x000000, "Member 'FCAAimManagerSetup::M_rotation_speed_combat' has a wrong offset!");
static_assert(offsetof(FCAAimManagerSetup, M_rotation_speed_idle) == 0x000004, "Member 'FCAAimManagerSetup::M_rotation_speed_idle' has a wrong offset!");

// ScriptStruct keaton.CAAITouchEvent
// 0x0020 (0x0020 - 0x0000)
struct FCAAITouchEvent final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_touched_actor;                                   // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_other_actor;                                     // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAITouchEvent) == 0x000008, "Wrong alignment on FCAAITouchEvent");
static_assert(sizeof(FCAAITouchEvent) == 0x000020, "Wrong size on FCAAITouchEvent");
static_assert(offsetof(FCAAITouchEvent, M_touched_actor) == 0x000010, "Member 'FCAAITouchEvent::M_touched_actor' has a wrong offset!");
static_assert(offsetof(FCAAITouchEvent, M_other_actor) == 0x000018, "Member 'FCAAITouchEvent::M_other_actor' has a wrong offset!");

// ScriptStruct keaton.CAFSMTransition
// 0x0018 (0x0020 - 0x0008)
struct FCAFSMTransition final : public FTableRowBase
{
public:
	struct FCAGameDatabaseRowHandle               M_target_state_handle;                             // 0x0008(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFSMTransition) == 0x000008, "Wrong alignment on FCAFSMTransition");
static_assert(sizeof(FCAFSMTransition) == 0x000020, "Wrong size on FCAFSMTransition");
static_assert(offsetof(FCAFSMTransition, M_target_state_handle) == 0x000008, "Member 'FCAFSMTransition::M_target_state_handle' has a wrong offset!");

// ScriptStruct keaton.CAAIWeaponNoiseEvent
// 0x0030 (0x0030 - 0x0000)
struct FCAAIWeaponNoiseEvent final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NoiseLocation;                                     // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Loudness;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAIWeaponNoiseEvent) == 0x000008, "Wrong alignment on FCAAIWeaponNoiseEvent");
static_assert(sizeof(FCAAIWeaponNoiseEvent) == 0x000030, "Wrong size on FCAAIWeaponNoiseEvent");
static_assert(offsetof(FCAAIWeaponNoiseEvent, NoiseLocation) == 0x000004, "Member 'FCAAIWeaponNoiseEvent::NoiseLocation' has a wrong offset!");
static_assert(offsetof(FCAAIWeaponNoiseEvent, Loudness) == 0x000010, "Member 'FCAAIWeaponNoiseEvent::Loudness' has a wrong offset!");
static_assert(offsetof(FCAAIWeaponNoiseEvent, MaxRange) == 0x000014, "Member 'FCAAIWeaponNoiseEvent::MaxRange' has a wrong offset!");
static_assert(offsetof(FCAAIWeaponNoiseEvent, Instigator) == 0x000018, "Member 'FCAAIWeaponNoiseEvent::Instigator' has a wrong offset!");
static_assert(offsetof(FCAAIWeaponNoiseEvent, Tag) == 0x000020, "Member 'FCAAIWeaponNoiseEvent::Tag' has a wrong offset!");

// ScriptStruct keaton.CAAllianceRecord
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FCAAllianceRecord final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAllianceRecord) == 0x000004, "Wrong alignment on FCAAllianceRecord");
static_assert(sizeof(FCAAllianceRecord) == 0x000008, "Wrong size on FCAAllianceRecord");

// ScriptStruct keaton.CAPreviouslyTriggeredEventPerSecurityArea
// 0x0010 (0x0010 - 0x0000)
struct FCAPreviouslyTriggeredEventPerSecurityArea final
{
public:
	TArray<uint32>                                M_event_id_array;                                  // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPreviouslyTriggeredEventPerSecurityArea) == 0x000008, "Wrong alignment on FCAPreviouslyTriggeredEventPerSecurityArea");
static_assert(sizeof(FCAPreviouslyTriggeredEventPerSecurityArea) == 0x000010, "Wrong size on FCAPreviouslyTriggeredEventPerSecurityArea");
static_assert(offsetof(FCAPreviouslyTriggeredEventPerSecurityArea, M_event_id_array) == 0x000000, "Member 'FCAPreviouslyTriggeredEventPerSecurityArea::M_event_id_array' has a wrong offset!");

// ScriptStruct keaton.CANPCTeamInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FCANPCTeamInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCTeamInfo) == 0x000004, "Wrong alignment on FCANPCTeamInfo");
static_assert(sizeof(FCANPCTeamInfo) == 0x000010, "Wrong size on FCANPCTeamInfo");

// ScriptStruct keaton.CAAmbientLightingState
// 0x0014 (0x0014 - 0x0000)
struct FCAAmbientLightingState final
{
public:
	struct FGameplayTag                           M_status_tag;                                      // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 M_tint;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_intensity;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAmbientLightingState) == 0x000004, "Wrong alignment on FCAAmbientLightingState");
static_assert(sizeof(FCAAmbientLightingState) == 0x000014, "Wrong size on FCAAmbientLightingState");
static_assert(offsetof(FCAAmbientLightingState, M_status_tag) == 0x000000, "Member 'FCAAmbientLightingState::M_status_tag' has a wrong offset!");
static_assert(offsetof(FCAAmbientLightingState, M_tint) == 0x00000C, "Member 'FCAAmbientLightingState::M_tint' has a wrong offset!");
static_assert(offsetof(FCAAmbientLightingState, M_intensity) == 0x000010, "Member 'FCAAmbientLightingState::M_intensity' has a wrong offset!");

// ScriptStruct keaton.SkelMeshMergeSectionMapping_BP
// 0x0010 (0x0010 - 0x0000)
struct FSkelMeshMergeSectionMapping_BP final
{
public:
	TArray<int32>                                 SectionIDs;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkelMeshMergeSectionMapping_BP) == 0x000008, "Wrong alignment on FSkelMeshMergeSectionMapping_BP");
static_assert(sizeof(FSkelMeshMergeSectionMapping_BP) == 0x000010, "Wrong size on FSkelMeshMergeSectionMapping_BP");
static_assert(offsetof(FSkelMeshMergeSectionMapping_BP, SectionIDs) == 0x000000, "Member 'FSkelMeshMergeSectionMapping_BP::SectionIDs' has a wrong offset!");

// ScriptStruct keaton.SkelMeshMergeUVTransform
// 0x0010 (0x0010 - 0x0000)
struct FSkelMeshMergeUVTransform final
{
public:
	TArray<struct FTransform>                     UVTransforms;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkelMeshMergeUVTransform) == 0x000008, "Wrong alignment on FSkelMeshMergeUVTransform");
static_assert(sizeof(FSkelMeshMergeUVTransform) == 0x000010, "Wrong size on FSkelMeshMergeUVTransform");
static_assert(offsetof(FSkelMeshMergeUVTransform, UVTransforms) == 0x000000, "Member 'FSkelMeshMergeUVTransform::UVTransforms' has a wrong offset!");

// ScriptStruct keaton.SkelMeshMergeUVTransformMapping
// 0x0010 (0x0010 - 0x0000)
struct FSkelMeshMergeUVTransformMapping final
{
public:
	TArray<struct FSkelMeshMergeUVTransform>      UVTransformsPerMesh;                               // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkelMeshMergeUVTransformMapping) == 0x000008, "Wrong alignment on FSkelMeshMergeUVTransformMapping");
static_assert(sizeof(FSkelMeshMergeUVTransformMapping) == 0x000010, "Wrong size on FSkelMeshMergeUVTransformMapping");
static_assert(offsetof(FSkelMeshMergeUVTransformMapping, UVTransformsPerMesh) == 0x000000, "Member 'FSkelMeshMergeUVTransformMapping::UVTransformsPerMesh' has a wrong offset!");

// ScriptStruct keaton.SkeletalMeshMergeParams
// 0x0040 (0x0040 - 0x0000)
struct FSkeletalMeshMergeParams final
{
public:
	TArray<struct FSkelMeshMergeSectionMapping_BP> MeshSectionMappings;                               // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSkelMeshMergeUVTransformMapping> UVTransformsPerMesh;                               // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USkeletalMesh*>                  MeshesToMerge;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         StripTopLODS;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNeedsCpuAccess : 1;                               // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSkeletonBefore : 1;                               // 0x0034(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeleton*                              Skeleton;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkeletalMeshMergeParams) == 0x000008, "Wrong alignment on FSkeletalMeshMergeParams");
static_assert(sizeof(FSkeletalMeshMergeParams) == 0x000040, "Wrong size on FSkeletalMeshMergeParams");
static_assert(offsetof(FSkeletalMeshMergeParams, MeshSectionMappings) == 0x000000, "Member 'FSkeletalMeshMergeParams::MeshSectionMappings' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshMergeParams, UVTransformsPerMesh) == 0x000010, "Member 'FSkeletalMeshMergeParams::UVTransformsPerMesh' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshMergeParams, MeshesToMerge) == 0x000020, "Member 'FSkeletalMeshMergeParams::MeshesToMerge' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshMergeParams, StripTopLODS) == 0x000030, "Member 'FSkeletalMeshMergeParams::StripTopLODS' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshMergeParams, Skeleton) == 0x000038, "Member 'FSkeletalMeshMergeParams::Skeleton' has a wrong offset!");

// ScriptStruct keaton.CASynchronisedState
// 0x0008 (0x0008 - 0x0000)
struct FCASynchronisedState final
{
public:
	float                                         M_ActivationTime;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_DeactivationTime;                                // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASynchronisedState) == 0x000004, "Wrong alignment on FCASynchronisedState");
static_assert(sizeof(FCASynchronisedState) == 0x000008, "Wrong size on FCASynchronisedState");
static_assert(offsetof(FCASynchronisedState, M_ActivationTime) == 0x000000, "Member 'FCASynchronisedState::M_ActivationTime' has a wrong offset!");
static_assert(offsetof(FCASynchronisedState, M_DeactivationTime) == 0x000004, "Member 'FCASynchronisedState::M_DeactivationTime' has a wrong offset!");

// ScriptStruct keaton.UseInteractableStateMapping
// 0x0003 (0x0003 - 0x0000)
struct FUseInteractableStateMapping final
{
public:
	ECAUseInteractableType                        M_interaction;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESysDeviceStateType                           M_state;                                           // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_enabled;                                         // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUseInteractableStateMapping) == 0x000001, "Wrong alignment on FUseInteractableStateMapping");
static_assert(sizeof(FUseInteractableStateMapping) == 0x000003, "Wrong size on FUseInteractableStateMapping");
static_assert(offsetof(FUseInteractableStateMapping, M_interaction) == 0x000000, "Member 'FUseInteractableStateMapping::M_interaction' has a wrong offset!");
static_assert(offsetof(FUseInteractableStateMapping, M_state) == 0x000001, "Member 'FUseInteractableStateMapping::M_state' has a wrong offset!");
static_assert(offsetof(FUseInteractableStateMapping, M_enabled) == 0x000002, "Member 'FUseInteractableStateMapping::M_enabled' has a wrong offset!");

// ScriptStruct keaton.AOEHitPoint
// 0x0018 (0x0018 - 0x0000)
struct FAOEHitPoint final
{
public:
	class USceneComponent*                        M_scene_component;                                 // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_offset;                                          // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAOEHitPoint) == 0x000008, "Wrong alignment on FAOEHitPoint");
static_assert(sizeof(FAOEHitPoint) == 0x000018, "Wrong size on FAOEHitPoint");
static_assert(offsetof(FAOEHitPoint, M_scene_component) == 0x000000, "Member 'FAOEHitPoint::M_scene_component' has a wrong offset!");
static_assert(offsetof(FAOEHitPoint, M_offset) == 0x000008, "Member 'FAOEHitPoint::M_offset' has a wrong offset!");

// ScriptStruct keaton.CAProjectileMovementComponentConfiguration
// 0x0000 (0x0008 - 0x0008)
struct FCAProjectileMovementComponentConfiguration final : public FTableRowBase
{
};
static_assert(alignof(FCAProjectileMovementComponentConfiguration) == 0x000008, "Wrong alignment on FCAProjectileMovementComponentConfiguration");
static_assert(sizeof(FCAProjectileMovementComponentConfiguration) == 0x000008, "Wrong size on FCAProjectileMovementComponentConfiguration");

// ScriptStruct keaton.CAUIInfoEntry
// 0x0090 (0x0090 - 0x0000)
struct FCAUIInfoEntry final
{
public:
	struct FCAText                                M_title;                                           // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_body;                                            // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_icon;                                            // 0x0060(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAUIInfoEntry) == 0x000008, "Wrong alignment on FCAUIInfoEntry");
static_assert(sizeof(FCAUIInfoEntry) == 0x000090, "Wrong size on FCAUIInfoEntry");
static_assert(offsetof(FCAUIInfoEntry, M_title) == 0x000000, "Member 'FCAUIInfoEntry::M_title' has a wrong offset!");
static_assert(offsetof(FCAUIInfoEntry, M_body) == 0x000030, "Member 'FCAUIInfoEntry::M_body' has a wrong offset!");
static_assert(offsetof(FCAUIInfoEntry, M_icon) == 0x000060, "Member 'FCAUIInfoEntry::M_icon' has a wrong offset!");

// ScriptStruct keaton.SkillfulKillsDownedData
// 0x0010 (0x0010 - 0x0000)
struct FSkillfulKillsDownedData final
{
public:
	TArray<class UAnimMontage*>                   M_anims;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillfulKillsDownedData) == 0x000008, "Wrong alignment on FSkillfulKillsDownedData");
static_assert(sizeof(FSkillfulKillsDownedData) == 0x000010, "Wrong size on FSkillfulKillsDownedData");
static_assert(offsetof(FSkillfulKillsDownedData, M_anims) == 0x000000, "Member 'FSkillfulKillsDownedData::M_anims' has a wrong offset!");

// ScriptStruct keaton.CAIntelTerminalActivityData
// 0x0010 (0x0010 - 0x0000)
struct FCAIntelTerminalActivityData final
{
public:
	TSubclassOf<class ACAActivityBase>            M_activity;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_weight;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAIntelTerminalActivityData) == 0x000008, "Wrong alignment on FCAIntelTerminalActivityData");
static_assert(sizeof(FCAIntelTerminalActivityData) == 0x000010, "Wrong size on FCAIntelTerminalActivityData");
static_assert(offsetof(FCAIntelTerminalActivityData, M_activity) == 0x000000, "Member 'FCAIntelTerminalActivityData::M_activity' has a wrong offset!");
static_assert(offsetof(FCAIntelTerminalActivityData, M_weight) == 0x000008, "Member 'FCAIntelTerminalActivityData::M_weight' has a wrong offset!");

// ScriptStruct keaton.CAIntelTerminalSetupDefinition
// 0x0050 (0x0058 - 0x0008)
struct FCAIntelTerminalSetupDefinition final : public FTableRowBase
{
public:
	TArray<struct FCAIntelTerminalActivityData>   M_activities;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UDataTable*                             M_rewards_table;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_allowed_reward_types;                            // 0x0020(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class ACARewardBoxBase>           M_reward_box_template;                             // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_offered_reward_count;                            // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_cooldown;                                        // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_success;                                         // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_failure;                                         // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAIntelTerminalSetupDefinition) == 0x000008, "Wrong alignment on FCAIntelTerminalSetupDefinition");
static_assert(sizeof(FCAIntelTerminalSetupDefinition) == 0x000058, "Wrong size on FCAIntelTerminalSetupDefinition");
static_assert(offsetof(FCAIntelTerminalSetupDefinition, M_activities) == 0x000008, "Member 'FCAIntelTerminalSetupDefinition::M_activities' has a wrong offset!");
static_assert(offsetof(FCAIntelTerminalSetupDefinition, M_rewards_table) == 0x000018, "Member 'FCAIntelTerminalSetupDefinition::M_rewards_table' has a wrong offset!");
static_assert(offsetof(FCAIntelTerminalSetupDefinition, M_allowed_reward_types) == 0x000020, "Member 'FCAIntelTerminalSetupDefinition::M_allowed_reward_types' has a wrong offset!");
static_assert(offsetof(FCAIntelTerminalSetupDefinition, M_reward_box_template) == 0x000040, "Member 'FCAIntelTerminalSetupDefinition::M_reward_box_template' has a wrong offset!");
static_assert(offsetof(FCAIntelTerminalSetupDefinition, M_offered_reward_count) == 0x000048, "Member 'FCAIntelTerminalSetupDefinition::M_offered_reward_count' has a wrong offset!");
static_assert(offsetof(FCAIntelTerminalSetupDefinition, M_cooldown) == 0x00004C, "Member 'FCAIntelTerminalSetupDefinition::M_cooldown' has a wrong offset!");
static_assert(offsetof(FCAIntelTerminalSetupDefinition, M_success) == 0x000050, "Member 'FCAIntelTerminalSetupDefinition::M_success' has a wrong offset!");
static_assert(offsetof(FCAIntelTerminalSetupDefinition, M_failure) == 0x000054, "Member 'FCAIntelTerminalSetupDefinition::M_failure' has a wrong offset!");

// ScriptStruct keaton.SkeletalMeshCustomFOVSpawnParam
// 0x0070 (0x0070 - 0x0000)
struct FSkeletalMeshCustomFOVSpawnParam final
{
public:
	class FName                                   M_bone_name;                                       // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_offset;                                          // 0x0010(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   M_collision_profile;                               // 0x0040(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          M_skeletal_mesh;                                   // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ACASkeletalMeshCustomFovActor*>  M_spawned_actors;                                  // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_use_parent_material;                             // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkeletalMeshCustomFOVSpawnParam) == 0x000010, "Wrong alignment on FSkeletalMeshCustomFOVSpawnParam");
static_assert(sizeof(FSkeletalMeshCustomFOVSpawnParam) == 0x000070, "Wrong size on FSkeletalMeshCustomFOVSpawnParam");
static_assert(offsetof(FSkeletalMeshCustomFOVSpawnParam, M_bone_name) == 0x000000, "Member 'FSkeletalMeshCustomFOVSpawnParam::M_bone_name' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshCustomFOVSpawnParam, M_offset) == 0x000010, "Member 'FSkeletalMeshCustomFOVSpawnParam::M_offset' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshCustomFOVSpawnParam, M_collision_profile) == 0x000040, "Member 'FSkeletalMeshCustomFOVSpawnParam::M_collision_profile' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshCustomFOVSpawnParam, M_skeletal_mesh) == 0x000050, "Member 'FSkeletalMeshCustomFOVSpawnParam::M_skeletal_mesh' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshCustomFOVSpawnParam, M_spawned_actors) == 0x000058, "Member 'FSkeletalMeshCustomFOVSpawnParam::M_spawned_actors' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshCustomFOVSpawnParam, M_use_parent_material) == 0x000068, "Member 'FSkeletalMeshCustomFOVSpawnParam::M_use_parent_material' has a wrong offset!");

// ScriptStruct keaton.CAAnimationHeightsData
// 0x0040 (0x0048 - 0x0008)
struct FCAAnimationHeightsData final : public FTableRowBase
{
public:
	float                                         M_expected_gameplay_camera_height;                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_expected_animation_camera_height;                // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_crouch_differential;                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ground_to_capsule_expectation;                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_pitch_radius_down;                               // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_pitch_radius_up;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_offset_for_collision;                            // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_z_offset_for_zero_g;                             // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_eye_height_below_capsule_top_zero_g;             // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_shoulder_offset_x;                               // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_shoulder_offset_z;                               // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_hand_to_grip_correction;                         // 0x0034(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_grip_tightness_correction;                       // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAnimationHeightsData) == 0x000008, "Wrong alignment on FCAAnimationHeightsData");
static_assert(sizeof(FCAAnimationHeightsData) == 0x000048, "Wrong size on FCAAnimationHeightsData");
static_assert(offsetof(FCAAnimationHeightsData, M_expected_gameplay_camera_height) == 0x000008, "Member 'FCAAnimationHeightsData::M_expected_gameplay_camera_height' has a wrong offset!");
static_assert(offsetof(FCAAnimationHeightsData, M_expected_animation_camera_height) == 0x00000C, "Member 'FCAAnimationHeightsData::M_expected_animation_camera_height' has a wrong offset!");
static_assert(offsetof(FCAAnimationHeightsData, M_crouch_differential) == 0x000010, "Member 'FCAAnimationHeightsData::M_crouch_differential' has a wrong offset!");
static_assert(offsetof(FCAAnimationHeightsData, M_ground_to_capsule_expectation) == 0x000014, "Member 'FCAAnimationHeightsData::M_ground_to_capsule_expectation' has a wrong offset!");
static_assert(offsetof(FCAAnimationHeightsData, M_pitch_radius_down) == 0x000018, "Member 'FCAAnimationHeightsData::M_pitch_radius_down' has a wrong offset!");
static_assert(offsetof(FCAAnimationHeightsData, M_pitch_radius_up) == 0x00001C, "Member 'FCAAnimationHeightsData::M_pitch_radius_up' has a wrong offset!");
static_assert(offsetof(FCAAnimationHeightsData, M_offset_for_collision) == 0x000020, "Member 'FCAAnimationHeightsData::M_offset_for_collision' has a wrong offset!");
static_assert(offsetof(FCAAnimationHeightsData, M_z_offset_for_zero_g) == 0x000024, "Member 'FCAAnimationHeightsData::M_z_offset_for_zero_g' has a wrong offset!");
static_assert(offsetof(FCAAnimationHeightsData, M_eye_height_below_capsule_top_zero_g) == 0x000028, "Member 'FCAAnimationHeightsData::M_eye_height_below_capsule_top_zero_g' has a wrong offset!");
static_assert(offsetof(FCAAnimationHeightsData, M_shoulder_offset_x) == 0x00002C, "Member 'FCAAnimationHeightsData::M_shoulder_offset_x' has a wrong offset!");
static_assert(offsetof(FCAAnimationHeightsData, M_shoulder_offset_z) == 0x000030, "Member 'FCAAnimationHeightsData::M_shoulder_offset_z' has a wrong offset!");
static_assert(offsetof(FCAAnimationHeightsData, M_hand_to_grip_correction) == 0x000034, "Member 'FCAAnimationHeightsData::M_hand_to_grip_correction' has a wrong offset!");
static_assert(offsetof(FCAAnimationHeightsData, M_grip_tightness_correction) == 0x000040, "Member 'FCAAnimationHeightsData::M_grip_tightness_correction' has a wrong offset!");

// ScriptStruct keaton.GravHookAnimList
// 0x0010 (0x0010 - 0x0000)
struct FGravHookAnimList final
{
public:
	class UAnimMontage*                           M_anim_held;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_anim_ADS;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGravHookAnimList) == 0x000008, "Wrong alignment on FGravHookAnimList");
static_assert(sizeof(FGravHookAnimList) == 0x000010, "Wrong size on FGravHookAnimList");
static_assert(offsetof(FGravHookAnimList, M_anim_held) == 0x000000, "Member 'FGravHookAnimList::M_anim_held' has a wrong offset!");
static_assert(offsetof(FGravHookAnimList, M_anim_ADS) == 0x000008, "Member 'FGravHookAnimList::M_anim_ADS' has a wrong offset!");

// ScriptStruct keaton.CAProjectileSplineParams
// 0x0024 (0x0024 - 0x0000)
struct FCAProjectileSplineParams final
{
public:
	bool                                          M_is_active;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    M_start_location;                                  // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    M_target_location;                                 // 0x0010(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_speed_factor;                                    // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_arc_param;                                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAProjectileSplineParams) == 0x000004, "Wrong alignment on FCAProjectileSplineParams");
static_assert(sizeof(FCAProjectileSplineParams) == 0x000024, "Wrong size on FCAProjectileSplineParams");
static_assert(offsetof(FCAProjectileSplineParams, M_is_active) == 0x000000, "Member 'FCAProjectileSplineParams::M_is_active' has a wrong offset!");
static_assert(offsetof(FCAProjectileSplineParams, M_start_location) == 0x000004, "Member 'FCAProjectileSplineParams::M_start_location' has a wrong offset!");
static_assert(offsetof(FCAProjectileSplineParams, M_target_location) == 0x000010, "Member 'FCAProjectileSplineParams::M_target_location' has a wrong offset!");
static_assert(offsetof(FCAProjectileSplineParams, M_speed_factor) == 0x00001C, "Member 'FCAProjectileSplineParams::M_speed_factor' has a wrong offset!");
static_assert(offsetof(FCAProjectileSplineParams, M_arc_param) == 0x000020, "Member 'FCAProjectileSplineParams::M_arc_param' has a wrong offset!");

// ScriptStruct keaton.CAHUDEntityTableRow
// 0x0090 (0x0098 - 0x0008)
struct FCAHUDEntityTableRow final : public FTableRowBase
{
public:
	ECAUIHUDEntityId                              M_entity_id;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAUIHUDEntityType                            M_entity_type;                                     // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           M_icon_color;                                      // 0x000C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCAHUDMapIconBase>          M_map_icon_class;                                  // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             M_map_icon_texture;                                // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              M_map_icon_size;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              M_map_icon_offset;                                 // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_always_clamp_map_position;                       // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAHUDClampingStyle                           M_clamping_rule;                                   // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_z_order;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAText                                M_legend_text;                                     // 0x0048(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class UCAHUDSpatialMarkerBase>    M_spatial_marker_class;                            // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             M_spatial_marker_texture;                          // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_override_texture;                                // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_disable_rotation;                                // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_ignore_minimap_rotation;                         // 0x008A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_interactable;                                 // 0x008B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_always_show_distance;                            // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_hidden_by_inf_level;                          // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_affected_by_player_height_diff;                  // 0x0091(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAHUDEntityTableRow) == 0x000008, "Wrong alignment on FCAHUDEntityTableRow");
static_assert(sizeof(FCAHUDEntityTableRow) == 0x000098, "Wrong size on FCAHUDEntityTableRow");
static_assert(offsetof(FCAHUDEntityTableRow, M_entity_id) == 0x000008, "Member 'FCAHUDEntityTableRow::M_entity_id' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_entity_type) == 0x000009, "Member 'FCAHUDEntityTableRow::M_entity_type' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_icon_color) == 0x00000C, "Member 'FCAHUDEntityTableRow::M_icon_color' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_map_icon_class) == 0x000020, "Member 'FCAHUDEntityTableRow::M_map_icon_class' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_map_icon_texture) == 0x000028, "Member 'FCAHUDEntityTableRow::M_map_icon_texture' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_map_icon_size) == 0x000030, "Member 'FCAHUDEntityTableRow::M_map_icon_size' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_map_icon_offset) == 0x000038, "Member 'FCAHUDEntityTableRow::M_map_icon_offset' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_always_clamp_map_position) == 0x000040, "Member 'FCAHUDEntityTableRow::M_always_clamp_map_position' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_clamping_rule) == 0x000041, "Member 'FCAHUDEntityTableRow::M_clamping_rule' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_z_order) == 0x000044, "Member 'FCAHUDEntityTableRow::M_z_order' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_legend_text) == 0x000048, "Member 'FCAHUDEntityTableRow::M_legend_text' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_spatial_marker_class) == 0x000078, "Member 'FCAHUDEntityTableRow::M_spatial_marker_class' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_spatial_marker_texture) == 0x000080, "Member 'FCAHUDEntityTableRow::M_spatial_marker_texture' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_override_texture) == 0x000088, "Member 'FCAHUDEntityTableRow::M_override_texture' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_disable_rotation) == 0x000089, "Member 'FCAHUDEntityTableRow::M_disable_rotation' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_ignore_minimap_rotation) == 0x00008A, "Member 'FCAHUDEntityTableRow::M_ignore_minimap_rotation' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_is_interactable) == 0x00008B, "Member 'FCAHUDEntityTableRow::M_is_interactable' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_always_show_distance) == 0x00008C, "Member 'FCAHUDEntityTableRow::M_always_show_distance' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_is_hidden_by_inf_level) == 0x000090, "Member 'FCAHUDEntityTableRow::M_is_hidden_by_inf_level' has a wrong offset!");
static_assert(offsetof(FCAHUDEntityTableRow, M_affected_by_player_height_diff) == 0x000091, "Member 'FCAHUDEntityTableRow::M_affected_by_player_height_diff' has a wrong offset!");

// ScriptStruct keaton.CAGMCItemBonusEffectPayloadData
// 0x0080 (0x0088 - 0x0008)
struct FCAGMCItemBonusEffectPayloadData final : public FTableRowBase
{
public:
	float                                         bonus_effect_chance;                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAWeaponPayload                       M_bonus_effect_payload;                            // 0x0010(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAGMCItemBonusEffectPayloadData) == 0x000008, "Wrong alignment on FCAGMCItemBonusEffectPayloadData");
static_assert(sizeof(FCAGMCItemBonusEffectPayloadData) == 0x000088, "Wrong size on FCAGMCItemBonusEffectPayloadData");
static_assert(offsetof(FCAGMCItemBonusEffectPayloadData, bonus_effect_chance) == 0x000008, "Member 'FCAGMCItemBonusEffectPayloadData::bonus_effect_chance' has a wrong offset!");
static_assert(offsetof(FCAGMCItemBonusEffectPayloadData, M_bonus_effect_payload) == 0x000010, "Member 'FCAGMCItemBonusEffectPayloadData::M_bonus_effect_payload' has a wrong offset!");

// ScriptStruct keaton.TeamScoreRewardsItem
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x08) FTeamScoreRewardsItem final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_score;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_rank_bonus;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0xA4];                                       // 0x000C(0x00A4)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTeamScoreRewardsItem) == 0x000008, "Wrong alignment on FTeamScoreRewardsItem");
static_assert(sizeof(FTeamScoreRewardsItem) == 0x0000B0, "Wrong size on FTeamScoreRewardsItem");
static_assert(offsetof(FTeamScoreRewardsItem, M_score) == 0x000004, "Member 'FTeamScoreRewardsItem::M_score' has a wrong offset!");
static_assert(offsetof(FTeamScoreRewardsItem, M_rank_bonus) == 0x000008, "Member 'FTeamScoreRewardsItem::M_rank_bonus' has a wrong offset!");

// ScriptStruct keaton.ProjectileLaunchConfig
// 0x0098 (0x00A0 - 0x0008)
struct FProjectileLaunchConfig final : public FTableRowBase
{
public:
	class FName                                   M_name;                                            // 0x0008(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_initial_launch_direction;                        // 0x0014(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_launch_direction_scale_pitch_centre_dead_zone;   // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_launch_direction_scale_pitch_up;                 // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_launch_direction_scale_pitch_down;               // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_player_movement_initial_launch_direction_miltipliers; // 0x002C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_scale_added_actor_movement_by_similarity_to_forward_direction; // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_prediciton_sweep_scale;                          // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_launch_offset;                                   // 0x0040(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_slide_offset;                                // 0x004C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_slide_launch_offset;                             // 0x0050(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_zerog_offset;                                // 0x005C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_zerog_launch_offset;                             // 0x0060(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_zerog_movement_modifiers;                    // 0x006C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_player_movement_zerog_launch_direction_miltipliers; // 0x0070(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_from_weapon_position;                            // 0x007C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_initial_launch_speed;                            // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_add_prediction_arc_launch_offset;                // 0x0084(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_prediction_arc_launch_offset;                    // 0x0088(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_minimum_speed;                                   // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_prediction_bounces_to_show;                      // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectileLaunchConfig) == 0x000008, "Wrong alignment on FProjectileLaunchConfig");
static_assert(sizeof(FProjectileLaunchConfig) == 0x0000A0, "Wrong size on FProjectileLaunchConfig");
static_assert(offsetof(FProjectileLaunchConfig, M_name) == 0x000008, "Member 'FProjectileLaunchConfig::M_name' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_initial_launch_direction) == 0x000014, "Member 'FProjectileLaunchConfig::M_initial_launch_direction' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_launch_direction_scale_pitch_centre_dead_zone) == 0x000020, "Member 'FProjectileLaunchConfig::M_launch_direction_scale_pitch_centre_dead_zone' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_launch_direction_scale_pitch_up) == 0x000024, "Member 'FProjectileLaunchConfig::M_launch_direction_scale_pitch_up' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_launch_direction_scale_pitch_down) == 0x000028, "Member 'FProjectileLaunchConfig::M_launch_direction_scale_pitch_down' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_player_movement_initial_launch_direction_miltipliers) == 0x00002C, "Member 'FProjectileLaunchConfig::M_player_movement_initial_launch_direction_miltipliers' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_scale_added_actor_movement_by_similarity_to_forward_direction) == 0x000038, "Member 'FProjectileLaunchConfig::M_scale_added_actor_movement_by_similarity_to_forward_direction' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_prediciton_sweep_scale) == 0x00003C, "Member 'FProjectileLaunchConfig::M_prediciton_sweep_scale' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_launch_offset) == 0x000040, "Member 'FProjectileLaunchConfig::M_launch_offset' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_use_slide_offset) == 0x00004C, "Member 'FProjectileLaunchConfig::M_use_slide_offset' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_slide_launch_offset) == 0x000050, "Member 'FProjectileLaunchConfig::M_slide_launch_offset' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_use_zerog_offset) == 0x00005C, "Member 'FProjectileLaunchConfig::M_use_zerog_offset' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_zerog_launch_offset) == 0x000060, "Member 'FProjectileLaunchConfig::M_zerog_launch_offset' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_use_zerog_movement_modifiers) == 0x00006C, "Member 'FProjectileLaunchConfig::M_use_zerog_movement_modifiers' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_player_movement_zerog_launch_direction_miltipliers) == 0x000070, "Member 'FProjectileLaunchConfig::M_player_movement_zerog_launch_direction_miltipliers' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_from_weapon_position) == 0x00007C, "Member 'FProjectileLaunchConfig::M_from_weapon_position' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_initial_launch_speed) == 0x000080, "Member 'FProjectileLaunchConfig::M_initial_launch_speed' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_add_prediction_arc_launch_offset) == 0x000084, "Member 'FProjectileLaunchConfig::M_add_prediction_arc_launch_offset' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_prediction_arc_launch_offset) == 0x000088, "Member 'FProjectileLaunchConfig::M_prediction_arc_launch_offset' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_minimum_speed) == 0x000094, "Member 'FProjectileLaunchConfig::M_minimum_speed' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchConfig, M_prediction_bounces_to_show) == 0x000098, "Member 'FProjectileLaunchConfig::M_prediction_bounces_to_show' has a wrong offset!");

// ScriptStruct keaton.CAAnimInstance_Component_Land
// 0x0028 (0x0038 - 0x0010)
struct FCAAnimInstance_Component_Land final : public FCAAnimInstance_Component
{
public:
	struct FVector                                M_pre_land_velocity;                               // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_pre_land_speed;                                  // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_last_ground_velocity;                            // 0x0020(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_heavy_landing_speed_threshold;                   // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_heavy_landing;                                // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_in_the_air;                                   // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_air_time;                                        // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAnimInstance_Component_Land) == 0x000008, "Wrong alignment on FCAAnimInstance_Component_Land");
static_assert(sizeof(FCAAnimInstance_Component_Land) == 0x000038, "Wrong size on FCAAnimInstance_Component_Land");
static_assert(offsetof(FCAAnimInstance_Component_Land, M_pre_land_velocity) == 0x000010, "Member 'FCAAnimInstance_Component_Land::M_pre_land_velocity' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Land, M_pre_land_speed) == 0x00001C, "Member 'FCAAnimInstance_Component_Land::M_pre_land_speed' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Land, M_last_ground_velocity) == 0x000020, "Member 'FCAAnimInstance_Component_Land::M_last_ground_velocity' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Land, M_heavy_landing_speed_threshold) == 0x00002C, "Member 'FCAAnimInstance_Component_Land::M_heavy_landing_speed_threshold' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Land, M_is_heavy_landing) == 0x000030, "Member 'FCAAnimInstance_Component_Land::M_is_heavy_landing' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Land, M_is_in_the_air) == 0x000031, "Member 'FCAAnimInstance_Component_Land::M_is_in_the_air' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Land, M_air_time) == 0x000034, "Member 'FCAAnimInstance_Component_Land::M_air_time' has a wrong offset!");

// ScriptStruct keaton.CAHitIndicator3D_DamagePair
// 0x0008 (0x0008 - 0x0000)
struct FCAHitIndicator3D_DamagePair final
{
public:
	float                                         M_min;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHitIndicator3D_DamagePair) == 0x000004, "Wrong alignment on FCAHitIndicator3D_DamagePair");
static_assert(sizeof(FCAHitIndicator3D_DamagePair) == 0x000008, "Wrong size on FCAHitIndicator3D_DamagePair");
static_assert(offsetof(FCAHitIndicator3D_DamagePair, M_min) == 0x000000, "Member 'FCAHitIndicator3D_DamagePair::M_min' has a wrong offset!");
static_assert(offsetof(FCAHitIndicator3D_DamagePair, M_max) == 0x000004, "Member 'FCAHitIndicator3D_DamagePair::M_max' has a wrong offset!");

// ScriptStruct keaton.CAHitIndicator3D_DamageScaleData
// 0x0120 (0x0120 - 0x0000)
struct FCAHitIndicator3D_DamageScaleData final
{
public:
	struct FCAHitIndicator3D_DamagePair           M_damage;                                          // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_lifespan;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     M_initial_scale_curve;                             // 0x0010(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     M_restart_scale_curve;                             // 0x0098(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHitIndicator3D_DamageScaleData) == 0x000008, "Wrong alignment on FCAHitIndicator3D_DamageScaleData");
static_assert(sizeof(FCAHitIndicator3D_DamageScaleData) == 0x000120, "Wrong size on FCAHitIndicator3D_DamageScaleData");
static_assert(offsetof(FCAHitIndicator3D_DamageScaleData, M_damage) == 0x000000, "Member 'FCAHitIndicator3D_DamageScaleData::M_damage' has a wrong offset!");
static_assert(offsetof(FCAHitIndicator3D_DamageScaleData, M_lifespan) == 0x000008, "Member 'FCAHitIndicator3D_DamageScaleData::M_lifespan' has a wrong offset!");
static_assert(offsetof(FCAHitIndicator3D_DamageScaleData, M_initial_scale_curve) == 0x000010, "Member 'FCAHitIndicator3D_DamageScaleData::M_initial_scale_curve' has a wrong offset!");
static_assert(offsetof(FCAHitIndicator3D_DamageScaleData, M_restart_scale_curve) == 0x000098, "Member 'FCAHitIndicator3D_DamageScaleData::M_restart_scale_curve' has a wrong offset!");

// ScriptStruct keaton.CAAnimInstance_Component_HeldPoses
// 0x0020 (0x0030 - 0x0010)
struct FCAAnimInstance_Component_HeldPoses final : public FCAAnimInstance_Component
{
public:
	class UAnimSequenceBase*                      M_standing_held_fire_pose;                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_standing_jog_held_fire_pose;                     // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouching_held_fire_pose;                        // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouching_jog_held_fire_pose;                    // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAnimInstance_Component_HeldPoses) == 0x000008, "Wrong alignment on FCAAnimInstance_Component_HeldPoses");
static_assert(sizeof(FCAAnimInstance_Component_HeldPoses) == 0x000030, "Wrong size on FCAAnimInstance_Component_HeldPoses");
static_assert(offsetof(FCAAnimInstance_Component_HeldPoses, M_standing_held_fire_pose) == 0x000010, "Member 'FCAAnimInstance_Component_HeldPoses::M_standing_held_fire_pose' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_HeldPoses, M_standing_jog_held_fire_pose) == 0x000018, "Member 'FCAAnimInstance_Component_HeldPoses::M_standing_jog_held_fire_pose' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_HeldPoses, M_crouching_held_fire_pose) == 0x000020, "Member 'FCAAnimInstance_Component_HeldPoses::M_crouching_held_fire_pose' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_HeldPoses, M_crouching_jog_held_fire_pose) == 0x000028, "Member 'FCAAnimInstance_Component_HeldPoses::M_crouching_jog_held_fire_pose' has a wrong offset!");

// ScriptStruct keaton.CAAnimInstance_Component_IK_Jiggles
// 0x0020 (0x0030 - 0x0010)
struct FCAAnimInstance_Component_IK_Jiggles final : public FCAAnimInstance_Component
{
public:
	class UAnimSequenceBase*                      M_held_ik_jiggle_pose;                             // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouch_ik_jiggle_pose;                           // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_left_ik_jiggle_weight;                           // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_right_ik_jiggle_weight;                          // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_ik_jiggles;                                  // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAnimInstance_Component_IK_Jiggles) == 0x000008, "Wrong alignment on FCAAnimInstance_Component_IK_Jiggles");
static_assert(sizeof(FCAAnimInstance_Component_IK_Jiggles) == 0x000030, "Wrong size on FCAAnimInstance_Component_IK_Jiggles");
static_assert(offsetof(FCAAnimInstance_Component_IK_Jiggles, M_held_ik_jiggle_pose) == 0x000010, "Member 'FCAAnimInstance_Component_IK_Jiggles::M_held_ik_jiggle_pose' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_IK_Jiggles, M_crouch_ik_jiggle_pose) == 0x000018, "Member 'FCAAnimInstance_Component_IK_Jiggles::M_crouch_ik_jiggle_pose' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_IK_Jiggles, M_left_ik_jiggle_weight) == 0x000020, "Member 'FCAAnimInstance_Component_IK_Jiggles::M_left_ik_jiggle_weight' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_IK_Jiggles, M_right_ik_jiggle_weight) == 0x000024, "Member 'FCAAnimInstance_Component_IK_Jiggles::M_right_ik_jiggle_weight' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_IK_Jiggles, M_use_ik_jiggles) == 0x000028, "Member 'FCAAnimInstance_Component_IK_Jiggles::M_use_ik_jiggles' has a wrong offset!");

// ScriptStruct keaton.CATweenInfo
// 0x0038 (0x0038 - 0x0000)
struct FCATweenInfo final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Current_time;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATweenEaseType                              Tween_type;                                        // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Start_float_value;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Change_float_value;                                // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Start_fvector2_value;                              // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Change_fvector2_value;                             // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                Output_widget;                                     // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATweenInfo) == 0x000008, "Wrong alignment on FCATweenInfo");
static_assert(sizeof(FCATweenInfo) == 0x000038, "Wrong size on FCATweenInfo");
static_assert(offsetof(FCATweenInfo, Delay) == 0x000000, "Member 'FCATweenInfo::Delay' has a wrong offset!");
static_assert(offsetof(FCATweenInfo, Duration) == 0x000004, "Member 'FCATweenInfo::Duration' has a wrong offset!");
static_assert(offsetof(FCATweenInfo, Current_time) == 0x000008, "Member 'FCATweenInfo::Current_time' has a wrong offset!");
static_assert(offsetof(FCATweenInfo, Tween_type) == 0x00000C, "Member 'FCATweenInfo::Tween_type' has a wrong offset!");
static_assert(offsetof(FCATweenInfo, Start_float_value) == 0x000010, "Member 'FCATweenInfo::Start_float_value' has a wrong offset!");
static_assert(offsetof(FCATweenInfo, Change_float_value) == 0x000014, "Member 'FCATweenInfo::Change_float_value' has a wrong offset!");
static_assert(offsetof(FCATweenInfo, Start_fvector2_value) == 0x000020, "Member 'FCATweenInfo::Start_fvector2_value' has a wrong offset!");
static_assert(offsetof(FCATweenInfo, Change_fvector2_value) == 0x000028, "Member 'FCATweenInfo::Change_fvector2_value' has a wrong offset!");
static_assert(offsetof(FCATweenInfo, Output_widget) == 0x000030, "Member 'FCATweenInfo::Output_widget' has a wrong offset!");

// ScriptStruct keaton.CAGMCSlotAttributeSet
// 0x00A8 (0x00A8 - 0x0000)
struct FCAGMCSlotAttributeSet final
{
public:
	struct FGameplayAttribute                     M_max_value_attribute;                             // 0x0000(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     M_current_value_attribute;                         // 0x0038(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     M_level_attribute;                                 // 0x0070(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAGMCSlotAttributeSet) == 0x000008, "Wrong alignment on FCAGMCSlotAttributeSet");
static_assert(sizeof(FCAGMCSlotAttributeSet) == 0x0000A8, "Wrong size on FCAGMCSlotAttributeSet");
static_assert(offsetof(FCAGMCSlotAttributeSet, M_max_value_attribute) == 0x000000, "Member 'FCAGMCSlotAttributeSet::M_max_value_attribute' has a wrong offset!");
static_assert(offsetof(FCAGMCSlotAttributeSet, M_current_value_attribute) == 0x000038, "Member 'FCAGMCSlotAttributeSet::M_current_value_attribute' has a wrong offset!");
static_assert(offsetof(FCAGMCSlotAttributeSet, M_level_attribute) == 0x000070, "Member 'FCAGMCSlotAttributeSet::M_level_attribute' has a wrong offset!");

// ScriptStruct keaton.CAAnimInstance_Component_Override_Layer
// 0x0010 (0x0020 - 0x0010)
struct FCAAnimInstance_Component_Override_Layer final : public FCAAnimInstance_Component
{
public:
	class UAnimSequenceBase*                      M_override_additive_pose;                          // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_override_weight;                                 // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAnimInstance_Component_Override_Layer) == 0x000008, "Wrong alignment on FCAAnimInstance_Component_Override_Layer");
static_assert(sizeof(FCAAnimInstance_Component_Override_Layer) == 0x000020, "Wrong size on FCAAnimInstance_Component_Override_Layer");
static_assert(offsetof(FCAAnimInstance_Component_Override_Layer, M_override_additive_pose) == 0x000010, "Member 'FCAAnimInstance_Component_Override_Layer::M_override_additive_pose' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Override_Layer, M_override_weight) == 0x000018, "Member 'FCAAnimInstance_Component_Override_Layer::M_override_weight' has a wrong offset!");

// ScriptStruct keaton.CAProjectileAOEData
// 0x0020 (0x0020 - 0x0000)
struct FCAProjectileAOEData final
{
public:
	struct FCAGameplayEffectContainer             M_effect_container;                                // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         M_effect_radius;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAProjectileAOEData) == 0x000008, "Wrong alignment on FCAProjectileAOEData");
static_assert(sizeof(FCAProjectileAOEData) == 0x000020, "Wrong size on FCAProjectileAOEData");
static_assert(offsetof(FCAProjectileAOEData, M_effect_container) == 0x000000, "Member 'FCAProjectileAOEData::M_effect_container' has a wrong offset!");
static_assert(offsetof(FCAProjectileAOEData, M_effect_radius) == 0x000018, "Member 'FCAProjectileAOEData::M_effect_radius' has a wrong offset!");

// ScriptStruct keaton.CAAnimInstance_Component_ZeroG
// 0x01A0 (0x01B0 - 0x0010)
struct FCAAnimInstance_Component_ZeroG final : public FCAAnimInstance_Component
{
public:
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EZeroGTakeOffDirection                        M_take_off_direction;                              // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EZeroGTakeOffType                             M_take_off_type;                                   // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_attach_normal;                                   // 0x001C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_attach_location;                                 // 0x0028(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_take_off_time;                                   // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_look_yaw;                                        // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_look_pitch;                                      // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_floatiness_scale;                                // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_just_entered_zero_g;                             // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_in_zero_g;                                    // 0x0045(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_attached;                                     // 0x0046(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_wall_forward_ratio;                              // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_wall_lateral_ratio;                              // 0x004C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_wall_vertical_ratio;                             // 0x0050(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_facing_wall;                                  // 0x0054(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_in_ceiling;                                   // 0x0055(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_predicted_impact_valid;                          // 0x0056(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57[0x1];                                       // 0x0057(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_predicted_impact_point;                          // 0x0058(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_predicted_impact_normal;                         // 0x0064(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_time_to_impact;                                  // 0x0070(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_distance_to_impact;                              // 0x0074(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_wall_normal_local;                               // 0x0078(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_wall_yaw_local;                                  // 0x0084(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_wall_pitch_local;                                // 0x0088(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_surface_long_TP;                                 // 0x008C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_surface_lat_TP;                                  // 0x0098(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_surface_horiz_TP;                                // 0x00A4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_surface_vert_TP;                                 // 0x00B0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_surface_longitudinal_speed_TP;                   // 0x00BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_surface_lateral_speed_TP;                        // 0x00C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_wall_horizontal_speed_TP;                        // 0x00C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_wall_vertical_speed_TP;                          // 0x00C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_boost_normalized_time;                    // 0x00CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_boost_alpha;                              // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_boost_duration;                           // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_surface_normal_FP;                               // 0x00D8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_surface_yaw_FP;                                  // 0x00E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_surface_pitch_FP;                                // 0x00E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_surface_long_FP;                                 // 0x00EC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_surface_lat_FP;                                  // 0x00F8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_surface_horiz_FP;                                // 0x0104(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_surface_vert_FP;                                 // 0x0110(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_velocity;                                        // 0x011C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_surface_longitudinal_speed_FP;                   // 0x0128(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_surface_lateral_speed_FP;                        // 0x012C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_wall_horizontal_speed_FP;                        // 0x0130(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_wall_vertical_speed_FP;                          // 0x0134(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_wall_horiz_vert_ratio_FP;                        // 0x0138(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_surface_distance_FP;                             // 0x013C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ceiling_wall_ratio_FP;                           // 0x0140(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ceiling_offset_FP;                               // 0x0144(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_148[0x68];                                     // 0x0148(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAnimInstance_Component_ZeroG) == 0x000008, "Wrong alignment on FCAAnimInstance_Component_ZeroG");
static_assert(sizeof(FCAAnimInstance_Component_ZeroG) == 0x0001B0, "Wrong size on FCAAnimInstance_Component_ZeroG");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_take_off_direction) == 0x000018, "Member 'FCAAnimInstance_Component_ZeroG::M_take_off_direction' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_take_off_type) == 0x000019, "Member 'FCAAnimInstance_Component_ZeroG::M_take_off_type' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_attach_normal) == 0x00001C, "Member 'FCAAnimInstance_Component_ZeroG::M_attach_normal' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_attach_location) == 0x000028, "Member 'FCAAnimInstance_Component_ZeroG::M_attach_location' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_take_off_time) == 0x000034, "Member 'FCAAnimInstance_Component_ZeroG::M_take_off_time' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_look_yaw) == 0x000038, "Member 'FCAAnimInstance_Component_ZeroG::M_look_yaw' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_look_pitch) == 0x00003C, "Member 'FCAAnimInstance_Component_ZeroG::M_look_pitch' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_floatiness_scale) == 0x000040, "Member 'FCAAnimInstance_Component_ZeroG::M_floatiness_scale' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_just_entered_zero_g) == 0x000044, "Member 'FCAAnimInstance_Component_ZeroG::M_just_entered_zero_g' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_is_in_zero_g) == 0x000045, "Member 'FCAAnimInstance_Component_ZeroG::M_is_in_zero_g' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_is_attached) == 0x000046, "Member 'FCAAnimInstance_Component_ZeroG::M_is_attached' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_wall_forward_ratio) == 0x000048, "Member 'FCAAnimInstance_Component_ZeroG::M_wall_forward_ratio' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_wall_lateral_ratio) == 0x00004C, "Member 'FCAAnimInstance_Component_ZeroG::M_wall_lateral_ratio' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_wall_vertical_ratio) == 0x000050, "Member 'FCAAnimInstance_Component_ZeroG::M_wall_vertical_ratio' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_is_facing_wall) == 0x000054, "Member 'FCAAnimInstance_Component_ZeroG::M_is_facing_wall' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_is_in_ceiling) == 0x000055, "Member 'FCAAnimInstance_Component_ZeroG::M_is_in_ceiling' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_predicted_impact_valid) == 0x000056, "Member 'FCAAnimInstance_Component_ZeroG::M_predicted_impact_valid' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_predicted_impact_point) == 0x000058, "Member 'FCAAnimInstance_Component_ZeroG::M_predicted_impact_point' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_predicted_impact_normal) == 0x000064, "Member 'FCAAnimInstance_Component_ZeroG::M_predicted_impact_normal' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_time_to_impact) == 0x000070, "Member 'FCAAnimInstance_Component_ZeroG::M_time_to_impact' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_distance_to_impact) == 0x000074, "Member 'FCAAnimInstance_Component_ZeroG::M_distance_to_impact' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_wall_normal_local) == 0x000078, "Member 'FCAAnimInstance_Component_ZeroG::M_wall_normal_local' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_wall_yaw_local) == 0x000084, "Member 'FCAAnimInstance_Component_ZeroG::M_wall_yaw_local' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_wall_pitch_local) == 0x000088, "Member 'FCAAnimInstance_Component_ZeroG::M_wall_pitch_local' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_surface_long_TP) == 0x00008C, "Member 'FCAAnimInstance_Component_ZeroG::M_surface_long_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_surface_lat_TP) == 0x000098, "Member 'FCAAnimInstance_Component_ZeroG::M_surface_lat_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_surface_horiz_TP) == 0x0000A4, "Member 'FCAAnimInstance_Component_ZeroG::M_surface_horiz_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_surface_vert_TP) == 0x0000B0, "Member 'FCAAnimInstance_Component_ZeroG::M_surface_vert_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_surface_longitudinal_speed_TP) == 0x0000BC, "Member 'FCAAnimInstance_Component_ZeroG::M_surface_longitudinal_speed_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_surface_lateral_speed_TP) == 0x0000C0, "Member 'FCAAnimInstance_Component_ZeroG::M_surface_lateral_speed_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_wall_horizontal_speed_TP) == 0x0000C4, "Member 'FCAAnimInstance_Component_ZeroG::M_wall_horizontal_speed_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_wall_vertical_speed_TP) == 0x0000C8, "Member 'FCAAnimInstance_Component_ZeroG::M_wall_vertical_speed_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_zero_g_boost_normalized_time) == 0x0000CC, "Member 'FCAAnimInstance_Component_ZeroG::M_zero_g_boost_normalized_time' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_zero_g_boost_alpha) == 0x0000D0, "Member 'FCAAnimInstance_Component_ZeroG::M_zero_g_boost_alpha' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_zero_g_boost_duration) == 0x0000D4, "Member 'FCAAnimInstance_Component_ZeroG::M_zero_g_boost_duration' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_surface_normal_FP) == 0x0000D8, "Member 'FCAAnimInstance_Component_ZeroG::M_surface_normal_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_surface_yaw_FP) == 0x0000E4, "Member 'FCAAnimInstance_Component_ZeroG::M_surface_yaw_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_surface_pitch_FP) == 0x0000E8, "Member 'FCAAnimInstance_Component_ZeroG::M_surface_pitch_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_surface_long_FP) == 0x0000EC, "Member 'FCAAnimInstance_Component_ZeroG::M_surface_long_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_surface_lat_FP) == 0x0000F8, "Member 'FCAAnimInstance_Component_ZeroG::M_surface_lat_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_surface_horiz_FP) == 0x000104, "Member 'FCAAnimInstance_Component_ZeroG::M_surface_horiz_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_surface_vert_FP) == 0x000110, "Member 'FCAAnimInstance_Component_ZeroG::M_surface_vert_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_velocity) == 0x00011C, "Member 'FCAAnimInstance_Component_ZeroG::M_velocity' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_surface_longitudinal_speed_FP) == 0x000128, "Member 'FCAAnimInstance_Component_ZeroG::M_surface_longitudinal_speed_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_surface_lateral_speed_FP) == 0x00012C, "Member 'FCAAnimInstance_Component_ZeroG::M_surface_lateral_speed_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_wall_horizontal_speed_FP) == 0x000130, "Member 'FCAAnimInstance_Component_ZeroG::M_wall_horizontal_speed_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_wall_vertical_speed_FP) == 0x000134, "Member 'FCAAnimInstance_Component_ZeroG::M_wall_vertical_speed_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_wall_horiz_vert_ratio_FP) == 0x000138, "Member 'FCAAnimInstance_Component_ZeroG::M_wall_horiz_vert_ratio_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_surface_distance_FP) == 0x00013C, "Member 'FCAAnimInstance_Component_ZeroG::M_surface_distance_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_ceiling_wall_ratio_FP) == 0x000140, "Member 'FCAAnimInstance_Component_ZeroG::M_ceiling_wall_ratio_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_ZeroG, M_ceiling_offset_FP) == 0x000144, "Member 'FCAAnimInstance_Component_ZeroG::M_ceiling_offset_FP' has a wrong offset!");

// ScriptStruct keaton.CAAIMissionObjectiveType
// 0x0038 (0x0038 - 0x0000)
struct FCAAIMissionObjectiveType final
{
public:
	TSoftClassPtr<class UClass>                   M_mission_objective_type;                          // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_swap_front_and_back;                             // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAMissionObjectiveTypeEnum                   M_mission_objective_type_enum;                     // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_affects_ai_portal_graph;                         // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAIMissionObjectiveType) == 0x000008, "Wrong alignment on FCAAIMissionObjectiveType");
static_assert(sizeof(FCAAIMissionObjectiveType) == 0x000038, "Wrong size on FCAAIMissionObjectiveType");
static_assert(offsetof(FCAAIMissionObjectiveType, M_mission_objective_type) == 0x000000, "Member 'FCAAIMissionObjectiveType::M_mission_objective_type' has a wrong offset!");
static_assert(offsetof(FCAAIMissionObjectiveType, M_swap_front_and_back) == 0x000030, "Member 'FCAAIMissionObjectiveType::M_swap_front_and_back' has a wrong offset!");
static_assert(offsetof(FCAAIMissionObjectiveType, M_mission_objective_type_enum) == 0x000031, "Member 'FCAAIMissionObjectiveType::M_mission_objective_type_enum' has a wrong offset!");
static_assert(offsetof(FCAAIMissionObjectiveType, M_affects_ai_portal_graph) == 0x000032, "Member 'FCAAIMissionObjectiveType::M_affects_ai_portal_graph' has a wrong offset!");

// ScriptStruct keaton.CAAIJoinedPortalType
// 0x0068 (0x0068 - 0x0000)
struct FCAAIJoinedPortalType final
{
public:
	TSoftClassPtr<class UClass>                   M_first;                                           // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_second;                                          // 0x0030(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_priority;                                        // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAIJoinedPortalType) == 0x000008, "Wrong alignment on FCAAIJoinedPortalType");
static_assert(sizeof(FCAAIJoinedPortalType) == 0x000068, "Wrong size on FCAAIJoinedPortalType");
static_assert(offsetof(FCAAIJoinedPortalType, M_first) == 0x000000, "Member 'FCAAIJoinedPortalType::M_first' has a wrong offset!");
static_assert(offsetof(FCAAIJoinedPortalType, M_second) == 0x000030, "Member 'FCAAIJoinedPortalType::M_second' has a wrong offset!");
static_assert(offsetof(FCAAIJoinedPortalType, M_priority) == 0x000060, "Member 'FCAAIJoinedPortalType::M_priority' has a wrong offset!");

// ScriptStruct keaton.CAAIPortalGraphData
// 0x0378 (0x0378 - 0x0000)
struct FCAAIPortalGraphData final
{
public:
	TArray<struct FCAAIMissionObjectiveType>      M_mission_objective_types;                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCAAIPortalType>                M_portal_types;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCAAIJoinedPortalType>          M_joined_portal_types;                             // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           M_vault_types;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        M_vault_interface_types;                           // 0x0040(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           M_extraction_types;                                // 0x0050(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           M_loot_types;                                      // 0x0060(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           M_loot_source_types;                               // 0x0070(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           M_intel_terminal_types;                            // 0x0080(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           M_alarm_terminal_types;                            // 0x0090(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_navigation_filter_no_doors_all_nav_links;        // 0x00A0(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_navigation_filter_no_doors_or_nav_links;         // 0x00D0(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_navigation_filter_all_doors_no_nav_links;        // 0x0100(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_navigation_filter_all_doors_and_nav_links;       // 0x0130(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_navigation_filter_valid_teleport_locations;      // 0x0160(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_navigation_filter_allow_obstacles;               // 0x0190(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_navigation_filter_no_obstacles;                  // 0x01C0(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_navigation_modifier_volume;                      // 0x01F0(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_navigation_modifier_sphere_volume;               // 0x0220(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   M_nav_area_door;                                   // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   M_nav_area_vault_door;                             // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   M_nav_area_blocked_door;                           // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   M_nav_area_mission_objective;                      // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   M_nav_area_inner;                                  // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   M_nav_area_outer;                                  // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   M_nav_area_non_camp;                               // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   M_nav_area_island;                                 // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   M_nav_area_permutation_blocked;                    // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_distance_from_portal_to_front_and_back_locations; // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_backup_distance_from_portal_to_front_and_back_locations; // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_portal_nav_mesh_test_depth;                      // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_node_height_above_nav_mesh;                      // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_distance_between_mission_objectives_and_portal_nodes; // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_distance_between_mission_objectives_and_joined_or_audio_portal_nodes; // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_distance_between_portal_nodes;               // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_forward_distance_between_portal_nodes;       // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_side_distance_between_portal_nodes;          // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_distance_between_portal_node_and_blocked_door; // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_adjoining_portal_rotation_threshold;             // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_portal_depth;                                    // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_portal_height;                               // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_portal_width;                                // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_portal_width;                                // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_inside_area_portal_ratio_threshold;              // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_leeway_for_is_in_portal_tests_width;             // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_leeway_for_is_in_portal_tests_height;            // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_portal_nav_modifier_volume_scalar_value;         // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_permutation_blocker_nav_modifier_volume_scalar_value; // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_nav_modifier_volume_depth_value;                 // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_nav_modifier_volume_height_increase;             // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_nav_modifier_sphere_volume_scalar_value;         // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_nav_modifier_sphere_volume_height_decrease;      // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_default_nav_modifier_sphere_volume_width;        // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_portal_location_test_count;                      // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_max_room_check;                                  // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_filter_any_nav_areas_outside_of_security_area_volumes; // 0x0304(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_305[0x3];                                      // 0x0305(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_portal_direction_clearance_distance_threshold;   // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_path_to_portal_distance_threshold;               // 0x030C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_distance_from_entrance_to_end_of_security_area;  // 0x0310(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_distance_from_main_path_graph_node_to_path_position; // 0x0314(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_distance_from_entrance_graph_node_to_exit_position; // 0x0318(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_distance_to_visible_mission_objective_location_threshold; // 0x031C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_number_of_patrol_routes_per_security_area;       // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_number_of_positions_per_path;                    // 0x0324(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_distance_from_main_route_graph_node_to_initial_patrol_position; // 0x0328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_distance_from_main_route_graph_node_to_initial_patrol_position; // 0x032C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_distance_from_alternate_route_graph_node_to_initial_patrol_position; // 0x0330(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_distance_from_alternate_route_graph_node_to_initial_patrol_position; // 0x0334(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_distance_from_default_graph_node_to_initial_patrol_position; // 0x0338(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_distance_from_default_graph_node_to_initial_patrol_position; // 0x033C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_distance_between_main_route_patrol_positions; // 0x0340(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_distance_between_main_route_patrol_positions; // 0x0344(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_distance_between_alternate_route_patrol_positions; // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_distance_between_alternate_route_patrol_positions; // 0x034C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_distance_between_default_patrol_positions;   // 0x0350(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_distance_between_default_patrol_positions;   // 0x0354(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_main_route_patrol_path_direction_randomness;     // 0x0358(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_alternate_route_patrol_path_direction_randomness; // 0x035C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_default_patrol_path_direction_randomness;        // 0x0360(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_path_to_direct_distance_variance_threshold;      // 0x0364(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_patrol_position_distance_to_cover_threshold;     // 0x0368(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_patrol_position_distance_to_portals_threshold;   // 0x036C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_patrol_position_distance_to_mission_objective_threshold; // 0x0370(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_patrol_position_distance_to_other_path_positions_threshold; // 0x0374(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAIPortalGraphData) == 0x000008, "Wrong alignment on FCAAIPortalGraphData");
static_assert(sizeof(FCAAIPortalGraphData) == 0x000378, "Wrong size on FCAAIPortalGraphData");
static_assert(offsetof(FCAAIPortalGraphData, M_mission_objective_types) == 0x000000, "Member 'FCAAIPortalGraphData::M_mission_objective_types' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_portal_types) == 0x000010, "Member 'FCAAIPortalGraphData::M_portal_types' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_joined_portal_types) == 0x000020, "Member 'FCAAIPortalGraphData::M_joined_portal_types' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_vault_types) == 0x000030, "Member 'FCAAIPortalGraphData::M_vault_types' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_vault_interface_types) == 0x000040, "Member 'FCAAIPortalGraphData::M_vault_interface_types' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_extraction_types) == 0x000050, "Member 'FCAAIPortalGraphData::M_extraction_types' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_loot_types) == 0x000060, "Member 'FCAAIPortalGraphData::M_loot_types' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_loot_source_types) == 0x000070, "Member 'FCAAIPortalGraphData::M_loot_source_types' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_intel_terminal_types) == 0x000080, "Member 'FCAAIPortalGraphData::M_intel_terminal_types' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_alarm_terminal_types) == 0x000090, "Member 'FCAAIPortalGraphData::M_alarm_terminal_types' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_navigation_filter_no_doors_all_nav_links) == 0x0000A0, "Member 'FCAAIPortalGraphData::M_navigation_filter_no_doors_all_nav_links' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_navigation_filter_no_doors_or_nav_links) == 0x0000D0, "Member 'FCAAIPortalGraphData::M_navigation_filter_no_doors_or_nav_links' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_navigation_filter_all_doors_no_nav_links) == 0x000100, "Member 'FCAAIPortalGraphData::M_navigation_filter_all_doors_no_nav_links' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_navigation_filter_all_doors_and_nav_links) == 0x000130, "Member 'FCAAIPortalGraphData::M_navigation_filter_all_doors_and_nav_links' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_navigation_filter_valid_teleport_locations) == 0x000160, "Member 'FCAAIPortalGraphData::M_navigation_filter_valid_teleport_locations' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_navigation_filter_allow_obstacles) == 0x000190, "Member 'FCAAIPortalGraphData::M_navigation_filter_allow_obstacles' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_navigation_filter_no_obstacles) == 0x0001C0, "Member 'FCAAIPortalGraphData::M_navigation_filter_no_obstacles' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_navigation_modifier_volume) == 0x0001F0, "Member 'FCAAIPortalGraphData::M_navigation_modifier_volume' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_navigation_modifier_sphere_volume) == 0x000220, "Member 'FCAAIPortalGraphData::M_navigation_modifier_sphere_volume' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_nav_area_door) == 0x000250, "Member 'FCAAIPortalGraphData::M_nav_area_door' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_nav_area_vault_door) == 0x000258, "Member 'FCAAIPortalGraphData::M_nav_area_vault_door' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_nav_area_blocked_door) == 0x000260, "Member 'FCAAIPortalGraphData::M_nav_area_blocked_door' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_nav_area_mission_objective) == 0x000268, "Member 'FCAAIPortalGraphData::M_nav_area_mission_objective' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_nav_area_inner) == 0x000270, "Member 'FCAAIPortalGraphData::M_nav_area_inner' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_nav_area_outer) == 0x000278, "Member 'FCAAIPortalGraphData::M_nav_area_outer' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_nav_area_non_camp) == 0x000280, "Member 'FCAAIPortalGraphData::M_nav_area_non_camp' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_nav_area_island) == 0x000288, "Member 'FCAAIPortalGraphData::M_nav_area_island' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_nav_area_permutation_blocked) == 0x000290, "Member 'FCAAIPortalGraphData::M_nav_area_permutation_blocked' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_distance_from_portal_to_front_and_back_locations) == 0x000298, "Member 'FCAAIPortalGraphData::M_distance_from_portal_to_front_and_back_locations' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_backup_distance_from_portal_to_front_and_back_locations) == 0x00029C, "Member 'FCAAIPortalGraphData::M_backup_distance_from_portal_to_front_and_back_locations' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_portal_nav_mesh_test_depth) == 0x0002A0, "Member 'FCAAIPortalGraphData::M_portal_nav_mesh_test_depth' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_node_height_above_nav_mesh) == 0x0002A4, "Member 'FCAAIPortalGraphData::M_node_height_above_nav_mesh' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_min_distance_between_mission_objectives_and_portal_nodes) == 0x0002A8, "Member 'FCAAIPortalGraphData::M_min_distance_between_mission_objectives_and_portal_nodes' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_min_distance_between_mission_objectives_and_joined_or_audio_portal_nodes) == 0x0002AC, "Member 'FCAAIPortalGraphData::M_min_distance_between_mission_objectives_and_joined_or_audio_portal_nodes' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_min_distance_between_portal_nodes) == 0x0002B0, "Member 'FCAAIPortalGraphData::M_min_distance_between_portal_nodes' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_min_forward_distance_between_portal_nodes) == 0x0002B4, "Member 'FCAAIPortalGraphData::M_min_forward_distance_between_portal_nodes' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_min_side_distance_between_portal_nodes) == 0x0002B8, "Member 'FCAAIPortalGraphData::M_min_side_distance_between_portal_nodes' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_min_distance_between_portal_node_and_blocked_door) == 0x0002BC, "Member 'FCAAIPortalGraphData::M_min_distance_between_portal_node_and_blocked_door' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_adjoining_portal_rotation_threshold) == 0x0002C0, "Member 'FCAAIPortalGraphData::M_adjoining_portal_rotation_threshold' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_portal_depth) == 0x0002C4, "Member 'FCAAIPortalGraphData::M_portal_depth' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_min_portal_height) == 0x0002C8, "Member 'FCAAIPortalGraphData::M_min_portal_height' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_min_portal_width) == 0x0002CC, "Member 'FCAAIPortalGraphData::M_min_portal_width' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_max_portal_width) == 0x0002D0, "Member 'FCAAIPortalGraphData::M_max_portal_width' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_inside_area_portal_ratio_threshold) == 0x0002D4, "Member 'FCAAIPortalGraphData::M_inside_area_portal_ratio_threshold' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_leeway_for_is_in_portal_tests_width) == 0x0002D8, "Member 'FCAAIPortalGraphData::M_leeway_for_is_in_portal_tests_width' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_leeway_for_is_in_portal_tests_height) == 0x0002DC, "Member 'FCAAIPortalGraphData::M_leeway_for_is_in_portal_tests_height' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_portal_nav_modifier_volume_scalar_value) == 0x0002E0, "Member 'FCAAIPortalGraphData::M_portal_nav_modifier_volume_scalar_value' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_permutation_blocker_nav_modifier_volume_scalar_value) == 0x0002E4, "Member 'FCAAIPortalGraphData::M_permutation_blocker_nav_modifier_volume_scalar_value' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_nav_modifier_volume_depth_value) == 0x0002E8, "Member 'FCAAIPortalGraphData::M_nav_modifier_volume_depth_value' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_nav_modifier_volume_height_increase) == 0x0002EC, "Member 'FCAAIPortalGraphData::M_nav_modifier_volume_height_increase' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_nav_modifier_sphere_volume_scalar_value) == 0x0002F0, "Member 'FCAAIPortalGraphData::M_nav_modifier_sphere_volume_scalar_value' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_nav_modifier_sphere_volume_height_decrease) == 0x0002F4, "Member 'FCAAIPortalGraphData::M_nav_modifier_sphere_volume_height_decrease' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_default_nav_modifier_sphere_volume_width) == 0x0002F8, "Member 'FCAAIPortalGraphData::M_default_nav_modifier_sphere_volume_width' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_portal_location_test_count) == 0x0002FC, "Member 'FCAAIPortalGraphData::M_portal_location_test_count' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_max_room_check) == 0x000300, "Member 'FCAAIPortalGraphData::M_max_room_check' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_filter_any_nav_areas_outside_of_security_area_volumes) == 0x000304, "Member 'FCAAIPortalGraphData::M_filter_any_nav_areas_outside_of_security_area_volumes' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_portal_direction_clearance_distance_threshold) == 0x000308, "Member 'FCAAIPortalGraphData::M_portal_direction_clearance_distance_threshold' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_path_to_portal_distance_threshold) == 0x00030C, "Member 'FCAAIPortalGraphData::M_path_to_portal_distance_threshold' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_distance_from_entrance_to_end_of_security_area) == 0x000310, "Member 'FCAAIPortalGraphData::M_distance_from_entrance_to_end_of_security_area' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_distance_from_main_path_graph_node_to_path_position) == 0x000314, "Member 'FCAAIPortalGraphData::M_distance_from_main_path_graph_node_to_path_position' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_distance_from_entrance_graph_node_to_exit_position) == 0x000318, "Member 'FCAAIPortalGraphData::M_distance_from_entrance_graph_node_to_exit_position' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_distance_to_visible_mission_objective_location_threshold) == 0x00031C, "Member 'FCAAIPortalGraphData::M_distance_to_visible_mission_objective_location_threshold' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_number_of_patrol_routes_per_security_area) == 0x000320, "Member 'FCAAIPortalGraphData::M_number_of_patrol_routes_per_security_area' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_number_of_positions_per_path) == 0x000324, "Member 'FCAAIPortalGraphData::M_number_of_positions_per_path' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_min_distance_from_main_route_graph_node_to_initial_patrol_position) == 0x000328, "Member 'FCAAIPortalGraphData::M_min_distance_from_main_route_graph_node_to_initial_patrol_position' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_max_distance_from_main_route_graph_node_to_initial_patrol_position) == 0x00032C, "Member 'FCAAIPortalGraphData::M_max_distance_from_main_route_graph_node_to_initial_patrol_position' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_min_distance_from_alternate_route_graph_node_to_initial_patrol_position) == 0x000330, "Member 'FCAAIPortalGraphData::M_min_distance_from_alternate_route_graph_node_to_initial_patrol_position' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_max_distance_from_alternate_route_graph_node_to_initial_patrol_position) == 0x000334, "Member 'FCAAIPortalGraphData::M_max_distance_from_alternate_route_graph_node_to_initial_patrol_position' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_min_distance_from_default_graph_node_to_initial_patrol_position) == 0x000338, "Member 'FCAAIPortalGraphData::M_min_distance_from_default_graph_node_to_initial_patrol_position' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_max_distance_from_default_graph_node_to_initial_patrol_position) == 0x00033C, "Member 'FCAAIPortalGraphData::M_max_distance_from_default_graph_node_to_initial_patrol_position' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_min_distance_between_main_route_patrol_positions) == 0x000340, "Member 'FCAAIPortalGraphData::M_min_distance_between_main_route_patrol_positions' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_max_distance_between_main_route_patrol_positions) == 0x000344, "Member 'FCAAIPortalGraphData::M_max_distance_between_main_route_patrol_positions' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_min_distance_between_alternate_route_patrol_positions) == 0x000348, "Member 'FCAAIPortalGraphData::M_min_distance_between_alternate_route_patrol_positions' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_max_distance_between_alternate_route_patrol_positions) == 0x00034C, "Member 'FCAAIPortalGraphData::M_max_distance_between_alternate_route_patrol_positions' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_min_distance_between_default_patrol_positions) == 0x000350, "Member 'FCAAIPortalGraphData::M_min_distance_between_default_patrol_positions' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_max_distance_between_default_patrol_positions) == 0x000354, "Member 'FCAAIPortalGraphData::M_max_distance_between_default_patrol_positions' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_main_route_patrol_path_direction_randomness) == 0x000358, "Member 'FCAAIPortalGraphData::M_main_route_patrol_path_direction_randomness' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_alternate_route_patrol_path_direction_randomness) == 0x00035C, "Member 'FCAAIPortalGraphData::M_alternate_route_patrol_path_direction_randomness' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_default_patrol_path_direction_randomness) == 0x000360, "Member 'FCAAIPortalGraphData::M_default_patrol_path_direction_randomness' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_path_to_direct_distance_variance_threshold) == 0x000364, "Member 'FCAAIPortalGraphData::M_path_to_direct_distance_variance_threshold' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_patrol_position_distance_to_cover_threshold) == 0x000368, "Member 'FCAAIPortalGraphData::M_patrol_position_distance_to_cover_threshold' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_patrol_position_distance_to_portals_threshold) == 0x00036C, "Member 'FCAAIPortalGraphData::M_patrol_position_distance_to_portals_threshold' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_patrol_position_distance_to_mission_objective_threshold) == 0x000370, "Member 'FCAAIPortalGraphData::M_patrol_position_distance_to_mission_objective_threshold' has a wrong offset!");
static_assert(offsetof(FCAAIPortalGraphData, M_patrol_position_distance_to_other_path_positions_threshold) == 0x000374, "Member 'FCAAIPortalGraphData::M_patrol_position_distance_to_other_path_positions_threshold' has a wrong offset!");

// ScriptStruct keaton.CATargetScoreRuleCategory
// 0x0010 (0x0010 - 0x0000)
struct FCATargetScoreRuleCategory final
{
public:
	TArray<class UCATargetScoreRule*>             M_target_score_rules;                              // 0x0000(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATargetScoreRuleCategory) == 0x000008, "Wrong alignment on FCATargetScoreRuleCategory");
static_assert(sizeof(FCATargetScoreRuleCategory) == 0x000010, "Wrong size on FCATargetScoreRuleCategory");
static_assert(offsetof(FCATargetScoreRuleCategory, M_target_score_rules) == 0x000000, "Member 'FCATargetScoreRuleCategory::M_target_score_rules' has a wrong offset!");

// ScriptStruct keaton.CAAnimParameter
// 0x0038 (0x0040 - 0x0008)
struct FCAAnimParameter final : public FTableRowBase
{
public:
	struct FFeatureKeyItem                        M_feature;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   M_name;                                            // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_value;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionClass                              M_locomotion_class;                                // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_specialist_name;                                 // 0x0020(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_device_name;                                     // 0x002C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_priority;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAnimParameter) == 0x000008, "Wrong alignment on FCAAnimParameter");
static_assert(sizeof(FCAAnimParameter) == 0x000040, "Wrong size on FCAAnimParameter");
static_assert(offsetof(FCAAnimParameter, M_feature) == 0x000008, "Member 'FCAAnimParameter::M_feature' has a wrong offset!");
static_assert(offsetof(FCAAnimParameter, M_name) == 0x00000C, "Member 'FCAAnimParameter::M_name' has a wrong offset!");
static_assert(offsetof(FCAAnimParameter, M_value) == 0x000018, "Member 'FCAAnimParameter::M_value' has a wrong offset!");
static_assert(offsetof(FCAAnimParameter, M_locomotion_class) == 0x00001C, "Member 'FCAAnimParameter::M_locomotion_class' has a wrong offset!");
static_assert(offsetof(FCAAnimParameter, M_specialist_name) == 0x000020, "Member 'FCAAnimParameter::M_specialist_name' has a wrong offset!");
static_assert(offsetof(FCAAnimParameter, M_device_name) == 0x00002C, "Member 'FCAAnimParameter::M_device_name' has a wrong offset!");
static_assert(offsetof(FCAAnimParameter, M_priority) == 0x000038, "Member 'FCAAnimParameter::M_priority' has a wrong offset!");

// ScriptStruct keaton.CAAnimInstance_Component_Equipment
// 0x0AE8 (0x0AF8 - 0x0010)
struct FCAAnimInstance_Component_Equipment final : public FCAAnimInstance_Component
{
public:
	uint8                                         Pad_10[0x18];                                      // 0x0010(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             M_default_param_list;                              // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_exclude_FP;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_exclude_TP;                                      // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_specialist_name;                                 // 0x0034(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_specialist_name_alt;                             // 0x0040(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_weapon_name;                                     // 0x004C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_mesh_name;                                       // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACACharacter_MainPlayer*                M_main_player;                                     // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACAWeapon*                              M_held_weapon;                                     // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionClass                              M_locomotion_class;                                // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_ads_as_locomotion_base;                      // 0x0079(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_fire_one_handed_ZG;                              // 0x007A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_sprint_left_hand_on_weapon;                      // 0x007B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_weapon_ADS_FOV_scale;                            // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sprint_modifier;                                 // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_weapon_offset_fix_ads;                           // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_weapon_camera_offset_ADS;                        // 0x0088(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_base_pose_additive_weight;                       // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ads_pose_additive_weight;                        // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      M_standing_held_TP;                                // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_standing_ADS_TP;                                 // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouching_held_TP;                               // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouching_ADS_TP;                                // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_flying_held_TP;                                  // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_flying_ADS_TP;                                   // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_standing_held_fire_TP;                           // 0x00D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouching_held_fire_TP;                          // 0x00D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_sliding_held_fire_TP;                            // 0x00E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_flying_held_fire_TP;                             // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_wall_held_fire_TP;                               // 0x00F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGWall_held_fire_TP;                             // 0x00F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_standing_held_upper_TP;                          // 0x0100(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_standing_ADS_upper_TP;                           // 0x0108(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_standing_injured_held_upper_TP;                  // 0x0110(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_standing_injured_held_lower_TP;                  // 0x0118(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouching_held_upper_TP;                         // 0x0120(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouching_ADS_upper_TP;                          // 0x0128(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_standing_held_fire_upper_TP;                     // 0x0130(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouching_held_fire_upper_TP;                    // 0x0138(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_standing_held_lower_TP;                          // 0x0140(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_standing_ADS_lower_TP;                           // 0x0148(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouching_held_lower_TP;                         // 0x0150(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouching_ADS_lower_TP;                          // 0x0158(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_standing_held_fire_lower_TP;                     // 0x0160(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouching_held_fire_lower_TP;                    // 0x0168(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_held_jump_long_TP;                               // 0x0170(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_fall_loop_TP;                                    // 0x0178(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_fall_loop_ADS_TP;                                // 0x0180(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Crouch_Fall_TP;                                  // 0x0188(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_land_held_TP;                                    // 0x0190(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_land_ADS_TP;                                     // 0x0198(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_heavy_land_held_TP;                              // 0x01A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouch_land_held_TP;                             // 0x01A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouch_land_ADS_TP;                              // 0x01B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGMB_land_held_TP;                               // 0x01B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGMB_land_ADS_TP;                                // 0x01C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGMB_Fall_TP;                                    // 0x01C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGFly_To_ZGMBFall_TP;                            // 0x01D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGFly_Held_Add_TP;                               // 0x01D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGFly_ADS_Add_TP;                                // 0x01E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGCeiling_Held_Add_TP;                           // 0x01E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGCeiling_ADS_Add_TP;                            // 0x01F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGWall_Held_Add_TP;                              // 0x01F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGWall_ADS_Add_TP;                               // 0x0200(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_StartSprint_Normal_G_TP;                         // 0x0208(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_sprint_TP;                                       // 0x0210(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_StartSprint_ZGMB_TP;                             // 0x0218(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGMB_sprint_TP;                                  // 0x0220(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_sprint_effort_TP;                                // 0x0228(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGMB_sprint_effort_TP;                           // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_slide_intro_TP;                                  // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_slide_loop_TP;                                   // 0x0240(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_slide_out_TP;                                    // 0x0248(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_held_to_ADS_TP;                                  // 0x0250(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ADS_to_held_TP;                                  // 0x0258(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGHeld_to_ADS_TP;                                // 0x0260(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ADS_to_ZGHeld_TP;                                // 0x0268(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_stand_to_crouch_TP;                              // 0x0270(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouch_to_stand_TP;                              // 0x0278(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_vault_TP;                                        // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Vault_ADS_TP;                                    // 0x0288(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_mantle_low_TP;                                   // 0x0290(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_mantle_mid_TP;                                   // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_mantle_high_TP;                                  // 0x02A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_mantle_low_crouch_TP;                            // 0x02A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_mantle_mid_crouch_TP;                            // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_mantle_high_crouch_TP;                           // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_traverse_top_low_TP;                             // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_traverse_top_mid_TP;                             // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_traverse_top_high_TP;                            // 0x02D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_traverse_top_mid_crouch_TP;                      // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_vault_top_mid_TP;                                // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_idle_add_TP;                                     // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_idle_crouch_add_TP;                              // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_injured_idle_add_TP;                             // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_turn_in_place_TP;                                // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_turn_in_place_crouch_TP;                         // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_standing_held_FP;                                // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_standing_ADS_FP;                                 // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouching_held_FP;                               // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouching_ADS_FP;                                // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Turn_Dummy_FP;                                   // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_flying_held_FP;                                  // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_flying_ADS_FP;                                   // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_standing_held_fire_FP;                           // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouching_held_fire_FP;                          // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_sliding_held_fire_FP;                            // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_flying_held_fire_FP;                             // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_flying_fast_held_fire_FP;                        // 0x0368(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_wall_held_fire_FP;                               // 0x0370(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGWall_held_fire_FP;                             // 0x0378(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_jog_FP;                                          // 0x0380(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_sprint_FP;                                       // 0x0388(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_jog_pose_FP;                                     // 0x0390(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_sprint_pose_FP;                                  // 0x0398(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ADS_walk_FP;                                     // 0x03A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ADS_ZGMB_Walk_FP;                                // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_slide_in_FP;                                     // 0x03B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_slide_in_ADS_FP;                                 // 0x03B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_slide_in_pose_FP;                                // 0x03C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_slide_loop_FP;                                   // 0x03C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_slide_held_add_FP;                               // 0x03D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_slide_ADS_add_FP;                                // 0x03D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_slide_out_FP;                                    // 0x03E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_slide_out_ADS_FP;                                // 0x03E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_slide_out_crouch_FP;                             // 0x03F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_slide_out_crouch_ADS_FP;                         // 0x03F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_held_jump_FP;                                    // 0x0400(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ADS_jump_FP;                                     // 0x0408(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_held_jump_long_FP;                               // 0x0410(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_fall_pose_FP;                                    // 0x0418(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_fall_pose_ADS_FP;                                // 0x0420(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_fall_loop_FP;                                    // 0x0428(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_fall_loop_ADS_FP;                                // 0x0430(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_land_held_FP;                                    // 0x0438(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_land_ADS_FP;                                     // 0x0440(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_heavy_land_held_FP;                              // 0x0448(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_heavy_land_ADS_FP;                               // 0x0450(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouch_land_held_FP;                             // 0x0458(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouch_land_ADS_FP;                              // 0x0460(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGMB_jog_FP;                                     // 0x0468(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGMB_sprint_FP;                                  // 0x0470(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGMB_fall_loop_FP;                               // 0x0478(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGMB_takeoff_fwd_FP;                             // 0x0480(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGMB_takeoff_back_FP;                            // 0x0488(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGMB_takeoff_left_FP;                            // 0x0490(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGMB_takeoff_right_FP;                           // 0x0498(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGMB_takeoff_ADS_FP;                             // 0x04A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZG_held_FP;                                      // 0x04A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZG_ADS_FP;                                       // 0x04B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGHeld_to_ADS_FP;                                // 0x04B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ADS_to_ZGHeld_FP;                                // 0x04C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_held_to_ADS_FP;                                  // 0x04C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ADS_to_held_FP;                                  // 0x04D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_stand_to_crouch_FP;                              // 0x04D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouch_to_stand_FP;                              // 0x04E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_vault_FP;                                        // 0x04E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Vault_CrouchDummy_FP;                            // 0x04F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_mantle_low_FP;                                   // 0x04F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_mantle_mid_FP;                                   // 0x0500(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_mantle_high_FP;                                  // 0x0508(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_mantle_low_crouch_FP;                            // 0x0510(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_mantle_mid_crouch_FP;                            // 0x0518(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_mantle_high_crouch_FP;                           // 0x0520(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_MantleHigh_CrouchDummy_FP;                       // 0x0528(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_MantleMid_CrouchDummy_FP;                        // 0x0530(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_MantleLow_CrouchDummy_FP;                        // 0x0538(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_MantleHigh_CrouchDummy_ADS_FP;                   // 0x0540(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_MantleMid_CrouchDummy_ADS_FP;                    // 0x0548(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_MantleLow_CrouchDummy_ADS_FP;                    // 0x0550(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_traverse_top_mid_FP;                             // 0x0558(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_traverse_top_mid_crouch_FP;                      // 0x0560(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_traverse_top_low_FP;                             // 0x0568(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_traverse_top_low_crouch_FP;                      // 0x0570(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ADS_vault_FP;                                    // 0x0578(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGFly_Held_Add_FP;                               // 0x0580(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGFly_Held_Fast_Add_FP;                          // 0x0588(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGFly_ADS_Add_FP;                                // 0x0590(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGFly_to_ZGMBFall_Held_FP;                       // 0x0598(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGFly_to_ZGMBFall_ADS_FP;                        // 0x05A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGWall_Move_ADS_FP;                              // 0x05A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGWall_Held_Add_FP;                              // 0x05B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGWall_ADS_Add_FP;                               // 0x05B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGCeiling_Pose_FP;                               // 0x05C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGBoostBigFwd_Held_FP;                           // 0x05C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGBoostBigLeft_Held_FP;                          // 0x05D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGBoostBigRight_Held_FP;                         // 0x05D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGBoostBigBack_Held_FP;                          // 0x05E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGBoostFwd_Held_FP;                              // 0x05E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGBoostLeft_Held_FP;                             // 0x05F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGBoostRight_Held_FP;                            // 0x05F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGBoostBack_Held_FP;                             // 0x0600(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGBoostSmallFwd_Held_FP;                         // 0x0608(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGBoostSmallLeft_Held_FP;                        // 0x0610(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGBoostSmallRight_Held_FP;                       // 0x0618(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGBoostSmallBack_Held_FP;                        // 0x0620(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGBoostFwd_ADS_FP;                               // 0x0628(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGBoostLeft_ADS_FP;                              // 0x0630(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGBoostRight_ADS_FP;                             // 0x0638(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGBoostBack_ADS_FP;                              // 0x0640(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGMB_to_ZeroG_FP;                                // 0x0648(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGMB_to_NormalG_FP;                              // 0x0650(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGMB_to_ZeroG_ADS_FP;                            // 0x0658(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ZGMB_to_NormalG_ADS_FP;                          // 0x0660(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_start_NormalG_FP;                                // 0x0668(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_stop_NormalG_FP;                                 // 0x0670(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Stop_ADS_normalG_FP;                             // 0x0678(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Start_ADS_normalG_FP;                            // 0x0680(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_stand_to_crouch_ADS_FP;                          // 0x0688(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_crouch_to_stand_ADS_FP;                          // 0x0690(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_SprintStop_normalG_FP;                           // 0x0698(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_SprintStart_normalG_FP;                          // 0x06A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_RunPoseMod_FP;                                   // 0x06A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_SprintPoseMod_FP;                                // 0x06B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_WalkPoseMod_FP;                                  // 0x06B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_jog_mod_curve_FP;                                // 0x06C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_sprint_mod_curve_FP;                             // 0x06C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_StandToSprint_FP;                                // 0x06D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_SprintToStand_FP;                                // 0x06D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_RunToSprint_FP;                                  // 0x06E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_SprintToRun_FP;                                  // 0x06E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Idle_Held_Add_FP;                                // 0x06F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Idle_ADS_Add_FP;                                 // 0x06F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Face_Default;                                    // 0x0700(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Face_ADS;                                        // 0x0708(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Face_Injured;                                    // 0x0710(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Face_Dead;                                       // 0x0718(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Face_Pain;                                       // 0x0720(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Face_Smile;                                      // 0x0728(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Face_Angry;                                      // 0x0730(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Face_Disgust;                                    // 0x0738(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Face_Sad;                                        // 0x0740(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Face_Shocked;                                    // 0x0748(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Face_Smirk;                                      // 0x0750(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Face_Surprised;                                  // 0x0758(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Face_Default_Idle_Add;                           // 0x0760(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Face_Injured_Idle_Add;                           // 0x0768(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Face_Blink;                                      // 0x0770(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Face_Test_1;                                     // 0x0778(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_Face_Test_2;                                     // 0x0780(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseAsset*                             M_Face_Poses;                                      // 0x0788(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_test_anim_1;                                     // 0x0790(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_test_anim_2;                                     // 0x0798(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_test_anim_3;                                     // 0x07A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_test_anim_4;                                     // 0x07A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimationAsset*>                M_idles_TP;                                        // 0x07B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimationAsset*>                M_idles_crouch_TP;                                 // 0x07C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimationAsset*>                M_idles_FP;                                        // 0x07D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 M_idles_weights_TP;                                // 0x07E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 M_idles_crouch_weights_TP;                         // 0x07F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 M_idles_weights_FP;                                // 0x0800(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_AO_Loco_Look_TP;                                 // 0x0810(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_AO_Held_TP;                                      // 0x0818(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_AO_ADS_TP;                                       // 0x0820(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_AO_Crouch_Held_TP;                               // 0x0828(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_AO_Crouch_ADS_TP;                                // 0x0830(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_loco_normalG_TP;                                 // 0x0838(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_loco_magBoots_TP;                                // 0x0840(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_loco_magBoots_slow_TP;                           // 0x0848(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_loco_crouch_TP;                                  // 0x0850(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_held_jump_TP;                                    // 0x0858(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_Slide_Loop_Aim_Poses_TP;                      // 0x0860(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_AB_ZGWall_move_vertical_TP;                      // 0x0868(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_AB_ZGWall_move_horizontal_TP;                    // 0x0870(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_AB_ZGMB_to_ZGFly_TP;                             // 0x0878(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_AB_crouch_to_ZGFly_TP;                           // 0x0880(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_start_normalG_stand_TP;                          // 0x0888(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_start_normalG_crouch_TP;                         // 0x0890(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_start_ZGMB_stand_TP;                             // 0x0898(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_stop_normalG_stand_TP;                           // 0x08A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_stop_normalG_crouch_TP;                          // 0x08A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_stop_ZGMB_stand_TP;                              // 0x08B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_InAir_Vertical_TP;                            // 0x08B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_InAir_Directional_TP;                         // 0x08C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_MantleMidVertical_Held_TP;                    // 0x08C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_MantleMidVertical_ADS_TP;                     // 0x08D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_TraverseTop_Stand_TP;                         // 0x08D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_TraverseTop_Crouch_TP;                        // 0x08E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_Start_Walk_ZGMB_Stand_TP;                     // 0x08E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_Start_Jog_ZGMB_Stand_TP;                      // 0x08F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGBoost_TP;                                   // 0x08F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGBoost_ADS_TP;                               // 0x0900(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGFly_to_ZGMB_TP;                             // 0x0908(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGFly_MoveUp90_TP;                            // 0x0910(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGFly_MoveUp45_TP;                            // 0x0918(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGFly_MoveHoriz_TP;                           // 0x0920(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGFly_MoveDown45_TP;                          // 0x0928(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGFly_MoveDown90_TP;                          // 0x0930(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGCeiling_Pose_Held_TP;                       // 0x0938(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGCeiling_Pose_ADS_TP;                        // 0x0940(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGWall_Pose_Held_TP;                          // 0x0948(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGWall_Pose_ADS_TP;                           // 0x0950(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGCeiling_Move_TP;                            // 0x0958(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGWall_Move_Vertical_TP;                      // 0x0960(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGWall_Move_Horizontal_TP;                    // 0x0968(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGWall_to_ZGFly_TP;                           // 0x0970(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGCeiling_to_ZGFly_TP;                        // 0x0978(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGFly_to_ZGCeiling_Land_TP;                   // 0x0980(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGFly_to_ZGWall_Land_TP;                      // 0x0988(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGFly_to_ZGMB_PreLand_TP;                     // 0x0990(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGFly_to_ZGCeiling_PreLand_TP;                // 0x0998(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGFly_to_ZGWall_PreLand_TP;                   // 0x09A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_ZGFly_Look_FP;                                   // 0x09A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_ZGFly_Look_Fast_FP;                              // 0x09B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_ZGWall_Held_Idle_FP;                             // 0x09B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_ZGWall_Land_FP;                                  // 0x09C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_ZGMB_Takeoff_FP;                                 // 0x09C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_ZGMB_Takeoff_Add_FP;                             // 0x09D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_inAir_held_FP;                                   // 0x09D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_inAir_ADS_FP;                                    // 0x09E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_loco_normalG_FP;                                 // 0x09E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_start_normalG_FP;                             // 0x09F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_stop_normalG_FP;                              // 0x09F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGWall_preland_FP;                            // 0x0A00(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGWall_land_FP;                               // 0x0A08(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_AB_ZGWall_move_vertical_FP;                      // 0x0A10(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_AB_ZGWall_move_horizontal_FP;                    // 0x0A18(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGWall_MoveVertical_FP;                       // 0x0A20(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGWall_MoveHorizontal_FP;                     // 0x0A28(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGCeiling_Move_FP;                            // 0x0A30(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGCeilingWall_Move_FP;                        // 0x0A38(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_AB_MantleUp_Low_FP;                              // 0x0A40(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_AB_MantleUp_Mid_FP;                              // 0x0A48(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_AB_MantleUp_High_FP;                             // 0x0A50(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_AB_Vault_FP;                                     // 0x0A58(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGBoost_FP;                                   // 0x0A60(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        M_BS_ZGBoost_ADS_FP;                               // 0x0A68(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_grav_hook_held;                                  // 0x0A70(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_grav_hook_ADS;                                   // 0x0A78(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FCAAnimParameter>    M_parameters_map;                                  // 0x0A80(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD0[0x28];                                     // 0x0AD0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAnimInstance_Component_Equipment) == 0x000008, "Wrong alignment on FCAAnimInstance_Component_Equipment");
static_assert(sizeof(FCAAnimInstance_Component_Equipment) == 0x000AF8, "Wrong size on FCAAnimInstance_Component_Equipment");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_default_param_list) == 0x000028, "Member 'FCAAnimInstance_Component_Equipment::M_default_param_list' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_exclude_FP) == 0x000030, "Member 'FCAAnimInstance_Component_Equipment::M_exclude_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_exclude_TP) == 0x000031, "Member 'FCAAnimInstance_Component_Equipment::M_exclude_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_specialist_name) == 0x000034, "Member 'FCAAnimInstance_Component_Equipment::M_specialist_name' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_specialist_name_alt) == 0x000040, "Member 'FCAAnimInstance_Component_Equipment::M_specialist_name_alt' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_weapon_name) == 0x00004C, "Member 'FCAAnimInstance_Component_Equipment::M_weapon_name' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_mesh_name) == 0x000058, "Member 'FCAAnimInstance_Component_Equipment::M_mesh_name' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_main_player) == 0x000068, "Member 'FCAAnimInstance_Component_Equipment::M_main_player' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_held_weapon) == 0x000070, "Member 'FCAAnimInstance_Component_Equipment::M_held_weapon' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_locomotion_class) == 0x000078, "Member 'FCAAnimInstance_Component_Equipment::M_locomotion_class' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_use_ads_as_locomotion_base) == 0x000079, "Member 'FCAAnimInstance_Component_Equipment::M_use_ads_as_locomotion_base' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_fire_one_handed_ZG) == 0x00007A, "Member 'FCAAnimInstance_Component_Equipment::M_fire_one_handed_ZG' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_sprint_left_hand_on_weapon) == 0x00007B, "Member 'FCAAnimInstance_Component_Equipment::M_sprint_left_hand_on_weapon' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_weapon_ADS_FOV_scale) == 0x00007C, "Member 'FCAAnimInstance_Component_Equipment::M_weapon_ADS_FOV_scale' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_sprint_modifier) == 0x000080, "Member 'FCAAnimInstance_Component_Equipment::M_sprint_modifier' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_weapon_offset_fix_ads) == 0x000084, "Member 'FCAAnimInstance_Component_Equipment::M_weapon_offset_fix_ads' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_weapon_camera_offset_ADS) == 0x000088, "Member 'FCAAnimInstance_Component_Equipment::M_weapon_camera_offset_ADS' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_base_pose_additive_weight) == 0x000094, "Member 'FCAAnimInstance_Component_Equipment::M_base_pose_additive_weight' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ads_pose_additive_weight) == 0x000098, "Member 'FCAAnimInstance_Component_Equipment::M_ads_pose_additive_weight' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_standing_held_TP) == 0x0000A0, "Member 'FCAAnimInstance_Component_Equipment::M_standing_held_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_standing_ADS_TP) == 0x0000A8, "Member 'FCAAnimInstance_Component_Equipment::M_standing_ADS_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouching_held_TP) == 0x0000B0, "Member 'FCAAnimInstance_Component_Equipment::M_crouching_held_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouching_ADS_TP) == 0x0000B8, "Member 'FCAAnimInstance_Component_Equipment::M_crouching_ADS_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_flying_held_TP) == 0x0000C0, "Member 'FCAAnimInstance_Component_Equipment::M_flying_held_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_flying_ADS_TP) == 0x0000C8, "Member 'FCAAnimInstance_Component_Equipment::M_flying_ADS_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_standing_held_fire_TP) == 0x0000D0, "Member 'FCAAnimInstance_Component_Equipment::M_standing_held_fire_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouching_held_fire_TP) == 0x0000D8, "Member 'FCAAnimInstance_Component_Equipment::M_crouching_held_fire_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_sliding_held_fire_TP) == 0x0000E0, "Member 'FCAAnimInstance_Component_Equipment::M_sliding_held_fire_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_flying_held_fire_TP) == 0x0000E8, "Member 'FCAAnimInstance_Component_Equipment::M_flying_held_fire_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_wall_held_fire_TP) == 0x0000F0, "Member 'FCAAnimInstance_Component_Equipment::M_wall_held_fire_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGWall_held_fire_TP) == 0x0000F8, "Member 'FCAAnimInstance_Component_Equipment::M_ZGWall_held_fire_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_standing_held_upper_TP) == 0x000100, "Member 'FCAAnimInstance_Component_Equipment::M_standing_held_upper_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_standing_ADS_upper_TP) == 0x000108, "Member 'FCAAnimInstance_Component_Equipment::M_standing_ADS_upper_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_standing_injured_held_upper_TP) == 0x000110, "Member 'FCAAnimInstance_Component_Equipment::M_standing_injured_held_upper_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_standing_injured_held_lower_TP) == 0x000118, "Member 'FCAAnimInstance_Component_Equipment::M_standing_injured_held_lower_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouching_held_upper_TP) == 0x000120, "Member 'FCAAnimInstance_Component_Equipment::M_crouching_held_upper_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouching_ADS_upper_TP) == 0x000128, "Member 'FCAAnimInstance_Component_Equipment::M_crouching_ADS_upper_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_standing_held_fire_upper_TP) == 0x000130, "Member 'FCAAnimInstance_Component_Equipment::M_standing_held_fire_upper_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouching_held_fire_upper_TP) == 0x000138, "Member 'FCAAnimInstance_Component_Equipment::M_crouching_held_fire_upper_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_standing_held_lower_TP) == 0x000140, "Member 'FCAAnimInstance_Component_Equipment::M_standing_held_lower_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_standing_ADS_lower_TP) == 0x000148, "Member 'FCAAnimInstance_Component_Equipment::M_standing_ADS_lower_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouching_held_lower_TP) == 0x000150, "Member 'FCAAnimInstance_Component_Equipment::M_crouching_held_lower_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouching_ADS_lower_TP) == 0x000158, "Member 'FCAAnimInstance_Component_Equipment::M_crouching_ADS_lower_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_standing_held_fire_lower_TP) == 0x000160, "Member 'FCAAnimInstance_Component_Equipment::M_standing_held_fire_lower_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouching_held_fire_lower_TP) == 0x000168, "Member 'FCAAnimInstance_Component_Equipment::M_crouching_held_fire_lower_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_held_jump_long_TP) == 0x000170, "Member 'FCAAnimInstance_Component_Equipment::M_held_jump_long_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_fall_loop_TP) == 0x000178, "Member 'FCAAnimInstance_Component_Equipment::M_fall_loop_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_fall_loop_ADS_TP) == 0x000180, "Member 'FCAAnimInstance_Component_Equipment::M_fall_loop_ADS_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Crouch_Fall_TP) == 0x000188, "Member 'FCAAnimInstance_Component_Equipment::M_Crouch_Fall_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_land_held_TP) == 0x000190, "Member 'FCAAnimInstance_Component_Equipment::M_land_held_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_land_ADS_TP) == 0x000198, "Member 'FCAAnimInstance_Component_Equipment::M_land_ADS_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_heavy_land_held_TP) == 0x0001A0, "Member 'FCAAnimInstance_Component_Equipment::M_heavy_land_held_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouch_land_held_TP) == 0x0001A8, "Member 'FCAAnimInstance_Component_Equipment::M_crouch_land_held_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouch_land_ADS_TP) == 0x0001B0, "Member 'FCAAnimInstance_Component_Equipment::M_crouch_land_ADS_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_land_held_TP) == 0x0001B8, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_land_held_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_land_ADS_TP) == 0x0001C0, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_land_ADS_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_Fall_TP) == 0x0001C8, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_Fall_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGFly_To_ZGMBFall_TP) == 0x0001D0, "Member 'FCAAnimInstance_Component_Equipment::M_ZGFly_To_ZGMBFall_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGFly_Held_Add_TP) == 0x0001D8, "Member 'FCAAnimInstance_Component_Equipment::M_ZGFly_Held_Add_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGFly_ADS_Add_TP) == 0x0001E0, "Member 'FCAAnimInstance_Component_Equipment::M_ZGFly_ADS_Add_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGCeiling_Held_Add_TP) == 0x0001E8, "Member 'FCAAnimInstance_Component_Equipment::M_ZGCeiling_Held_Add_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGCeiling_ADS_Add_TP) == 0x0001F0, "Member 'FCAAnimInstance_Component_Equipment::M_ZGCeiling_ADS_Add_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGWall_Held_Add_TP) == 0x0001F8, "Member 'FCAAnimInstance_Component_Equipment::M_ZGWall_Held_Add_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGWall_ADS_Add_TP) == 0x000200, "Member 'FCAAnimInstance_Component_Equipment::M_ZGWall_ADS_Add_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_StartSprint_Normal_G_TP) == 0x000208, "Member 'FCAAnimInstance_Component_Equipment::M_StartSprint_Normal_G_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_sprint_TP) == 0x000210, "Member 'FCAAnimInstance_Component_Equipment::M_sprint_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_StartSprint_ZGMB_TP) == 0x000218, "Member 'FCAAnimInstance_Component_Equipment::M_StartSprint_ZGMB_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_sprint_TP) == 0x000220, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_sprint_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_sprint_effort_TP) == 0x000228, "Member 'FCAAnimInstance_Component_Equipment::M_sprint_effort_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_sprint_effort_TP) == 0x000230, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_sprint_effort_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_slide_intro_TP) == 0x000238, "Member 'FCAAnimInstance_Component_Equipment::M_slide_intro_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_slide_loop_TP) == 0x000240, "Member 'FCAAnimInstance_Component_Equipment::M_slide_loop_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_slide_out_TP) == 0x000248, "Member 'FCAAnimInstance_Component_Equipment::M_slide_out_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_held_to_ADS_TP) == 0x000250, "Member 'FCAAnimInstance_Component_Equipment::M_held_to_ADS_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ADS_to_held_TP) == 0x000258, "Member 'FCAAnimInstance_Component_Equipment::M_ADS_to_held_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGHeld_to_ADS_TP) == 0x000260, "Member 'FCAAnimInstance_Component_Equipment::M_ZGHeld_to_ADS_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ADS_to_ZGHeld_TP) == 0x000268, "Member 'FCAAnimInstance_Component_Equipment::M_ADS_to_ZGHeld_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_stand_to_crouch_TP) == 0x000270, "Member 'FCAAnimInstance_Component_Equipment::M_stand_to_crouch_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouch_to_stand_TP) == 0x000278, "Member 'FCAAnimInstance_Component_Equipment::M_crouch_to_stand_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_vault_TP) == 0x000280, "Member 'FCAAnimInstance_Component_Equipment::M_vault_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Vault_ADS_TP) == 0x000288, "Member 'FCAAnimInstance_Component_Equipment::M_Vault_ADS_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_mantle_low_TP) == 0x000290, "Member 'FCAAnimInstance_Component_Equipment::M_mantle_low_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_mantle_mid_TP) == 0x000298, "Member 'FCAAnimInstance_Component_Equipment::M_mantle_mid_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_mantle_high_TP) == 0x0002A0, "Member 'FCAAnimInstance_Component_Equipment::M_mantle_high_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_mantle_low_crouch_TP) == 0x0002A8, "Member 'FCAAnimInstance_Component_Equipment::M_mantle_low_crouch_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_mantle_mid_crouch_TP) == 0x0002B0, "Member 'FCAAnimInstance_Component_Equipment::M_mantle_mid_crouch_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_mantle_high_crouch_TP) == 0x0002B8, "Member 'FCAAnimInstance_Component_Equipment::M_mantle_high_crouch_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_traverse_top_low_TP) == 0x0002C0, "Member 'FCAAnimInstance_Component_Equipment::M_traverse_top_low_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_traverse_top_mid_TP) == 0x0002C8, "Member 'FCAAnimInstance_Component_Equipment::M_traverse_top_mid_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_traverse_top_high_TP) == 0x0002D0, "Member 'FCAAnimInstance_Component_Equipment::M_traverse_top_high_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_traverse_top_mid_crouch_TP) == 0x0002D8, "Member 'FCAAnimInstance_Component_Equipment::M_traverse_top_mid_crouch_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_vault_top_mid_TP) == 0x0002E0, "Member 'FCAAnimInstance_Component_Equipment::M_vault_top_mid_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_idle_add_TP) == 0x0002E8, "Member 'FCAAnimInstance_Component_Equipment::M_idle_add_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_idle_crouch_add_TP) == 0x0002F0, "Member 'FCAAnimInstance_Component_Equipment::M_idle_crouch_add_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_injured_idle_add_TP) == 0x0002F8, "Member 'FCAAnimInstance_Component_Equipment::M_injured_idle_add_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_turn_in_place_TP) == 0x000300, "Member 'FCAAnimInstance_Component_Equipment::M_turn_in_place_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_turn_in_place_crouch_TP) == 0x000308, "Member 'FCAAnimInstance_Component_Equipment::M_turn_in_place_crouch_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_standing_held_FP) == 0x000310, "Member 'FCAAnimInstance_Component_Equipment::M_standing_held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_standing_ADS_FP) == 0x000318, "Member 'FCAAnimInstance_Component_Equipment::M_standing_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouching_held_FP) == 0x000320, "Member 'FCAAnimInstance_Component_Equipment::M_crouching_held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouching_ADS_FP) == 0x000328, "Member 'FCAAnimInstance_Component_Equipment::M_crouching_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Turn_Dummy_FP) == 0x000330, "Member 'FCAAnimInstance_Component_Equipment::M_Turn_Dummy_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_flying_held_FP) == 0x000338, "Member 'FCAAnimInstance_Component_Equipment::M_flying_held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_flying_ADS_FP) == 0x000340, "Member 'FCAAnimInstance_Component_Equipment::M_flying_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_standing_held_fire_FP) == 0x000348, "Member 'FCAAnimInstance_Component_Equipment::M_standing_held_fire_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouching_held_fire_FP) == 0x000350, "Member 'FCAAnimInstance_Component_Equipment::M_crouching_held_fire_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_sliding_held_fire_FP) == 0x000358, "Member 'FCAAnimInstance_Component_Equipment::M_sliding_held_fire_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_flying_held_fire_FP) == 0x000360, "Member 'FCAAnimInstance_Component_Equipment::M_flying_held_fire_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_flying_fast_held_fire_FP) == 0x000368, "Member 'FCAAnimInstance_Component_Equipment::M_flying_fast_held_fire_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_wall_held_fire_FP) == 0x000370, "Member 'FCAAnimInstance_Component_Equipment::M_wall_held_fire_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGWall_held_fire_FP) == 0x000378, "Member 'FCAAnimInstance_Component_Equipment::M_ZGWall_held_fire_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_jog_FP) == 0x000380, "Member 'FCAAnimInstance_Component_Equipment::M_jog_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_sprint_FP) == 0x000388, "Member 'FCAAnimInstance_Component_Equipment::M_sprint_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_jog_pose_FP) == 0x000390, "Member 'FCAAnimInstance_Component_Equipment::M_jog_pose_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_sprint_pose_FP) == 0x000398, "Member 'FCAAnimInstance_Component_Equipment::M_sprint_pose_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ADS_walk_FP) == 0x0003A0, "Member 'FCAAnimInstance_Component_Equipment::M_ADS_walk_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ADS_ZGMB_Walk_FP) == 0x0003A8, "Member 'FCAAnimInstance_Component_Equipment::M_ADS_ZGMB_Walk_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_slide_in_FP) == 0x0003B0, "Member 'FCAAnimInstance_Component_Equipment::M_slide_in_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_slide_in_ADS_FP) == 0x0003B8, "Member 'FCAAnimInstance_Component_Equipment::M_slide_in_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_slide_in_pose_FP) == 0x0003C0, "Member 'FCAAnimInstance_Component_Equipment::M_slide_in_pose_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_slide_loop_FP) == 0x0003C8, "Member 'FCAAnimInstance_Component_Equipment::M_slide_loop_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_slide_held_add_FP) == 0x0003D0, "Member 'FCAAnimInstance_Component_Equipment::M_slide_held_add_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_slide_ADS_add_FP) == 0x0003D8, "Member 'FCAAnimInstance_Component_Equipment::M_slide_ADS_add_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_slide_out_FP) == 0x0003E0, "Member 'FCAAnimInstance_Component_Equipment::M_slide_out_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_slide_out_ADS_FP) == 0x0003E8, "Member 'FCAAnimInstance_Component_Equipment::M_slide_out_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_slide_out_crouch_FP) == 0x0003F0, "Member 'FCAAnimInstance_Component_Equipment::M_slide_out_crouch_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_slide_out_crouch_ADS_FP) == 0x0003F8, "Member 'FCAAnimInstance_Component_Equipment::M_slide_out_crouch_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_held_jump_FP) == 0x000400, "Member 'FCAAnimInstance_Component_Equipment::M_held_jump_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ADS_jump_FP) == 0x000408, "Member 'FCAAnimInstance_Component_Equipment::M_ADS_jump_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_held_jump_long_FP) == 0x000410, "Member 'FCAAnimInstance_Component_Equipment::M_held_jump_long_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_fall_pose_FP) == 0x000418, "Member 'FCAAnimInstance_Component_Equipment::M_fall_pose_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_fall_pose_ADS_FP) == 0x000420, "Member 'FCAAnimInstance_Component_Equipment::M_fall_pose_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_fall_loop_FP) == 0x000428, "Member 'FCAAnimInstance_Component_Equipment::M_fall_loop_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_fall_loop_ADS_FP) == 0x000430, "Member 'FCAAnimInstance_Component_Equipment::M_fall_loop_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_land_held_FP) == 0x000438, "Member 'FCAAnimInstance_Component_Equipment::M_land_held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_land_ADS_FP) == 0x000440, "Member 'FCAAnimInstance_Component_Equipment::M_land_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_heavy_land_held_FP) == 0x000448, "Member 'FCAAnimInstance_Component_Equipment::M_heavy_land_held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_heavy_land_ADS_FP) == 0x000450, "Member 'FCAAnimInstance_Component_Equipment::M_heavy_land_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouch_land_held_FP) == 0x000458, "Member 'FCAAnimInstance_Component_Equipment::M_crouch_land_held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouch_land_ADS_FP) == 0x000460, "Member 'FCAAnimInstance_Component_Equipment::M_crouch_land_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_jog_FP) == 0x000468, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_jog_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_sprint_FP) == 0x000470, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_sprint_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_fall_loop_FP) == 0x000478, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_fall_loop_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_takeoff_fwd_FP) == 0x000480, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_takeoff_fwd_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_takeoff_back_FP) == 0x000488, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_takeoff_back_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_takeoff_left_FP) == 0x000490, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_takeoff_left_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_takeoff_right_FP) == 0x000498, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_takeoff_right_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_takeoff_ADS_FP) == 0x0004A0, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_takeoff_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZG_held_FP) == 0x0004A8, "Member 'FCAAnimInstance_Component_Equipment::M_ZG_held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZG_ADS_FP) == 0x0004B0, "Member 'FCAAnimInstance_Component_Equipment::M_ZG_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGHeld_to_ADS_FP) == 0x0004B8, "Member 'FCAAnimInstance_Component_Equipment::M_ZGHeld_to_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ADS_to_ZGHeld_FP) == 0x0004C0, "Member 'FCAAnimInstance_Component_Equipment::M_ADS_to_ZGHeld_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_held_to_ADS_FP) == 0x0004C8, "Member 'FCAAnimInstance_Component_Equipment::M_held_to_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ADS_to_held_FP) == 0x0004D0, "Member 'FCAAnimInstance_Component_Equipment::M_ADS_to_held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_stand_to_crouch_FP) == 0x0004D8, "Member 'FCAAnimInstance_Component_Equipment::M_stand_to_crouch_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouch_to_stand_FP) == 0x0004E0, "Member 'FCAAnimInstance_Component_Equipment::M_crouch_to_stand_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_vault_FP) == 0x0004E8, "Member 'FCAAnimInstance_Component_Equipment::M_vault_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Vault_CrouchDummy_FP) == 0x0004F0, "Member 'FCAAnimInstance_Component_Equipment::M_Vault_CrouchDummy_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_mantle_low_FP) == 0x0004F8, "Member 'FCAAnimInstance_Component_Equipment::M_mantle_low_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_mantle_mid_FP) == 0x000500, "Member 'FCAAnimInstance_Component_Equipment::M_mantle_mid_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_mantle_high_FP) == 0x000508, "Member 'FCAAnimInstance_Component_Equipment::M_mantle_high_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_mantle_low_crouch_FP) == 0x000510, "Member 'FCAAnimInstance_Component_Equipment::M_mantle_low_crouch_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_mantle_mid_crouch_FP) == 0x000518, "Member 'FCAAnimInstance_Component_Equipment::M_mantle_mid_crouch_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_mantle_high_crouch_FP) == 0x000520, "Member 'FCAAnimInstance_Component_Equipment::M_mantle_high_crouch_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_MantleHigh_CrouchDummy_FP) == 0x000528, "Member 'FCAAnimInstance_Component_Equipment::M_MantleHigh_CrouchDummy_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_MantleMid_CrouchDummy_FP) == 0x000530, "Member 'FCAAnimInstance_Component_Equipment::M_MantleMid_CrouchDummy_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_MantleLow_CrouchDummy_FP) == 0x000538, "Member 'FCAAnimInstance_Component_Equipment::M_MantleLow_CrouchDummy_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_MantleHigh_CrouchDummy_ADS_FP) == 0x000540, "Member 'FCAAnimInstance_Component_Equipment::M_MantleHigh_CrouchDummy_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_MantleMid_CrouchDummy_ADS_FP) == 0x000548, "Member 'FCAAnimInstance_Component_Equipment::M_MantleMid_CrouchDummy_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_MantleLow_CrouchDummy_ADS_FP) == 0x000550, "Member 'FCAAnimInstance_Component_Equipment::M_MantleLow_CrouchDummy_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_traverse_top_mid_FP) == 0x000558, "Member 'FCAAnimInstance_Component_Equipment::M_traverse_top_mid_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_traverse_top_mid_crouch_FP) == 0x000560, "Member 'FCAAnimInstance_Component_Equipment::M_traverse_top_mid_crouch_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_traverse_top_low_FP) == 0x000568, "Member 'FCAAnimInstance_Component_Equipment::M_traverse_top_low_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_traverse_top_low_crouch_FP) == 0x000570, "Member 'FCAAnimInstance_Component_Equipment::M_traverse_top_low_crouch_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ADS_vault_FP) == 0x000578, "Member 'FCAAnimInstance_Component_Equipment::M_ADS_vault_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGFly_Held_Add_FP) == 0x000580, "Member 'FCAAnimInstance_Component_Equipment::M_ZGFly_Held_Add_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGFly_Held_Fast_Add_FP) == 0x000588, "Member 'FCAAnimInstance_Component_Equipment::M_ZGFly_Held_Fast_Add_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGFly_ADS_Add_FP) == 0x000590, "Member 'FCAAnimInstance_Component_Equipment::M_ZGFly_ADS_Add_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGFly_to_ZGMBFall_Held_FP) == 0x000598, "Member 'FCAAnimInstance_Component_Equipment::M_ZGFly_to_ZGMBFall_Held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGFly_to_ZGMBFall_ADS_FP) == 0x0005A0, "Member 'FCAAnimInstance_Component_Equipment::M_ZGFly_to_ZGMBFall_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGWall_Move_ADS_FP) == 0x0005A8, "Member 'FCAAnimInstance_Component_Equipment::M_ZGWall_Move_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGWall_Held_Add_FP) == 0x0005B0, "Member 'FCAAnimInstance_Component_Equipment::M_ZGWall_Held_Add_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGWall_ADS_Add_FP) == 0x0005B8, "Member 'FCAAnimInstance_Component_Equipment::M_ZGWall_ADS_Add_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGCeiling_Pose_FP) == 0x0005C0, "Member 'FCAAnimInstance_Component_Equipment::M_ZGCeiling_Pose_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGBoostBigFwd_Held_FP) == 0x0005C8, "Member 'FCAAnimInstance_Component_Equipment::M_ZGBoostBigFwd_Held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGBoostBigLeft_Held_FP) == 0x0005D0, "Member 'FCAAnimInstance_Component_Equipment::M_ZGBoostBigLeft_Held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGBoostBigRight_Held_FP) == 0x0005D8, "Member 'FCAAnimInstance_Component_Equipment::M_ZGBoostBigRight_Held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGBoostBigBack_Held_FP) == 0x0005E0, "Member 'FCAAnimInstance_Component_Equipment::M_ZGBoostBigBack_Held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGBoostFwd_Held_FP) == 0x0005E8, "Member 'FCAAnimInstance_Component_Equipment::M_ZGBoostFwd_Held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGBoostLeft_Held_FP) == 0x0005F0, "Member 'FCAAnimInstance_Component_Equipment::M_ZGBoostLeft_Held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGBoostRight_Held_FP) == 0x0005F8, "Member 'FCAAnimInstance_Component_Equipment::M_ZGBoostRight_Held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGBoostBack_Held_FP) == 0x000600, "Member 'FCAAnimInstance_Component_Equipment::M_ZGBoostBack_Held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGBoostSmallFwd_Held_FP) == 0x000608, "Member 'FCAAnimInstance_Component_Equipment::M_ZGBoostSmallFwd_Held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGBoostSmallLeft_Held_FP) == 0x000610, "Member 'FCAAnimInstance_Component_Equipment::M_ZGBoostSmallLeft_Held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGBoostSmallRight_Held_FP) == 0x000618, "Member 'FCAAnimInstance_Component_Equipment::M_ZGBoostSmallRight_Held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGBoostSmallBack_Held_FP) == 0x000620, "Member 'FCAAnimInstance_Component_Equipment::M_ZGBoostSmallBack_Held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGBoostFwd_ADS_FP) == 0x000628, "Member 'FCAAnimInstance_Component_Equipment::M_ZGBoostFwd_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGBoostLeft_ADS_FP) == 0x000630, "Member 'FCAAnimInstance_Component_Equipment::M_ZGBoostLeft_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGBoostRight_ADS_FP) == 0x000638, "Member 'FCAAnimInstance_Component_Equipment::M_ZGBoostRight_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGBoostBack_ADS_FP) == 0x000640, "Member 'FCAAnimInstance_Component_Equipment::M_ZGBoostBack_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_to_ZeroG_FP) == 0x000648, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_to_ZeroG_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_to_NormalG_FP) == 0x000650, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_to_NormalG_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_to_ZeroG_ADS_FP) == 0x000658, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_to_ZeroG_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_to_NormalG_ADS_FP) == 0x000660, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_to_NormalG_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_start_NormalG_FP) == 0x000668, "Member 'FCAAnimInstance_Component_Equipment::M_start_NormalG_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_stop_NormalG_FP) == 0x000670, "Member 'FCAAnimInstance_Component_Equipment::M_stop_NormalG_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Stop_ADS_normalG_FP) == 0x000678, "Member 'FCAAnimInstance_Component_Equipment::M_Stop_ADS_normalG_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Start_ADS_normalG_FP) == 0x000680, "Member 'FCAAnimInstance_Component_Equipment::M_Start_ADS_normalG_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_stand_to_crouch_ADS_FP) == 0x000688, "Member 'FCAAnimInstance_Component_Equipment::M_stand_to_crouch_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_crouch_to_stand_ADS_FP) == 0x000690, "Member 'FCAAnimInstance_Component_Equipment::M_crouch_to_stand_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_SprintStop_normalG_FP) == 0x000698, "Member 'FCAAnimInstance_Component_Equipment::M_SprintStop_normalG_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_SprintStart_normalG_FP) == 0x0006A0, "Member 'FCAAnimInstance_Component_Equipment::M_SprintStart_normalG_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_RunPoseMod_FP) == 0x0006A8, "Member 'FCAAnimInstance_Component_Equipment::M_RunPoseMod_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_SprintPoseMod_FP) == 0x0006B0, "Member 'FCAAnimInstance_Component_Equipment::M_SprintPoseMod_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_WalkPoseMod_FP) == 0x0006B8, "Member 'FCAAnimInstance_Component_Equipment::M_WalkPoseMod_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_jog_mod_curve_FP) == 0x0006C0, "Member 'FCAAnimInstance_Component_Equipment::M_jog_mod_curve_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_sprint_mod_curve_FP) == 0x0006C8, "Member 'FCAAnimInstance_Component_Equipment::M_sprint_mod_curve_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_StandToSprint_FP) == 0x0006D0, "Member 'FCAAnimInstance_Component_Equipment::M_StandToSprint_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_SprintToStand_FP) == 0x0006D8, "Member 'FCAAnimInstance_Component_Equipment::M_SprintToStand_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_RunToSprint_FP) == 0x0006E0, "Member 'FCAAnimInstance_Component_Equipment::M_RunToSprint_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_SprintToRun_FP) == 0x0006E8, "Member 'FCAAnimInstance_Component_Equipment::M_SprintToRun_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Idle_Held_Add_FP) == 0x0006F0, "Member 'FCAAnimInstance_Component_Equipment::M_Idle_Held_Add_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Idle_ADS_Add_FP) == 0x0006F8, "Member 'FCAAnimInstance_Component_Equipment::M_Idle_ADS_Add_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Face_Default) == 0x000700, "Member 'FCAAnimInstance_Component_Equipment::M_Face_Default' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Face_ADS) == 0x000708, "Member 'FCAAnimInstance_Component_Equipment::M_Face_ADS' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Face_Injured) == 0x000710, "Member 'FCAAnimInstance_Component_Equipment::M_Face_Injured' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Face_Dead) == 0x000718, "Member 'FCAAnimInstance_Component_Equipment::M_Face_Dead' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Face_Pain) == 0x000720, "Member 'FCAAnimInstance_Component_Equipment::M_Face_Pain' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Face_Smile) == 0x000728, "Member 'FCAAnimInstance_Component_Equipment::M_Face_Smile' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Face_Angry) == 0x000730, "Member 'FCAAnimInstance_Component_Equipment::M_Face_Angry' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Face_Disgust) == 0x000738, "Member 'FCAAnimInstance_Component_Equipment::M_Face_Disgust' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Face_Sad) == 0x000740, "Member 'FCAAnimInstance_Component_Equipment::M_Face_Sad' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Face_Shocked) == 0x000748, "Member 'FCAAnimInstance_Component_Equipment::M_Face_Shocked' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Face_Smirk) == 0x000750, "Member 'FCAAnimInstance_Component_Equipment::M_Face_Smirk' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Face_Surprised) == 0x000758, "Member 'FCAAnimInstance_Component_Equipment::M_Face_Surprised' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Face_Default_Idle_Add) == 0x000760, "Member 'FCAAnimInstance_Component_Equipment::M_Face_Default_Idle_Add' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Face_Injured_Idle_Add) == 0x000768, "Member 'FCAAnimInstance_Component_Equipment::M_Face_Injured_Idle_Add' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Face_Blink) == 0x000770, "Member 'FCAAnimInstance_Component_Equipment::M_Face_Blink' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Face_Test_1) == 0x000778, "Member 'FCAAnimInstance_Component_Equipment::M_Face_Test_1' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Face_Test_2) == 0x000780, "Member 'FCAAnimInstance_Component_Equipment::M_Face_Test_2' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_Face_Poses) == 0x000788, "Member 'FCAAnimInstance_Component_Equipment::M_Face_Poses' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_test_anim_1) == 0x000790, "Member 'FCAAnimInstance_Component_Equipment::M_test_anim_1' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_test_anim_2) == 0x000798, "Member 'FCAAnimInstance_Component_Equipment::M_test_anim_2' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_test_anim_3) == 0x0007A0, "Member 'FCAAnimInstance_Component_Equipment::M_test_anim_3' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_test_anim_4) == 0x0007A8, "Member 'FCAAnimInstance_Component_Equipment::M_test_anim_4' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_idles_TP) == 0x0007B0, "Member 'FCAAnimInstance_Component_Equipment::M_idles_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_idles_crouch_TP) == 0x0007C0, "Member 'FCAAnimInstance_Component_Equipment::M_idles_crouch_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_idles_FP) == 0x0007D0, "Member 'FCAAnimInstance_Component_Equipment::M_idles_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_idles_weights_TP) == 0x0007E0, "Member 'FCAAnimInstance_Component_Equipment::M_idles_weights_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_idles_crouch_weights_TP) == 0x0007F0, "Member 'FCAAnimInstance_Component_Equipment::M_idles_crouch_weights_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_idles_weights_FP) == 0x000800, "Member 'FCAAnimInstance_Component_Equipment::M_idles_weights_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_AO_Loco_Look_TP) == 0x000810, "Member 'FCAAnimInstance_Component_Equipment::M_AO_Loco_Look_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_AO_Held_TP) == 0x000818, "Member 'FCAAnimInstance_Component_Equipment::M_AO_Held_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_AO_ADS_TP) == 0x000820, "Member 'FCAAnimInstance_Component_Equipment::M_AO_ADS_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_AO_Crouch_Held_TP) == 0x000828, "Member 'FCAAnimInstance_Component_Equipment::M_AO_Crouch_Held_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_AO_Crouch_ADS_TP) == 0x000830, "Member 'FCAAnimInstance_Component_Equipment::M_AO_Crouch_ADS_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_loco_normalG_TP) == 0x000838, "Member 'FCAAnimInstance_Component_Equipment::M_loco_normalG_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_loco_magBoots_TP) == 0x000840, "Member 'FCAAnimInstance_Component_Equipment::M_loco_magBoots_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_loco_magBoots_slow_TP) == 0x000848, "Member 'FCAAnimInstance_Component_Equipment::M_loco_magBoots_slow_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_loco_crouch_TP) == 0x000850, "Member 'FCAAnimInstance_Component_Equipment::M_loco_crouch_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_held_jump_TP) == 0x000858, "Member 'FCAAnimInstance_Component_Equipment::M_held_jump_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_Slide_Loop_Aim_Poses_TP) == 0x000860, "Member 'FCAAnimInstance_Component_Equipment::M_BS_Slide_Loop_Aim_Poses_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_AB_ZGWall_move_vertical_TP) == 0x000868, "Member 'FCAAnimInstance_Component_Equipment::M_AB_ZGWall_move_vertical_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_AB_ZGWall_move_horizontal_TP) == 0x000870, "Member 'FCAAnimInstance_Component_Equipment::M_AB_ZGWall_move_horizontal_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_AB_ZGMB_to_ZGFly_TP) == 0x000878, "Member 'FCAAnimInstance_Component_Equipment::M_AB_ZGMB_to_ZGFly_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_AB_crouch_to_ZGFly_TP) == 0x000880, "Member 'FCAAnimInstance_Component_Equipment::M_AB_crouch_to_ZGFly_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_start_normalG_stand_TP) == 0x000888, "Member 'FCAAnimInstance_Component_Equipment::M_start_normalG_stand_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_start_normalG_crouch_TP) == 0x000890, "Member 'FCAAnimInstance_Component_Equipment::M_start_normalG_crouch_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_start_ZGMB_stand_TP) == 0x000898, "Member 'FCAAnimInstance_Component_Equipment::M_start_ZGMB_stand_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_stop_normalG_stand_TP) == 0x0008A0, "Member 'FCAAnimInstance_Component_Equipment::M_stop_normalG_stand_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_stop_normalG_crouch_TP) == 0x0008A8, "Member 'FCAAnimInstance_Component_Equipment::M_stop_normalG_crouch_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_stop_ZGMB_stand_TP) == 0x0008B0, "Member 'FCAAnimInstance_Component_Equipment::M_stop_ZGMB_stand_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_InAir_Vertical_TP) == 0x0008B8, "Member 'FCAAnimInstance_Component_Equipment::M_BS_InAir_Vertical_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_InAir_Directional_TP) == 0x0008C0, "Member 'FCAAnimInstance_Component_Equipment::M_BS_InAir_Directional_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_MantleMidVertical_Held_TP) == 0x0008C8, "Member 'FCAAnimInstance_Component_Equipment::M_BS_MantleMidVertical_Held_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_MantleMidVertical_ADS_TP) == 0x0008D0, "Member 'FCAAnimInstance_Component_Equipment::M_BS_MantleMidVertical_ADS_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_TraverseTop_Stand_TP) == 0x0008D8, "Member 'FCAAnimInstance_Component_Equipment::M_BS_TraverseTop_Stand_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_TraverseTop_Crouch_TP) == 0x0008E0, "Member 'FCAAnimInstance_Component_Equipment::M_BS_TraverseTop_Crouch_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_Start_Walk_ZGMB_Stand_TP) == 0x0008E8, "Member 'FCAAnimInstance_Component_Equipment::M_BS_Start_Walk_ZGMB_Stand_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_Start_Jog_ZGMB_Stand_TP) == 0x0008F0, "Member 'FCAAnimInstance_Component_Equipment::M_BS_Start_Jog_ZGMB_Stand_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGBoost_TP) == 0x0008F8, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGBoost_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGBoost_ADS_TP) == 0x000900, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGBoost_ADS_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGFly_to_ZGMB_TP) == 0x000908, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGFly_to_ZGMB_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGFly_MoveUp90_TP) == 0x000910, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGFly_MoveUp90_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGFly_MoveUp45_TP) == 0x000918, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGFly_MoveUp45_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGFly_MoveHoriz_TP) == 0x000920, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGFly_MoveHoriz_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGFly_MoveDown45_TP) == 0x000928, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGFly_MoveDown45_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGFly_MoveDown90_TP) == 0x000930, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGFly_MoveDown90_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGCeiling_Pose_Held_TP) == 0x000938, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGCeiling_Pose_Held_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGCeiling_Pose_ADS_TP) == 0x000940, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGCeiling_Pose_ADS_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGWall_Pose_Held_TP) == 0x000948, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGWall_Pose_Held_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGWall_Pose_ADS_TP) == 0x000950, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGWall_Pose_ADS_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGCeiling_Move_TP) == 0x000958, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGCeiling_Move_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGWall_Move_Vertical_TP) == 0x000960, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGWall_Move_Vertical_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGWall_Move_Horizontal_TP) == 0x000968, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGWall_Move_Horizontal_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGWall_to_ZGFly_TP) == 0x000970, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGWall_to_ZGFly_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGCeiling_to_ZGFly_TP) == 0x000978, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGCeiling_to_ZGFly_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGFly_to_ZGCeiling_Land_TP) == 0x000980, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGFly_to_ZGCeiling_Land_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGFly_to_ZGWall_Land_TP) == 0x000988, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGFly_to_ZGWall_Land_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGFly_to_ZGMB_PreLand_TP) == 0x000990, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGFly_to_ZGMB_PreLand_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGFly_to_ZGCeiling_PreLand_TP) == 0x000998, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGFly_to_ZGCeiling_PreLand_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGFly_to_ZGWall_PreLand_TP) == 0x0009A0, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGFly_to_ZGWall_PreLand_TP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGFly_Look_FP) == 0x0009A8, "Member 'FCAAnimInstance_Component_Equipment::M_ZGFly_Look_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGFly_Look_Fast_FP) == 0x0009B0, "Member 'FCAAnimInstance_Component_Equipment::M_ZGFly_Look_Fast_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGWall_Held_Idle_FP) == 0x0009B8, "Member 'FCAAnimInstance_Component_Equipment::M_ZGWall_Held_Idle_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGWall_Land_FP) == 0x0009C0, "Member 'FCAAnimInstance_Component_Equipment::M_ZGWall_Land_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_Takeoff_FP) == 0x0009C8, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_Takeoff_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_ZGMB_Takeoff_Add_FP) == 0x0009D0, "Member 'FCAAnimInstance_Component_Equipment::M_ZGMB_Takeoff_Add_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_inAir_held_FP) == 0x0009D8, "Member 'FCAAnimInstance_Component_Equipment::M_inAir_held_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_inAir_ADS_FP) == 0x0009E0, "Member 'FCAAnimInstance_Component_Equipment::M_inAir_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_loco_normalG_FP) == 0x0009E8, "Member 'FCAAnimInstance_Component_Equipment::M_loco_normalG_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_start_normalG_FP) == 0x0009F0, "Member 'FCAAnimInstance_Component_Equipment::M_BS_start_normalG_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_stop_normalG_FP) == 0x0009F8, "Member 'FCAAnimInstance_Component_Equipment::M_BS_stop_normalG_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGWall_preland_FP) == 0x000A00, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGWall_preland_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGWall_land_FP) == 0x000A08, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGWall_land_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_AB_ZGWall_move_vertical_FP) == 0x000A10, "Member 'FCAAnimInstance_Component_Equipment::M_AB_ZGWall_move_vertical_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_AB_ZGWall_move_horizontal_FP) == 0x000A18, "Member 'FCAAnimInstance_Component_Equipment::M_AB_ZGWall_move_horizontal_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGWall_MoveVertical_FP) == 0x000A20, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGWall_MoveVertical_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGWall_MoveHorizontal_FP) == 0x000A28, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGWall_MoveHorizontal_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGCeiling_Move_FP) == 0x000A30, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGCeiling_Move_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGCeilingWall_Move_FP) == 0x000A38, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGCeilingWall_Move_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_AB_MantleUp_Low_FP) == 0x000A40, "Member 'FCAAnimInstance_Component_Equipment::M_AB_MantleUp_Low_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_AB_MantleUp_Mid_FP) == 0x000A48, "Member 'FCAAnimInstance_Component_Equipment::M_AB_MantleUp_Mid_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_AB_MantleUp_High_FP) == 0x000A50, "Member 'FCAAnimInstance_Component_Equipment::M_AB_MantleUp_High_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_AB_Vault_FP) == 0x000A58, "Member 'FCAAnimInstance_Component_Equipment::M_AB_Vault_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGBoost_FP) == 0x000A60, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGBoost_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_BS_ZGBoost_ADS_FP) == 0x000A68, "Member 'FCAAnimInstance_Component_Equipment::M_BS_ZGBoost_ADS_FP' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_grav_hook_held) == 0x000A70, "Member 'FCAAnimInstance_Component_Equipment::M_grav_hook_held' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_grav_hook_ADS) == 0x000A78, "Member 'FCAAnimInstance_Component_Equipment::M_grav_hook_ADS' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Equipment, M_parameters_map) == 0x000A80, "Member 'FCAAnimInstance_Component_Equipment::M_parameters_map' has a wrong offset!");

// ScriptStruct keaton.CAAnimInstance_Component_Crouch
// 0x0048 (0x0058 - 0x0010)
struct FCAAnimInstance_Component_Crouch final : public FCAAnimInstance_Component
{
public:
	float                                         M_crouch_duration;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_crouch_jump_duration;                            // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_crouch_from_fall_duration;                       // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_vault_crouch_recover_duration;                   // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_slide_duration;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_slide_jump_duration;                             // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_from_jump_fall;                                  // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_did_finish_vaulting;                             // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x1];                                       // 0x002A(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_is_crouching;                                    // 0x002B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_crouch_playback_ratio;                           // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_crouch_ratio;                                    // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_crouch_derivative;                               // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_crouch_change_strength;                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_crouch_change_direction;                         // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_crouch_change_rate;                              // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_sliding;                                      // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_slide_ratio;                                     // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_slide_derivative;                                // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_slide_change_strength;                           // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_slide_change_direction;                          // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAnimInstance_Component_Crouch) == 0x000008, "Wrong alignment on FCAAnimInstance_Component_Crouch");
static_assert(sizeof(FCAAnimInstance_Component_Crouch) == 0x000058, "Wrong size on FCAAnimInstance_Component_Crouch");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_crouch_duration) == 0x000010, "Member 'FCAAnimInstance_Component_Crouch::M_crouch_duration' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_crouch_jump_duration) == 0x000014, "Member 'FCAAnimInstance_Component_Crouch::M_crouch_jump_duration' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_crouch_from_fall_duration) == 0x000018, "Member 'FCAAnimInstance_Component_Crouch::M_crouch_from_fall_duration' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_vault_crouch_recover_duration) == 0x00001C, "Member 'FCAAnimInstance_Component_Crouch::M_vault_crouch_recover_duration' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_slide_duration) == 0x000020, "Member 'FCAAnimInstance_Component_Crouch::M_slide_duration' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_slide_jump_duration) == 0x000024, "Member 'FCAAnimInstance_Component_Crouch::M_slide_jump_duration' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_from_jump_fall) == 0x000028, "Member 'FCAAnimInstance_Component_Crouch::M_from_jump_fall' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_did_finish_vaulting) == 0x000029, "Member 'FCAAnimInstance_Component_Crouch::M_did_finish_vaulting' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_is_crouching) == 0x00002B, "Member 'FCAAnimInstance_Component_Crouch::M_is_crouching' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_crouch_playback_ratio) == 0x00002C, "Member 'FCAAnimInstance_Component_Crouch::M_crouch_playback_ratio' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_crouch_ratio) == 0x000030, "Member 'FCAAnimInstance_Component_Crouch::M_crouch_ratio' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_crouch_derivative) == 0x000034, "Member 'FCAAnimInstance_Component_Crouch::M_crouch_derivative' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_crouch_change_strength) == 0x000038, "Member 'FCAAnimInstance_Component_Crouch::M_crouch_change_strength' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_crouch_change_direction) == 0x00003C, "Member 'FCAAnimInstance_Component_Crouch::M_crouch_change_direction' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_crouch_change_rate) == 0x000040, "Member 'FCAAnimInstance_Component_Crouch::M_crouch_change_rate' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_is_sliding) == 0x000044, "Member 'FCAAnimInstance_Component_Crouch::M_is_sliding' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_slide_ratio) == 0x000048, "Member 'FCAAnimInstance_Component_Crouch::M_slide_ratio' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_slide_derivative) == 0x00004C, "Member 'FCAAnimInstance_Component_Crouch::M_slide_derivative' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_slide_change_strength) == 0x000050, "Member 'FCAAnimInstance_Component_Crouch::M_slide_change_strength' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Crouch, M_slide_change_direction) == 0x000054, "Member 'FCAAnimInstance_Component_Crouch::M_slide_change_direction' has a wrong offset!");

// ScriptStruct keaton.CAEmissiveMeshSlot
// 0x0030 (0x0030 - 0x0000)
struct FCAEmissiveMeshSlot final
{
public:
	class UMeshComponent*                         Mesh;                                              // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Material_slot_name;                                // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Property_name;                                     // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULightComponent*                        Light;                                             // 0x0020(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min_intensity_range;                               // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max_intensity_range;                               // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAEmissiveMeshSlot) == 0x000008, "Wrong alignment on FCAEmissiveMeshSlot");
static_assert(sizeof(FCAEmissiveMeshSlot) == 0x000030, "Wrong size on FCAEmissiveMeshSlot");
static_assert(offsetof(FCAEmissiveMeshSlot, Mesh) == 0x000000, "Member 'FCAEmissiveMeshSlot::Mesh' has a wrong offset!");
static_assert(offsetof(FCAEmissiveMeshSlot, Material_slot_name) == 0x000008, "Member 'FCAEmissiveMeshSlot::Material_slot_name' has a wrong offset!");
static_assert(offsetof(FCAEmissiveMeshSlot, Property_name) == 0x000014, "Member 'FCAEmissiveMeshSlot::Property_name' has a wrong offset!");
static_assert(offsetof(FCAEmissiveMeshSlot, Light) == 0x000020, "Member 'FCAEmissiveMeshSlot::Light' has a wrong offset!");
static_assert(offsetof(FCAEmissiveMeshSlot, Min_intensity_range) == 0x000028, "Member 'FCAEmissiveMeshSlot::Min_intensity_range' has a wrong offset!");
static_assert(offsetof(FCAEmissiveMeshSlot, Max_intensity_range) == 0x00002C, "Member 'FCAEmissiveMeshSlot::Max_intensity_range' has a wrong offset!");

// ScriptStruct keaton.CAAnimInstance_Component_Aiming
// 0x0030 (0x0040 - 0x0010)
struct FCAAnimInstance_Component_Aiming final : public FCAAnimInstance_Component
{
public:
	float                                         M_aiming_yaw;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_aiming_pitch;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_held_to_ads_duration;                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ads_to_held_duration;                            // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ads_playback_ratio;                              // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ads_ratio;                                       // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ads_derivative;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ads_change_strength;                             // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ads_change_direction;                            // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ads_change_rate;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_aiming_down_sights;                           // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_ads_as_base;                                 // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_firing;                                       // 0x003A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_reloading;                                    // 0x003B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAnimInstance_Component_Aiming) == 0x000008, "Wrong alignment on FCAAnimInstance_Component_Aiming");
static_assert(sizeof(FCAAnimInstance_Component_Aiming) == 0x000040, "Wrong size on FCAAnimInstance_Component_Aiming");
static_assert(offsetof(FCAAnimInstance_Component_Aiming, M_aiming_yaw) == 0x000010, "Member 'FCAAnimInstance_Component_Aiming::M_aiming_yaw' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Aiming, M_aiming_pitch) == 0x000014, "Member 'FCAAnimInstance_Component_Aiming::M_aiming_pitch' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Aiming, M_held_to_ads_duration) == 0x000018, "Member 'FCAAnimInstance_Component_Aiming::M_held_to_ads_duration' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Aiming, M_ads_to_held_duration) == 0x00001C, "Member 'FCAAnimInstance_Component_Aiming::M_ads_to_held_duration' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Aiming, M_ads_playback_ratio) == 0x000020, "Member 'FCAAnimInstance_Component_Aiming::M_ads_playback_ratio' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Aiming, M_ads_ratio) == 0x000024, "Member 'FCAAnimInstance_Component_Aiming::M_ads_ratio' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Aiming, M_ads_derivative) == 0x000028, "Member 'FCAAnimInstance_Component_Aiming::M_ads_derivative' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Aiming, M_ads_change_strength) == 0x00002C, "Member 'FCAAnimInstance_Component_Aiming::M_ads_change_strength' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Aiming, M_ads_change_direction) == 0x000030, "Member 'FCAAnimInstance_Component_Aiming::M_ads_change_direction' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Aiming, M_ads_change_rate) == 0x000034, "Member 'FCAAnimInstance_Component_Aiming::M_ads_change_rate' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Aiming, M_is_aiming_down_sights) == 0x000038, "Member 'FCAAnimInstance_Component_Aiming::M_is_aiming_down_sights' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Aiming, M_use_ads_as_base) == 0x000039, "Member 'FCAAnimInstance_Component_Aiming::M_use_ads_as_base' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Aiming, M_is_firing) == 0x00003A, "Member 'FCAAnimInstance_Component_Aiming::M_is_firing' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Aiming, M_is_reloading) == 0x00003B, "Member 'FCAAnimInstance_Component_Aiming::M_is_reloading' has a wrong offset!");

// ScriptStruct keaton.CARewardCategory
// 0x0020 (0x0020 - 0x0000)
struct FCARewardCategory final
{
public:
	int32                                         M_exponent;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_handle;                                          // 0x0004(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         M_multiplier;                                      // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARewardCategory) == 0x000004, "Wrong alignment on FCARewardCategory");
static_assert(sizeof(FCARewardCategory) == 0x000020, "Wrong size on FCARewardCategory");
static_assert(offsetof(FCARewardCategory, M_exponent) == 0x000000, "Member 'FCARewardCategory::M_exponent' has a wrong offset!");
static_assert(offsetof(FCARewardCategory, M_handle) == 0x000004, "Member 'FCARewardCategory::M_handle' has a wrong offset!");
static_assert(offsetof(FCARewardCategory, M_multiplier) == 0x00001C, "Member 'FCARewardCategory::M_multiplier' has a wrong offset!");

// ScriptStruct keaton.CAAnimInstance_Component_Movement
// 0x0008 (0x0018 - 0x0010)
struct FCAAnimInstance_Component_Movement final : public FCAAnimInstance_Component
{
public:
	ECAPlayerMovementMetaMode                     M_player_movement_meta_mode;                       // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAPlayerMovementMetaMode                     M_prev_player_movement_meta_mode;                  // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAPlayerMovementMetaMode                     M_from_player_movement_meta_mode;                  // 0x0012(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAPlayerMovementMode                         M_player_movement_mode;                            // 0x0013(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAPlayerMovementMode                         M_prev_player_movement_mode;                       // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAPlayerMovementMode                         M_from_player_movement_mode;                       // 0x0015(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAnimInstance_Component_Movement) == 0x000008, "Wrong alignment on FCAAnimInstance_Component_Movement");
static_assert(sizeof(FCAAnimInstance_Component_Movement) == 0x000018, "Wrong size on FCAAnimInstance_Component_Movement");
static_assert(offsetof(FCAAnimInstance_Component_Movement, M_player_movement_meta_mode) == 0x000010, "Member 'FCAAnimInstance_Component_Movement::M_player_movement_meta_mode' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Movement, M_prev_player_movement_meta_mode) == 0x000011, "Member 'FCAAnimInstance_Component_Movement::M_prev_player_movement_meta_mode' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Movement, M_from_player_movement_meta_mode) == 0x000012, "Member 'FCAAnimInstance_Component_Movement::M_from_player_movement_meta_mode' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Movement, M_player_movement_mode) == 0x000013, "Member 'FCAAnimInstance_Component_Movement::M_player_movement_mode' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Movement, M_prev_player_movement_mode) == 0x000014, "Member 'FCAAnimInstance_Component_Movement::M_prev_player_movement_mode' has a wrong offset!");
static_assert(offsetof(FCAAnimInstance_Component_Movement, M_from_player_movement_mode) == 0x000015, "Member 'FCAAnimInstance_Component_Movement::M_from_player_movement_mode' has a wrong offset!");

// ScriptStruct keaton.CAAnimInstance_Component_TP_SpecialistPoses
// 0x0000 (0x0010 - 0x0010)
struct FCAAnimInstance_Component_TP_SpecialistPoses final : public FCAAnimInstance_Component
{
};
static_assert(alignof(FCAAnimInstance_Component_TP_SpecialistPoses) == 0x000008, "Wrong alignment on FCAAnimInstance_Component_TP_SpecialistPoses");
static_assert(sizeof(FCAAnimInstance_Component_TP_SpecialistPoses) == 0x000010, "Wrong size on FCAAnimInstance_Component_TP_SpecialistPoses");

// ScriptStruct keaton.CAAnimInstance_Component_TP_Procedural
// 0x0000 (0x0010 - 0x0010)
struct FCAAnimInstance_Component_TP_Procedural final : public FCAAnimInstance_Component
{
};
static_assert(alignof(FCAAnimInstance_Component_TP_Procedural) == 0x000008, "Wrong alignment on FCAAnimInstance_Component_TP_Procedural");
static_assert(sizeof(FCAAnimInstance_Component_TP_Procedural) == 0x000010, "Wrong size on FCAAnimInstance_Component_TP_Procedural");

// ScriptStruct keaton.CAAnimInstance_Component_TP_Fastpaths
// 0x0000 (0x0010 - 0x0010)
struct FCAAnimInstance_Component_TP_Fastpaths final : public FCAAnimInstance_Component
{
};
static_assert(alignof(FCAAnimInstance_Component_TP_Fastpaths) == 0x000008, "Wrong alignment on FCAAnimInstance_Component_TP_Fastpaths");
static_assert(sizeof(FCAAnimInstance_Component_TP_Fastpaths) == 0x000010, "Wrong size on FCAAnimInstance_Component_TP_Fastpaths");

// ScriptStruct keaton.CAIPAsset
// 0x001C (0x001C - 0x0000)
struct FCAIPAsset final
{
public:
	class FName                                   PackagePath;                                       // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  PersistentId;                                      // 0x000C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAIPAsset) == 0x000004, "Wrong alignment on FCAIPAsset");
static_assert(sizeof(FCAIPAsset) == 0x00001C, "Wrong size on FCAIPAsset");
static_assert(offsetof(FCAIPAsset, PackagePath) == 0x000000, "Member 'FCAIPAsset::PackagePath' has a wrong offset!");
static_assert(offsetof(FCAIPAsset, PersistentId) == 0x00000C, "Member 'FCAIPAsset::PersistentId' has a wrong offset!");

// ScriptStruct keaton.DrivenLookBoneParams
// 0x0080 (0x0080 - 0x0000)
struct FDrivenLookBoneParams final
{
public:
	struct FBoneReference                         LookBone;                                          // 0x0000(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         TargetBone;                                        // 0x0014(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LookAtLocation;                                    // 0x0028(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseUpRef;                                         // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRefPose;                                       // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAxis                                  LookAxis;                                          // 0x0038(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         UpRefBone;                                         // 0x0048(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LookUpAxisTarget;                                  // 0x005C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAxis                                  LookUpAxis;                                        // 0x0068(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FAlpha;                                            // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyToBothBones;                                 // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x007D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDrivenLookBoneParams) == 0x000004, "Wrong alignment on FDrivenLookBoneParams");
static_assert(sizeof(FDrivenLookBoneParams) == 0x000080, "Wrong size on FDrivenLookBoneParams");
static_assert(offsetof(FDrivenLookBoneParams, LookBone) == 0x000000, "Member 'FDrivenLookBoneParams::LookBone' has a wrong offset!");
static_assert(offsetof(FDrivenLookBoneParams, TargetBone) == 0x000014, "Member 'FDrivenLookBoneParams::TargetBone' has a wrong offset!");
static_assert(offsetof(FDrivenLookBoneParams, LookAtLocation) == 0x000028, "Member 'FDrivenLookBoneParams::LookAtLocation' has a wrong offset!");
static_assert(offsetof(FDrivenLookBoneParams, bUseUpRef) == 0x000034, "Member 'FDrivenLookBoneParams::bUseUpRef' has a wrong offset!");
static_assert(offsetof(FDrivenLookBoneParams, bUseRefPose) == 0x000035, "Member 'FDrivenLookBoneParams::bUseRefPose' has a wrong offset!");
static_assert(offsetof(FDrivenLookBoneParams, LookAxis) == 0x000038, "Member 'FDrivenLookBoneParams::LookAxis' has a wrong offset!");
static_assert(offsetof(FDrivenLookBoneParams, UpRefBone) == 0x000048, "Member 'FDrivenLookBoneParams::UpRefBone' has a wrong offset!");
static_assert(offsetof(FDrivenLookBoneParams, LookUpAxisTarget) == 0x00005C, "Member 'FDrivenLookBoneParams::LookUpAxisTarget' has a wrong offset!");
static_assert(offsetof(FDrivenLookBoneParams, LookUpAxis) == 0x000068, "Member 'FDrivenLookBoneParams::LookUpAxis' has a wrong offset!");
static_assert(offsetof(FDrivenLookBoneParams, FAlpha) == 0x000078, "Member 'FDrivenLookBoneParams::FAlpha' has a wrong offset!");
static_assert(offsetof(FDrivenLookBoneParams, bApplyToBothBones) == 0x00007C, "Member 'FDrivenLookBoneParams::bApplyToBothBones' has a wrong offset!");
static_assert(offsetof(FDrivenLookBoneParams, bDrawDebug) == 0x00007D, "Member 'FDrivenLookBoneParams::bDrawDebug' has a wrong offset!");

// ScriptStruct keaton.DrivenLookBoneParamsArray
// 0x0010 (0x0010 - 0x0000)
struct FDrivenLookBoneParamsArray final
{
public:
	TArray<struct FDrivenLookBoneParams>          Array;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDrivenLookBoneParamsArray) == 0x000008, "Wrong alignment on FDrivenLookBoneParamsArray");
static_assert(sizeof(FDrivenLookBoneParamsArray) == 0x000010, "Wrong size on FDrivenLookBoneParamsArray");
static_assert(offsetof(FDrivenLookBoneParamsArray, Array) == 0x000000, "Member 'FDrivenLookBoneParamsArray::Array' has a wrong offset!");

// ScriptStruct keaton.CAAnimNode_DrivenLookBones
// 0x0040 (0x0050 - 0x0010)
struct FCAAnimNode_DrivenLookBones final : public FAnimNode_Base
{
public:
	struct FComponentSpacePoseLink                ComponentPose;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FDrivenLookBoneParams>          DrivenBoneList;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDrivenLookBoneParamsArray             Parameters;                                        // 0x0030(0x0010)(Edit, NativeAccessSpecifierPublic)
	int32                                         LODThreshold;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActualAlpha;                                       // 0x0044(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAnimNode_DrivenLookBones) == 0x000008, "Wrong alignment on FCAAnimNode_DrivenLookBones");
static_assert(sizeof(FCAAnimNode_DrivenLookBones) == 0x000050, "Wrong size on FCAAnimNode_DrivenLookBones");
static_assert(offsetof(FCAAnimNode_DrivenLookBones, ComponentPose) == 0x000010, "Member 'FCAAnimNode_DrivenLookBones::ComponentPose' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_DrivenLookBones, DrivenBoneList) == 0x000020, "Member 'FCAAnimNode_DrivenLookBones::DrivenBoneList' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_DrivenLookBones, Parameters) == 0x000030, "Member 'FCAAnimNode_DrivenLookBones::Parameters' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_DrivenLookBones, LODThreshold) == 0x000040, "Member 'FCAAnimNode_DrivenLookBones::LODThreshold' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_DrivenLookBones, ActualAlpha) == 0x000044, "Member 'FCAAnimNode_DrivenLookBones::ActualAlpha' has a wrong offset!");

// ScriptStruct keaton.CADialogueFEMappingRow
// 0x0010 (0x0018 - 0x0008)
struct FCADialogueFEMappingRow final : public FTableRowBase
{
public:
	struct FCAAudioSwitchValueType                FESpecialistName;                                  // 0x0008(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioBankNameType                   BankName;                                          // 0x000C(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      DDESpecialistName;                                 // 0x0010(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioSwitchValueType                SpecialistName;                                    // 0x0014(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADialogueFEMappingRow) == 0x000008, "Wrong alignment on FCADialogueFEMappingRow");
static_assert(sizeof(FCADialogueFEMappingRow) == 0x000018, "Wrong size on FCADialogueFEMappingRow");
static_assert(offsetof(FCADialogueFEMappingRow, FESpecialistName) == 0x000008, "Member 'FCADialogueFEMappingRow::FESpecialistName' has a wrong offset!");
static_assert(offsetof(FCADialogueFEMappingRow, BankName) == 0x00000C, "Member 'FCADialogueFEMappingRow::BankName' has a wrong offset!");
static_assert(offsetof(FCADialogueFEMappingRow, DDESpecialistName) == 0x000010, "Member 'FCADialogueFEMappingRow::DDESpecialistName' has a wrong offset!");
static_assert(offsetof(FCADialogueFEMappingRow, SpecialistName) == 0x000014, "Member 'FCADialogueFEMappingRow::SpecialistName' has a wrong offset!");

// ScriptStruct keaton.FollowAnimPair
// 0x0010 (0x0010 - 0x0000)
struct FFollowAnimPair final
{
public:
	class UAnimMontage*                           M_character_montage;                               // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_following_equipment_montage;                     // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFollowAnimPair) == 0x000008, "Wrong alignment on FFollowAnimPair");
static_assert(sizeof(FFollowAnimPair) == 0x000010, "Wrong size on FFollowAnimPair");
static_assert(offsetof(FFollowAnimPair, M_character_montage) == 0x000000, "Member 'FFollowAnimPair::M_character_montage' has a wrong offset!");
static_assert(offsetof(FFollowAnimPair, M_following_equipment_montage) == 0x000008, "Member 'FFollowAnimPair::M_following_equipment_montage' has a wrong offset!");

// ScriptStruct keaton.DrivenTwistBoneParams
// 0x0064 (0x0064 - 0x0000)
struct FDrivenTwistBoneParams final
{
public:
	struct FBoneReference                         TwistBone;                                         // 0x0000(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         SourceBone;                                        // 0x0014(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         TargetBone;                                        // 0x0028(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         BaseBone;                                          // 0x003C(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FRatio;                                            // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SourceRotation;                                    // 0x0054(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDrivenTwistBoneParams) == 0x000004, "Wrong alignment on FDrivenTwistBoneParams");
static_assert(sizeof(FDrivenTwistBoneParams) == 0x000064, "Wrong size on FDrivenTwistBoneParams");
static_assert(offsetof(FDrivenTwistBoneParams, TwistBone) == 0x000000, "Member 'FDrivenTwistBoneParams::TwistBone' has a wrong offset!");
static_assert(offsetof(FDrivenTwistBoneParams, SourceBone) == 0x000014, "Member 'FDrivenTwistBoneParams::SourceBone' has a wrong offset!");
static_assert(offsetof(FDrivenTwistBoneParams, TargetBone) == 0x000028, "Member 'FDrivenTwistBoneParams::TargetBone' has a wrong offset!");
static_assert(offsetof(FDrivenTwistBoneParams, BaseBone) == 0x00003C, "Member 'FDrivenTwistBoneParams::BaseBone' has a wrong offset!");
static_assert(offsetof(FDrivenTwistBoneParams, FRatio) == 0x000050, "Member 'FDrivenTwistBoneParams::FRatio' has a wrong offset!");
static_assert(offsetof(FDrivenTwistBoneParams, SourceRotation) == 0x000054, "Member 'FDrivenTwistBoneParams::SourceRotation' has a wrong offset!");
static_assert(offsetof(FDrivenTwistBoneParams, bDrawDebug) == 0x000060, "Member 'FDrivenTwistBoneParams::bDrawDebug' has a wrong offset!");

// ScriptStruct keaton.CAAnimNode_DrivenTwistBones
// 0x0038 (0x0048 - 0x0010)
struct FCAAnimNode_DrivenTwistBones final : public FAnimNode_Base
{
public:
	struct FComponentSpacePoseLink                ComponentPose;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FDrivenTwistBoneParams>         DrivenBoneList;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LODThreshold;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActualAlpha;                                       // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0xC];                                       // 0x003C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAnimNode_DrivenTwistBones) == 0x000008, "Wrong alignment on FCAAnimNode_DrivenTwistBones");
static_assert(sizeof(FCAAnimNode_DrivenTwistBones) == 0x000048, "Wrong size on FCAAnimNode_DrivenTwistBones");
static_assert(offsetof(FCAAnimNode_DrivenTwistBones, ComponentPose) == 0x000010, "Member 'FCAAnimNode_DrivenTwistBones::ComponentPose' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_DrivenTwistBones, DrivenBoneList) == 0x000020, "Member 'FCAAnimNode_DrivenTwistBones::DrivenBoneList' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_DrivenTwistBones, bEnable) == 0x000030, "Member 'FCAAnimNode_DrivenTwistBones::bEnable' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_DrivenTwistBones, LODThreshold) == 0x000034, "Member 'FCAAnimNode_DrivenTwistBones::LODThreshold' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_DrivenTwistBones, ActualAlpha) == 0x000038, "Member 'FCAAnimNode_DrivenTwistBones::ActualAlpha' has a wrong offset!");

// ScriptStruct keaton.CAAnimNode_FPBoneCollapse
// 0x0038 (0x0048 - 0x0010)
struct FCAAnimNode_FPBoneCollapse final : public FAnimNode_Base
{
public:
	struct FComponentSpacePoseLink                ComponentPose;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x28];                                      // 0x0020(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAnimNode_FPBoneCollapse) == 0x000008, "Wrong alignment on FCAAnimNode_FPBoneCollapse");
static_assert(sizeof(FCAAnimNode_FPBoneCollapse) == 0x000048, "Wrong size on FCAAnimNode_FPBoneCollapse");
static_assert(offsetof(FCAAnimNode_FPBoneCollapse, ComponentPose) == 0x000010, "Member 'FCAAnimNode_FPBoneCollapse::ComponentPose' has a wrong offset!");

// ScriptStruct keaton.CARewardDistributionGroupLimit
// 0x0020 (0x0020 - 0x0000)
struct FCARewardDistributionGroupLimit final
{
public:
	struct FDataTableRowHandle                    M_reward_distribution;                             // 0x0000(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         M_source_count;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_grouping_owner_count;                            // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARewardDistributionGroupLimit) == 0x000008, "Wrong alignment on FCARewardDistributionGroupLimit");
static_assert(sizeof(FCARewardDistributionGroupLimit) == 0x000020, "Wrong size on FCARewardDistributionGroupLimit");
static_assert(offsetof(FCARewardDistributionGroupLimit, M_reward_distribution) == 0x000000, "Member 'FCARewardDistributionGroupLimit::M_reward_distribution' has a wrong offset!");
static_assert(offsetof(FCARewardDistributionGroupLimit, M_source_count) == 0x000018, "Member 'FCARewardDistributionGroupLimit::M_source_count' has a wrong offset!");
static_assert(offsetof(FCARewardDistributionGroupLimit, M_grouping_owner_count) == 0x00001C, "Member 'FCARewardDistributionGroupLimit::M_grouping_owner_count' has a wrong offset!");

// ScriptStruct keaton.CARewardDistributionGroupingData
// 0x0010 (0x0018 - 0x0008)
struct FCARewardDistributionGroupingData final : public FTableRowBase
{
public:
	TArray<struct FCARewardDistributionGroupLimit> M_reward_distribution_limits;                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARewardDistributionGroupingData) == 0x000008, "Wrong alignment on FCARewardDistributionGroupingData");
static_assert(sizeof(FCARewardDistributionGroupingData) == 0x000018, "Wrong size on FCARewardDistributionGroupingData");
static_assert(offsetof(FCARewardDistributionGroupingData, M_reward_distribution_limits) == 0x000008, "Member 'FCARewardDistributionGroupingData::M_reward_distribution_limits' has a wrong offset!");

// ScriptStruct keaton.CAAnimNode_ReTransformBone
// 0x0090 (0x00A0 - 0x0010)
struct FCAAnimNode_ReTransformBone final : public FAnimNode_Base
{
public:
	struct FComponentSpacePoseLink                ComponentPose;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         SourceBone;                                        // 0x0020(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         TargetBone;                                        // 0x0034(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         CMBone;                                            // 0x0048(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                PointA0;                                           // 0x005C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PointB0;                                           // 0x0068(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PointA1;                                           // 0x0074(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PointB1;                                           // 0x0080(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetPosition;                                      // 0x008C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetRotation;                                      // 0x008D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Alpha;                                             // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODThreshold;                                      // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAnimNode_ReTransformBone) == 0x000008, "Wrong alignment on FCAAnimNode_ReTransformBone");
static_assert(sizeof(FCAAnimNode_ReTransformBone) == 0x0000A0, "Wrong size on FCAAnimNode_ReTransformBone");
static_assert(offsetof(FCAAnimNode_ReTransformBone, ComponentPose) == 0x000010, "Member 'FCAAnimNode_ReTransformBone::ComponentPose' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_ReTransformBone, SourceBone) == 0x000020, "Member 'FCAAnimNode_ReTransformBone::SourceBone' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_ReTransformBone, TargetBone) == 0x000034, "Member 'FCAAnimNode_ReTransformBone::TargetBone' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_ReTransformBone, CMBone) == 0x000048, "Member 'FCAAnimNode_ReTransformBone::CMBone' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_ReTransformBone, PointA0) == 0x00005C, "Member 'FCAAnimNode_ReTransformBone::PointA0' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_ReTransformBone, PointB0) == 0x000068, "Member 'FCAAnimNode_ReTransformBone::PointB0' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_ReTransformBone, PointA1) == 0x000074, "Member 'FCAAnimNode_ReTransformBone::PointA1' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_ReTransformBone, PointB1) == 0x000080, "Member 'FCAAnimNode_ReTransformBone::PointB1' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_ReTransformBone, bSetPosition) == 0x00008C, "Member 'FCAAnimNode_ReTransformBone::bSetPosition' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_ReTransformBone, bSetRotation) == 0x00008D, "Member 'FCAAnimNode_ReTransformBone::bSetRotation' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_ReTransformBone, Alpha) == 0x000090, "Member 'FCAAnimNode_ReTransformBone::Alpha' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_ReTransformBone, LODThreshold) == 0x000094, "Member 'FCAAnimNode_ReTransformBone::LODThreshold' has a wrong offset!");

// ScriptStruct keaton.TimedEvent
// 0x0018 (0x0018 - 0x0000)
struct FTimedEvent final
{
public:
	float                                         M_SecondsFromBegin;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_FunctionName;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTimedEvent) == 0x000008, "Wrong alignment on FTimedEvent");
static_assert(sizeof(FTimedEvent) == 0x000018, "Wrong size on FTimedEvent");
static_assert(offsetof(FTimedEvent, M_SecondsFromBegin) == 0x000000, "Member 'FTimedEvent::M_SecondsFromBegin' has a wrong offset!");
static_assert(offsetof(FTimedEvent, M_FunctionName) == 0x000008, "Member 'FTimedEvent::M_FunctionName' has a wrong offset!");

// ScriptStruct keaton.CAAnimNode_TranslationMultiplier
// 0x0028 (0x0038 - 0x0010)
struct FCAAnimNode_TranslationMultiplier final : public FAnimNode_Base
{
public:
	struct FPoseLink                              AnimationPose;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              TranslationMultiplier;                             // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bResetChildOnActivation;                           // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAnimNode_TranslationMultiplier) == 0x000008, "Wrong alignment on FCAAnimNode_TranslationMultiplier");
static_assert(sizeof(FCAAnimNode_TranslationMultiplier) == 0x000038, "Wrong size on FCAAnimNode_TranslationMultiplier");
static_assert(offsetof(FCAAnimNode_TranslationMultiplier, AnimationPose) == 0x000010, "Member 'FCAAnimNode_TranslationMultiplier::AnimationPose' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_TranslationMultiplier, TranslationMultiplier) == 0x000020, "Member 'FCAAnimNode_TranslationMultiplier::TranslationMultiplier' has a wrong offset!");
static_assert(offsetof(FCAAnimNode_TranslationMultiplier, bResetChildOnActivation) == 0x000030, "Member 'FCAAnimNode_TranslationMultiplier::bResetChildOnActivation' has a wrong offset!");

// ScriptStruct keaton.CAScreenDataTransport
// 0x00D8 (0x00D8 - 0x0000)
struct FCAScreenDataTransport final
{
public:
	uint8                                         Pad_0[0x98];                                       // 0x0000(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class UCABaseScreen*                          M_screen;                                          // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            M_curve;                                           // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAScreenDataTransport) == 0x000008, "Wrong alignment on FCAScreenDataTransport");
static_assert(sizeof(FCAScreenDataTransport) == 0x0000D8, "Wrong size on FCAScreenDataTransport");
static_assert(offsetof(FCAScreenDataTransport, M_screen) == 0x000098, "Member 'FCAScreenDataTransport::M_screen' has a wrong offset!");
static_assert(offsetof(FCAScreenDataTransport, M_curve) == 0x0000A0, "Member 'FCAScreenDataTransport::M_curve' has a wrong offset!");

// ScriptStruct keaton.BlendTimeSelectorData
// 0x0040 (0x0040 - 0x0000)
struct FBlendTimeSelectorData final
{
public:
	class FName                                   M_slot;                                            // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlphaBlend                            M_blend_out;                                       // 0x0010(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlendTimeSelectorData) == 0x000008, "Wrong alignment on FBlendTimeSelectorData");
static_assert(sizeof(FBlendTimeSelectorData) == 0x000040, "Wrong size on FBlendTimeSelectorData");
static_assert(offsetof(FBlendTimeSelectorData, M_slot) == 0x000000, "Member 'FBlendTimeSelectorData::M_slot' has a wrong offset!");
static_assert(offsetof(FBlendTimeSelectorData, M_blend_out) == 0x000010, "Member 'FBlendTimeSelectorData::M_blend_out' has a wrong offset!");

// ScriptStruct keaton.CAWeaponFireModeAdditionalData
// 0x0020 (0x0028 - 0x0008)
struct FCAWeaponFireModeAdditionalData final : public FTableRowBase
{
public:
	struct FGameplayTag                           M_on_shot_fired_gameplay_event_tag;                // 0x0008(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_allow_weapon_to_network_implementation_hack;     // 0x0014(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_auto_reload;                                     // 0x0015(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_on_weapon_out_of_ammo_tag;                       // 0x0018(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAWeaponFireModeAdditionalData) == 0x000008, "Wrong alignment on FCAWeaponFireModeAdditionalData");
static_assert(sizeof(FCAWeaponFireModeAdditionalData) == 0x000028, "Wrong size on FCAWeaponFireModeAdditionalData");
static_assert(offsetof(FCAWeaponFireModeAdditionalData, M_on_shot_fired_gameplay_event_tag) == 0x000008, "Member 'FCAWeaponFireModeAdditionalData::M_on_shot_fired_gameplay_event_tag' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAdditionalData, M_allow_weapon_to_network_implementation_hack) == 0x000014, "Member 'FCAWeaponFireModeAdditionalData::M_allow_weapon_to_network_implementation_hack' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAdditionalData, M_auto_reload) == 0x000015, "Member 'FCAWeaponFireModeAdditionalData::M_auto_reload' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAdditionalData, M_on_weapon_out_of_ammo_tag) == 0x000018, "Member 'FCAWeaponFireModeAdditionalData::M_on_weapon_out_of_ammo_tag' has a wrong offset!");

// ScriptStruct keaton.LOSParameters
// 0x0014 (0x0014 - 0x0000)
struct FLOSParameters final
{
public:
	struct FVector                                M_origin;                                          // 0x0000(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_distance;                                        // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               M_trace_type;                                      // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_filter_based_on_los;                             // 0x0011(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLOSParameters) == 0x000004, "Wrong alignment on FLOSParameters");
static_assert(sizeof(FLOSParameters) == 0x000014, "Wrong size on FLOSParameters");
static_assert(offsetof(FLOSParameters, M_origin) == 0x000000, "Member 'FLOSParameters::M_origin' has a wrong offset!");
static_assert(offsetof(FLOSParameters, M_distance) == 0x00000C, "Member 'FLOSParameters::M_distance' has a wrong offset!");
static_assert(offsetof(FLOSParameters, M_trace_type) == 0x000010, "Member 'FLOSParameters::M_trace_type' has a wrong offset!");
static_assert(offsetof(FLOSParameters, M_filter_based_on_los) == 0x000011, "Member 'FLOSParameters::M_filter_based_on_los' has a wrong offset!");

// ScriptStruct keaton.AOEParameters
// 0x0040 (0x0040 - 0x0000)
struct FAOEParameters final
{
public:
	struct FVector                                M_sphere_centre;                                   // 0x0000(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_radius;                                          // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               M_trace_type;                                      // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_filter_based_on_los;                             // 0x0011(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_instigator;                                      // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             M_match_only_actors_of_type;                       // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             M_exclude_actors_of_type;                          // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAOEParameters) == 0x000008, "Wrong alignment on FAOEParameters");
static_assert(sizeof(FAOEParameters) == 0x000040, "Wrong size on FAOEParameters");
static_assert(offsetof(FAOEParameters, M_sphere_centre) == 0x000000, "Member 'FAOEParameters::M_sphere_centre' has a wrong offset!");
static_assert(offsetof(FAOEParameters, M_radius) == 0x00000C, "Member 'FAOEParameters::M_radius' has a wrong offset!");
static_assert(offsetof(FAOEParameters, M_trace_type) == 0x000010, "Member 'FAOEParameters::M_trace_type' has a wrong offset!");
static_assert(offsetof(FAOEParameters, M_filter_based_on_los) == 0x000011, "Member 'FAOEParameters::M_filter_based_on_los' has a wrong offset!");
static_assert(offsetof(FAOEParameters, M_instigator) == 0x000018, "Member 'FAOEParameters::M_instigator' has a wrong offset!");
static_assert(offsetof(FAOEParameters, M_match_only_actors_of_type) == 0x000020, "Member 'FAOEParameters::M_match_only_actors_of_type' has a wrong offset!");
static_assert(offsetof(FAOEParameters, M_exclude_actors_of_type) == 0x000030, "Member 'FAOEParameters::M_exclude_actors_of_type' has a wrong offset!");

// ScriptStruct keaton.TeleporterSetupData
// 0x0030 (0x0030 - 0x0000)
struct FTeleporterSetupData final
{
public:
	bool                                          M_overlap_trigger;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_trigger_dimensions;                              // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_same_team_only;                                  // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_one_way;                                         // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_limit_number_of_uses;                            // 0x0012(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_number_of_uses;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATeleportLifetimeSetup                      M_lifespan_setup;                                  // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_lifespan;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_optional_destination_rotation;               // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_destination_rotation_axes;                       // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeleporterSetupData) == 0x000004, "Wrong alignment on FTeleporterSetupData");
static_assert(sizeof(FTeleporterSetupData) == 0x000030, "Wrong size on FTeleporterSetupData");
static_assert(offsetof(FTeleporterSetupData, M_overlap_trigger) == 0x000000, "Member 'FTeleporterSetupData::M_overlap_trigger' has a wrong offset!");
static_assert(offsetof(FTeleporterSetupData, M_trigger_dimensions) == 0x000004, "Member 'FTeleporterSetupData::M_trigger_dimensions' has a wrong offset!");
static_assert(offsetof(FTeleporterSetupData, M_same_team_only) == 0x000010, "Member 'FTeleporterSetupData::M_same_team_only' has a wrong offset!");
static_assert(offsetof(FTeleporterSetupData, M_one_way) == 0x000011, "Member 'FTeleporterSetupData::M_one_way' has a wrong offset!");
static_assert(offsetof(FTeleporterSetupData, M_limit_number_of_uses) == 0x000012, "Member 'FTeleporterSetupData::M_limit_number_of_uses' has a wrong offset!");
static_assert(offsetof(FTeleporterSetupData, M_number_of_uses) == 0x000014, "Member 'FTeleporterSetupData::M_number_of_uses' has a wrong offset!");
static_assert(offsetof(FTeleporterSetupData, M_lifespan_setup) == 0x000018, "Member 'FTeleporterSetupData::M_lifespan_setup' has a wrong offset!");
static_assert(offsetof(FTeleporterSetupData, M_lifespan) == 0x00001C, "Member 'FTeleporterSetupData::M_lifespan' has a wrong offset!");
static_assert(offsetof(FTeleporterSetupData, M_use_optional_destination_rotation) == 0x000020, "Member 'FTeleporterSetupData::M_use_optional_destination_rotation' has a wrong offset!");
static_assert(offsetof(FTeleporterSetupData, M_destination_rotation_axes) == 0x000024, "Member 'FTeleporterSetupData::M_destination_rotation_axes' has a wrong offset!");

// ScriptStruct keaton.CAARcLensPingTypeDefinition
// 0x00A8 (0x00B0 - 0x0008)
struct FCAARcLensPingTypeDefinition final : public FTableRowBase
{
public:
	class FString                                 M_row_id;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAArcLensPingType                            M_ping_type;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAUIHUDEntityId                              M_ping_id;                                         // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAPingContext                                M_ping_context;                                    // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             M_icon;                                            // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAText                                M_label;                                           // 0x0028(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCAText                                M_text_chat_event_label;                           // 0x0058(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   M_audio_event_name;                                // 0x0088(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_ping_audio_event;                                // 0x0094(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_2d_ping_audio_event;                             // 0x0098(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   M_ping_dialogue_name;                              // 0x009C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_animation_montage;                               // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAARcLensPingTypeDefinition) == 0x000008, "Wrong alignment on FCAARcLensPingTypeDefinition");
static_assert(sizeof(FCAARcLensPingTypeDefinition) == 0x0000B0, "Wrong size on FCAARcLensPingTypeDefinition");
static_assert(offsetof(FCAARcLensPingTypeDefinition, M_row_id) == 0x000008, "Member 'FCAARcLensPingTypeDefinition::M_row_id' has a wrong offset!");
static_assert(offsetof(FCAARcLensPingTypeDefinition, M_ping_type) == 0x000018, "Member 'FCAARcLensPingTypeDefinition::M_ping_type' has a wrong offset!");
static_assert(offsetof(FCAARcLensPingTypeDefinition, M_ping_id) == 0x000019, "Member 'FCAARcLensPingTypeDefinition::M_ping_id' has a wrong offset!");
static_assert(offsetof(FCAARcLensPingTypeDefinition, M_ping_context) == 0x00001A, "Member 'FCAARcLensPingTypeDefinition::M_ping_context' has a wrong offset!");
static_assert(offsetof(FCAARcLensPingTypeDefinition, M_icon) == 0x000020, "Member 'FCAARcLensPingTypeDefinition::M_icon' has a wrong offset!");
static_assert(offsetof(FCAARcLensPingTypeDefinition, M_label) == 0x000028, "Member 'FCAARcLensPingTypeDefinition::M_label' has a wrong offset!");
static_assert(offsetof(FCAARcLensPingTypeDefinition, M_text_chat_event_label) == 0x000058, "Member 'FCAARcLensPingTypeDefinition::M_text_chat_event_label' has a wrong offset!");
static_assert(offsetof(FCAARcLensPingTypeDefinition, M_audio_event_name) == 0x000088, "Member 'FCAARcLensPingTypeDefinition::M_audio_event_name' has a wrong offset!");
static_assert(offsetof(FCAARcLensPingTypeDefinition, M_ping_audio_event) == 0x000094, "Member 'FCAARcLensPingTypeDefinition::M_ping_audio_event' has a wrong offset!");
static_assert(offsetof(FCAARcLensPingTypeDefinition, M_2d_ping_audio_event) == 0x000098, "Member 'FCAARcLensPingTypeDefinition::M_2d_ping_audio_event' has a wrong offset!");
static_assert(offsetof(FCAARcLensPingTypeDefinition, M_ping_dialogue_name) == 0x00009C, "Member 'FCAARcLensPingTypeDefinition::M_ping_dialogue_name' has a wrong offset!");
static_assert(offsetof(FCAARcLensPingTypeDefinition, M_animation_montage) == 0x0000A8, "Member 'FCAARcLensPingTypeDefinition::M_animation_montage' has a wrong offset!");

// ScriptStruct keaton.CAStatusEffectDefinition
// 0x0030 (0x0030 - 0x0000)
struct FCAStatusEffectDefinition final
{
public:
	TArray<struct FGameplayTag>                   TagsGranted;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   TagsRequired;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   TagsIgnored;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAStatusEffectDefinition) == 0x000008, "Wrong alignment on FCAStatusEffectDefinition");
static_assert(sizeof(FCAStatusEffectDefinition) == 0x000030, "Wrong size on FCAStatusEffectDefinition");
static_assert(offsetof(FCAStatusEffectDefinition, TagsGranted) == 0x000000, "Member 'FCAStatusEffectDefinition::TagsGranted' has a wrong offset!");
static_assert(offsetof(FCAStatusEffectDefinition, TagsRequired) == 0x000010, "Member 'FCAStatusEffectDefinition::TagsRequired' has a wrong offset!");
static_assert(offsetof(FCAStatusEffectDefinition, TagsIgnored) == 0x000020, "Member 'FCAStatusEffectDefinition::TagsIgnored' has a wrong offset!");

// ScriptStruct keaton.CAArcLensPingSlotData
// 0x0020 (0x0028 - 0x0008)
struct FCAArcLensPingSlotData final : public FTableRowBase
{
public:
	ECAArcLensPingSlot                            M_ping_slot;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    M_ping_table_row_handle;                           // 0x0010(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAArcLensPingSlotData) == 0x000008, "Wrong alignment on FCAArcLensPingSlotData");
static_assert(sizeof(FCAArcLensPingSlotData) == 0x000028, "Wrong size on FCAArcLensPingSlotData");
static_assert(offsetof(FCAArcLensPingSlotData, M_ping_slot) == 0x000008, "Member 'FCAArcLensPingSlotData::M_ping_slot' has a wrong offset!");
static_assert(offsetof(FCAArcLensPingSlotData, M_ping_table_row_handle) == 0x000010, "Member 'FCAArcLensPingSlotData::M_ping_table_row_handle' has a wrong offset!");

// ScriptStruct keaton.CAAssignedNPC
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FCAAssignedNPC final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAssignedNPC) == 0x000004, "Wrong alignment on FCAAssignedNPC");
static_assert(sizeof(FCAAssignedNPC) == 0x000014, "Wrong size on FCAAssignedNPC");

// ScriptStruct keaton.CAAudioFootstepTriggerDef
// 0x0020 (0x0020 - 0x0000)
struct FCAAudioFootstepTriggerDef final
{
public:
	class FString                                 Label;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      FPEvent;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      TPEvent;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      TPInitialEvent;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAudioFootstepTriggerDef) == 0x000008, "Wrong alignment on FCAAudioFootstepTriggerDef");
static_assert(sizeof(FCAAudioFootstepTriggerDef) == 0x000020, "Wrong size on FCAAudioFootstepTriggerDef");
static_assert(offsetof(FCAAudioFootstepTriggerDef, Label) == 0x000000, "Member 'FCAAudioFootstepTriggerDef::Label' has a wrong offset!");
static_assert(offsetof(FCAAudioFootstepTriggerDef, FPEvent) == 0x000010, "Member 'FCAAudioFootstepTriggerDef::FPEvent' has a wrong offset!");
static_assert(offsetof(FCAAudioFootstepTriggerDef, TPEvent) == 0x000014, "Member 'FCAAudioFootstepTriggerDef::TPEvent' has a wrong offset!");
static_assert(offsetof(FCAAudioFootstepTriggerDef, TPInitialEvent) == 0x000018, "Member 'FCAAudioFootstepTriggerDef::TPInitialEvent' has a wrong offset!");

// ScriptStruct keaton.CAHUDInventoryBuffDescription
// 0x0040 (0x0040 - 0x0000)
struct FCAHUDInventoryBuffDescription final
{
public:
	class FString                                 M_number_str;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAText                                M_description_text;                                // 0x0010(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDInventoryBuffDescription) == 0x000008, "Wrong alignment on FCAHUDInventoryBuffDescription");
static_assert(sizeof(FCAHUDInventoryBuffDescription) == 0x000040, "Wrong size on FCAHUDInventoryBuffDescription");
static_assert(offsetof(FCAHUDInventoryBuffDescription, M_number_str) == 0x000000, "Member 'FCAHUDInventoryBuffDescription::M_number_str' has a wrong offset!");
static_assert(offsetof(FCAHUDInventoryBuffDescription, M_description_text) == 0x000010, "Member 'FCAHUDInventoryBuffDescription::M_description_text' has a wrong offset!");

// ScriptStruct keaton.CAWeaponFireModeAdditionalAudioData
// 0x0060 (0x0060 - 0x0000)
struct FCAWeaponFireModeAdditionalAudioData final
{
public:
	TArray<struct FCAAudioEventType>              M_fire_sound_single;                               // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAAudioEventType>              M_secondary_fire_sound_single;                     // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAAudioEventType>              M_fire_sound_start;                                // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAAudioEventType>              M_fire_sound_stop;                                 // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_dry_fire_sound;                                  // 0x0040(0x0004)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_reload_start_sound;                              // 0x0044(0x0004)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_reload_stop_sound;                               // 0x0048(0x0004)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_clip_empty_sound;                                // 0x004C(0x0004)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UCAAudioBank>>    M_sound_banks;                                     // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAWeaponFireModeAdditionalAudioData) == 0x000008, "Wrong alignment on FCAWeaponFireModeAdditionalAudioData");
static_assert(sizeof(FCAWeaponFireModeAdditionalAudioData) == 0x000060, "Wrong size on FCAWeaponFireModeAdditionalAudioData");
static_assert(offsetof(FCAWeaponFireModeAdditionalAudioData, M_fire_sound_single) == 0x000000, "Member 'FCAWeaponFireModeAdditionalAudioData::M_fire_sound_single' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAdditionalAudioData, M_secondary_fire_sound_single) == 0x000010, "Member 'FCAWeaponFireModeAdditionalAudioData::M_secondary_fire_sound_single' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAdditionalAudioData, M_fire_sound_start) == 0x000020, "Member 'FCAWeaponFireModeAdditionalAudioData::M_fire_sound_start' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAdditionalAudioData, M_fire_sound_stop) == 0x000030, "Member 'FCAWeaponFireModeAdditionalAudioData::M_fire_sound_stop' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAdditionalAudioData, M_dry_fire_sound) == 0x000040, "Member 'FCAWeaponFireModeAdditionalAudioData::M_dry_fire_sound' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAdditionalAudioData, M_reload_start_sound) == 0x000044, "Member 'FCAWeaponFireModeAdditionalAudioData::M_reload_start_sound' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAdditionalAudioData, M_reload_stop_sound) == 0x000048, "Member 'FCAWeaponFireModeAdditionalAudioData::M_reload_stop_sound' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAdditionalAudioData, M_clip_empty_sound) == 0x00004C, "Member 'FCAWeaponFireModeAdditionalAudioData::M_clip_empty_sound' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAdditionalAudioData, M_sound_banks) == 0x000050, "Member 'FCAWeaponFireModeAdditionalAudioData::M_sound_banks' has a wrong offset!");

// ScriptStruct keaton.CAAudioFoostepTrackEntry
// 0x0018 (0x0018 - 0x0000)
struct FCAAudioFoostepTrackEntry final
{
public:
	class FString                                 Label;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAudioFoostepTrackEntry) == 0x000008, "Wrong alignment on FCAAudioFoostepTrackEntry");
static_assert(sizeof(FCAAudioFoostepTrackEntry) == 0x000018, "Wrong size on FCAAudioFoostepTrackEntry");
static_assert(offsetof(FCAAudioFoostepTrackEntry, Label) == 0x000000, "Member 'FCAAudioFoostepTrackEntry::Label' has a wrong offset!");
static_assert(offsetof(FCAAudioFoostepTrackEntry, Offset) == 0x000010, "Member 'FCAAudioFoostepTrackEntry::Offset' has a wrong offset!");

// ScriptStruct keaton.CAAudioFootstepTrackAdditionalSettings
// 0x0018 (0x0018 - 0x0000)
struct FCAAudioFootstepTrackAdditionalSettings final
{
public:
	float                                         SyncRate;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SyncThreshold;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotifyTimeout;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinNotifyTime;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Analogue;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnalogueSyncMaxRate;                               // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAudioFootstepTrackAdditionalSettings) == 0x000004, "Wrong alignment on FCAAudioFootstepTrackAdditionalSettings");
static_assert(sizeof(FCAAudioFootstepTrackAdditionalSettings) == 0x000018, "Wrong size on FCAAudioFootstepTrackAdditionalSettings");
static_assert(offsetof(FCAAudioFootstepTrackAdditionalSettings, SyncRate) == 0x000000, "Member 'FCAAudioFootstepTrackAdditionalSettings::SyncRate' has a wrong offset!");
static_assert(offsetof(FCAAudioFootstepTrackAdditionalSettings, SyncThreshold) == 0x000004, "Member 'FCAAudioFootstepTrackAdditionalSettings::SyncThreshold' has a wrong offset!");
static_assert(offsetof(FCAAudioFootstepTrackAdditionalSettings, NotifyTimeout) == 0x000008, "Member 'FCAAudioFootstepTrackAdditionalSettings::NotifyTimeout' has a wrong offset!");
static_assert(offsetof(FCAAudioFootstepTrackAdditionalSettings, MinNotifyTime) == 0x00000C, "Member 'FCAAudioFootstepTrackAdditionalSettings::MinNotifyTime' has a wrong offset!");
static_assert(offsetof(FCAAudioFootstepTrackAdditionalSettings, Analogue) == 0x000010, "Member 'FCAAudioFootstepTrackAdditionalSettings::Analogue' has a wrong offset!");
static_assert(offsetof(FCAAudioFootstepTrackAdditionalSettings, AnalogueSyncMaxRate) == 0x000014, "Member 'FCAAudioFootstepTrackAdditionalSettings::AnalogueSyncMaxRate' has a wrong offset!");

// ScriptStruct keaton.CAAudioFootstepTrack
// 0x0038 (0x0038 - 0x0000)
struct FCAAudioFootstepTrack final
{
public:
	ECAPlayerMovementMode                         MovementMode;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAAudioFoostepTrackEntry>      Triggers;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         CycleTime;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialDelay;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAAudioFootstepTrackAdditionalSettings AdditionalSettings;                                // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAudioFootstepTrack) == 0x000008, "Wrong alignment on FCAAudioFootstepTrack");
static_assert(sizeof(FCAAudioFootstepTrack) == 0x000038, "Wrong size on FCAAudioFootstepTrack");
static_assert(offsetof(FCAAudioFootstepTrack, MovementMode) == 0x000000, "Member 'FCAAudioFootstepTrack::MovementMode' has a wrong offset!");
static_assert(offsetof(FCAAudioFootstepTrack, Triggers) == 0x000008, "Member 'FCAAudioFootstepTrack::Triggers' has a wrong offset!");
static_assert(offsetof(FCAAudioFootstepTrack, CycleTime) == 0x000018, "Member 'FCAAudioFootstepTrack::CycleTime' has a wrong offset!");
static_assert(offsetof(FCAAudioFootstepTrack, InitialDelay) == 0x00001C, "Member 'FCAAudioFootstepTrack::InitialDelay' has a wrong offset!");
static_assert(offsetof(FCAAudioFootstepTrack, AdditionalSettings) == 0x000020, "Member 'FCAAudioFootstepTrack::AdditionalSettings' has a wrong offset!");

// ScriptStruct keaton.CAAudioProxyDialogueRequestParams
// 0x0018 (0x0018 - 0x0000)
struct FCAAudioProxyDialogueRequestParams final
{
public:
	uint32                                        Controller;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ACACharacter>            Character;                                         // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Trigger;                                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Dialogue_name;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Team_num;                                          // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAudioProxyDialogueRequestParams) == 0x000004, "Wrong alignment on FCAAudioProxyDialogueRequestParams");
static_assert(sizeof(FCAAudioProxyDialogueRequestParams) == 0x000018, "Wrong size on FCAAudioProxyDialogueRequestParams");
static_assert(offsetof(FCAAudioProxyDialogueRequestParams, Controller) == 0x000000, "Member 'FCAAudioProxyDialogueRequestParams::Controller' has a wrong offset!");
static_assert(offsetof(FCAAudioProxyDialogueRequestParams, Character) == 0x000004, "Member 'FCAAudioProxyDialogueRequestParams::Character' has a wrong offset!");
static_assert(offsetof(FCAAudioProxyDialogueRequestParams, Trigger) == 0x00000C, "Member 'FCAAudioProxyDialogueRequestParams::Trigger' has a wrong offset!");
static_assert(offsetof(FCAAudioProxyDialogueRequestParams, Dialogue_name) == 0x000010, "Member 'FCAAudioProxyDialogueRequestParams::Dialogue_name' has a wrong offset!");
static_assert(offsetof(FCAAudioProxyDialogueRequestParams, Team_num) == 0x000014, "Member 'FCAAudioProxyDialogueRequestParams::Team_num' has a wrong offset!");

// ScriptStruct keaton.CAServicesGraffitiTableRow
// 0x0038 (0x0040 - 0x0008)
struct FCAServicesGraffitiTableRow final : public FTableRowBase
{
public:
	struct FCAGameDatabaseRowHandle               M_handle;                                          // 0x0008(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_is_disabled;                                     // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_owned;                                        // 0x0021(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAObtainableOption>            M_obtain_options;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ECAAvailableVia                               M_available_via;                                   // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAServicesGraffitiTableRow) == 0x000008, "Wrong alignment on FCAServicesGraffitiTableRow");
static_assert(sizeof(FCAServicesGraffitiTableRow) == 0x000040, "Wrong size on FCAServicesGraffitiTableRow");
static_assert(offsetof(FCAServicesGraffitiTableRow, M_handle) == 0x000008, "Member 'FCAServicesGraffitiTableRow::M_handle' has a wrong offset!");
static_assert(offsetof(FCAServicesGraffitiTableRow, M_is_disabled) == 0x000020, "Member 'FCAServicesGraffitiTableRow::M_is_disabled' has a wrong offset!");
static_assert(offsetof(FCAServicesGraffitiTableRow, M_is_owned) == 0x000021, "Member 'FCAServicesGraffitiTableRow::M_is_owned' has a wrong offset!");
static_assert(offsetof(FCAServicesGraffitiTableRow, M_obtain_options) == 0x000028, "Member 'FCAServicesGraffitiTableRow::M_obtain_options' has a wrong offset!");
static_assert(offsetof(FCAServicesGraffitiTableRow, M_available_via) == 0x000038, "Member 'FCAServicesGraffitiTableRow::M_available_via' has a wrong offset!");

// ScriptStruct keaton.CAFastPathDebrisBulletTracerImpulse
// 0x002C (0x002C - 0x0000)
struct FCAFastPathDebrisBulletTracerImpulse final
{
public:
	struct FVector                                Trace_start;                                       // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Trace_end;                                         // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max_distance_along_trace;                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff_exponent_along_trace;                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius_falloff_exponent;                           // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFastPathDebrisBulletTracerImpulse) == 0x000004, "Wrong alignment on FCAFastPathDebrisBulletTracerImpulse");
static_assert(sizeof(FCAFastPathDebrisBulletTracerImpulse) == 0x00002C, "Wrong size on FCAFastPathDebrisBulletTracerImpulse");
static_assert(offsetof(FCAFastPathDebrisBulletTracerImpulse, Trace_start) == 0x000000, "Member 'FCAFastPathDebrisBulletTracerImpulse::Trace_start' has a wrong offset!");
static_assert(offsetof(FCAFastPathDebrisBulletTracerImpulse, Trace_end) == 0x00000C, "Member 'FCAFastPathDebrisBulletTracerImpulse::Trace_end' has a wrong offset!");
static_assert(offsetof(FCAFastPathDebrisBulletTracerImpulse, Strength) == 0x000018, "Member 'FCAFastPathDebrisBulletTracerImpulse::Strength' has a wrong offset!");
static_assert(offsetof(FCAFastPathDebrisBulletTracerImpulse, Max_distance_along_trace) == 0x00001C, "Member 'FCAFastPathDebrisBulletTracerImpulse::Max_distance_along_trace' has a wrong offset!");
static_assert(offsetof(FCAFastPathDebrisBulletTracerImpulse, Falloff_exponent_along_trace) == 0x000020, "Member 'FCAFastPathDebrisBulletTracerImpulse::Falloff_exponent_along_trace' has a wrong offset!");
static_assert(offsetof(FCAFastPathDebrisBulletTracerImpulse, Radius) == 0x000024, "Member 'FCAFastPathDebrisBulletTracerImpulse::Radius' has a wrong offset!");
static_assert(offsetof(FCAFastPathDebrisBulletTracerImpulse, Radius_falloff_exponent) == 0x000028, "Member 'FCAFastPathDebrisBulletTracerImpulse::Radius_falloff_exponent' has a wrong offset!");

// ScriptStruct keaton.CAAudioProxyReplicatedLocationArray
// 0x0030 (0x0138 - 0x0108)
struct FCAAudioProxyReplicatedLocationArray final : public FFastArraySerializer
{
public:
	TArray<struct FCAAudioProxyReplicatedLocationItem> Items;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAudioTransformListChanged;                       // 0x0118(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAudioTransformListRemoved;                       // 0x0128(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAudioProxyReplicatedLocationArray) == 0x000008, "Wrong alignment on FCAAudioProxyReplicatedLocationArray");
static_assert(sizeof(FCAAudioProxyReplicatedLocationArray) == 0x000138, "Wrong size on FCAAudioProxyReplicatedLocationArray");
static_assert(offsetof(FCAAudioProxyReplicatedLocationArray, Items) == 0x000108, "Member 'FCAAudioProxyReplicatedLocationArray::Items' has a wrong offset!");
static_assert(offsetof(FCAAudioProxyReplicatedLocationArray, OnAudioTransformListChanged) == 0x000118, "Member 'FCAAudioProxyReplicatedLocationArray::OnAudioTransformListChanged' has a wrong offset!");
static_assert(offsetof(FCAAudioProxyReplicatedLocationArray, OnAudioTransformListRemoved) == 0x000128, "Member 'FCAAudioProxyReplicatedLocationArray::OnAudioTransformListRemoved' has a wrong offset!");

// ScriptStruct keaton.CAAudioPhysicalInfo
// 0x0018 (0x0018 - 0x0000)
struct FCAAudioPhysicalInfo final
{
public:
	struct FVector_NetQuantize                    Location;                                          // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    Forward;                                           // 0x000C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAudioPhysicalInfo) == 0x000004, "Wrong alignment on FCAAudioPhysicalInfo");
static_assert(sizeof(FCAAudioPhysicalInfo) == 0x000018, "Wrong size on FCAAudioPhysicalInfo");
static_assert(offsetof(FCAAudioPhysicalInfo, Location) == 0x000000, "Member 'FCAAudioPhysicalInfo::Location' has a wrong offset!");
static_assert(offsetof(FCAAudioPhysicalInfo, Forward) == 0x00000C, "Member 'FCAAudioPhysicalInfo::Forward' has a wrong offset!");

// ScriptStruct keaton.CAAudioProxyStopParams
// 0x0040 (0x0040 - 0x0000)
struct FCAAudioProxyStopParams final
{
public:
	TArray<struct FCAAudioEventType>              M_event_array;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCAAudioEventType>              M_spectated_event_array;                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCAAudioInstigatorParams               M_instigator;                                      // 0x0020(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioPhysicalInfo                   M_physical_info;                                   // 0x0028(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAudioProxyStopParams) == 0x000008, "Wrong alignment on FCAAudioProxyStopParams");
static_assert(sizeof(FCAAudioProxyStopParams) == 0x000040, "Wrong size on FCAAudioProxyStopParams");
static_assert(offsetof(FCAAudioProxyStopParams, M_event_array) == 0x000000, "Member 'FCAAudioProxyStopParams::M_event_array' has a wrong offset!");
static_assert(offsetof(FCAAudioProxyStopParams, M_spectated_event_array) == 0x000010, "Member 'FCAAudioProxyStopParams::M_spectated_event_array' has a wrong offset!");
static_assert(offsetof(FCAAudioProxyStopParams, M_instigator) == 0x000020, "Member 'FCAAudioProxyStopParams::M_instigator' has a wrong offset!");
static_assert(offsetof(FCAAudioProxyStopParams, M_physical_info) == 0x000028, "Member 'FCAAudioProxyStopParams::M_physical_info' has a wrong offset!");

// ScriptStruct keaton.ServicesLuaFile
// 0x0020 (0x0020 - 0x0000)
struct FServicesLuaFile final
{
public:
	class FString                                 Content;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FServicesLuaFile) == 0x000008, "Wrong alignment on FServicesLuaFile");
static_assert(sizeof(FServicesLuaFile) == 0x000020, "Wrong size on FServicesLuaFile");
static_assert(offsetof(FServicesLuaFile, Content) == 0x000000, "Member 'FServicesLuaFile::Content' has a wrong offset!");
static_assert(offsetof(FServicesLuaFile, Name) == 0x000010, "Member 'FServicesLuaFile::Name' has a wrong offset!");

// ScriptStruct keaton.CADetectedActorData
// 0x0010 (0x0010 - 0x0000)
struct FCADetectedActorData final
{
public:
	class AActor*                                 M_detected_actor;                                  // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECADetectorType                               M_detector_type;                                   // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_time_in_seconds;                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADetectedActorData) == 0x000008, "Wrong alignment on FCADetectedActorData");
static_assert(sizeof(FCADetectedActorData) == 0x000010, "Wrong size on FCADetectedActorData");
static_assert(offsetof(FCADetectedActorData, M_detected_actor) == 0x000000, "Member 'FCADetectedActorData::M_detected_actor' has a wrong offset!");
static_assert(offsetof(FCADetectedActorData, M_detector_type) == 0x000008, "Member 'FCADetectedActorData::M_detector_type' has a wrong offset!");
static_assert(offsetof(FCADetectedActorData, M_time_in_seconds) == 0x00000C, "Member 'FCADetectedActorData::M_time_in_seconds' has a wrong offset!");

// ScriptStruct keaton.CAAudioSwitchParams
// 0x0008 (0x0008 - 0x0000)
struct FCAAudioSwitchParams final
{
public:
	uint32                                        Name;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Value;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAudioSwitchParams) == 0x000004, "Wrong alignment on FCAAudioSwitchParams");
static_assert(sizeof(FCAAudioSwitchParams) == 0x000008, "Wrong size on FCAAudioSwitchParams");
static_assert(offsetof(FCAAudioSwitchParams, Name) == 0x000000, "Member 'FCAAudioSwitchParams::Name' has a wrong offset!");
static_assert(offsetof(FCAAudioSwitchParams, Value) == 0x000004, "Member 'FCAAudioSwitchParams::Value' has a wrong offset!");

// ScriptStruct keaton.CAAudioProxySingleParams
// 0x0050 (0x0050 - 0x0000)
struct FCAAudioProxySingleParams
{
public:
	TArray<struct FCAAudioEventType>              M_event_array;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCAAudioEventType>              M_spectated_event_array;                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCAAudioSwitchParams                   M_switch_params;                                   // 0x0020(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioPhysicalInfo                   M_physical_info;                                   // 0x0028(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioInstigatorParams               M_instigator;                                      // 0x0040(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_single_shot_weapon;                              // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAudioProxySingleParams) == 0x000008, "Wrong alignment on FCAAudioProxySingleParams");
static_assert(sizeof(FCAAudioProxySingleParams) == 0x000050, "Wrong size on FCAAudioProxySingleParams");
static_assert(offsetof(FCAAudioProxySingleParams, M_event_array) == 0x000000, "Member 'FCAAudioProxySingleParams::M_event_array' has a wrong offset!");
static_assert(offsetof(FCAAudioProxySingleParams, M_spectated_event_array) == 0x000010, "Member 'FCAAudioProxySingleParams::M_spectated_event_array' has a wrong offset!");
static_assert(offsetof(FCAAudioProxySingleParams, M_switch_params) == 0x000020, "Member 'FCAAudioProxySingleParams::M_switch_params' has a wrong offset!");
static_assert(offsetof(FCAAudioProxySingleParams, M_physical_info) == 0x000028, "Member 'FCAAudioProxySingleParams::M_physical_info' has a wrong offset!");
static_assert(offsetof(FCAAudioProxySingleParams, M_instigator) == 0x000040, "Member 'FCAAudioProxySingleParams::M_instigator' has a wrong offset!");
static_assert(offsetof(FCAAudioProxySingleParams, M_single_shot_weapon) == 0x000048, "Member 'FCAAudioProxySingleParams::M_single_shot_weapon' has a wrong offset!");

// ScriptStruct keaton.CATeamSummaryMetaData
// 0x0038 (0x0038 - 0x0000)
struct FCATeamSummaryMetaData final
{
public:
	struct FDataTableRowHandle                    M_killed_category_handle;                          // 0x0000(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    M_assistkilled_category_handle;                    // 0x0018(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         M_num_of_displayed_battle_stats;                   // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCATeamSummaryMetaData) == 0x000008, "Wrong alignment on FCATeamSummaryMetaData");
static_assert(sizeof(FCATeamSummaryMetaData) == 0x000038, "Wrong size on FCATeamSummaryMetaData");
static_assert(offsetof(FCATeamSummaryMetaData, M_killed_category_handle) == 0x000000, "Member 'FCATeamSummaryMetaData::M_killed_category_handle' has a wrong offset!");
static_assert(offsetof(FCATeamSummaryMetaData, M_assistkilled_category_handle) == 0x000018, "Member 'FCATeamSummaryMetaData::M_assistkilled_category_handle' has a wrong offset!");
static_assert(offsetof(FCATeamSummaryMetaData, M_num_of_displayed_battle_stats) == 0x000030, "Member 'FCATeamSummaryMetaData::M_num_of_displayed_battle_stats' has a wrong offset!");

// ScriptStruct keaton.CAHUDActionIconsRow
// 0x0048 (0x0050 - 0x0008)
struct FCAHUDActionIconsRow final : public FTableRowBase
{
public:
	class UTexture2D*                             M_pc_icon;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             M_xbox_icon;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             M_playstation_icon;                                // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_pc_icon_text;                                    // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_xbox_icon_text;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_playstation_icon_text;                           // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDActionIconsRow) == 0x000008, "Wrong alignment on FCAHUDActionIconsRow");
static_assert(sizeof(FCAHUDActionIconsRow) == 0x000050, "Wrong size on FCAHUDActionIconsRow");
static_assert(offsetof(FCAHUDActionIconsRow, M_pc_icon) == 0x000008, "Member 'FCAHUDActionIconsRow::M_pc_icon' has a wrong offset!");
static_assert(offsetof(FCAHUDActionIconsRow, M_xbox_icon) == 0x000010, "Member 'FCAHUDActionIconsRow::M_xbox_icon' has a wrong offset!");
static_assert(offsetof(FCAHUDActionIconsRow, M_playstation_icon) == 0x000018, "Member 'FCAHUDActionIconsRow::M_playstation_icon' has a wrong offset!");
static_assert(offsetof(FCAHUDActionIconsRow, M_pc_icon_text) == 0x000020, "Member 'FCAHUDActionIconsRow::M_pc_icon_text' has a wrong offset!");
static_assert(offsetof(FCAHUDActionIconsRow, M_xbox_icon_text) == 0x000030, "Member 'FCAHUDActionIconsRow::M_xbox_icon_text' has a wrong offset!");
static_assert(offsetof(FCAHUDActionIconsRow, M_playstation_icon_text) == 0x000040, "Member 'FCAHUDActionIconsRow::M_playstation_icon_text' has a wrong offset!");

// ScriptStruct keaton.CAAudioProxyLoopParams
// 0x0008 (0x0058 - 0x0050)
struct FCAAudioProxyLoopParams final : public FCAAudioProxySingleParams
{
public:
	struct FCAAudioProxyRTPCParams                M_rtpc;                                            // 0x0050(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAudioProxyLoopParams) == 0x000008, "Wrong alignment on FCAAudioProxyLoopParams");
static_assert(sizeof(FCAAudioProxyLoopParams) == 0x000058, "Wrong size on FCAAudioProxyLoopParams");
static_assert(offsetof(FCAAudioProxyLoopParams, M_rtpc) == 0x000050, "Member 'FCAAudioProxyLoopParams::M_rtpc' has a wrong offset!");

// ScriptStruct keaton.CAFragGrenadeDataTableRow
// 0x0070 (0x0078 - 0x0008)
struct FCAFragGrenadeDataTableRow final : public FTableRowBase
{
public:
	int32                                         M_upgrade_level;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAAOEDetonationType                          Detonation_type;                                   // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAGameplayEffectGravityValue                 M_gravity_value;                                   // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fuse_time;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_radius;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_damage;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_elite_multiplier;                                // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_npc_multiplier;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_foam_multiplier;                                 // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_lifesteal_max;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_lifesteal_min;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_gravity_scale;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_bounciness;                                      // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_friction;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACAExplosionEffect>         M_explosion_effect;                                // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAGameplayEffectContainer             M_effect_container;                                // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          M_bounced;                                         // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAFragGrenadeBounceDataRow>    M_bounces_data;                                    // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFragGrenadeDataTableRow) == 0x000008, "Wrong alignment on FCAFragGrenadeDataTableRow");
static_assert(sizeof(FCAFragGrenadeDataTableRow) == 0x000078, "Wrong size on FCAFragGrenadeDataTableRow");
static_assert(offsetof(FCAFragGrenadeDataTableRow, M_upgrade_level) == 0x000008, "Member 'FCAFragGrenadeDataTableRow::M_upgrade_level' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeDataTableRow, Detonation_type) == 0x00000C, "Member 'FCAFragGrenadeDataTableRow::Detonation_type' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeDataTableRow, M_gravity_value) == 0x00000D, "Member 'FCAFragGrenadeDataTableRow::M_gravity_value' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeDataTableRow, M_fuse_time) == 0x000010, "Member 'FCAFragGrenadeDataTableRow::M_fuse_time' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeDataTableRow, M_radius) == 0x000014, "Member 'FCAFragGrenadeDataTableRow::M_radius' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeDataTableRow, M_damage) == 0x000018, "Member 'FCAFragGrenadeDataTableRow::M_damage' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeDataTableRow, M_elite_multiplier) == 0x00001C, "Member 'FCAFragGrenadeDataTableRow::M_elite_multiplier' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeDataTableRow, M_npc_multiplier) == 0x000020, "Member 'FCAFragGrenadeDataTableRow::M_npc_multiplier' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeDataTableRow, M_foam_multiplier) == 0x000024, "Member 'FCAFragGrenadeDataTableRow::M_foam_multiplier' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeDataTableRow, M_lifesteal_max) == 0x000028, "Member 'FCAFragGrenadeDataTableRow::M_lifesteal_max' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeDataTableRow, M_lifesteal_min) == 0x00002C, "Member 'FCAFragGrenadeDataTableRow::M_lifesteal_min' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeDataTableRow, M_gravity_scale) == 0x000030, "Member 'FCAFragGrenadeDataTableRow::M_gravity_scale' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeDataTableRow, M_bounciness) == 0x000034, "Member 'FCAFragGrenadeDataTableRow::M_bounciness' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeDataTableRow, M_friction) == 0x000038, "Member 'FCAFragGrenadeDataTableRow::M_friction' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeDataTableRow, M_explosion_effect) == 0x000040, "Member 'FCAFragGrenadeDataTableRow::M_explosion_effect' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeDataTableRow, M_effect_container) == 0x000048, "Member 'FCAFragGrenadeDataTableRow::M_effect_container' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeDataTableRow, M_bounced) == 0x000060, "Member 'FCAFragGrenadeDataTableRow::M_bounced' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeDataTableRow, M_bounces_data) == 0x000068, "Member 'FCAFragGrenadeDataTableRow::M_bounces_data' has a wrong offset!");

// ScriptStruct keaton.ProjectilePathVertex
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FProjectilePathVertex final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectilePathVertex) == 0x000004, "Wrong alignment on FProjectilePathVertex");
static_assert(sizeof(FProjectilePathVertex) == 0x00001C, "Wrong size on FProjectilePathVertex");

// ScriptStruct keaton.CAActionBindingSymbols
// 0x0008 (0x0010 - 0x0008)
struct FCAActionBindingSymbols final : public FTableRowBase
{
public:
	class UCABaseActionBindingSymbol*             M_symbol;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAActionBindingSymbols) == 0x000008, "Wrong alignment on FCAActionBindingSymbols");
static_assert(sizeof(FCAActionBindingSymbols) == 0x000010, "Wrong size on FCAActionBindingSymbols");
static_assert(offsetof(FCAActionBindingSymbols, M_symbol) == 0x000008, "Member 'FCAActionBindingSymbols::M_symbol' has a wrong offset!");

// ScriptStruct keaton.CADoLaterQueueItem
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FCADoLaterQueueItem final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADoLaterQueueItem) == 0x000004, "Wrong alignment on FCADoLaterQueueItem");
static_assert(sizeof(FCADoLaterQueueItem) == 0x00001C, "Wrong size on FCADoLaterQueueItem");

// ScriptStruct keaton.CANavMeshAnalyserTaskCoverData
// 0x0018 (0x0018 - 0x0000)
struct FCANavMeshAnalyserTaskCoverData final
{
public:
	float                                         Low_cover_test_height;                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         High_cover_test_height;                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Shoot_capability_side_offset;                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Shoot_capability_test_distance;                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cover_test_distance;                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cover_railing_test_count;                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANavMeshAnalyserTaskCoverData) == 0x000004, "Wrong alignment on FCANavMeshAnalyserTaskCoverData");
static_assert(sizeof(FCANavMeshAnalyserTaskCoverData) == 0x000018, "Wrong size on FCANavMeshAnalyserTaskCoverData");
static_assert(offsetof(FCANavMeshAnalyserTaskCoverData, Low_cover_test_height) == 0x000000, "Member 'FCANavMeshAnalyserTaskCoverData::Low_cover_test_height' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskCoverData, High_cover_test_height) == 0x000004, "Member 'FCANavMeshAnalyserTaskCoverData::High_cover_test_height' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskCoverData, Shoot_capability_side_offset) == 0x000008, "Member 'FCANavMeshAnalyserTaskCoverData::Shoot_capability_side_offset' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskCoverData, Shoot_capability_test_distance) == 0x00000C, "Member 'FCANavMeshAnalyserTaskCoverData::Shoot_capability_test_distance' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskCoverData, Cover_test_distance) == 0x000010, "Member 'FCANavMeshAnalyserTaskCoverData::Cover_test_distance' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskCoverData, Cover_railing_test_count) == 0x000014, "Member 'FCANavMeshAnalyserTaskCoverData::Cover_railing_test_count' has a wrong offset!");

// ScriptStruct keaton.CANavMeshAnalyserTaskJumpClassData
// 0x0008 (0x0018 - 0x0010)
struct FCANavMeshAnalyserTaskJumpClassData final : public FCANavMeshAnalyserTaskClassData
{
public:
	float                                         Jump_max_height;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANavMeshAnalyserTaskJumpClassData) == 0x000008, "Wrong alignment on FCANavMeshAnalyserTaskJumpClassData");
static_assert(sizeof(FCANavMeshAnalyserTaskJumpClassData) == 0x000018, "Wrong size on FCANavMeshAnalyserTaskJumpClassData");
static_assert(offsetof(FCANavMeshAnalyserTaskJumpClassData, Jump_max_height) == 0x000010, "Member 'FCANavMeshAnalyserTaskJumpClassData::Jump_max_height' has a wrong offset!");

// ScriptStruct keaton.CANavMeshAnalyserTaskJumpData
// 0x0028 (0x0060 - 0x0038)
struct FCANavMeshAnalyserTaskJumpData final : public FCANavMeshAnalyserTaskTypeData
{
public:
	float                                         Jump_min_height;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCANavMeshAnalyserTaskJumpClassData> Jump_classes;                                      // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Min_jump_start_horizontal_distance;                // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max_jump_start_horizontal_distance;                // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Jump_start_horizontal_distance_step;               // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Jump_end_horizontal_distance;                      // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANavMeshAnalyserTaskJumpData) == 0x000008, "Wrong alignment on FCANavMeshAnalyserTaskJumpData");
static_assert(sizeof(FCANavMeshAnalyserTaskJumpData) == 0x000060, "Wrong size on FCANavMeshAnalyserTaskJumpData");
static_assert(offsetof(FCANavMeshAnalyserTaskJumpData, Jump_min_height) == 0x000038, "Member 'FCANavMeshAnalyserTaskJumpData::Jump_min_height' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskJumpData, Jump_classes) == 0x000040, "Member 'FCANavMeshAnalyserTaskJumpData::Jump_classes' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskJumpData, Min_jump_start_horizontal_distance) == 0x000050, "Member 'FCANavMeshAnalyserTaskJumpData::Min_jump_start_horizontal_distance' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskJumpData, Max_jump_start_horizontal_distance) == 0x000054, "Member 'FCANavMeshAnalyserTaskJumpData::Max_jump_start_horizontal_distance' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskJumpData, Jump_start_horizontal_distance_step) == 0x000058, "Member 'FCANavMeshAnalyserTaskJumpData::Jump_start_horizontal_distance_step' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskJumpData, Jump_end_horizontal_distance) == 0x00005C, "Member 'FCANavMeshAnalyserTaskJumpData::Jump_end_horizontal_distance' has a wrong offset!");

// ScriptStruct keaton.CANavMeshAnalyserTaskDropClassData
// 0x0008 (0x0018 - 0x0010)
struct FCANavMeshAnalyserTaskDropClassData final : public FCANavMeshAnalyserTaskClassData
{
public:
	float                                         Drop_max_height;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANavMeshAnalyserTaskDropClassData) == 0x000008, "Wrong alignment on FCANavMeshAnalyserTaskDropClassData");
static_assert(sizeof(FCANavMeshAnalyserTaskDropClassData) == 0x000018, "Wrong size on FCANavMeshAnalyserTaskDropClassData");
static_assert(offsetof(FCANavMeshAnalyserTaskDropClassData, Drop_max_height) == 0x000010, "Member 'FCANavMeshAnalyserTaskDropClassData::Drop_max_height' has a wrong offset!");

// ScriptStruct keaton.CANavMeshAnalyserTaskDropData
// 0x0028 (0x0060 - 0x0038)
struct FCANavMeshAnalyserTaskDropData final : public FCANavMeshAnalyserTaskTypeData
{
public:
	float                                         Drop_min_height;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCANavMeshAnalyserTaskDropClassData> Drop_classes;                                      // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Min_drop_start_horizontal_distance;                // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max_drop_start_horizontal_distance;                // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Drop_start_horizontal_distance_step;               // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANavMeshAnalyserTaskDropData) == 0x000008, "Wrong alignment on FCANavMeshAnalyserTaskDropData");
static_assert(sizeof(FCANavMeshAnalyserTaskDropData) == 0x000060, "Wrong size on FCANavMeshAnalyserTaskDropData");
static_assert(offsetof(FCANavMeshAnalyserTaskDropData, Drop_min_height) == 0x000038, "Member 'FCANavMeshAnalyserTaskDropData::Drop_min_height' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskDropData, Drop_classes) == 0x000040, "Member 'FCANavMeshAnalyserTaskDropData::Drop_classes' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskDropData, Min_drop_start_horizontal_distance) == 0x000050, "Member 'FCANavMeshAnalyserTaskDropData::Min_drop_start_horizontal_distance' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskDropData, Max_drop_start_horizontal_distance) == 0x000054, "Member 'FCANavMeshAnalyserTaskDropData::Max_drop_start_horizontal_distance' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskDropData, Drop_start_horizontal_distance_step) == 0x000058, "Member 'FCANavMeshAnalyserTaskDropData::Drop_start_horizontal_distance_step' has a wrong offset!");

// ScriptStruct keaton.CANavMeshAnalyserTaskVaultData
// 0x0040 (0x0078 - 0x0038)
struct FCANavMeshAnalyserTaskVaultData final : public FCANavMeshAnalyserTaskTypeData
{
public:
	float                                         Vault_jump_min_height;                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Vault_drop_min_height;                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCANavMeshAnalyserTaskVaultClassData> Vault_classes;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Vault_start_horizontal_distance;                   // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Vault_end_horizontal_distance;                     // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Vault_nav_leniency;                                // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Vault_mid_clearing_checks;                         // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Minimum_unmodified_height_value;                   // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Initial_vault_thrust_value;                        // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Vault_thrust_weight_value;                         // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Initial_vault_arc_param_value;                     // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Vault_arc_param_weight_value;                      // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANavMeshAnalyserTaskVaultData) == 0x000008, "Wrong alignment on FCANavMeshAnalyserTaskVaultData");
static_assert(sizeof(FCANavMeshAnalyserTaskVaultData) == 0x000078, "Wrong size on FCANavMeshAnalyserTaskVaultData");
static_assert(offsetof(FCANavMeshAnalyserTaskVaultData, Vault_jump_min_height) == 0x000038, "Member 'FCANavMeshAnalyserTaskVaultData::Vault_jump_min_height' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskVaultData, Vault_drop_min_height) == 0x00003C, "Member 'FCANavMeshAnalyserTaskVaultData::Vault_drop_min_height' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskVaultData, Vault_classes) == 0x000040, "Member 'FCANavMeshAnalyserTaskVaultData::Vault_classes' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskVaultData, Vault_start_horizontal_distance) == 0x000050, "Member 'FCANavMeshAnalyserTaskVaultData::Vault_start_horizontal_distance' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskVaultData, Vault_end_horizontal_distance) == 0x000054, "Member 'FCANavMeshAnalyserTaskVaultData::Vault_end_horizontal_distance' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskVaultData, Vault_nav_leniency) == 0x000058, "Member 'FCANavMeshAnalyserTaskVaultData::Vault_nav_leniency' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskVaultData, Vault_mid_clearing_checks) == 0x00005C, "Member 'FCANavMeshAnalyserTaskVaultData::Vault_mid_clearing_checks' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskVaultData, Minimum_unmodified_height_value) == 0x000060, "Member 'FCANavMeshAnalyserTaskVaultData::Minimum_unmodified_height_value' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskVaultData, Initial_vault_thrust_value) == 0x000064, "Member 'FCANavMeshAnalyserTaskVaultData::Initial_vault_thrust_value' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskVaultData, Vault_thrust_weight_value) == 0x000068, "Member 'FCANavMeshAnalyserTaskVaultData::Vault_thrust_weight_value' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskVaultData, Initial_vault_arc_param_value) == 0x00006C, "Member 'FCANavMeshAnalyserTaskVaultData::Initial_vault_arc_param_value' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskVaultData, Vault_arc_param_weight_value) == 0x000070, "Member 'FCANavMeshAnalyserTaskVaultData::Vault_arc_param_weight_value' has a wrong offset!");

// ScriptStruct keaton.CANavMeshAnalyserTaskData
// 0x0168 (0x0168 - 0x0000)
struct FCANavMeshAnalyserTaskData final
{
public:
	struct FCANavMeshAnalyserTaskCoverData        Cover_data;                                        // 0x0000(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCANavMeshAnalyserTaskJumpData         Jump_data;                                         // 0x0018(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FCANavMeshAnalyserTaskDropData         Drop_data;                                         // 0x0078(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FCANavMeshAnalyserTaskVaultData        Vault_data;                                        // 0x00D8(0x0078)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FCANavMeshAnalyserTaskNPCPathData> Npc_path_data;                                     // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Edge_walking_step;                                 // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Nav_mesh_hole_distance;                            // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANavMeshAnalyserTaskData) == 0x000008, "Wrong alignment on FCANavMeshAnalyserTaskData");
static_assert(sizeof(FCANavMeshAnalyserTaskData) == 0x000168, "Wrong size on FCANavMeshAnalyserTaskData");
static_assert(offsetof(FCANavMeshAnalyserTaskData, Cover_data) == 0x000000, "Member 'FCANavMeshAnalyserTaskData::Cover_data' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskData, Jump_data) == 0x000018, "Member 'FCANavMeshAnalyserTaskData::Jump_data' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskData, Drop_data) == 0x000078, "Member 'FCANavMeshAnalyserTaskData::Drop_data' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskData, Vault_data) == 0x0000D8, "Member 'FCANavMeshAnalyserTaskData::Vault_data' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskData, Npc_path_data) == 0x000150, "Member 'FCANavMeshAnalyserTaskData::Npc_path_data' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskData, Edge_walking_step) == 0x000160, "Member 'FCANavMeshAnalyserTaskData::Edge_walking_step' has a wrong offset!");
static_assert(offsetof(FCANavMeshAnalyserTaskData, Nav_mesh_hole_distance) == 0x000164, "Member 'FCANavMeshAnalyserTaskData::Nav_mesh_hole_distance' has a wrong offset!");

// ScriptStruct keaton.CAFTUEBehaviourItem
// 0x0080 (0x0080 - 0x0000)
struct FCAFTUEBehaviourItem final
{
public:
	TSet<ECAFTUETrackingFlag>                     M_tracking_flags;                                  // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_behaviour_class;                                 // 0x0050(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFTUEBehaviourItem) == 0x000008, "Wrong alignment on FCAFTUEBehaviourItem");
static_assert(sizeof(FCAFTUEBehaviourItem) == 0x000080, "Wrong size on FCAFTUEBehaviourItem");
static_assert(offsetof(FCAFTUEBehaviourItem, M_tracking_flags) == 0x000000, "Member 'FCAFTUEBehaviourItem::M_tracking_flags' has a wrong offset!");
static_assert(offsetof(FCAFTUEBehaviourItem, M_behaviour_class) == 0x000050, "Member 'FCAFTUEBehaviourItem::M_behaviour_class' has a wrong offset!");

// ScriptStruct keaton.CAHUDBaseDataStruct
// 0x0000 (0x0008 - 0x0008)
struct FCAHUDBaseDataStruct : public FTableRowBase
{
};
static_assert(alignof(FCAHUDBaseDataStruct) == 0x000008, "Wrong alignment on FCAHUDBaseDataStruct");
static_assert(sizeof(FCAHUDBaseDataStruct) == 0x000008, "Wrong size on FCAHUDBaseDataStruct");

// ScriptStruct keaton.CAHUDAmmoDataStruct
// 0x0008 (0x0010 - 0x0008)
struct FCAHUDAmmoDataStruct final : public FCAHUDBaseDataStruct
{
public:
	int32                                         Max_ammo;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Current_ammo;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDAmmoDataStruct) == 0x000008, "Wrong alignment on FCAHUDAmmoDataStruct");
static_assert(sizeof(FCAHUDAmmoDataStruct) == 0x000010, "Wrong size on FCAHUDAmmoDataStruct");
static_assert(offsetof(FCAHUDAmmoDataStruct, Max_ammo) == 0x000008, "Member 'FCAHUDAmmoDataStruct::Max_ammo' has a wrong offset!");
static_assert(offsetof(FCAHUDAmmoDataStruct, Current_ammo) == 0x00000C, "Member 'FCAHUDAmmoDataStruct::Current_ammo' has a wrong offset!");

// ScriptStruct keaton.CAIndicatorInfo
// 0x0078 (0x0078 - 0x0000)
struct FCAIndicatorInfo final
{
public:
	struct FCAText                                M_ca_localisable_text;                             // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_unlocalisable_text;                              // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_image;                                           // 0x0048(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAIndicatorInfo) == 0x000008, "Wrong alignment on FCAIndicatorInfo");
static_assert(sizeof(FCAIndicatorInfo) == 0x000078, "Wrong size on FCAIndicatorInfo");
static_assert(offsetof(FCAIndicatorInfo, M_ca_localisable_text) == 0x000000, "Member 'FCAIndicatorInfo::M_ca_localisable_text' has a wrong offset!");
static_assert(offsetof(FCAIndicatorInfo, M_unlocalisable_text) == 0x000030, "Member 'FCAIndicatorInfo::M_unlocalisable_text' has a wrong offset!");
static_assert(offsetof(FCAIndicatorInfo, M_image) == 0x000048, "Member 'FCAIndicatorInfo::M_image' has a wrong offset!");

// ScriptStruct keaton.CAScreenTransition
// 0x0030 (0x0030 - 0x0000)
struct FCAScreenTransition final
{
public:
	class UCABaseScreen*                          M_screen;                                          // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            M_curve;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x20];                                      // 0x0010(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAScreenTransition) == 0x000008, "Wrong alignment on FCAScreenTransition");
static_assert(sizeof(FCAScreenTransition) == 0x000030, "Wrong size on FCAScreenTransition");
static_assert(offsetof(FCAScreenTransition, M_screen) == 0x000000, "Member 'FCAScreenTransition::M_screen' has a wrong offset!");
static_assert(offsetof(FCAScreenTransition, M_curve) == 0x000008, "Member 'FCAScreenTransition::M_curve' has a wrong offset!");

// ScriptStruct keaton.CANiagaraVariableFloatPair
// 0x0010 (0x0010 - 0x0000)
struct FCANiagaraVariableFloatPair final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANiagaraVariableFloatPair) == 0x000004, "Wrong alignment on FCANiagaraVariableFloatPair");
static_assert(sizeof(FCANiagaraVariableFloatPair) == 0x000010, "Wrong size on FCANiagaraVariableFloatPair");
static_assert(offsetof(FCANiagaraVariableFloatPair, Name) == 0x000000, "Member 'FCANiagaraVariableFloatPair::Name' has a wrong offset!");
static_assert(offsetof(FCANiagaraVariableFloatPair, Value) == 0x00000C, "Member 'FCANiagaraVariableFloatPair::Value' has a wrong offset!");

// ScriptStruct keaton.CAServicesSpecialistItem
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FCAServicesSpecialistItem final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAServicesSpecialistItem) == 0x000004, "Wrong alignment on FCAServicesSpecialistItem");
static_assert(sizeof(FCAServicesSpecialistItem) == 0x000010, "Wrong size on FCAServicesSpecialistItem");

// ScriptStruct keaton.CABaseActionElementCustomization
// 0x02C8 (0x02D0 - 0x0008)
struct FCABaseActionElementCustomization final : public FTableRowBase
{
public:
	struct FButtonStyle                           M_button_style;                                    // 0x0008(0x02A8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   M_text_style;                                      // 0x02B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_symbol_on_left;                                  // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCABaseActionElementCustomization) == 0x000008, "Wrong alignment on FCABaseActionElementCustomization");
static_assert(sizeof(FCABaseActionElementCustomization) == 0x0002D0, "Wrong size on FCABaseActionElementCustomization");
static_assert(offsetof(FCABaseActionElementCustomization, M_button_style) == 0x000008, "Member 'FCABaseActionElementCustomization::M_button_style' has a wrong offset!");
static_assert(offsetof(FCABaseActionElementCustomization, M_text_style) == 0x0002B0, "Member 'FCABaseActionElementCustomization::M_text_style' has a wrong offset!");
static_assert(offsetof(FCABaseActionElementCustomization, M_symbol_on_left) == 0x0002C8, "Member 'FCABaseActionElementCustomization::M_symbol_on_left' has a wrong offset!");

// ScriptStruct keaton.CALocalisationEntry
// 0x0010 (0x0018 - 0x0008)
struct FCALocalisationEntry final : public FTableRowBase
{
public:
	int64                                         M_loc_table_guid_hash;                             // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         M_loc_id_hash;                                     // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALocalisationEntry) == 0x000008, "Wrong alignment on FCALocalisationEntry");
static_assert(sizeof(FCALocalisationEntry) == 0x000018, "Wrong size on FCALocalisationEntry");
static_assert(offsetof(FCALocalisationEntry, M_loc_table_guid_hash) == 0x000008, "Member 'FCALocalisationEntry::M_loc_table_guid_hash' has a wrong offset!");
static_assert(offsetof(FCALocalisationEntry, M_loc_id_hash) == 0x000010, "Member 'FCALocalisationEntry::M_loc_id_hash' has a wrong offset!");

// ScriptStruct keaton.CAChallengeDefinition
// 0x0030 (0x0030 - 0x0000)
struct FCAChallengeDefinition final
{
public:
	class FString                                 M_challenge_key;                                   // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_threshold;                                       // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_progress;                                        // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_dependency_logic;                                // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_persistent;                                   // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_team_challenge;                               // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAChallengeDefinition) == 0x000008, "Wrong alignment on FCAChallengeDefinition");
static_assert(sizeof(FCAChallengeDefinition) == 0x000030, "Wrong size on FCAChallengeDefinition");
static_assert(offsetof(FCAChallengeDefinition, M_challenge_key) == 0x000000, "Member 'FCAChallengeDefinition::M_challenge_key' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinition, M_threshold) == 0x000010, "Member 'FCAChallengeDefinition::M_threshold' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinition, M_progress) == 0x000014, "Member 'FCAChallengeDefinition::M_progress' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinition, M_dependency_logic) == 0x000018, "Member 'FCAChallengeDefinition::M_dependency_logic' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinition, M_is_persistent) == 0x000028, "Member 'FCAChallengeDefinition::M_is_persistent' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinition, M_is_team_challenge) == 0x000029, "Member 'FCAChallengeDefinition::M_is_team_challenge' has a wrong offset!");

// ScriptStruct keaton.CAServicesChallengeTableRow
// 0x00B8 (0x00C0 - 0x0008)
struct FCAServicesChallengeTableRow : public FTableRowBase
{
public:
	struct FCALocalisationEntry                   M_title;                                           // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCALocalisationEntry                   M_description;                                     // 0x0020(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         M_progress;                                        // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_progress_target;                                 // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_visibility_type;                                 // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         M_ts_from;                                         // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         M_ts_to;                                           // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAChallengeDefinition>         M_challenge_definitions;                           // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 M_challenge_combination_logic;                     // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_challenge_celebration_on_success;                // 0x0080(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_locked;                                       // 0x0081(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_claim_me;                                        // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_reward_package;                                  // 0x0098(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 M_challenge_type;                                  // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAServicesChallengeTableRow) == 0x000008, "Wrong alignment on FCAServicesChallengeTableRow");
static_assert(sizeof(FCAServicesChallengeTableRow) == 0x0000C0, "Wrong size on FCAServicesChallengeTableRow");
static_assert(offsetof(FCAServicesChallengeTableRow, M_title) == 0x000008, "Member 'FCAServicesChallengeTableRow::M_title' has a wrong offset!");
static_assert(offsetof(FCAServicesChallengeTableRow, M_description) == 0x000020, "Member 'FCAServicesChallengeTableRow::M_description' has a wrong offset!");
static_assert(offsetof(FCAServicesChallengeTableRow, M_progress) == 0x000038, "Member 'FCAServicesChallengeTableRow::M_progress' has a wrong offset!");
static_assert(offsetof(FCAServicesChallengeTableRow, M_progress_target) == 0x00003C, "Member 'FCAServicesChallengeTableRow::M_progress_target' has a wrong offset!");
static_assert(offsetof(FCAServicesChallengeTableRow, M_visibility_type) == 0x000040, "Member 'FCAServicesChallengeTableRow::M_visibility_type' has a wrong offset!");
static_assert(offsetof(FCAServicesChallengeTableRow, M_ts_from) == 0x000050, "Member 'FCAServicesChallengeTableRow::M_ts_from' has a wrong offset!");
static_assert(offsetof(FCAServicesChallengeTableRow, M_ts_to) == 0x000058, "Member 'FCAServicesChallengeTableRow::M_ts_to' has a wrong offset!");
static_assert(offsetof(FCAServicesChallengeTableRow, M_challenge_definitions) == 0x000060, "Member 'FCAServicesChallengeTableRow::M_challenge_definitions' has a wrong offset!");
static_assert(offsetof(FCAServicesChallengeTableRow, M_challenge_combination_logic) == 0x000070, "Member 'FCAServicesChallengeTableRow::M_challenge_combination_logic' has a wrong offset!");
static_assert(offsetof(FCAServicesChallengeTableRow, M_challenge_celebration_on_success) == 0x000080, "Member 'FCAServicesChallengeTableRow::M_challenge_celebration_on_success' has a wrong offset!");
static_assert(offsetof(FCAServicesChallengeTableRow, M_is_locked) == 0x000081, "Member 'FCAServicesChallengeTableRow::M_is_locked' has a wrong offset!");
static_assert(offsetof(FCAServicesChallengeTableRow, M_claim_me) == 0x000088, "Member 'FCAServicesChallengeTableRow::M_claim_me' has a wrong offset!");
static_assert(offsetof(FCAServicesChallengeTableRow, M_reward_package) == 0x000098, "Member 'FCAServicesChallengeTableRow::M_reward_package' has a wrong offset!");
static_assert(offsetof(FCAServicesChallengeTableRow, M_challenge_type) == 0x0000B0, "Member 'FCAServicesChallengeTableRow::M_challenge_type' has a wrong offset!");

// ScriptStruct keaton.CASocialProfileUserMap
// 0x0050 (0x0050 - 0x0000)
struct FCASocialProfileUserMap final
{
public:
	TMap<class FString, struct FCASocialProfile>  M_user_profile_map;                                // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASocialProfileUserMap) == 0x000008, "Wrong alignment on FCASocialProfileUserMap");
static_assert(sizeof(FCASocialProfileUserMap) == 0x000050, "Wrong size on FCASocialProfileUserMap");
static_assert(offsetof(FCASocialProfileUserMap, M_user_profile_map) == 0x000000, "Member 'FCASocialProfileUserMap::M_user_profile_map' has a wrong offset!");

// ScriptStruct keaton.CAHealthBarFovValues
// 0x000C (0x000C - 0x0000)
struct FCAHealthBarFovValues final
{
public:
	ECAFovLevel                                   M_fov_level;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_cumulative_width_screen_percentage;              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_cumulative_height_screen_percentage;             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHealthBarFovValues) == 0x000004, "Wrong alignment on FCAHealthBarFovValues");
static_assert(sizeof(FCAHealthBarFovValues) == 0x00000C, "Wrong size on FCAHealthBarFovValues");
static_assert(offsetof(FCAHealthBarFovValues, M_fov_level) == 0x000000, "Member 'FCAHealthBarFovValues::M_fov_level' has a wrong offset!");
static_assert(offsetof(FCAHealthBarFovValues, M_cumulative_width_screen_percentage) == 0x000004, "Member 'FCAHealthBarFovValues::M_cumulative_width_screen_percentage' has a wrong offset!");
static_assert(offsetof(FCAHealthBarFovValues, M_cumulative_height_screen_percentage) == 0x000008, "Member 'FCAHealthBarFovValues::M_cumulative_height_screen_percentage' has a wrong offset!");

// ScriptStruct keaton.CAHUDFovRow
// 0x0018 (0x0020 - 0x0008)
struct FCAHUDFovRow final : public FTableRowBase
{
public:
	ECAFovActorType                               M_fov_actor_type;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAHealthBarFovValues>          M_health_bar_fov_data;                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDFovRow) == 0x000008, "Wrong alignment on FCAHUDFovRow");
static_assert(sizeof(FCAHUDFovRow) == 0x000020, "Wrong size on FCAHUDFovRow");
static_assert(offsetof(FCAHUDFovRow, M_fov_actor_type) == 0x000008, "Member 'FCAHUDFovRow::M_fov_actor_type' has a wrong offset!");
static_assert(offsetof(FCAHUDFovRow, M_health_bar_fov_data) == 0x000010, "Member 'FCAHUDFovRow::M_health_bar_fov_data' has a wrong offset!");

// ScriptStruct keaton.CAFTUEPurchase
// 0x0058 (0x0058 - 0x0000)
struct FCAFTUEPurchase final
{
public:
	struct FCAObtainableOption                    M_obtain_option;                                   // 0x0000(0x0040)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_specialist;                                      // 0x0040(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFTUEPurchase) == 0x000008, "Wrong alignment on FCAFTUEPurchase");
static_assert(sizeof(FCAFTUEPurchase) == 0x000058, "Wrong size on FCAFTUEPurchase");
static_assert(offsetof(FCAFTUEPurchase, M_obtain_option) == 0x000000, "Member 'FCAFTUEPurchase::M_obtain_option' has a wrong offset!");
static_assert(offsetof(FCAFTUEPurchase, M_specialist) == 0x000040, "Member 'FCAFTUEPurchase::M_specialist' has a wrong offset!");

// ScriptStruct keaton.CAFTUEPurchaseOptions
// 0x0030 (0x0030 - 0x0000)
struct FCAFTUEPurchaseOptions final
{
public:
	TArray<struct FCAFTUEPurchase>                M_ftue_purchases;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAServicesFixedReward                 M_currency_handle;                                 // 0x0010(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFTUEPurchaseOptions) == 0x000008, "Wrong alignment on FCAFTUEPurchaseOptions");
static_assert(sizeof(FCAFTUEPurchaseOptions) == 0x000030, "Wrong size on FCAFTUEPurchaseOptions");
static_assert(offsetof(FCAFTUEPurchaseOptions, M_ftue_purchases) == 0x000000, "Member 'FCAFTUEPurchaseOptions::M_ftue_purchases' has a wrong offset!");
static_assert(offsetof(FCAFTUEPurchaseOptions, M_currency_handle) == 0x000010, "Member 'FCAFTUEPurchaseOptions::M_currency_handle' has a wrong offset!");

// ScriptStruct keaton.CAPlayerMatchReward
// 0x0058 (0x0058 - 0x0000)
struct FCAPlayerMatchReward final
{
public:
	TMap<class FString, int32>                    M_reward;                                          // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_reward_average;                                  // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_new_record;                                      // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPlayerMatchReward) == 0x000008, "Wrong alignment on FCAPlayerMatchReward");
static_assert(sizeof(FCAPlayerMatchReward) == 0x000058, "Wrong size on FCAPlayerMatchReward");
static_assert(offsetof(FCAPlayerMatchReward, M_reward) == 0x000000, "Member 'FCAPlayerMatchReward::M_reward' has a wrong offset!");
static_assert(offsetof(FCAPlayerMatchReward, M_reward_average) == 0x000050, "Member 'FCAPlayerMatchReward::M_reward_average' has a wrong offset!");
static_assert(offsetof(FCAPlayerMatchReward, M_new_record) == 0x000054, "Member 'FCAPlayerMatchReward::M_new_record' has a wrong offset!");

// ScriptStruct keaton.CABattleChallengeProgress
// 0x001C (0x001C - 0x0000)
struct FCABattleChallengeProgress final
{
public:
	struct FCAGameDatabaseRowHandle               M_handle;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         M_progress;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCABattleChallengeProgress) == 0x000004, "Wrong alignment on FCABattleChallengeProgress");
static_assert(sizeof(FCABattleChallengeProgress) == 0x00001C, "Wrong size on FCABattleChallengeProgress");
static_assert(offsetof(FCABattleChallengeProgress, M_handle) == 0x000000, "Member 'FCABattleChallengeProgress::M_handle' has a wrong offset!");
static_assert(offsetof(FCABattleChallengeProgress, M_progress) == 0x000018, "Member 'FCABattleChallengeProgress::M_progress' has a wrong offset!");

// ScriptStruct keaton.CAPlayerMatchResults
// 0x00E8 (0x00E8 - 0x0000)
struct FCAPlayerMatchResults final
{
public:
	class FString                                 M_user_id;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_user_name;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_team_id;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAPlayerExtractionStatus                     M_extraction_state;                                // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_specialist_name;                                 // 0x0028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FCAPlayerMatchReward> M_player_rewards;                                  // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 M_game_mode;                                       // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_team_rank;                                       // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCADecoderBattleLoot>           M_loot;                                            // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCABattleChallengeProgress>     M_challenges;                                      // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_team_icon;                                       // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 M_battle_map;                                      // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPlayerMatchResults) == 0x000008, "Wrong alignment on FCAPlayerMatchResults");
static_assert(sizeof(FCAPlayerMatchResults) == 0x0000E8, "Wrong size on FCAPlayerMatchResults");
static_assert(offsetof(FCAPlayerMatchResults, M_user_id) == 0x000000, "Member 'FCAPlayerMatchResults::M_user_id' has a wrong offset!");
static_assert(offsetof(FCAPlayerMatchResults, M_user_name) == 0x000010, "Member 'FCAPlayerMatchResults::M_user_name' has a wrong offset!");
static_assert(offsetof(FCAPlayerMatchResults, M_team_id) == 0x000020, "Member 'FCAPlayerMatchResults::M_team_id' has a wrong offset!");
static_assert(offsetof(FCAPlayerMatchResults, M_extraction_state) == 0x000024, "Member 'FCAPlayerMatchResults::M_extraction_state' has a wrong offset!");
static_assert(offsetof(FCAPlayerMatchResults, M_specialist_name) == 0x000028, "Member 'FCAPlayerMatchResults::M_specialist_name' has a wrong offset!");
static_assert(offsetof(FCAPlayerMatchResults, M_player_rewards) == 0x000038, "Member 'FCAPlayerMatchResults::M_player_rewards' has a wrong offset!");
static_assert(offsetof(FCAPlayerMatchResults, M_game_mode) == 0x000088, "Member 'FCAPlayerMatchResults::M_game_mode' has a wrong offset!");
static_assert(offsetof(FCAPlayerMatchResults, M_team_rank) == 0x000098, "Member 'FCAPlayerMatchResults::M_team_rank' has a wrong offset!");
static_assert(offsetof(FCAPlayerMatchResults, M_loot) == 0x0000A0, "Member 'FCAPlayerMatchResults::M_loot' has a wrong offset!");
static_assert(offsetof(FCAPlayerMatchResults, M_challenges) == 0x0000B0, "Member 'FCAPlayerMatchResults::M_challenges' has a wrong offset!");
static_assert(offsetof(FCAPlayerMatchResults, M_team_icon) == 0x0000C0, "Member 'FCAPlayerMatchResults::M_team_icon' has a wrong offset!");
static_assert(offsetof(FCAPlayerMatchResults, M_battle_map) == 0x0000D8, "Member 'FCAPlayerMatchResults::M_battle_map' has a wrong offset!");

// ScriptStruct keaton.CABattleResult
// 0x0030 (0x0030 - 0x0000)
struct FCABattleResult final
{
public:
	class FString                                 M_battle_id;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_timestamp;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAPlayerMatchResults>          M_result;                                          // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_is_partial;                                      // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCABattleResult) == 0x000008, "Wrong alignment on FCABattleResult");
static_assert(sizeof(FCABattleResult) == 0x000030, "Wrong size on FCABattleResult");
static_assert(offsetof(FCABattleResult, M_battle_id) == 0x000000, "Member 'FCABattleResult::M_battle_id' has a wrong offset!");
static_assert(offsetof(FCABattleResult, M_timestamp) == 0x000010, "Member 'FCABattleResult::M_timestamp' has a wrong offset!");
static_assert(offsetof(FCABattleResult, M_result) == 0x000018, "Member 'FCABattleResult::M_result' has a wrong offset!");
static_assert(offsetof(FCABattleResult, M_is_partial) == 0x000028, "Member 'FCABattleResult::M_is_partial' has a wrong offset!");

// ScriptStruct keaton.CAInputBindingToTagMapping_Instance
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FCAInputBindingToTagMapping_Instance final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAInputBindingToTagMapping_Instance) == 0x000008, "Wrong alignment on FCAInputBindingToTagMapping_Instance");
static_assert(sizeof(FCAInputBindingToTagMapping_Instance) == 0x000040, "Wrong size on FCAInputBindingToTagMapping_Instance");

// ScriptStruct keaton.ShowProjectilePathParams
// 0x0010 (0x0010 - 0x0000)
struct FShowProjectilePathParams final
{
public:
	TSubclassOf<class ACAProjectileBase>          M_projectile_class;                                // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_increasing_velocity_over_time;               // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_enabled;                                         // 0x0009(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_tactical_level;                                  // 0x000A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShowProjectilePathParams) == 0x000008, "Wrong alignment on FShowProjectilePathParams");
static_assert(sizeof(FShowProjectilePathParams) == 0x000010, "Wrong size on FShowProjectilePathParams");
static_assert(offsetof(FShowProjectilePathParams, M_projectile_class) == 0x000000, "Member 'FShowProjectilePathParams::M_projectile_class' has a wrong offset!");
static_assert(offsetof(FShowProjectilePathParams, M_use_increasing_velocity_over_time) == 0x000008, "Member 'FShowProjectilePathParams::M_use_increasing_velocity_over_time' has a wrong offset!");
static_assert(offsetof(FShowProjectilePathParams, M_enabled) == 0x000009, "Member 'FShowProjectilePathParams::M_enabled' has a wrong offset!");
static_assert(offsetof(FShowProjectilePathParams, M_tactical_level) == 0x00000A, "Member 'FShowProjectilePathParams::M_tactical_level' has a wrong offset!");

// ScriptStruct keaton.ExtractionFeedbackInfo
// 0x0048 (0x0048 - 0x0000)
struct FExtractionFeedbackInfo final
{
public:
	TWeakObjectPtr<class AActor>                  M_extraction_area;                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExtractionAreaState                          M_extraction_state;                                // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCATeamID>                      M_occupying_teams_with_sufficient_area_loot;       // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCATeamID>                      M_occupying_teams_with_insufficient_area_loot;     // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_has_my_team_progress;                            // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCATeamID                              M_team_id_with_extraction_progress;                // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAThresholdState                             M_threshold_state;                                 // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_extraction_end_time;                             // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_extraction_duration;                             // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_am_i_in_area;                                    // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExtractionFeedbackInfo) == 0x000008, "Wrong alignment on FExtractionFeedbackInfo");
static_assert(sizeof(FExtractionFeedbackInfo) == 0x000048, "Wrong size on FExtractionFeedbackInfo");
static_assert(offsetof(FExtractionFeedbackInfo, M_extraction_area) == 0x000000, "Member 'FExtractionFeedbackInfo::M_extraction_area' has a wrong offset!");
static_assert(offsetof(FExtractionFeedbackInfo, M_extraction_state) == 0x000008, "Member 'FExtractionFeedbackInfo::M_extraction_state' has a wrong offset!");
static_assert(offsetof(FExtractionFeedbackInfo, M_occupying_teams_with_sufficient_area_loot) == 0x000010, "Member 'FExtractionFeedbackInfo::M_occupying_teams_with_sufficient_area_loot' has a wrong offset!");
static_assert(offsetof(FExtractionFeedbackInfo, M_occupying_teams_with_insufficient_area_loot) == 0x000020, "Member 'FExtractionFeedbackInfo::M_occupying_teams_with_insufficient_area_loot' has a wrong offset!");
static_assert(offsetof(FExtractionFeedbackInfo, M_has_my_team_progress) == 0x000030, "Member 'FExtractionFeedbackInfo::M_has_my_team_progress' has a wrong offset!");
static_assert(offsetof(FExtractionFeedbackInfo, M_team_id_with_extraction_progress) == 0x000034, "Member 'FExtractionFeedbackInfo::M_team_id_with_extraction_progress' has a wrong offset!");
static_assert(offsetof(FExtractionFeedbackInfo, M_threshold_state) == 0x000038, "Member 'FExtractionFeedbackInfo::M_threshold_state' has a wrong offset!");
static_assert(offsetof(FExtractionFeedbackInfo, M_extraction_end_time) == 0x00003C, "Member 'FExtractionFeedbackInfo::M_extraction_end_time' has a wrong offset!");
static_assert(offsetof(FExtractionFeedbackInfo, M_extraction_duration) == 0x000040, "Member 'FExtractionFeedbackInfo::M_extraction_duration' has a wrong offset!");
static_assert(offsetof(FExtractionFeedbackInfo, M_am_i_in_area) == 0x000044, "Member 'FExtractionFeedbackInfo::M_am_i_in_area' has a wrong offset!");

// ScriptStruct keaton.CAHUDValuableMarkerInfo
// 0x00A8 (0x00B0 - 0x0008)
struct FCAHUDValuableMarkerInfo final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UTexture2D>              M_icon_texture;                                    // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           M_custom_colour;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_custom_colour;                               // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_name;                                            // 0x0050(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCAText                                M_description;                                     // 0x0080(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDValuableMarkerInfo) == 0x000008, "Wrong alignment on FCAHUDValuableMarkerInfo");
static_assert(sizeof(FCAHUDValuableMarkerInfo) == 0x0000B0, "Wrong size on FCAHUDValuableMarkerInfo");
static_assert(offsetof(FCAHUDValuableMarkerInfo, M_icon_texture) == 0x000008, "Member 'FCAHUDValuableMarkerInfo::M_icon_texture' has a wrong offset!");
static_assert(offsetof(FCAHUDValuableMarkerInfo, M_custom_colour) == 0x000038, "Member 'FCAHUDValuableMarkerInfo::M_custom_colour' has a wrong offset!");
static_assert(offsetof(FCAHUDValuableMarkerInfo, M_use_custom_colour) == 0x000048, "Member 'FCAHUDValuableMarkerInfo::M_use_custom_colour' has a wrong offset!");
static_assert(offsetof(FCAHUDValuableMarkerInfo, M_name) == 0x000050, "Member 'FCAHUDValuableMarkerInfo::M_name' has a wrong offset!");
static_assert(offsetof(FCAHUDValuableMarkerInfo, M_description) == 0x000080, "Member 'FCAHUDValuableMarkerInfo::M_description' has a wrong offset!");

// ScriptStruct keaton.MemoryDataInfo
// 0x0158 (0x0158 - 0x0000)
struct FMemoryDataInfo final
{
public:
	uint64                                        M_frame_no;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_total_kb;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_total_plt_kb;                                    // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_untracked_kb;                                    // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_untracked_plt_kb;                                // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_llm_overhead_kb;                                 // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_fmalloc_kb;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_fmalloc_unused_kb;                               // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_thread_stack;                                    // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_thread_stack_plt;                                // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_engine_misc;                                     // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_fname;                                           // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_meshes_kb;                                       // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_shaders;                                         // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_pso;                                             // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_textures_kb;                                     // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_texture_meta;                                    // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_render_targets;                                  // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_scene_render;                                    // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_rhi_misc;                                        // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_async_loading;                                   // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_uobjects;                                        // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_animation;                                       // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_static_mesh;                                     // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_materials;                                       // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_particles;                                       // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_niagara;                                         // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_gc;                                              // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_ui;                                              // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_physics_kb;                                      // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_physx_kb;                                        // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_chaos;                                           // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_render_thread;                                   // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_graphics_kb;                                     // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_asset_registry;                                  // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_config_system;                                   // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_init_uobject;                                    // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_material_instance;                               // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_skeletal_mesh;                                   // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_landscape;                                       // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_mmio;                                            // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_virtual_memory;                                  // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        M_navmesh;                                         // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMemoryDataInfo) == 0x000008, "Wrong alignment on FMemoryDataInfo");
static_assert(sizeof(FMemoryDataInfo) == 0x000158, "Wrong size on FMemoryDataInfo");
static_assert(offsetof(FMemoryDataInfo, M_frame_no) == 0x000000, "Member 'FMemoryDataInfo::M_frame_no' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_total_kb) == 0x000008, "Member 'FMemoryDataInfo::M_total_kb' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_total_plt_kb) == 0x000010, "Member 'FMemoryDataInfo::M_total_plt_kb' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_untracked_kb) == 0x000018, "Member 'FMemoryDataInfo::M_untracked_kb' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_untracked_plt_kb) == 0x000020, "Member 'FMemoryDataInfo::M_untracked_plt_kb' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_llm_overhead_kb) == 0x000028, "Member 'FMemoryDataInfo::M_llm_overhead_kb' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_fmalloc_kb) == 0x000030, "Member 'FMemoryDataInfo::M_fmalloc_kb' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_fmalloc_unused_kb) == 0x000038, "Member 'FMemoryDataInfo::M_fmalloc_unused_kb' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_thread_stack) == 0x000040, "Member 'FMemoryDataInfo::M_thread_stack' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_thread_stack_plt) == 0x000048, "Member 'FMemoryDataInfo::M_thread_stack_plt' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_engine_misc) == 0x000050, "Member 'FMemoryDataInfo::M_engine_misc' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_fname) == 0x000058, "Member 'FMemoryDataInfo::M_fname' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_meshes_kb) == 0x000060, "Member 'FMemoryDataInfo::M_meshes_kb' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_shaders) == 0x000068, "Member 'FMemoryDataInfo::M_shaders' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_pso) == 0x000070, "Member 'FMemoryDataInfo::M_pso' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_textures_kb) == 0x000078, "Member 'FMemoryDataInfo::M_textures_kb' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_texture_meta) == 0x000080, "Member 'FMemoryDataInfo::M_texture_meta' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_render_targets) == 0x000088, "Member 'FMemoryDataInfo::M_render_targets' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_scene_render) == 0x000090, "Member 'FMemoryDataInfo::M_scene_render' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_rhi_misc) == 0x000098, "Member 'FMemoryDataInfo::M_rhi_misc' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_async_loading) == 0x0000A0, "Member 'FMemoryDataInfo::M_async_loading' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_uobjects) == 0x0000A8, "Member 'FMemoryDataInfo::M_uobjects' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_animation) == 0x0000B0, "Member 'FMemoryDataInfo::M_animation' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_static_mesh) == 0x0000B8, "Member 'FMemoryDataInfo::M_static_mesh' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_materials) == 0x0000C0, "Member 'FMemoryDataInfo::M_materials' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_particles) == 0x0000C8, "Member 'FMemoryDataInfo::M_particles' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_niagara) == 0x0000D0, "Member 'FMemoryDataInfo::M_niagara' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_gc) == 0x0000D8, "Member 'FMemoryDataInfo::M_gc' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_ui) == 0x0000E0, "Member 'FMemoryDataInfo::M_ui' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_physics_kb) == 0x0000E8, "Member 'FMemoryDataInfo::M_physics_kb' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_physx_kb) == 0x0000F0, "Member 'FMemoryDataInfo::M_physx_kb' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_chaos) == 0x0000F8, "Member 'FMemoryDataInfo::M_chaos' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_render_thread) == 0x000100, "Member 'FMemoryDataInfo::M_render_thread' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_graphics_kb) == 0x000108, "Member 'FMemoryDataInfo::M_graphics_kb' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_asset_registry) == 0x000110, "Member 'FMemoryDataInfo::M_asset_registry' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_config_system) == 0x000118, "Member 'FMemoryDataInfo::M_config_system' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_init_uobject) == 0x000120, "Member 'FMemoryDataInfo::M_init_uobject' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_material_instance) == 0x000128, "Member 'FMemoryDataInfo::M_material_instance' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_skeletal_mesh) == 0x000130, "Member 'FMemoryDataInfo::M_skeletal_mesh' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_landscape) == 0x000138, "Member 'FMemoryDataInfo::M_landscape' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_mmio) == 0x000140, "Member 'FMemoryDataInfo::M_mmio' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_virtual_memory) == 0x000148, "Member 'FMemoryDataInfo::M_virtual_memory' has a wrong offset!");
static_assert(offsetof(FMemoryDataInfo, M_navmesh) == 0x000150, "Member 'FMemoryDataInfo::M_navmesh' has a wrong offset!");

// ScriptStruct keaton.CAShipNPCConstraintsData
// 0x0010 (0x0018 - 0x0008)
struct FCAShipNPCConstraintsData final : public FTableRowBase
{
public:
	int32                                         M_max_npc_count;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_upper_active_npc_threshold_limit;                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_lower_active_npc_threshold_limit;                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAShipNPCConstraintsData) == 0x000008, "Wrong alignment on FCAShipNPCConstraintsData");
static_assert(sizeof(FCAShipNPCConstraintsData) == 0x000018, "Wrong size on FCAShipNPCConstraintsData");
static_assert(offsetof(FCAShipNPCConstraintsData, M_max_npc_count) == 0x000008, "Member 'FCAShipNPCConstraintsData::M_max_npc_count' has a wrong offset!");
static_assert(offsetof(FCAShipNPCConstraintsData, M_upper_active_npc_threshold_limit) == 0x00000C, "Member 'FCAShipNPCConstraintsData::M_upper_active_npc_threshold_limit' has a wrong offset!");
static_assert(offsetof(FCAShipNPCConstraintsData, M_lower_active_npc_threshold_limit) == 0x000010, "Member 'FCAShipNPCConstraintsData::M_lower_active_npc_threshold_limit' has a wrong offset!");

// ScriptStruct keaton.FrameDataInfo
// 0x0070 (0x0070 - 0x0000)
struct FFrameDataInfo final
{
public:
	uint64                                        M_frame_no;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_render_thread_frame_time;                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_game_thread_frame_time;                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_gpu_frame_time;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_frame_time;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_actor_count;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_camera_position;                                 // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_camera_direction;                                // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              M_timestamp;                                       // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_visible_light_count;                             // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_visible_shadowlight_count;                       // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_drawcalls;                                       // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_triangle_count;                                  // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_texture_memory;                                  // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         M_skeletal_mesh_memory;                            // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         M_static_mesh_memory;                              // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        M_elapsed_time;                                    // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFrameDataInfo) == 0x000008, "Wrong alignment on FFrameDataInfo");
static_assert(sizeof(FFrameDataInfo) == 0x000070, "Wrong size on FFrameDataInfo");
static_assert(offsetof(FFrameDataInfo, M_frame_no) == 0x000000, "Member 'FFrameDataInfo::M_frame_no' has a wrong offset!");
static_assert(offsetof(FFrameDataInfo, M_render_thread_frame_time) == 0x000008, "Member 'FFrameDataInfo::M_render_thread_frame_time' has a wrong offset!");
static_assert(offsetof(FFrameDataInfo, M_game_thread_frame_time) == 0x00000C, "Member 'FFrameDataInfo::M_game_thread_frame_time' has a wrong offset!");
static_assert(offsetof(FFrameDataInfo, M_gpu_frame_time) == 0x000010, "Member 'FFrameDataInfo::M_gpu_frame_time' has a wrong offset!");
static_assert(offsetof(FFrameDataInfo, M_frame_time) == 0x000014, "Member 'FFrameDataInfo::M_frame_time' has a wrong offset!");
static_assert(offsetof(FFrameDataInfo, M_actor_count) == 0x000018, "Member 'FFrameDataInfo::M_actor_count' has a wrong offset!");
static_assert(offsetof(FFrameDataInfo, M_camera_position) == 0x00001C, "Member 'FFrameDataInfo::M_camera_position' has a wrong offset!");
static_assert(offsetof(FFrameDataInfo, M_camera_direction) == 0x000028, "Member 'FFrameDataInfo::M_camera_direction' has a wrong offset!");
static_assert(offsetof(FFrameDataInfo, M_timestamp) == 0x000038, "Member 'FFrameDataInfo::M_timestamp' has a wrong offset!");
static_assert(offsetof(FFrameDataInfo, M_visible_light_count) == 0x000040, "Member 'FFrameDataInfo::M_visible_light_count' has a wrong offset!");
static_assert(offsetof(FFrameDataInfo, M_visible_shadowlight_count) == 0x000044, "Member 'FFrameDataInfo::M_visible_shadowlight_count' has a wrong offset!");
static_assert(offsetof(FFrameDataInfo, M_drawcalls) == 0x000048, "Member 'FFrameDataInfo::M_drawcalls' has a wrong offset!");
static_assert(offsetof(FFrameDataInfo, M_triangle_count) == 0x00004C, "Member 'FFrameDataInfo::M_triangle_count' has a wrong offset!");
static_assert(offsetof(FFrameDataInfo, M_texture_memory) == 0x000050, "Member 'FFrameDataInfo::M_texture_memory' has a wrong offset!");
static_assert(offsetof(FFrameDataInfo, M_skeletal_mesh_memory) == 0x000058, "Member 'FFrameDataInfo::M_skeletal_mesh_memory' has a wrong offset!");
static_assert(offsetof(FFrameDataInfo, M_static_mesh_memory) == 0x000060, "Member 'FFrameDataInfo::M_static_mesh_memory' has a wrong offset!");
static_assert(offsetof(FFrameDataInfo, M_elapsed_time) == 0x000068, "Member 'FFrameDataInfo::M_elapsed_time' has a wrong offset!");

// ScriptStruct keaton.CATeamResults
// 0x0020 (0x0020 - 0x0000)
struct FCATeamResults final
{
public:
	TArray<struct FCAPlayerMatchResults>          M_members;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_loot;                                            // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_me;                                           // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_rank;                                            // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCATeamResults) == 0x000008, "Wrong alignment on FCATeamResults");
static_assert(sizeof(FCATeamResults) == 0x000020, "Wrong size on FCATeamResults");
static_assert(offsetof(FCATeamResults, M_members) == 0x000000, "Member 'FCATeamResults::M_members' has a wrong offset!");
static_assert(offsetof(FCATeamResults, M_loot) == 0x000010, "Member 'FCATeamResults::M_loot' has a wrong offset!");
static_assert(offsetof(FCATeamResults, M_is_me) == 0x000014, "Member 'FCATeamResults::M_is_me' has a wrong offset!");
static_assert(offsetof(FCATeamResults, M_rank) == 0x000018, "Member 'FCATeamResults::M_rank' has a wrong offset!");

// ScriptStruct keaton.LevelDataInfo
// 0x0020 (0x0020 - 0x0000)
struct FLevelDataInfo final
{
public:
	class FString                                 M_name;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_num_actors;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_num_components;                                  // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_num_materials;                                   // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelDataInfo) == 0x000008, "Wrong alignment on FLevelDataInfo");
static_assert(sizeof(FLevelDataInfo) == 0x000020, "Wrong size on FLevelDataInfo");
static_assert(offsetof(FLevelDataInfo, M_name) == 0x000000, "Member 'FLevelDataInfo::M_name' has a wrong offset!");
static_assert(offsetof(FLevelDataInfo, M_num_actors) == 0x000010, "Member 'FLevelDataInfo::M_num_actors' has a wrong offset!");
static_assert(offsetof(FLevelDataInfo, M_num_components) == 0x000014, "Member 'FLevelDataInfo::M_num_components' has a wrong offset!");
static_assert(offsetof(FLevelDataInfo, M_num_materials) == 0x000018, "Member 'FLevelDataInfo::M_num_materials' has a wrong offset!");

// ScriptStruct keaton.CAFSMTransitionMapping
// 0x001C (0x001C - 0x0000)
struct FCAFSMTransitionMapping final
{
public:
	ECAFlowAction                                 M_transition_action;                               // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAGameDatabaseRowHandle               M_transition_handle;                               // 0x0004(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFSMTransitionMapping) == 0x000004, "Wrong alignment on FCAFSMTransitionMapping");
static_assert(sizeof(FCAFSMTransitionMapping) == 0x00001C, "Wrong size on FCAFSMTransitionMapping");
static_assert(offsetof(FCAFSMTransitionMapping, M_transition_action) == 0x000000, "Member 'FCAFSMTransitionMapping::M_transition_action' has a wrong offset!");
static_assert(offsetof(FCAFSMTransitionMapping, M_transition_handle) == 0x000004, "Member 'FCAFSMTransitionMapping::M_transition_handle' has a wrong offset!");

// ScriptStruct keaton.MeshBudgetInfo
// 0x0018 (0x0018 - 0x0000)
struct FMeshBudgetInfo final
{
public:
	class FString                                 M_name;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_budget;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_value;                                           // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshBudgetInfo) == 0x000008, "Wrong alignment on FMeshBudgetInfo");
static_assert(sizeof(FMeshBudgetInfo) == 0x000018, "Wrong size on FMeshBudgetInfo");
static_assert(offsetof(FMeshBudgetInfo, M_name) == 0x000000, "Member 'FMeshBudgetInfo::M_name' has a wrong offset!");
static_assert(offsetof(FMeshBudgetInfo, M_budget) == 0x000010, "Member 'FMeshBudgetInfo::M_budget' has a wrong offset!");
static_assert(offsetof(FMeshBudgetInfo, M_value) == 0x000014, "Member 'FMeshBudgetInfo::M_value' has a wrong offset!");

// ScriptStruct keaton.CASysTrackingTarget
// 0x0010 (0x0010 - 0x0000)
struct FCASysTrackingTarget final
{
public:
	TWeakObjectPtr<class AActor>                  M_target;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_entry_time;                                      // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_progress;                                        // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASysTrackingTarget) == 0x000004, "Wrong alignment on FCASysTrackingTarget");
static_assert(sizeof(FCASysTrackingTarget) == 0x000010, "Wrong size on FCASysTrackingTarget");
static_assert(offsetof(FCASysTrackingTarget, M_target) == 0x000000, "Member 'FCASysTrackingTarget::M_target' has a wrong offset!");
static_assert(offsetof(FCASysTrackingTarget, M_entry_time) == 0x000008, "Member 'FCASysTrackingTarget::M_entry_time' has a wrong offset!");
static_assert(offsetof(FCASysTrackingTarget, M_progress) == 0x00000C, "Member 'FCASysTrackingTarget::M_progress' has a wrong offset!");

// ScriptStruct keaton.LevelScreens
// 0x0040 (0x0040 - 0x0000)
struct FLevelScreens final
{
public:
	TSoftObjectPtr<class UWorld>                  M_level;                                           // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ACameraActor>>    M_screenshot_location;                             // 0x0030(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelScreens) == 0x000008, "Wrong alignment on FLevelScreens");
static_assert(sizeof(FLevelScreens) == 0x000040, "Wrong size on FLevelScreens");
static_assert(offsetof(FLevelScreens, M_level) == 0x000000, "Member 'FLevelScreens::M_level' has a wrong offset!");
static_assert(offsetof(FLevelScreens, M_screenshot_location) == 0x000030, "Member 'FLevelScreens::M_screenshot_location' has a wrong offset!");

// ScriptStruct keaton.CABatchData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FCABatchData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCABatchData) == 0x000008, "Wrong alignment on FCABatchData");
static_assert(sizeof(FCABatchData) == 0x000018, "Wrong size on FCABatchData");

// ScriptStruct keaton.MountedEquipmentInfo
// 0x0040 (0x0040 - 0x0000)
struct FMountedEquipmentInfo final
{
public:
	int32                                         M_mount_index;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        M_fp_attached_component;                           // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        M_tp_attached_component;                           // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAEquipmentMountingComponent*          M_mounting_component;                              // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_actor_we_are_mounted_to;                         // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_fp_socket_name;                                  // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_tp_socket_name;                                  // 0x0034(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMountedEquipmentInfo) == 0x000008, "Wrong alignment on FMountedEquipmentInfo");
static_assert(sizeof(FMountedEquipmentInfo) == 0x000040, "Wrong size on FMountedEquipmentInfo");
static_assert(offsetof(FMountedEquipmentInfo, M_mount_index) == 0x000000, "Member 'FMountedEquipmentInfo::M_mount_index' has a wrong offset!");
static_assert(offsetof(FMountedEquipmentInfo, M_fp_attached_component) == 0x000008, "Member 'FMountedEquipmentInfo::M_fp_attached_component' has a wrong offset!");
static_assert(offsetof(FMountedEquipmentInfo, M_tp_attached_component) == 0x000010, "Member 'FMountedEquipmentInfo::M_tp_attached_component' has a wrong offset!");
static_assert(offsetof(FMountedEquipmentInfo, M_mounting_component) == 0x000018, "Member 'FMountedEquipmentInfo::M_mounting_component' has a wrong offset!");
static_assert(offsetof(FMountedEquipmentInfo, M_actor_we_are_mounted_to) == 0x000020, "Member 'FMountedEquipmentInfo::M_actor_we_are_mounted_to' has a wrong offset!");
static_assert(offsetof(FMountedEquipmentInfo, M_fp_socket_name) == 0x000028, "Member 'FMountedEquipmentInfo::M_fp_socket_name' has a wrong offset!");
static_assert(offsetof(FMountedEquipmentInfo, M_tp_socket_name) == 0x000034, "Member 'FMountedEquipmentInfo::M_tp_socket_name' has a wrong offset!");

// ScriptStruct keaton.CATextWithOptionalLocKey
// 0x0048 (0x0048 - 0x0000)
struct FCATextWithOptionalLocKey final
{
public:
	struct FCAText                                M_text_loc_key;                                    // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   M_text_not_localised;                              // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATextWithOptionalLocKey) == 0x000008, "Wrong alignment on FCATextWithOptionalLocKey");
static_assert(sizeof(FCATextWithOptionalLocKey) == 0x000048, "Wrong size on FCATextWithOptionalLocKey");
static_assert(offsetof(FCATextWithOptionalLocKey, M_text_loc_key) == 0x000000, "Member 'FCATextWithOptionalLocKey::M_text_loc_key' has a wrong offset!");
static_assert(offsetof(FCATextWithOptionalLocKey, M_text_not_localised) == 0x000030, "Member 'FCATextWithOptionalLocKey::M_text_not_localised' has a wrong offset!");

// ScriptStruct keaton.CAHUDInputData
// 0x0010 (0x0010 - 0x0000)
struct FCAHUDInputData final
{
public:
	class FName                                   M_action_name;                                     // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAHUDInputType                               M_input_type;                                      // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAHUDInputData) == 0x000004, "Wrong alignment on FCAHUDInputData");
static_assert(sizeof(FCAHUDInputData) == 0x000010, "Wrong size on FCAHUDInputData");
static_assert(offsetof(FCAHUDInputData, M_action_name) == 0x000000, "Member 'FCAHUDInputData::M_action_name' has a wrong offset!");
static_assert(offsetof(FCAHUDInputData, M_input_type) == 0x00000C, "Member 'FCAHUDInputData::M_input_type' has a wrong offset!");

// ScriptStruct keaton.CANotificationMessageTableRow
// 0x0210 (0x0218 - 0x0008)
struct FCANotificationMessageTableRow final : public FTableRowBase
{
public:
	ECAHUDNotificationType                        M_notification_type;                               // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAHUDPopupPriority                           M_priority;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCATextWithOptionalLocKey              M_headline_text;                                   // 0x0010(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCATextWithOptionalLocKey              M_title_text;                                      // 0x0058(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCATextWithOptionalLocKey              M_message_text;                                    // 0x00A0(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCATextWithOptionalLocKey              M_first_button_text;                               // 0x00E8(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCATextWithOptionalLocKey              M_second_button_text;                              // 0x0130(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCATextWithOptionalLocKey              M_third_button_text;                               // 0x0178(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAHUDInputData>                M_icon_data_array;                                 // 0x01C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_image;                                           // 0x01D0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    M_first_button_action;                             // 0x0200(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    M_second_button_action;                            // 0x0208(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    M_third_button_action;                             // 0x0210(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANotificationMessageTableRow) == 0x000008, "Wrong alignment on FCANotificationMessageTableRow");
static_assert(sizeof(FCANotificationMessageTableRow) == 0x000218, "Wrong size on FCANotificationMessageTableRow");
static_assert(offsetof(FCANotificationMessageTableRow, M_notification_type) == 0x000008, "Member 'FCANotificationMessageTableRow::M_notification_type' has a wrong offset!");
static_assert(offsetof(FCANotificationMessageTableRow, M_priority) == 0x000009, "Member 'FCANotificationMessageTableRow::M_priority' has a wrong offset!");
static_assert(offsetof(FCANotificationMessageTableRow, M_headline_text) == 0x000010, "Member 'FCANotificationMessageTableRow::M_headline_text' has a wrong offset!");
static_assert(offsetof(FCANotificationMessageTableRow, M_title_text) == 0x000058, "Member 'FCANotificationMessageTableRow::M_title_text' has a wrong offset!");
static_assert(offsetof(FCANotificationMessageTableRow, M_message_text) == 0x0000A0, "Member 'FCANotificationMessageTableRow::M_message_text' has a wrong offset!");
static_assert(offsetof(FCANotificationMessageTableRow, M_first_button_text) == 0x0000E8, "Member 'FCANotificationMessageTableRow::M_first_button_text' has a wrong offset!");
static_assert(offsetof(FCANotificationMessageTableRow, M_second_button_text) == 0x000130, "Member 'FCANotificationMessageTableRow::M_second_button_text' has a wrong offset!");
static_assert(offsetof(FCANotificationMessageTableRow, M_third_button_text) == 0x000178, "Member 'FCANotificationMessageTableRow::M_third_button_text' has a wrong offset!");
static_assert(offsetof(FCANotificationMessageTableRow, M_icon_data_array) == 0x0001C0, "Member 'FCANotificationMessageTableRow::M_icon_data_array' has a wrong offset!");
static_assert(offsetof(FCANotificationMessageTableRow, M_image) == 0x0001D0, "Member 'FCANotificationMessageTableRow::M_image' has a wrong offset!");
static_assert(offsetof(FCANotificationMessageTableRow, M_first_button_action) == 0x000200, "Member 'FCANotificationMessageTableRow::M_first_button_action' has a wrong offset!");
static_assert(offsetof(FCANotificationMessageTableRow, M_second_button_action) == 0x000208, "Member 'FCANotificationMessageTableRow::M_second_button_action' has a wrong offset!");
static_assert(offsetof(FCANotificationMessageTableRow, M_third_button_action) == 0x000210, "Member 'FCANotificationMessageTableRow::M_third_button_action' has a wrong offset!");

// ScriptStruct keaton.CATeamBonusData
// 0x0020 (0x0020 - 0x0000)
struct FCATeamBonusData final
{
public:
	TArray<TSubclassOf<class UGameplayEffect>>    M_gameplay_effects;                                // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_team_bonus_id;                                   // 0x0010(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCATeamBonusData) == 0x000008, "Wrong alignment on FCATeamBonusData");
static_assert(sizeof(FCATeamBonusData) == 0x000020, "Wrong size on FCATeamBonusData");
static_assert(offsetof(FCATeamBonusData, M_gameplay_effects) == 0x000000, "Member 'FCATeamBonusData::M_gameplay_effects' has a wrong offset!");
static_assert(offsetof(FCATeamBonusData, M_team_bonus_id) == 0x000010, "Member 'FCATeamBonusData::M_team_bonus_id' has a wrong offset!");

// ScriptStruct keaton.CABrandCameraContainer
// 0x0080 (0x0080 - 0x0000)
struct FCABrandCameraContainer final
{
public:
	class UCACameraComponent*                     M_camera;                                          // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x78];                                       // 0x0008(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCABrandCameraContainer) == 0x000008, "Wrong alignment on FCABrandCameraContainer");
static_assert(sizeof(FCABrandCameraContainer) == 0x000080, "Wrong size on FCABrandCameraContainer");
static_assert(offsetof(FCABrandCameraContainer, M_camera) == 0x000000, "Member 'FCABrandCameraContainer::M_camera' has a wrong offset!");

// ScriptStruct keaton.CABrandCameraContainer_Value
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FCABrandCameraContainer_Value final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCABrandCameraContainer_Value) == 0x000008, "Wrong alignment on FCABrandCameraContainer_Value");
static_assert(sizeof(FCABrandCameraContainer_Value) == 0x000030, "Wrong size on FCABrandCameraContainer_Value");

// ScriptStruct keaton.CAUntouchableProjectileAliases
// 0x0010 (0x0018 - 0x0008)
struct FCAUntouchableProjectileAliases final : public FTableRowBase
{
public:
	TSubclassOf<class ACAProjectileBase>          Key;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACAProjectileBase>          Value;                                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAUntouchableProjectileAliases) == 0x000008, "Wrong alignment on FCAUntouchableProjectileAliases");
static_assert(sizeof(FCAUntouchableProjectileAliases) == 0x000018, "Wrong size on FCAUntouchableProjectileAliases");
static_assert(offsetof(FCAUntouchableProjectileAliases, Key) == 0x000008, "Member 'FCAUntouchableProjectileAliases::Key' has a wrong offset!");
static_assert(offsetof(FCAUntouchableProjectileAliases, Value) == 0x000010, "Member 'FCAUntouchableProjectileAliases::Value' has a wrong offset!");

// ScriptStruct keaton.CABrand_Commands
// 0x0010 (0x0018 - 0x0008)
struct FCABrand_Commands final : public FTableRowBase
{
public:
	TArray<class FString>                         M_commands;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCABrand_Commands) == 0x000008, "Wrong alignment on FCABrand_Commands");
static_assert(sizeof(FCABrand_Commands) == 0x000018, "Wrong size on FCABrand_Commands");
static_assert(offsetof(FCABrand_Commands, M_commands) == 0x000008, "Member 'FCABrand_Commands::M_commands' has a wrong offset!");

// ScriptStruct keaton.CAServicesProfileSpecialistStats
// 0x0078 (0x0078 - 0x0000)
struct FCAServicesProfileSpecialistStats final
{
public:
	struct FCAGameDatabaseRowHandle               M_specialist_reference;                            // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         M_matches_completed;                               // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_win_rate;                                        // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    M_placements;                                      // 0x0020(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         M_killed_players;                                  // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAServicesProfileSpecialistStats) == 0x000008, "Wrong alignment on FCAServicesProfileSpecialistStats");
static_assert(sizeof(FCAServicesProfileSpecialistStats) == 0x000078, "Wrong size on FCAServicesProfileSpecialistStats");
static_assert(offsetof(FCAServicesProfileSpecialistStats, M_specialist_reference) == 0x000000, "Member 'FCAServicesProfileSpecialistStats::M_specialist_reference' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileSpecialistStats, M_matches_completed) == 0x000018, "Member 'FCAServicesProfileSpecialistStats::M_matches_completed' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileSpecialistStats, M_win_rate) == 0x00001C, "Member 'FCAServicesProfileSpecialistStats::M_win_rate' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileSpecialistStats, M_placements) == 0x000020, "Member 'FCAServicesProfileSpecialistStats::M_placements' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileSpecialistStats, M_killed_players) == 0x000070, "Member 'FCAServicesProfileSpecialistStats::M_killed_players' has a wrong offset!");

// ScriptStruct keaton.CAServicesProfileStatsTableRow
// 0x00B0 (0x00B8 - 0x0008)
struct FCAServicesProfileStatsTableRow final : public FTableRowBase
{
public:
	int32                                         M_downed_players;                                  // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_killed_players;                                  // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_deaths_in_pvp;                                   // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_allies_revived;                                  // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_self_downed;                                     // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_loot_total;                                      // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_breached_vaults;                                 // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_team_got_wiped;                                  // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_team_timed_out;                                  // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_win_rate;                                        // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_k_d_ratio;                                       // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_crates_opened;                                   // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_damage_dealt_total;                              // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_damage_dealt_critical;                           // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_damage_dealt_normal;                             // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_killed_npcs;                                     // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_killed_lasers;                                   // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_killed_tanks;                                    // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_matches_completed;                               // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_respawners_used;                                 // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            M_placements;                                      // 0x0058(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FCAServicesProfileSpecialistStats> M_specialist_stats;                                // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAServicesProfileStatsTableRow) == 0x000008, "Wrong alignment on FCAServicesProfileStatsTableRow");
static_assert(sizeof(FCAServicesProfileStatsTableRow) == 0x0000B8, "Wrong size on FCAServicesProfileStatsTableRow");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_downed_players) == 0x000008, "Member 'FCAServicesProfileStatsTableRow::M_downed_players' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_killed_players) == 0x00000C, "Member 'FCAServicesProfileStatsTableRow::M_killed_players' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_deaths_in_pvp) == 0x000010, "Member 'FCAServicesProfileStatsTableRow::M_deaths_in_pvp' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_allies_revived) == 0x000014, "Member 'FCAServicesProfileStatsTableRow::M_allies_revived' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_self_downed) == 0x000018, "Member 'FCAServicesProfileStatsTableRow::M_self_downed' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_loot_total) == 0x00001C, "Member 'FCAServicesProfileStatsTableRow::M_loot_total' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_breached_vaults) == 0x000020, "Member 'FCAServicesProfileStatsTableRow::M_breached_vaults' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_team_got_wiped) == 0x000024, "Member 'FCAServicesProfileStatsTableRow::M_team_got_wiped' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_team_timed_out) == 0x000028, "Member 'FCAServicesProfileStatsTableRow::M_team_timed_out' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_win_rate) == 0x00002C, "Member 'FCAServicesProfileStatsTableRow::M_win_rate' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_k_d_ratio) == 0x000030, "Member 'FCAServicesProfileStatsTableRow::M_k_d_ratio' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_crates_opened) == 0x000034, "Member 'FCAServicesProfileStatsTableRow::M_crates_opened' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_damage_dealt_total) == 0x000038, "Member 'FCAServicesProfileStatsTableRow::M_damage_dealt_total' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_damage_dealt_critical) == 0x00003C, "Member 'FCAServicesProfileStatsTableRow::M_damage_dealt_critical' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_damage_dealt_normal) == 0x000040, "Member 'FCAServicesProfileStatsTableRow::M_damage_dealt_normal' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_killed_npcs) == 0x000044, "Member 'FCAServicesProfileStatsTableRow::M_killed_npcs' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_killed_lasers) == 0x000048, "Member 'FCAServicesProfileStatsTableRow::M_killed_lasers' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_killed_tanks) == 0x00004C, "Member 'FCAServicesProfileStatsTableRow::M_killed_tanks' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_matches_completed) == 0x000050, "Member 'FCAServicesProfileStatsTableRow::M_matches_completed' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_respawners_used) == 0x000054, "Member 'FCAServicesProfileStatsTableRow::M_respawners_used' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_placements) == 0x000058, "Member 'FCAServicesProfileStatsTableRow::M_placements' has a wrong offset!");
static_assert(offsetof(FCAServicesProfileStatsTableRow, M_specialist_stats) == 0x0000A8, "Member 'FCAServicesProfileStatsTableRow::M_specialist_stats' has a wrong offset!");

// ScriptStruct keaton.CABreadCrumbTrailItem
// 0x0020 (0x0020 - 0x0000)
struct FCABreadCrumbTrailItem final
{
public:
	struct FVector_NetQuantize                    M_location;                                        // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_rotation;                                        // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         M_player_id;                                       // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATRAIL_DROP_TYPE                            M_drop_type;                                       // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_force;                                           // 0x001D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCABreadCrumbTrailItem) == 0x000004, "Wrong alignment on FCABreadCrumbTrailItem");
static_assert(sizeof(FCABreadCrumbTrailItem) == 0x000020, "Wrong size on FCABreadCrumbTrailItem");
static_assert(offsetof(FCABreadCrumbTrailItem, M_location) == 0x000000, "Member 'FCABreadCrumbTrailItem::M_location' has a wrong offset!");
static_assert(offsetof(FCABreadCrumbTrailItem, M_rotation) == 0x00000C, "Member 'FCABreadCrumbTrailItem::M_rotation' has a wrong offset!");
static_assert(offsetof(FCABreadCrumbTrailItem, M_player_id) == 0x000018, "Member 'FCABreadCrumbTrailItem::M_player_id' has a wrong offset!");
static_assert(offsetof(FCABreadCrumbTrailItem, M_drop_type) == 0x00001C, "Member 'FCABreadCrumbTrailItem::M_drop_type' has a wrong offset!");
static_assert(offsetof(FCABreadCrumbTrailItem, M_force) == 0x00001D, "Member 'FCABreadCrumbTrailItem::M_force' has a wrong offset!");

// ScriptStruct keaton.CADialogueRuleResponseData
// 0x0050 (0x0058 - 0x0008)
struct FCADialogueRuleResponseData final : public FTableRowBase
{
public:
	struct FCAHashableString                      RuleName;                                          // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAHashableString                      ResponseName;                                      // 0x000C(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        LocalPlayerEvent;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TeamEvent;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        EnemyTeamEvent;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAHashableString                      FollowUp;                                          // 0x001C(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowUpTimingMin;                                 // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowUpTimingMax;                                 // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAHashableString                      FollowUpType;                                      // 0x0028(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAHashableString                      WritebackKey;                                      // 0x002C(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAHashableString                      WritebackOperator;                                 // 0x0030(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritebackValue;                                    // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAHashableString                      Priority;                                          // 0x0038(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAHashableString                      InterruptEqualPriority;                            // 0x003C(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QueueLifeTime;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDelay;                                          // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDelay;                                          // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weighting;                                         // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAHashableString                      WritebackScope;                                    // 0x0050(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSFX;                                             // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADialogueRuleResponseData) == 0x000008, "Wrong alignment on FCADialogueRuleResponseData");
static_assert(sizeof(FCADialogueRuleResponseData) == 0x000058, "Wrong size on FCADialogueRuleResponseData");
static_assert(offsetof(FCADialogueRuleResponseData, RuleName) == 0x000008, "Member 'FCADialogueRuleResponseData::RuleName' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, ResponseName) == 0x00000C, "Member 'FCADialogueRuleResponseData::ResponseName' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, LocalPlayerEvent) == 0x000010, "Member 'FCADialogueRuleResponseData::LocalPlayerEvent' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, TeamEvent) == 0x000014, "Member 'FCADialogueRuleResponseData::TeamEvent' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, EnemyTeamEvent) == 0x000018, "Member 'FCADialogueRuleResponseData::EnemyTeamEvent' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, FollowUp) == 0x00001C, "Member 'FCADialogueRuleResponseData::FollowUp' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, FollowUpTimingMin) == 0x000020, "Member 'FCADialogueRuleResponseData::FollowUpTimingMin' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, FollowUpTimingMax) == 0x000024, "Member 'FCADialogueRuleResponseData::FollowUpTimingMax' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, FollowUpType) == 0x000028, "Member 'FCADialogueRuleResponseData::FollowUpType' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, WritebackKey) == 0x00002C, "Member 'FCADialogueRuleResponseData::WritebackKey' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, WritebackOperator) == 0x000030, "Member 'FCADialogueRuleResponseData::WritebackOperator' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, WritebackValue) == 0x000034, "Member 'FCADialogueRuleResponseData::WritebackValue' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, Priority) == 0x000038, "Member 'FCADialogueRuleResponseData::Priority' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, InterruptEqualPriority) == 0x00003C, "Member 'FCADialogueRuleResponseData::InterruptEqualPriority' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, QueueLifeTime) == 0x000040, "Member 'FCADialogueRuleResponseData::QueueLifeTime' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, MinDelay) == 0x000044, "Member 'FCADialogueRuleResponseData::MinDelay' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, MaxDelay) == 0x000048, "Member 'FCADialogueRuleResponseData::MaxDelay' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, Weighting) == 0x00004C, "Member 'FCADialogueRuleResponseData::Weighting' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, WritebackScope) == 0x000050, "Member 'FCADialogueRuleResponseData::WritebackScope' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleResponseData, IsSFX) == 0x000054, "Member 'FCADialogueRuleResponseData::IsSFX' has a wrong offset!");

// ScriptStruct keaton.CABreadcrumbDropRule
// 0x0004 (0x0004 - 0x0000)
struct FCABreadcrumbDropRule final
{
public:
	ECAPlayerAbilityMode                          PreviousMode;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PrevEquals;                                        // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAPlayerAbilityMode                          NewMode;                                           // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewEquals;                                         // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCABreadcrumbDropRule) == 0x000001, "Wrong alignment on FCABreadcrumbDropRule");
static_assert(sizeof(FCABreadcrumbDropRule) == 0x000004, "Wrong size on FCABreadcrumbDropRule");
static_assert(offsetof(FCABreadcrumbDropRule, PreviousMode) == 0x000000, "Member 'FCABreadcrumbDropRule::PreviousMode' has a wrong offset!");
static_assert(offsetof(FCABreadcrumbDropRule, PrevEquals) == 0x000001, "Member 'FCABreadcrumbDropRule::PrevEquals' has a wrong offset!");
static_assert(offsetof(FCABreadcrumbDropRule, NewMode) == 0x000002, "Member 'FCABreadcrumbDropRule::NewMode' has a wrong offset!");
static_assert(offsetof(FCABreadcrumbDropRule, NewEquals) == 0x000003, "Member 'FCABreadcrumbDropRule::NewEquals' has a wrong offset!");

// ScriptStruct keaton.CAServicesPackageTableRow
// 0x0010 (0x0018 - 0x0008)
struct FCAServicesPackageTableRow final : public FTableRowBase
{
public:
	TArray<struct FCAServicesFixedReward>         M_fixed_rewards;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAServicesPackageTableRow) == 0x000008, "Wrong alignment on FCAServicesPackageTableRow");
static_assert(sizeof(FCAServicesPackageTableRow) == 0x000018, "Wrong size on FCAServicesPackageTableRow");
static_assert(offsetof(FCAServicesPackageTableRow, M_fixed_rewards) == 0x000008, "Member 'FCAServicesPackageTableRow::M_fixed_rewards' has a wrong offset!");

// ScriptStruct keaton.CAFloatBuff
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FCAFloatBuff final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAFloatBuff) == 0x000004, "Wrong alignment on FCAFloatBuff");
static_assert(sizeof(FCAFloatBuff) == 0x00000C, "Wrong size on FCAFloatBuff");

// ScriptStruct keaton.CABuffableFloat
// 0x0060 (0x0060 - 0x0000)
struct FCABuffableFloat
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAFloatBuff>                   M_additive_buffs;                                  // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FCAFloatBuff>                   M_multiplicative_buffs;                            // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FCAFloatBuff>                   M_min_buffs;                                       // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FCAFloatBuff>                   M_max_buffs;                                       // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCABuffableFloat) == 0x000008, "Wrong alignment on FCABuffableFloat");
static_assert(sizeof(FCABuffableFloat) == 0x000060, "Wrong size on FCABuffableFloat");
static_assert(offsetof(FCABuffableFloat, M_additive_buffs) == 0x000018, "Member 'FCABuffableFloat::M_additive_buffs' has a wrong offset!");
static_assert(offsetof(FCABuffableFloat, M_multiplicative_buffs) == 0x000028, "Member 'FCABuffableFloat::M_multiplicative_buffs' has a wrong offset!");
static_assert(offsetof(FCABuffableFloat, M_min_buffs) == 0x000038, "Member 'FCABuffableFloat::M_min_buffs' has a wrong offset!");
static_assert(offsetof(FCABuffableFloat, M_max_buffs) == 0x000048, "Member 'FCABuffableFloat::M_max_buffs' has a wrong offset!");

// ScriptStruct keaton.CAFoamAlignmentHelper
// 0x0010 (0x0010 - 0x0000)
struct FCAFoamAlignmentHelper final
{
public:
	ECAAlignmentPosition                          M_alignment_position;                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        M_alignment_component;                             // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFoamAlignmentHelper) == 0x000008, "Wrong alignment on FCAFoamAlignmentHelper");
static_assert(sizeof(FCAFoamAlignmentHelper) == 0x000010, "Wrong size on FCAFoamAlignmentHelper");
static_assert(offsetof(FCAFoamAlignmentHelper, M_alignment_position) == 0x000000, "Member 'FCAFoamAlignmentHelper::M_alignment_position' has a wrong offset!");
static_assert(offsetof(FCAFoamAlignmentHelper, M_alignment_component) == 0x000008, "Member 'FCAFoamAlignmentHelper::M_alignment_component' has a wrong offset!");

// ScriptStruct keaton.CABuffable_int
// 0x0000 (0x0060 - 0x0060)
struct FCABuffable_int final : public FCABuffableFloat
{
};
static_assert(alignof(FCABuffable_int) == 0x000008, "Wrong alignment on FCABuffable_int");
static_assert(sizeof(FCABuffable_int) == 0x000060, "Wrong size on FCABuffable_int");

// ScriptStruct keaton.PlayerAssetConfigurationForLevelSequence
// 0x00F0 (0x00F0 - 0x0000)
struct FPlayerAssetConfigurationForLevelSequence final
{
public:
	struct FCAPlayerCharacterAssets               M_player_character_assets;                         // 0x0000(0x00B0)(NativeAccessSpecifierPublic)
	struct FCALoadoutSlots                        M_loadout_slots;                                   // 0x00B0(0x0040)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerAssetConfigurationForLevelSequence) == 0x000008, "Wrong alignment on FPlayerAssetConfigurationForLevelSequence");
static_assert(sizeof(FPlayerAssetConfigurationForLevelSequence) == 0x0000F0, "Wrong size on FPlayerAssetConfigurationForLevelSequence");
static_assert(offsetof(FPlayerAssetConfigurationForLevelSequence, M_player_character_assets) == 0x000000, "Member 'FPlayerAssetConfigurationForLevelSequence::M_player_character_assets' has a wrong offset!");
static_assert(offsetof(FPlayerAssetConfigurationForLevelSequence, M_loadout_slots) == 0x0000B0, "Member 'FPlayerAssetConfigurationForLevelSequence::M_loadout_slots' has a wrong offset!");

// ScriptStruct keaton.CARespawnOptions
// 0x0020 (0x0020 - 0x0000)
struct FCARespawnOptions final
{
public:
	ECASpawnSelection                             M_spawn_selection;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECASpawnSelection                             M_respawn_selection;                               // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_respawn_policy;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_respawn_time_in_seconds;                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_respawn_time_death_multiplier;                   // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_respawn_time_match_time_multiplier;              // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_respawn_time_match_time_frequency;               // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_respawn_cooldown_in_seconds;                     // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_activate_stations_in_deactivation_order;         // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCARespawnOptions) == 0x000004, "Wrong alignment on FCARespawnOptions");
static_assert(sizeof(FCARespawnOptions) == 0x000020, "Wrong size on FCARespawnOptions");
static_assert(offsetof(FCARespawnOptions, M_spawn_selection) == 0x000000, "Member 'FCARespawnOptions::M_spawn_selection' has a wrong offset!");
static_assert(offsetof(FCARespawnOptions, M_respawn_selection) == 0x000001, "Member 'FCARespawnOptions::M_respawn_selection' has a wrong offset!");
static_assert(offsetof(FCARespawnOptions, M_respawn_policy) == 0x000004, "Member 'FCARespawnOptions::M_respawn_policy' has a wrong offset!");
static_assert(offsetof(FCARespawnOptions, M_respawn_time_in_seconds) == 0x000008, "Member 'FCARespawnOptions::M_respawn_time_in_seconds' has a wrong offset!");
static_assert(offsetof(FCARespawnOptions, M_respawn_time_death_multiplier) == 0x00000C, "Member 'FCARespawnOptions::M_respawn_time_death_multiplier' has a wrong offset!");
static_assert(offsetof(FCARespawnOptions, M_respawn_time_match_time_multiplier) == 0x000010, "Member 'FCARespawnOptions::M_respawn_time_match_time_multiplier' has a wrong offset!");
static_assert(offsetof(FCARespawnOptions, M_respawn_time_match_time_frequency) == 0x000014, "Member 'FCARespawnOptions::M_respawn_time_match_time_frequency' has a wrong offset!");
static_assert(offsetof(FCARespawnOptions, M_respawn_cooldown_in_seconds) == 0x000018, "Member 'FCARespawnOptions::M_respawn_cooldown_in_seconds' has a wrong offset!");
static_assert(offsetof(FCARespawnOptions, M_activate_stations_in_deactivation_order) == 0x00001C, "Member 'FCARespawnOptions::M_activate_stations_in_deactivation_order' has a wrong offset!");

// ScriptStruct keaton.CABuffHandle
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FCABuffHandle final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UCAWeaponStatsComponent> M_owning_stats_component;                          // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCABuffHandle) == 0x000008, "Wrong alignment on FCABuffHandle");
static_assert(sizeof(FCABuffHandle) == 0x000018, "Wrong size on FCABuffHandle");
static_assert(offsetof(FCABuffHandle, M_owning_stats_component) == 0x000010, "Member 'FCABuffHandle::M_owning_stats_component' has a wrong offset!");

// ScriptStruct keaton.CABuildServicesPath
// 0x0010 (0x0010 - 0x0000)
struct FCABuildServicesPath final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCABuildServicesPath) == 0x000008, "Wrong alignment on FCABuildServicesPath");
static_assert(sizeof(FCABuildServicesPath) == 0x000010, "Wrong size on FCABuildServicesPath");
static_assert(offsetof(FCABuildServicesPath, Path) == 0x000000, "Member 'FCABuildServicesPath::Path' has a wrong offset!");

// ScriptStruct keaton.CABuildServicesEntry
// 0x0040 (0x0040 - 0x0000)
struct FCABuildServicesEntry final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Template;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCABuildServicesPath                   Concrete_Stream;                                   // 0x0020(0x0010)(NativeAccessSpecifierPublic)
	TArray<struct FCABuildServicesPath>           Virtual_Streams;                                   // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCABuildServicesEntry) == 0x000008, "Wrong alignment on FCABuildServicesEntry");
static_assert(sizeof(FCABuildServicesEntry) == 0x000040, "Wrong size on FCABuildServicesEntry");
static_assert(offsetof(FCABuildServicesEntry, Name) == 0x000000, "Member 'FCABuildServicesEntry::Name' has a wrong offset!");
static_assert(offsetof(FCABuildServicesEntry, Template) == 0x000010, "Member 'FCABuildServicesEntry::Template' has a wrong offset!");
static_assert(offsetof(FCABuildServicesEntry, Concrete_Stream) == 0x000020, "Member 'FCABuildServicesEntry::Concrete_Stream' has a wrong offset!");
static_assert(offsetof(FCABuildServicesEntry, Virtual_Streams) == 0x000030, "Member 'FCABuildServicesEntry::Virtual_Streams' has a wrong offset!");

// ScriptStruct keaton.CAEmoteOption
// 0x0040 (0x0040 - 0x0000)
struct FCAEmoteOption final
{
public:
	class FName                                   M_name;                                            // 0x0000(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAAvailableVia                               M_available_via;                                   // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAGameDatabaseRowHandle               M_handle;                                          // 0x0010(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_is_disabled;                                     // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_owned;                                        // 0x0029(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAObtainableOption>            M_obtain_options;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAEmoteOption) == 0x000008, "Wrong alignment on FCAEmoteOption");
static_assert(sizeof(FCAEmoteOption) == 0x000040, "Wrong size on FCAEmoteOption");
static_assert(offsetof(FCAEmoteOption, M_name) == 0x000000, "Member 'FCAEmoteOption::M_name' has a wrong offset!");
static_assert(offsetof(FCAEmoteOption, M_available_via) == 0x00000C, "Member 'FCAEmoteOption::M_available_via' has a wrong offset!");
static_assert(offsetof(FCAEmoteOption, M_handle) == 0x000010, "Member 'FCAEmoteOption::M_handle' has a wrong offset!");
static_assert(offsetof(FCAEmoteOption, M_is_disabled) == 0x000028, "Member 'FCAEmoteOption::M_is_disabled' has a wrong offset!");
static_assert(offsetof(FCAEmoteOption, M_is_owned) == 0x000029, "Member 'FCAEmoteOption::M_is_owned' has a wrong offset!");
static_assert(offsetof(FCAEmoteOption, M_obtain_options) == 0x000030, "Member 'FCAEmoteOption::M_obtain_options' has a wrong offset!");

// ScriptStruct keaton.CAHistoryItem
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FCAHistoryItem final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAHistoryItem) == 0x000008, "Wrong alignment on FCAHistoryItem");
static_assert(sizeof(FCAHistoryItem) == 0x000028, "Wrong size on FCAHistoryItem");

// ScriptStruct keaton.CACallbackDelegate
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FCACallbackDelegate final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCACallbackDelegate) == 0x000008, "Wrong alignment on FCACallbackDelegate");
static_assert(sizeof(FCACallbackDelegate) == 0x000028, "Wrong size on FCACallbackDelegate");

// ScriptStruct keaton.CAMissionWaveGroupData
// 0x0028 (0x0028 - 0x0000)
struct FCAMissionWaveGroupData final
{
public:
	class FString                                 M_wave_group_name;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAMissionWaveGroupTupleData>   M_mission_waves;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_exclude_selected_waves_until_all_other_waves_have_been_selected; // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMissionWaveGroupData) == 0x000008, "Wrong alignment on FCAMissionWaveGroupData");
static_assert(sizeof(FCAMissionWaveGroupData) == 0x000028, "Wrong size on FCAMissionWaveGroupData");
static_assert(offsetof(FCAMissionWaveGroupData, M_wave_group_name) == 0x000000, "Member 'FCAMissionWaveGroupData::M_wave_group_name' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveGroupData, M_mission_waves) == 0x000010, "Member 'FCAMissionWaveGroupData::M_mission_waves' has a wrong offset!");
static_assert(offsetof(FCAMissionWaveGroupData, M_exclude_selected_waves_until_all_other_waves_have_been_selected) == 0x000020, "Member 'FCAMissionWaveGroupData::M_exclude_selected_waves_until_all_other_waves_have_been_selected' has a wrong offset!");

// ScriptStruct keaton.ConfigBasedSpawnInfo
// 0x0018 (0x0018 - 0x0000)
struct FConfigBasedSpawnInfo final
{
public:
	struct FGameplayTag                           M_config;                                          // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     M_actor_to_spawn;                                  // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConfigBasedSpawnInfo) == 0x000008, "Wrong alignment on FConfigBasedSpawnInfo");
static_assert(sizeof(FConfigBasedSpawnInfo) == 0x000018, "Wrong size on FConfigBasedSpawnInfo");
static_assert(offsetof(FConfigBasedSpawnInfo, M_config) == 0x000000, "Member 'FConfigBasedSpawnInfo::M_config' has a wrong offset!");
static_assert(offsetof(FConfigBasedSpawnInfo, M_actor_to_spawn) == 0x000010, "Member 'FConfigBasedSpawnInfo::M_actor_to_spawn' has a wrong offset!");

// ScriptStruct keaton.CACampTypeConstraintsTagLimits
// 0x0014 (0x0014 - 0x0000)
struct FCACampTypeConstraintsTagLimits final
{
public:
	struct FGameplayTag                           CampConstraintIdentifier;                          // 0x0000(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min;                                               // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACampTypeConstraintsTagLimits) == 0x000004, "Wrong alignment on FCACampTypeConstraintsTagLimits");
static_assert(sizeof(FCACampTypeConstraintsTagLimits) == 0x000014, "Wrong size on FCACampTypeConstraintsTagLimits");
static_assert(offsetof(FCACampTypeConstraintsTagLimits, CampConstraintIdentifier) == 0x000000, "Member 'FCACampTypeConstraintsTagLimits::CampConstraintIdentifier' has a wrong offset!");
static_assert(offsetof(FCACampTypeConstraintsTagLimits, Min) == 0x00000C, "Member 'FCACampTypeConstraintsTagLimits::Min' has a wrong offset!");
static_assert(offsetof(FCACampTypeConstraintsTagLimits, Max) == 0x000010, "Member 'FCACampTypeConstraintsTagLimits::Max' has a wrong offset!");

// ScriptStruct keaton.CACampTypeConstraints
// 0x0010 (0x0018 - 0x0008)
struct FCACampTypeConstraints final : public FTableRowBase
{
public:
	TArray<struct FCACampTypeConstraintsTagLimits> TagLimits;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACampTypeConstraints) == 0x000008, "Wrong alignment on FCACampTypeConstraints");
static_assert(sizeof(FCACampTypeConstraints) == 0x000018, "Wrong size on FCACampTypeConstraints");
static_assert(offsetof(FCACampTypeConstraints, TagLimits) == 0x000008, "Member 'FCACampTypeConstraints::TagLimits' has a wrong offset!");

// ScriptStruct keaton.CAFastPathDebrisSpawnItem
// 0x0028 (0x0028 - 0x0000)
struct FCAFastPathDebrisSpawnItem final
{
public:
	class UCAFastPathDebrisItem*                  M_item;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_relative_frequency;                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              M_velocity_range;                                  // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              M_angular_velocity_range;                          // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              M_scale_range;                                     // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAFastPathDebrisSpawnItem) == 0x000008, "Wrong alignment on FCAFastPathDebrisSpawnItem");
static_assert(sizeof(FCAFastPathDebrisSpawnItem) == 0x000028, "Wrong size on FCAFastPathDebrisSpawnItem");
static_assert(offsetof(FCAFastPathDebrisSpawnItem, M_item) == 0x000000, "Member 'FCAFastPathDebrisSpawnItem::M_item' has a wrong offset!");
static_assert(offsetof(FCAFastPathDebrisSpawnItem, M_relative_frequency) == 0x000008, "Member 'FCAFastPathDebrisSpawnItem::M_relative_frequency' has a wrong offset!");
static_assert(offsetof(FCAFastPathDebrisSpawnItem, M_velocity_range) == 0x00000C, "Member 'FCAFastPathDebrisSpawnItem::M_velocity_range' has a wrong offset!");
static_assert(offsetof(FCAFastPathDebrisSpawnItem, M_angular_velocity_range) == 0x000014, "Member 'FCAFastPathDebrisSpawnItem::M_angular_velocity_range' has a wrong offset!");
static_assert(offsetof(FCAFastPathDebrisSpawnItem, M_scale_range) == 0x00001C, "Member 'FCAFastPathDebrisSpawnItem::M_scale_range' has a wrong offset!");

// ScriptStruct keaton.CAHUDTeamScoreboardItem
// 0x0018 (0x0018 - 0x0000)
struct FCAHUDTeamScoreboardItem final
{
public:
	struct FCATeamID                              M_team_id;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_team_score;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_rank;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_local_team;                                   // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_team_wiped;                                   // 0x000D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_has_reached_threshold;                           // 0x000E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_has_extraction_progress;                         // 0x000F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAHUDTeamScoreboardItemWidget*         M_linked_widget;                                   // 0x0010(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDTeamScoreboardItem) == 0x000008, "Wrong alignment on FCAHUDTeamScoreboardItem");
static_assert(sizeof(FCAHUDTeamScoreboardItem) == 0x000018, "Wrong size on FCAHUDTeamScoreboardItem");
static_assert(offsetof(FCAHUDTeamScoreboardItem, M_team_id) == 0x000000, "Member 'FCAHUDTeamScoreboardItem::M_team_id' has a wrong offset!");
static_assert(offsetof(FCAHUDTeamScoreboardItem, M_team_score) == 0x000004, "Member 'FCAHUDTeamScoreboardItem::M_team_score' has a wrong offset!");
static_assert(offsetof(FCAHUDTeamScoreboardItem, M_rank) == 0x000008, "Member 'FCAHUDTeamScoreboardItem::M_rank' has a wrong offset!");
static_assert(offsetof(FCAHUDTeamScoreboardItem, M_is_local_team) == 0x00000C, "Member 'FCAHUDTeamScoreboardItem::M_is_local_team' has a wrong offset!");
static_assert(offsetof(FCAHUDTeamScoreboardItem, M_is_team_wiped) == 0x00000D, "Member 'FCAHUDTeamScoreboardItem::M_is_team_wiped' has a wrong offset!");
static_assert(offsetof(FCAHUDTeamScoreboardItem, M_has_reached_threshold) == 0x00000E, "Member 'FCAHUDTeamScoreboardItem::M_has_reached_threshold' has a wrong offset!");
static_assert(offsetof(FCAHUDTeamScoreboardItem, M_has_extraction_progress) == 0x00000F, "Member 'FCAHUDTeamScoreboardItem::M_has_extraction_progress' has a wrong offset!");
static_assert(offsetof(FCAHUDTeamScoreboardItem, M_linked_widget) == 0x000010, "Member 'FCAHUDTeamScoreboardItem::M_linked_widget' has a wrong offset!");

// ScriptStruct keaton.CAAnimOverride
// 0x0078 (0x0080 - 0x0008)
struct FCAAnimOverride final : public FTableRowBase
{
public:
	struct FFeatureKeyItem                        M_feature;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   M_name;                                            // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimationAsset>         M_animation;                                       // 0x0018(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionClass                              M_locomotion_class;                                // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_specialist_name;                                 // 0x004C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_device_name;                                     // 0x0058(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_mesh_name;                                       // 0x0064(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_anim_tag;                                        // 0x0070(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_priority;                                        // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAnimOverride) == 0x000008, "Wrong alignment on FCAAnimOverride");
static_assert(sizeof(FCAAnimOverride) == 0x000080, "Wrong size on FCAAnimOverride");
static_assert(offsetof(FCAAnimOverride, M_feature) == 0x000008, "Member 'FCAAnimOverride::M_feature' has a wrong offset!");
static_assert(offsetof(FCAAnimOverride, M_name) == 0x00000C, "Member 'FCAAnimOverride::M_name' has a wrong offset!");
static_assert(offsetof(FCAAnimOverride, M_animation) == 0x000018, "Member 'FCAAnimOverride::M_animation' has a wrong offset!");
static_assert(offsetof(FCAAnimOverride, M_locomotion_class) == 0x000048, "Member 'FCAAnimOverride::M_locomotion_class' has a wrong offset!");
static_assert(offsetof(FCAAnimOverride, M_specialist_name) == 0x00004C, "Member 'FCAAnimOverride::M_specialist_name' has a wrong offset!");
static_assert(offsetof(FCAAnimOverride, M_device_name) == 0x000058, "Member 'FCAAnimOverride::M_device_name' has a wrong offset!");
static_assert(offsetof(FCAAnimOverride, M_mesh_name) == 0x000064, "Member 'FCAAnimOverride::M_mesh_name' has a wrong offset!");
static_assert(offsetof(FCAAnimOverride, M_anim_tag) == 0x000070, "Member 'FCAAnimOverride::M_anim_tag' has a wrong offset!");
static_assert(offsetof(FCAAnimOverride, M_priority) == 0x00007C, "Member 'FCAAnimOverride::M_priority' has a wrong offset!");

// ScriptStruct keaton.NPCSpawnLimitData
// 0x0010 (0x0010 - 0x0000)
struct FNPCSpawnLimitData final
{
public:
	struct FGameplayTag                           M_type;                                            // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_limit;                                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCSpawnLimitData) == 0x000004, "Wrong alignment on FNPCSpawnLimitData");
static_assert(sizeof(FNPCSpawnLimitData) == 0x000010, "Wrong size on FNPCSpawnLimitData");
static_assert(offsetof(FNPCSpawnLimitData, M_type) == 0x000000, "Member 'FNPCSpawnLimitData::M_type' has a wrong offset!");
static_assert(offsetof(FNPCSpawnLimitData, M_limit) == 0x00000C, "Member 'FNPCSpawnLimitData::M_limit' has a wrong offset!");

// ScriptStruct keaton.CACampTypeData
// 0x0180 (0x0188 - 0x0008)
struct FCACampTypeData final : public FTableRowBase
{
public:
	struct FGameplayTag                           CampTypeID;                                        // 0x0008(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CampConfigID;                                      // 0x0014(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   CampConstraintIdentifiers;                         // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   TagsToAssignToSecurityArea;                        // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ECAUIHUDEntityId                              VaultIconID;                                       // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCADataTableRowHandle                  VaultCaptureRow;                                   // 0x0048(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCADataTableHandle                     CampLootContainerDistribution;                     // 0x0060(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAText                                CampTypeText;                                      // 0x0068(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<class UDataTable*>                     M_mission_tables_to_always_use;                    // 0x0098(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UDataTable*>                     M_additional_random_mission_tables;                // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCADataTableHandle                     M_objective_loop_missions;                         // 0x00B8(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_override_npc_spawn_token_limit;                  // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_npc_spawn_token_limit;                           // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_override_npc_spawn_limits_per_type;              // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNPCSpawnLimitData>             M_npc_spawn_limits_per_type;                       // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_override_npc_escalator_spawn_limit;              // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_npc_escalator_spawn_limit;                       // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_npc_deescalation_percentage;                     // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_reward_distribution_identifier;                  // 0x00EC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCARewardDistributionTableEntry> M_reward_distributions;                            // 0x00F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    M_reward_distribution_grouping;                    // 0x0108(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_override_state_machine_to_use;                   // 0x0120(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCAStateMachineDefinitionDataAsset> M_security_area_state_machine_asset;               // 0x0128(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCAStateMachineDefinitionDataAsset> M_escalation_state_machine_asset;                  // 0x0158(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACampTypeData) == 0x000008, "Wrong alignment on FCACampTypeData");
static_assert(sizeof(FCACampTypeData) == 0x000188, "Wrong size on FCACampTypeData");
static_assert(offsetof(FCACampTypeData, CampTypeID) == 0x000008, "Member 'FCACampTypeData::CampTypeID' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, CampConfigID) == 0x000014, "Member 'FCACampTypeData::CampConfigID' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, CampConstraintIdentifiers) == 0x000020, "Member 'FCACampTypeData::CampConstraintIdentifiers' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, TagsToAssignToSecurityArea) == 0x000030, "Member 'FCACampTypeData::TagsToAssignToSecurityArea' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, VaultIconID) == 0x000040, "Member 'FCACampTypeData::VaultIconID' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, VaultCaptureRow) == 0x000048, "Member 'FCACampTypeData::VaultCaptureRow' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, CampLootContainerDistribution) == 0x000060, "Member 'FCACampTypeData::CampLootContainerDistribution' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, CampTypeText) == 0x000068, "Member 'FCACampTypeData::CampTypeText' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, M_mission_tables_to_always_use) == 0x000098, "Member 'FCACampTypeData::M_mission_tables_to_always_use' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, M_additional_random_mission_tables) == 0x0000A8, "Member 'FCACampTypeData::M_additional_random_mission_tables' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, M_objective_loop_missions) == 0x0000B8, "Member 'FCACampTypeData::M_objective_loop_missions' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, M_override_npc_spawn_token_limit) == 0x0000C0, "Member 'FCACampTypeData::M_override_npc_spawn_token_limit' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, M_npc_spawn_token_limit) == 0x0000C4, "Member 'FCACampTypeData::M_npc_spawn_token_limit' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, M_override_npc_spawn_limits_per_type) == 0x0000C8, "Member 'FCACampTypeData::M_override_npc_spawn_limits_per_type' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, M_npc_spawn_limits_per_type) == 0x0000D0, "Member 'FCACampTypeData::M_npc_spawn_limits_per_type' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, M_override_npc_escalator_spawn_limit) == 0x0000E0, "Member 'FCACampTypeData::M_override_npc_escalator_spawn_limit' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, M_npc_escalator_spawn_limit) == 0x0000E4, "Member 'FCACampTypeData::M_npc_escalator_spawn_limit' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, M_npc_deescalation_percentage) == 0x0000E8, "Member 'FCACampTypeData::M_npc_deescalation_percentage' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, M_reward_distribution_identifier) == 0x0000EC, "Member 'FCACampTypeData::M_reward_distribution_identifier' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, M_reward_distributions) == 0x0000F8, "Member 'FCACampTypeData::M_reward_distributions' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, M_reward_distribution_grouping) == 0x000108, "Member 'FCACampTypeData::M_reward_distribution_grouping' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, M_override_state_machine_to_use) == 0x000120, "Member 'FCACampTypeData::M_override_state_machine_to_use' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, M_security_area_state_machine_asset) == 0x000128, "Member 'FCACampTypeData::M_security_area_state_machine_asset' has a wrong offset!");
static_assert(offsetof(FCACampTypeData, M_escalation_state_machine_asset) == 0x000158, "Member 'FCACampTypeData::M_escalation_state_machine_asset' has a wrong offset!");

// ScriptStruct keaton.CADamageOptions
// 0x0010 (0x0010 - 0x0000)
struct FCADamageOptions final
{
public:
	float                                         M_damage_multiplier_NPCs_to_NPCs;                  // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_damage_multiplier_NPCs_to_players;               // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_damage_multiplier_players_to_NPCs;               // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_damage_multiplier_players_to_players;            // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADamageOptions) == 0x000004, "Wrong alignment on FCADamageOptions");
static_assert(sizeof(FCADamageOptions) == 0x000010, "Wrong size on FCADamageOptions");
static_assert(offsetof(FCADamageOptions, M_damage_multiplier_NPCs_to_NPCs) == 0x000000, "Member 'FCADamageOptions::M_damage_multiplier_NPCs_to_NPCs' has a wrong offset!");
static_assert(offsetof(FCADamageOptions, M_damage_multiplier_NPCs_to_players) == 0x000004, "Member 'FCADamageOptions::M_damage_multiplier_NPCs_to_players' has a wrong offset!");
static_assert(offsetof(FCADamageOptions, M_damage_multiplier_players_to_NPCs) == 0x000008, "Member 'FCADamageOptions::M_damage_multiplier_players_to_NPCs' has a wrong offset!");
static_assert(offsetof(FCADamageOptions, M_damage_multiplier_players_to_players) == 0x00000C, "Member 'FCADamageOptions::M_damage_multiplier_players_to_players' has a wrong offset!");

// ScriptStruct keaton.CAServicesMatchMakingQueueTableRow
// 0x0028 (0x0030 - 0x0008)
struct FCAServicesMatchMakingQueueTableRow final : public FTableRowBase
{
public:
	class FString                                 M_queue_name;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_handle;                                          // 0x0018(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAServicesMatchMakingQueueTableRow) == 0x000008, "Wrong alignment on FCAServicesMatchMakingQueueTableRow");
static_assert(sizeof(FCAServicesMatchMakingQueueTableRow) == 0x000030, "Wrong size on FCAServicesMatchMakingQueueTableRow");
static_assert(offsetof(FCAServicesMatchMakingQueueTableRow, M_queue_name) == 0x000008, "Member 'FCAServicesMatchMakingQueueTableRow::M_queue_name' has a wrong offset!");
static_assert(offsetof(FCAServicesMatchMakingQueueTableRow, M_handle) == 0x000018, "Member 'FCAServicesMatchMakingQueueTableRow::M_handle' has a wrong offset!");

// ScriptStruct keaton.CACampConfigDescriptor
// 0x0108 (0x0108 - 0x0000)
struct FCACampConfigDescriptor final
{
public:
	struct FGameplayTag                           CampConfigID;                                      // 0x0000(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           LevelsToLoadAlways;                                // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           AdditionalRandomLevelsToLoad;                      // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CampTheme;                                         // 0x0030(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, int32>              M_objective_loop_type_limit;                       // 0x0040(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         M_objective_loop_area_limit;                       // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_override_additional_random_mission_tables;       // 0x0094(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDataTable*>                     AdditionalRandomMissionTables;                     // 0x0098(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_override_npc_spawn_token_limit;                  // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_npc_spawn_token_limit;                           // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_override_npc_spawn_limits_per_type;              // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNPCSpawnLimitData>             M_npc_spawn_limits_per_type;                       // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_override_npc_escalator_spawn_limit;              // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_npc_escalator_spawn_limit;                       // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_reward_distribution_identifier;                  // 0x00D0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCARewardDistributionTableEntry> M_reward_distributions;                            // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    M_reward_distribution_grouping;                    // 0x00F0(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACampConfigDescriptor) == 0x000008, "Wrong alignment on FCACampConfigDescriptor");
static_assert(sizeof(FCACampConfigDescriptor) == 0x000108, "Wrong size on FCACampConfigDescriptor");
static_assert(offsetof(FCACampConfigDescriptor, CampConfigID) == 0x000000, "Member 'FCACampConfigDescriptor::CampConfigID' has a wrong offset!");
static_assert(offsetof(FCACampConfigDescriptor, LevelsToLoadAlways) == 0x000010, "Member 'FCACampConfigDescriptor::LevelsToLoadAlways' has a wrong offset!");
static_assert(offsetof(FCACampConfigDescriptor, AdditionalRandomLevelsToLoad) == 0x000020, "Member 'FCACampConfigDescriptor::AdditionalRandomLevelsToLoad' has a wrong offset!");
static_assert(offsetof(FCACampConfigDescriptor, CampTheme) == 0x000030, "Member 'FCACampConfigDescriptor::CampTheme' has a wrong offset!");
static_assert(offsetof(FCACampConfigDescriptor, M_objective_loop_type_limit) == 0x000040, "Member 'FCACampConfigDescriptor::M_objective_loop_type_limit' has a wrong offset!");
static_assert(offsetof(FCACampConfigDescriptor, M_objective_loop_area_limit) == 0x000090, "Member 'FCACampConfigDescriptor::M_objective_loop_area_limit' has a wrong offset!");
static_assert(offsetof(FCACampConfigDescriptor, M_override_additional_random_mission_tables) == 0x000094, "Member 'FCACampConfigDescriptor::M_override_additional_random_mission_tables' has a wrong offset!");
static_assert(offsetof(FCACampConfigDescriptor, AdditionalRandomMissionTables) == 0x000098, "Member 'FCACampConfigDescriptor::AdditionalRandomMissionTables' has a wrong offset!");
static_assert(offsetof(FCACampConfigDescriptor, M_override_npc_spawn_token_limit) == 0x0000A8, "Member 'FCACampConfigDescriptor::M_override_npc_spawn_token_limit' has a wrong offset!");
static_assert(offsetof(FCACampConfigDescriptor, M_npc_spawn_token_limit) == 0x0000AC, "Member 'FCACampConfigDescriptor::M_npc_spawn_token_limit' has a wrong offset!");
static_assert(offsetof(FCACampConfigDescriptor, M_override_npc_spawn_limits_per_type) == 0x0000B0, "Member 'FCACampConfigDescriptor::M_override_npc_spawn_limits_per_type' has a wrong offset!");
static_assert(offsetof(FCACampConfigDescriptor, M_npc_spawn_limits_per_type) == 0x0000B8, "Member 'FCACampConfigDescriptor::M_npc_spawn_limits_per_type' has a wrong offset!");
static_assert(offsetof(FCACampConfigDescriptor, M_override_npc_escalator_spawn_limit) == 0x0000C8, "Member 'FCACampConfigDescriptor::M_override_npc_escalator_spawn_limit' has a wrong offset!");
static_assert(offsetof(FCACampConfigDescriptor, M_npc_escalator_spawn_limit) == 0x0000CC, "Member 'FCACampConfigDescriptor::M_npc_escalator_spawn_limit' has a wrong offset!");
static_assert(offsetof(FCACampConfigDescriptor, M_reward_distribution_identifier) == 0x0000D0, "Member 'FCACampConfigDescriptor::M_reward_distribution_identifier' has a wrong offset!");
static_assert(offsetof(FCACampConfigDescriptor, M_reward_distributions) == 0x0000E0, "Member 'FCACampConfigDescriptor::M_reward_distributions' has a wrong offset!");
static_assert(offsetof(FCACampConfigDescriptor, M_reward_distribution_grouping) == 0x0000F0, "Member 'FCACampConfigDescriptor::M_reward_distribution_grouping' has a wrong offset!");

// ScriptStruct keaton.CAPerCampData
// 0x0028 (0x0030 - 0x0008)
struct FCAPerCampData final : public FTableRowBase
{
public:
	TArray<struct FCACampConfigDescriptor>        CampTypeDescriptors;                               // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   MasterLevel;                                       // 0x0018(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           HubID;                                             // 0x0024(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPerCampData) == 0x000008, "Wrong alignment on FCAPerCampData");
static_assert(sizeof(FCAPerCampData) == 0x000030, "Wrong size on FCAPerCampData");
static_assert(offsetof(FCAPerCampData, CampTypeDescriptors) == 0x000008, "Member 'FCAPerCampData::CampTypeDescriptors' has a wrong offset!");
static_assert(offsetof(FCAPerCampData, MasterLevel) == 0x000018, "Member 'FCAPerCampData::MasterLevel' has a wrong offset!");
static_assert(offsetof(FCAPerCampData, HubID) == 0x000024, "Member 'FCAPerCampData::HubID' has a wrong offset!");

// ScriptStruct keaton.CAEffectVariant
// 0x0060 (0x0060 - 0x0000)
struct FCAEffectVariant final
{
public:
	class FName                                   Identifier;                                        // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   Effect_blueprint;                                  // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Effect_asset;                                      // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAEffectVariant) == 0x000008, "Wrong alignment on FCAEffectVariant");
static_assert(sizeof(FCAEffectVariant) == 0x000060, "Wrong size on FCAEffectVariant");
static_assert(offsetof(FCAEffectVariant, Identifier) == 0x000000, "Member 'FCAEffectVariant::Identifier' has a wrong offset!");
static_assert(offsetof(FCAEffectVariant, Effect_blueprint) == 0x000010, "Member 'FCAEffectVariant::Effect_blueprint' has a wrong offset!");
static_assert(offsetof(FCAEffectVariant, Effect_asset) == 0x000040, "Member 'FCAEffectVariant::Effect_asset' has a wrong offset!");

// ScriptStruct keaton.CAEffectRow
// 0x0060 (0x0068 - 0x0008)
struct FCAEffectRow final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   Default_effect_blueprint;                          // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Default_effect_asset;                              // 0x0038(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAEffectVariant>               Effect_variants;                                   // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAEffectRow) == 0x000008, "Wrong alignment on FCAEffectRow");
static_assert(sizeof(FCAEffectRow) == 0x000068, "Wrong size on FCAEffectRow");
static_assert(offsetof(FCAEffectRow, Default_effect_blueprint) == 0x000008, "Member 'FCAEffectRow::Default_effect_blueprint' has a wrong offset!");
static_assert(offsetof(FCAEffectRow, Default_effect_asset) == 0x000038, "Member 'FCAEffectRow::Default_effect_asset' has a wrong offset!");
static_assert(offsetof(FCAEffectRow, Effect_variants) == 0x000058, "Member 'FCAEffectRow::Effect_variants' has a wrong offset!");

// ScriptStruct keaton.CARewardSourceToRewardSetTableData
// 0x0078 (0x0078 - 0x0000)
struct FCARewardSourceToRewardSetTableData final
{
public:
	struct FGameplayTag                           M_reward_source_type;                              // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              M_reward_set_table;                                // 0x0010(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_apply_default_rule_set;                          // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              M_rule_set_table;                                  // 0x0048(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARewardSourceToRewardSetTableData) == 0x000008, "Wrong alignment on FCARewardSourceToRewardSetTableData");
static_assert(sizeof(FCARewardSourceToRewardSetTableData) == 0x000078, "Wrong size on FCARewardSourceToRewardSetTableData");
static_assert(offsetof(FCARewardSourceToRewardSetTableData, M_reward_source_type) == 0x000000, "Member 'FCARewardSourceToRewardSetTableData::M_reward_source_type' has a wrong offset!");
static_assert(offsetof(FCARewardSourceToRewardSetTableData, M_reward_set_table) == 0x000010, "Member 'FCARewardSourceToRewardSetTableData::M_reward_set_table' has a wrong offset!");
static_assert(offsetof(FCARewardSourceToRewardSetTableData, M_apply_default_rule_set) == 0x000040, "Member 'FCARewardSourceToRewardSetTableData::M_apply_default_rule_set' has a wrong offset!");
static_assert(offsetof(FCARewardSourceToRewardSetTableData, M_rule_set_table) == 0x000048, "Member 'FCARewardSourceToRewardSetTableData::M_rule_set_table' has a wrong offset!");

// ScriptStruct keaton.CARewardDistributionData
// 0x0020 (0x0028 - 0x0008)
struct FCARewardDistributionData final : public FTableRowBase
{
public:
	bool                                          M_enabled;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        M_priority;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCARewardSourceToRewardSetTableData> M_reward_source_to_reward_set_mapping;             // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARewardDistributionData) == 0x000008, "Wrong alignment on FCARewardDistributionData");
static_assert(sizeof(FCARewardDistributionData) == 0x000028, "Wrong size on FCARewardDistributionData");
static_assert(offsetof(FCARewardDistributionData, M_enabled) == 0x000008, "Member 'FCARewardDistributionData::M_enabled' has a wrong offset!");
static_assert(offsetof(FCARewardDistributionData, M_priority) == 0x00000C, "Member 'FCARewardDistributionData::M_priority' has a wrong offset!");
static_assert(offsetof(FCARewardDistributionData, M_reward_source_to_reward_set_mapping) == 0x000018, "Member 'FCARewardDistributionData::M_reward_source_to_reward_set_mapping' has a wrong offset!");

// ScriptStruct keaton.CAAttributeInitialisationTableCapture
// 0x0010 (0x0018 - 0x0008)
struct FCAAttributeInitialisationTableCapture final : public FTableRowBase
{
public:
	float                                         MaxCapture;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRelease;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCATeamID                              StartingTeam;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAttributeInitialisationTableCapture) == 0x000008, "Wrong alignment on FCAAttributeInitialisationTableCapture");
static_assert(sizeof(FCAAttributeInitialisationTableCapture) == 0x000018, "Wrong size on FCAAttributeInitialisationTableCapture");
static_assert(offsetof(FCAAttributeInitialisationTableCapture, MaxCapture) == 0x000008, "Member 'FCAAttributeInitialisationTableCapture::MaxCapture' has a wrong offset!");
static_assert(offsetof(FCAAttributeInitialisationTableCapture, MaxRelease) == 0x00000C, "Member 'FCAAttributeInitialisationTableCapture::MaxRelease' has a wrong offset!");
static_assert(offsetof(FCAAttributeInitialisationTableCapture, StartingTeam) == 0x000010, "Member 'FCAAttributeInitialisationTableCapture::StartingTeam' has a wrong offset!");

// ScriptStruct keaton.CAChallengeCaptureInfo
// 0x001C (0x001C - 0x0000)
struct FCAChallengeCaptureInfo final
{
public:
	int32                                         M_SourceFlags;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_TargetFlags;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_UsingFlags;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SourceOwnerFlags;                                // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_TargetOwnerFlags;                                // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_OriginalSourceFlags;                             // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HitFlags;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAChallengeCaptureInfo) == 0x000004, "Wrong alignment on FCAChallengeCaptureInfo");
static_assert(sizeof(FCAChallengeCaptureInfo) == 0x00001C, "Wrong size on FCAChallengeCaptureInfo");
static_assert(offsetof(FCAChallengeCaptureInfo, M_SourceFlags) == 0x000000, "Member 'FCAChallengeCaptureInfo::M_SourceFlags' has a wrong offset!");
static_assert(offsetof(FCAChallengeCaptureInfo, M_TargetFlags) == 0x000004, "Member 'FCAChallengeCaptureInfo::M_TargetFlags' has a wrong offset!");
static_assert(offsetof(FCAChallengeCaptureInfo, M_UsingFlags) == 0x000008, "Member 'FCAChallengeCaptureInfo::M_UsingFlags' has a wrong offset!");
static_assert(offsetof(FCAChallengeCaptureInfo, M_SourceOwnerFlags) == 0x00000C, "Member 'FCAChallengeCaptureInfo::M_SourceOwnerFlags' has a wrong offset!");
static_assert(offsetof(FCAChallengeCaptureInfo, M_TargetOwnerFlags) == 0x000010, "Member 'FCAChallengeCaptureInfo::M_TargetOwnerFlags' has a wrong offset!");
static_assert(offsetof(FCAChallengeCaptureInfo, M_OriginalSourceFlags) == 0x000014, "Member 'FCAChallengeCaptureInfo::M_OriginalSourceFlags' has a wrong offset!");
static_assert(offsetof(FCAChallengeCaptureInfo, M_HitFlags) == 0x000018, "Member 'FCAChallengeCaptureInfo::M_HitFlags' has a wrong offset!");

// ScriptStruct keaton.CAFragGrenadeLevelDataRow
// 0x0068 (0x0068 - 0x0000)
struct FCAFragGrenadeLevelDataRow final
{
public:
	ECAGameplayEffectGravityValue                 M_gravity_value;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fuse_time;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_radius;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_damage;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_elite_multiplier;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_npc_multiplier;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_foam_multiplier;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_lifesteal_max;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_lifesteal_min;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_gravity_scale;                                   // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_bounciness;                                      // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_friction;                                        // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACAExplosionEffect>         M_explosion_effect;                                // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAGameplayEffectContainer             M_effect_container;                                // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          M_bounced;                                         // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAFragGrenadeBounceDataRow>    M_bounces_data;                                    // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFragGrenadeLevelDataRow) == 0x000008, "Wrong alignment on FCAFragGrenadeLevelDataRow");
static_assert(sizeof(FCAFragGrenadeLevelDataRow) == 0x000068, "Wrong size on FCAFragGrenadeLevelDataRow");
static_assert(offsetof(FCAFragGrenadeLevelDataRow, M_gravity_value) == 0x000000, "Member 'FCAFragGrenadeLevelDataRow::M_gravity_value' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeLevelDataRow, M_fuse_time) == 0x000004, "Member 'FCAFragGrenadeLevelDataRow::M_fuse_time' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeLevelDataRow, M_radius) == 0x000008, "Member 'FCAFragGrenadeLevelDataRow::M_radius' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeLevelDataRow, M_damage) == 0x00000C, "Member 'FCAFragGrenadeLevelDataRow::M_damage' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeLevelDataRow, M_elite_multiplier) == 0x000010, "Member 'FCAFragGrenadeLevelDataRow::M_elite_multiplier' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeLevelDataRow, M_npc_multiplier) == 0x000014, "Member 'FCAFragGrenadeLevelDataRow::M_npc_multiplier' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeLevelDataRow, M_foam_multiplier) == 0x000018, "Member 'FCAFragGrenadeLevelDataRow::M_foam_multiplier' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeLevelDataRow, M_lifesteal_max) == 0x00001C, "Member 'FCAFragGrenadeLevelDataRow::M_lifesteal_max' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeLevelDataRow, M_lifesteal_min) == 0x000020, "Member 'FCAFragGrenadeLevelDataRow::M_lifesteal_min' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeLevelDataRow, M_gravity_scale) == 0x000024, "Member 'FCAFragGrenadeLevelDataRow::M_gravity_scale' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeLevelDataRow, M_bounciness) == 0x000028, "Member 'FCAFragGrenadeLevelDataRow::M_bounciness' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeLevelDataRow, M_friction) == 0x00002C, "Member 'FCAFragGrenadeLevelDataRow::M_friction' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeLevelDataRow, M_explosion_effect) == 0x000030, "Member 'FCAFragGrenadeLevelDataRow::M_explosion_effect' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeLevelDataRow, M_effect_container) == 0x000038, "Member 'FCAFragGrenadeLevelDataRow::M_effect_container' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeLevelDataRow, M_bounced) == 0x000050, "Member 'FCAFragGrenadeLevelDataRow::M_bounced' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeLevelDataRow, M_bounces_data) == 0x000058, "Member 'FCAFragGrenadeLevelDataRow::M_bounces_data' has a wrong offset!");

// ScriptStruct keaton.CAChallengeConstraintFilter
// 0x00B0 (0x00B0 - 0x0000)
struct FCAChallengeConstraintFilter final
{
public:
	ECAChallengeConstraintAllegiance              M_TargetAllegiance;                                // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFeatureClassPtr>               M_Classes;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               M_RequirementTags;                                 // 0x0018(0x0040)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         M_MovementModes;                                   // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BodyParts;                                       // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_Names;                                           // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UPhysicalMaterial>> M_Surfaces;                                        // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           M_AttachmentClasses;                               // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FCAOriginalSourceInfo                  M_OriginalSourceInformation;                       // 0x0090(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         M_HitRequirements;                                 // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_LocationRequirements;                            // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAChallengeConstraintFilter) == 0x000008, "Wrong alignment on FCAChallengeConstraintFilter");
static_assert(sizeof(FCAChallengeConstraintFilter) == 0x0000B0, "Wrong size on FCAChallengeConstraintFilter");
static_assert(offsetof(FCAChallengeConstraintFilter, M_TargetAllegiance) == 0x000000, "Member 'FCAChallengeConstraintFilter::M_TargetAllegiance' has a wrong offset!");
static_assert(offsetof(FCAChallengeConstraintFilter, M_Classes) == 0x000008, "Member 'FCAChallengeConstraintFilter::M_Classes' has a wrong offset!");
static_assert(offsetof(FCAChallengeConstraintFilter, M_RequirementTags) == 0x000018, "Member 'FCAChallengeConstraintFilter::M_RequirementTags' has a wrong offset!");
static_assert(offsetof(FCAChallengeConstraintFilter, M_MovementModes) == 0x000058, "Member 'FCAChallengeConstraintFilter::M_MovementModes' has a wrong offset!");
static_assert(offsetof(FCAChallengeConstraintFilter, M_BodyParts) == 0x00005C, "Member 'FCAChallengeConstraintFilter::M_BodyParts' has a wrong offset!");
static_assert(offsetof(FCAChallengeConstraintFilter, M_Names) == 0x000060, "Member 'FCAChallengeConstraintFilter::M_Names' has a wrong offset!");
static_assert(offsetof(FCAChallengeConstraintFilter, M_Surfaces) == 0x000070, "Member 'FCAChallengeConstraintFilter::M_Surfaces' has a wrong offset!");
static_assert(offsetof(FCAChallengeConstraintFilter, M_AttachmentClasses) == 0x000080, "Member 'FCAChallengeConstraintFilter::M_AttachmentClasses' has a wrong offset!");
static_assert(offsetof(FCAChallengeConstraintFilter, M_OriginalSourceInformation) == 0x000090, "Member 'FCAChallengeConstraintFilter::M_OriginalSourceInformation' has a wrong offset!");
static_assert(offsetof(FCAChallengeConstraintFilter, M_HitRequirements) == 0x0000A8, "Member 'FCAChallengeConstraintFilter::M_HitRequirements' has a wrong offset!");
static_assert(offsetof(FCAChallengeConstraintFilter, M_LocationRequirements) == 0x0000AC, "Member 'FCAChallengeConstraintFilter::M_LocationRequirements' has a wrong offset!");

// ScriptStruct keaton.CAChallengeConstraintSet
// 0x00C0 (0x00C8 - 0x0008)
struct FCAChallengeConstraintSet final : public FTableRowBase
{
public:
	ECAChallengeConstraintContext                 M_ConstraintType;                                  // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAChallengeConstraintApplication             M_ConstraintApplication;                           // 0x0009(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAChallengeConstraintScriptOwner             M_ScriptOwner;                                     // 0x000A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAChallengeConstraintLogic                   M_ConstraintLogic;                                 // 0x000B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_EvaluateOnAllDefinitionEvents;                   // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_EvaluateOnEvents;                                // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_EnableFailureLeniency;                           // 0x0014(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAChallengeConstraintFilter           M_ConstraintFilter;                                // 0x0018(0x00B0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAChallengeConstraintSet) == 0x000008, "Wrong alignment on FCAChallengeConstraintSet");
static_assert(sizeof(FCAChallengeConstraintSet) == 0x0000C8, "Wrong size on FCAChallengeConstraintSet");
static_assert(offsetof(FCAChallengeConstraintSet, M_ConstraintType) == 0x000008, "Member 'FCAChallengeConstraintSet::M_ConstraintType' has a wrong offset!");
static_assert(offsetof(FCAChallengeConstraintSet, M_ConstraintApplication) == 0x000009, "Member 'FCAChallengeConstraintSet::M_ConstraintApplication' has a wrong offset!");
static_assert(offsetof(FCAChallengeConstraintSet, M_ScriptOwner) == 0x00000A, "Member 'FCAChallengeConstraintSet::M_ScriptOwner' has a wrong offset!");
static_assert(offsetof(FCAChallengeConstraintSet, M_ConstraintLogic) == 0x00000B, "Member 'FCAChallengeConstraintSet::M_ConstraintLogic' has a wrong offset!");
static_assert(offsetof(FCAChallengeConstraintSet, M_EvaluateOnAllDefinitionEvents) == 0x00000C, "Member 'FCAChallengeConstraintSet::M_EvaluateOnAllDefinitionEvents' has a wrong offset!");
static_assert(offsetof(FCAChallengeConstraintSet, M_EvaluateOnEvents) == 0x000010, "Member 'FCAChallengeConstraintSet::M_EvaluateOnEvents' has a wrong offset!");
static_assert(offsetof(FCAChallengeConstraintSet, M_EnableFailureLeniency) == 0x000014, "Member 'FCAChallengeConstraintSet::M_EnableFailureLeniency' has a wrong offset!");
static_assert(offsetof(FCAChallengeConstraintSet, M_ConstraintFilter) == 0x000018, "Member 'FCAChallengeConstraintSet::M_ConstraintFilter' has a wrong offset!");

// ScriptStruct keaton.CAChallengeTemplateConstraintSet
// 0x000C (0x000C - 0x0000)
struct FCAChallengeTemplateConstraintSet final
{
public:
	class FName                                   M_TemplateName;                                    // 0x0000(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAChallengeTemplateConstraintSet) == 0x000004, "Wrong alignment on FCAChallengeTemplateConstraintSet");
static_assert(sizeof(FCAChallengeTemplateConstraintSet) == 0x00000C, "Wrong size on FCAChallengeTemplateConstraintSet");
static_assert(offsetof(FCAChallengeTemplateConstraintSet, M_TemplateName) == 0x000000, "Member 'FCAChallengeTemplateConstraintSet::M_TemplateName' has a wrong offset!");

// ScriptStruct keaton.CAChallengeDefinitionData
// 0x01D8 (0x01E0 - 0x0008)
struct FCAChallengeDefinitionData final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_ChallengeTitle;                                  // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   M_ChallengeDescription;                            // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_Script;                                          // 0x0048(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsTeamChallenge;                                 // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsSelectable;                                    // 0x0079(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsTutorialScript;                                // 0x007A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAChallengeConstraintScriptOwner             M_ScriptOwner;                                     // 0x007B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsPassive;                                       // 0x007C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_EnableChallengeDebugging;                        // 0x007D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsXPOnlyChallenge;                               // 0x007E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsPlaceholder;                                   // 0x007F(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_RewardCategory;                                  // 0x0080(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_ChallengeXpKickerPrompt;                         // 0x0090(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_DebugForceCaptureAllObjectInfo;                  // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_DebugForceCaptureAllEvents;                      // 0x00C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x2];                                       // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_Threshold;                                       // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SucceedOnEvents;                                 // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_FailOnEvents;                                    // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class FName>                             M_ConditionalTags;                                 // 0x00D0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      M_Constants;                                       // 0x0120(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_ExecuteByTimer;                                  // 0x0170(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_ExecutionDelay;                                  // 0x0174(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_FailureLeniencyTime;                             // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_LeniencyFailuresResetChallenge;                  // 0x017C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D[0x3];                                      // 0x017D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FCAChallengeConstraintSet> M_Constraints;                                     // 0x0180(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAChallengeTemplateConstraintSet> M_TemplateConstraints;                             // 0x01D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAChallengeDefinitionData) == 0x000008, "Wrong alignment on FCAChallengeDefinitionData");
static_assert(sizeof(FCAChallengeDefinitionData) == 0x0001E0, "Wrong size on FCAChallengeDefinitionData");
static_assert(offsetof(FCAChallengeDefinitionData, M_ChallengeTitle) == 0x000018, "Member 'FCAChallengeDefinitionData::M_ChallengeTitle' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_ChallengeDescription) == 0x000030, "Member 'FCAChallengeDefinitionData::M_ChallengeDescription' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_Script) == 0x000048, "Member 'FCAChallengeDefinitionData::M_Script' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_IsTeamChallenge) == 0x000078, "Member 'FCAChallengeDefinitionData::M_IsTeamChallenge' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_IsSelectable) == 0x000079, "Member 'FCAChallengeDefinitionData::M_IsSelectable' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_IsTutorialScript) == 0x00007A, "Member 'FCAChallengeDefinitionData::M_IsTutorialScript' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_ScriptOwner) == 0x00007B, "Member 'FCAChallengeDefinitionData::M_ScriptOwner' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_IsPassive) == 0x00007C, "Member 'FCAChallengeDefinitionData::M_IsPassive' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_EnableChallengeDebugging) == 0x00007D, "Member 'FCAChallengeDefinitionData::M_EnableChallengeDebugging' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_IsXPOnlyChallenge) == 0x00007E, "Member 'FCAChallengeDefinitionData::M_IsXPOnlyChallenge' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_IsPlaceholder) == 0x00007F, "Member 'FCAChallengeDefinitionData::M_IsPlaceholder' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_RewardCategory) == 0x000080, "Member 'FCAChallengeDefinitionData::M_RewardCategory' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_ChallengeXpKickerPrompt) == 0x000090, "Member 'FCAChallengeDefinitionData::M_ChallengeXpKickerPrompt' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_DebugForceCaptureAllObjectInfo) == 0x0000C0, "Member 'FCAChallengeDefinitionData::M_DebugForceCaptureAllObjectInfo' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_DebugForceCaptureAllEvents) == 0x0000C1, "Member 'FCAChallengeDefinitionData::M_DebugForceCaptureAllEvents' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_Threshold) == 0x0000C4, "Member 'FCAChallengeDefinitionData::M_Threshold' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_SucceedOnEvents) == 0x0000C8, "Member 'FCAChallengeDefinitionData::M_SucceedOnEvents' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_FailOnEvents) == 0x0000CC, "Member 'FCAChallengeDefinitionData::M_FailOnEvents' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_ConditionalTags) == 0x0000D0, "Member 'FCAChallengeDefinitionData::M_ConditionalTags' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_Constants) == 0x000120, "Member 'FCAChallengeDefinitionData::M_Constants' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_ExecuteByTimer) == 0x000170, "Member 'FCAChallengeDefinitionData::M_ExecuteByTimer' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_ExecutionDelay) == 0x000174, "Member 'FCAChallengeDefinitionData::M_ExecutionDelay' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_FailureLeniencyTime) == 0x000178, "Member 'FCAChallengeDefinitionData::M_FailureLeniencyTime' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_LeniencyFailuresResetChallenge) == 0x00017C, "Member 'FCAChallengeDefinitionData::M_LeniencyFailuresResetChallenge' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_Constraints) == 0x000180, "Member 'FCAChallengeDefinitionData::M_Constraints' has a wrong offset!");
static_assert(offsetof(FCAChallengeDefinitionData, M_TemplateConstraints) == 0x0001D0, "Member 'FCAChallengeDefinitionData::M_TemplateConstraints' has a wrong offset!");

// ScriptStruct keaton.CAZoneData
// 0x00D0 (0x00D0 - 0x0000)
struct FCAZoneData final
{
public:
	float                                         M_volume;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_pressure;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_change;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           M_zone_actors;                                     // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSet<int32>                                   M_connected_zones;                                 // 0x0060(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_tags;                                            // 0x00B0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAZoneData) == 0x000008, "Wrong alignment on FCAZoneData");
static_assert(sizeof(FCAZoneData) == 0x0000D0, "Wrong size on FCAZoneData");
static_assert(offsetof(FCAZoneData, M_volume) == 0x000000, "Member 'FCAZoneData::M_volume' has a wrong offset!");
static_assert(offsetof(FCAZoneData, M_pressure) == 0x000004, "Member 'FCAZoneData::M_pressure' has a wrong offset!");
static_assert(offsetof(FCAZoneData, M_change) == 0x000008, "Member 'FCAZoneData::M_change' has a wrong offset!");
static_assert(offsetof(FCAZoneData, M_zone_actors) == 0x000010, "Member 'FCAZoneData::M_zone_actors' has a wrong offset!");
static_assert(offsetof(FCAZoneData, M_connected_zones) == 0x000060, "Member 'FCAZoneData::M_connected_zones' has a wrong offset!");
static_assert(offsetof(FCAZoneData, M_tags) == 0x0000B0, "Member 'FCAZoneData::M_tags' has a wrong offset!");

// ScriptStruct keaton.ProjectileMetaData
// 0x0004 (0x0004 - 0x0000)
struct FProjectileMetaData final
{
public:
	float                                         M_server_time;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileMetaData) == 0x000004, "Wrong alignment on FProjectileMetaData");
static_assert(sizeof(FProjectileMetaData) == 0x000004, "Wrong size on FProjectileMetaData");
static_assert(offsetof(FProjectileMetaData, M_server_time) == 0x000000, "Member 'FProjectileMetaData::M_server_time' has a wrong offset!");

// ScriptStruct keaton.CAItemLevelUpDefinition
// 0x0048 (0x0048 - 0x0000)
struct FCAItemLevelUpDefinition final
{
public:
	float                                         M_exp_to_reach_this_level;                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_increase_quantity_on_inventory;                  // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAEffectWithSetByCallerTags>   M_effects_wtih_set_by_caller_tags;                 // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_icon_texture;                                    // 0x0018(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAItemLevelUpDefinition) == 0x000008, "Wrong alignment on FCAItemLevelUpDefinition");
static_assert(sizeof(FCAItemLevelUpDefinition) == 0x000048, "Wrong size on FCAItemLevelUpDefinition");
static_assert(offsetof(FCAItemLevelUpDefinition, M_exp_to_reach_this_level) == 0x000000, "Member 'FCAItemLevelUpDefinition::M_exp_to_reach_this_level' has a wrong offset!");
static_assert(offsetof(FCAItemLevelUpDefinition, M_increase_quantity_on_inventory) == 0x000004, "Member 'FCAItemLevelUpDefinition::M_increase_quantity_on_inventory' has a wrong offset!");
static_assert(offsetof(FCAItemLevelUpDefinition, M_effects_wtih_set_by_caller_tags) == 0x000008, "Member 'FCAItemLevelUpDefinition::M_effects_wtih_set_by_caller_tags' has a wrong offset!");
static_assert(offsetof(FCAItemLevelUpDefinition, M_icon_texture) == 0x000018, "Member 'FCAItemLevelUpDefinition::M_icon_texture' has a wrong offset!");

// ScriptStruct keaton.CAItemLevelUpDataRow
// 0x0040 (0x0048 - 0x0008)
struct FCAItemLevelUpDataRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UCAInventoryItem>        M_inventory_item;                                  // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAItemLevelUpDefinition>       M_item_levels;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAItemLevelUpDataRow) == 0x000008, "Wrong alignment on FCAItemLevelUpDataRow");
static_assert(sizeof(FCAItemLevelUpDataRow) == 0x000048, "Wrong size on FCAItemLevelUpDataRow");
static_assert(offsetof(FCAItemLevelUpDataRow, M_inventory_item) == 0x000008, "Member 'FCAItemLevelUpDataRow::M_inventory_item' has a wrong offset!");
static_assert(offsetof(FCAItemLevelUpDataRow, M_item_levels) == 0x000038, "Member 'FCAItemLevelUpDataRow::M_item_levels' has a wrong offset!");

// ScriptStruct keaton.ServicesPakHeaderEncryption
// 0x0020 (0x0020 - 0x0000)
struct FServicesPakHeaderEncryption final
{
public:
	class FString                                 Guid;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FServicesPakHeaderEncryption) == 0x000008, "Wrong alignment on FServicesPakHeaderEncryption");
static_assert(sizeof(FServicesPakHeaderEncryption) == 0x000020, "Wrong size on FServicesPakHeaderEncryption");
static_assert(offsetof(FServicesPakHeaderEncryption, Guid) == 0x000000, "Member 'FServicesPakHeaderEncryption::Guid' has a wrong offset!");
static_assert(offsetof(FServicesPakHeaderEncryption, Key) == 0x000010, "Member 'FServicesPakHeaderEncryption::Key' has a wrong offset!");

// ScriptStruct keaton.CAUniqueObjectData
// 0x001C (0x001C - 0x0000)
struct FCAUniqueObjectData final
{
public:
	TWeakObjectPtr<class UObject>                 Target;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCATeamID                              TeamID;                                            // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         When;                                              // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAUniqueObjectData) == 0x000004, "Wrong alignment on FCAUniqueObjectData");
static_assert(sizeof(FCAUniqueObjectData) == 0x00001C, "Wrong size on FCAUniqueObjectData");
static_assert(offsetof(FCAUniqueObjectData, Target) == 0x000000, "Member 'FCAUniqueObjectData::Target' has a wrong offset!");
static_assert(offsetof(FCAUniqueObjectData, Position) == 0x000008, "Member 'FCAUniqueObjectData::Position' has a wrong offset!");
static_assert(offsetof(FCAUniqueObjectData, TeamID) == 0x000014, "Member 'FCAUniqueObjectData::TeamID' has a wrong offset!");
static_assert(offsetof(FCAUniqueObjectData, When) == 0x000018, "Member 'FCAUniqueObjectData::When' has a wrong offset!");

// ScriptStruct keaton.CAWeaponBuffDefinition
// 0x0060 (0x0060 - 0x0000)
struct FCAWeaponBuffDefinition final
{
public:
	struct FGameplayTag                           M_weapon_tag;                                      // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_slot_tag;                                        // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAWeaponBuffableStatID                       M_buff_stat;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECABuffType                                   M_buff_type;                                       // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_buff_value;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAWeaponPayload>               M_buff_payloads;                                   // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              M_buff_shot_pattern;                               // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAWeaponBuffDefinition) == 0x000008, "Wrong alignment on FCAWeaponBuffDefinition");
static_assert(sizeof(FCAWeaponBuffDefinition) == 0x000060, "Wrong size on FCAWeaponBuffDefinition");
static_assert(offsetof(FCAWeaponBuffDefinition, M_weapon_tag) == 0x000000, "Member 'FCAWeaponBuffDefinition::M_weapon_tag' has a wrong offset!");
static_assert(offsetof(FCAWeaponBuffDefinition, M_slot_tag) == 0x00000C, "Member 'FCAWeaponBuffDefinition::M_slot_tag' has a wrong offset!");
static_assert(offsetof(FCAWeaponBuffDefinition, M_buff_stat) == 0x000018, "Member 'FCAWeaponBuffDefinition::M_buff_stat' has a wrong offset!");
static_assert(offsetof(FCAWeaponBuffDefinition, M_buff_type) == 0x000019, "Member 'FCAWeaponBuffDefinition::M_buff_type' has a wrong offset!");
static_assert(offsetof(FCAWeaponBuffDefinition, M_buff_value) == 0x00001C, "Member 'FCAWeaponBuffDefinition::M_buff_value' has a wrong offset!");
static_assert(offsetof(FCAWeaponBuffDefinition, M_buff_payloads) == 0x000020, "Member 'FCAWeaponBuffDefinition::M_buff_payloads' has a wrong offset!");
static_assert(offsetof(FCAWeaponBuffDefinition, M_buff_shot_pattern) == 0x000030, "Member 'FCAWeaponBuffDefinition::M_buff_shot_pattern' has a wrong offset!");

// ScriptStruct keaton.CAZeroGWeaponBuffData
// 0x0010 (0x0010 - 0x0000)
struct FCAZeroGWeaponBuffData final
{
public:
	TArray<struct FCAWeaponBuffDefinition>        Buffs;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAZeroGWeaponBuffData) == 0x000008, "Wrong alignment on FCAZeroGWeaponBuffData");
static_assert(sizeof(FCAZeroGWeaponBuffData) == 0x000010, "Wrong size on FCAZeroGWeaponBuffData");
static_assert(offsetof(FCAZeroGWeaponBuffData, Buffs) == 0x000000, "Member 'FCAZeroGWeaponBuffData::Buffs' has a wrong offset!");

// ScriptStruct keaton.CAChallengeStatsStruct
// 0x0008 (0x0008 - 0x0000)
struct FCAChallengeStatsStruct final
{
public:
	int32                                         M_damage;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_critical_damage;                                 // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAChallengeStatsStruct) == 0x000004, "Wrong alignment on FCAChallengeStatsStruct");
static_assert(sizeof(FCAChallengeStatsStruct) == 0x000008, "Wrong size on FCAChallengeStatsStruct");
static_assert(offsetof(FCAChallengeStatsStruct, M_damage) == 0x000000, "Member 'FCAChallengeStatsStruct::M_damage' has a wrong offset!");
static_assert(offsetof(FCAChallengeStatsStruct, M_critical_damage) == 0x000004, "Member 'FCAChallengeStatsStruct::M_critical_damage' has a wrong offset!");

// ScriptStruct keaton.CAInstrumentedTimerDataSet
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FCAInstrumentedTimerDataSet final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAInstrumentedTimerDataSet) == 0x000008, "Wrong alignment on FCAInstrumentedTimerDataSet");
static_assert(sizeof(FCAInstrumentedTimerDataSet) == 0x000068, "Wrong size on FCAInstrumentedTimerDataSet");

// ScriptStruct keaton.CAChallengeArmourStruct
// 0x000C (0x000C - 0x0000)
struct FCAChallengeArmourStruct final
{
public:
	int32                                         M_current_value;                                   // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_max_value;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_current_stack;                                   // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_max_stack;                                       // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAChallengeArmourStruct) == 0x000004, "Wrong alignment on FCAChallengeArmourStruct");
static_assert(sizeof(FCAChallengeArmourStruct) == 0x00000C, "Wrong size on FCAChallengeArmourStruct");
static_assert(offsetof(FCAChallengeArmourStruct, M_current_value) == 0x000000, "Member 'FCAChallengeArmourStruct::M_current_value' has a wrong offset!");
static_assert(offsetof(FCAChallengeArmourStruct, M_max_value) == 0x000004, "Member 'FCAChallengeArmourStruct::M_max_value' has a wrong offset!");
static_assert(offsetof(FCAChallengeArmourStruct, M_current_stack) == 0x000008, "Member 'FCAChallengeArmourStruct::M_current_stack' has a wrong offset!");
static_assert(offsetof(FCAChallengeArmourStruct, M_max_stack) == 0x000009, "Member 'FCAChallengeArmourStruct::M_max_stack' has a wrong offset!");

// ScriptStruct keaton.CAChallengeScoreStruct
// 0x001C (0x001C - 0x0000)
struct FCAChallengeScoreStruct final
{
public:
	int32                                         M_individual_score;                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_death_count;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_team_score;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_score_threshold;                                 // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_team_rank;                                       // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_num_teams;                                       // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_alive;                                        // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_disconnected;                                 // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAChallengeScoreStruct) == 0x000004, "Wrong alignment on FCAChallengeScoreStruct");
static_assert(sizeof(FCAChallengeScoreStruct) == 0x00001C, "Wrong size on FCAChallengeScoreStruct");
static_assert(offsetof(FCAChallengeScoreStruct, M_individual_score) == 0x000000, "Member 'FCAChallengeScoreStruct::M_individual_score' has a wrong offset!");
static_assert(offsetof(FCAChallengeScoreStruct, M_death_count) == 0x000004, "Member 'FCAChallengeScoreStruct::M_death_count' has a wrong offset!");
static_assert(offsetof(FCAChallengeScoreStruct, M_team_score) == 0x000008, "Member 'FCAChallengeScoreStruct::M_team_score' has a wrong offset!");
static_assert(offsetof(FCAChallengeScoreStruct, M_score_threshold) == 0x00000C, "Member 'FCAChallengeScoreStruct::M_score_threshold' has a wrong offset!");
static_assert(offsetof(FCAChallengeScoreStruct, M_team_rank) == 0x000010, "Member 'FCAChallengeScoreStruct::M_team_rank' has a wrong offset!");
static_assert(offsetof(FCAChallengeScoreStruct, M_num_teams) == 0x000014, "Member 'FCAChallengeScoreStruct::M_num_teams' has a wrong offset!");
static_assert(offsetof(FCAChallengeScoreStruct, M_is_alive) == 0x000018, "Member 'FCAChallengeScoreStruct::M_is_alive' has a wrong offset!");
static_assert(offsetof(FCAChallengeScoreStruct, M_is_disconnected) == 0x000019, "Member 'FCAChallengeScoreStruct::M_is_disconnected' has a wrong offset!");

// ScriptStruct keaton.CATargetObjectTargetingRule
// 0x0014 (0x0014 - 0x0000)
struct FCATargetObjectTargetingRule final
{
public:
	ECATargetObjectTargetingRuleType              M_rule_type;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_inverse_condition;                               // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_range_radius;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_npc_special_ability;                             // 0x0008(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATargetObjectTargetingRule) == 0x000004, "Wrong alignment on FCATargetObjectTargetingRule");
static_assert(sizeof(FCATargetObjectTargetingRule) == 0x000014, "Wrong size on FCATargetObjectTargetingRule");
static_assert(offsetof(FCATargetObjectTargetingRule, M_rule_type) == 0x000000, "Member 'FCATargetObjectTargetingRule::M_rule_type' has a wrong offset!");
static_assert(offsetof(FCATargetObjectTargetingRule, M_inverse_condition) == 0x000001, "Member 'FCATargetObjectTargetingRule::M_inverse_condition' has a wrong offset!");
static_assert(offsetof(FCATargetObjectTargetingRule, M_range_radius) == 0x000004, "Member 'FCATargetObjectTargetingRule::M_range_radius' has a wrong offset!");
static_assert(offsetof(FCATargetObjectTargetingRule, M_npc_special_ability) == 0x000008, "Member 'FCATargetObjectTargetingRule::M_npc_special_ability' has a wrong offset!");

// ScriptStruct keaton.CAClaimQueueItem
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FCAClaimQueueItem final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAClaimQueueItem) == 0x000008, "Wrong alignment on FCAClaimQueueItem");
static_assert(sizeof(FCAClaimQueueItem) == 0x000030, "Wrong size on FCAClaimQueueItem");

// ScriptStruct keaton.GetExtraResourcesResponse
// 0x0028 (0x0028 - 0x0000)
struct FGetExtraResourcesResponse final
{
public:
	int32                                         M_version;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_index;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_content;                                         // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetExtraResourcesResponse) == 0x000008, "Wrong alignment on FGetExtraResourcesResponse");
static_assert(sizeof(FGetExtraResourcesResponse) == 0x000028, "Wrong size on FGetExtraResourcesResponse");
static_assert(offsetof(FGetExtraResourcesResponse, M_version) == 0x000000, "Member 'FGetExtraResourcesResponse::M_version' has a wrong offset!");
static_assert(offsetof(FGetExtraResourcesResponse, M_index) == 0x000008, "Member 'FGetExtraResourcesResponse::M_index' has a wrong offset!");
static_assert(offsetof(FGetExtraResourcesResponse, M_content) == 0x000018, "Member 'FGetExtraResourcesResponse::M_content' has a wrong offset!");

// ScriptStruct keaton.CACharacterConstructionReplicatedData
// 0x000C (0x000C - 0x0000)
struct FCACharacterConstructionReplicatedData final
{
public:
	class FName                                   M_row_name;                                        // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACharacterConstructionReplicatedData) == 0x000004, "Wrong alignment on FCACharacterConstructionReplicatedData");
static_assert(sizeof(FCACharacterConstructionReplicatedData) == 0x00000C, "Wrong size on FCACharacterConstructionReplicatedData");
static_assert(offsetof(FCACharacterConstructionReplicatedData, M_row_name) == 0x000000, "Member 'FCACharacterConstructionReplicatedData::M_row_name' has a wrong offset!");

// ScriptStruct keaton.CAFastPathTeleportTimeElapsed
// 0x0018 (0x0018 - 0x0000)
struct FCAFastPathTeleportTimeElapsed final
{
public:
	class FString                                 Level_name;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Elapsed_time;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAFastPathTeleportTimeElapsed) == 0x000008, "Wrong alignment on FCAFastPathTeleportTimeElapsed");
static_assert(sizeof(FCAFastPathTeleportTimeElapsed) == 0x000018, "Wrong size on FCAFastPathTeleportTimeElapsed");
static_assert(offsetof(FCAFastPathTeleportTimeElapsed, Level_name) == 0x000000, "Member 'FCAFastPathTeleportTimeElapsed::Level_name' has a wrong offset!");
static_assert(offsetof(FCAFastPathTeleportTimeElapsed, Elapsed_time) == 0x000010, "Member 'FCAFastPathTeleportTimeElapsed::Elapsed_time' has a wrong offset!");

// ScriptStruct keaton.CATargetModeActorTableRow
// 0x0008 (0x0010 - 0x0008)
struct FCATargetModeActorTableRow final : public FTableRowBase
{
public:
	ECAUI_ReticuleTargettingMode                  M_target_mode;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCATargetModeActorTableRow) == 0x000008, "Wrong alignment on FCATargetModeActorTableRow");
static_assert(sizeof(FCATargetModeActorTableRow) == 0x000010, "Wrong size on FCATargetModeActorTableRow");
static_assert(offsetof(FCATargetModeActorTableRow, M_target_mode) == 0x000008, "Member 'FCATargetModeActorTableRow::M_target_mode' has a wrong offset!");

// ScriptStruct keaton.CAUIEventMap
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FCAUIEventMap final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAUIEventMap) == 0x000008, "Wrong alignment on FCAUIEventMap");
static_assert(sizeof(FCAUIEventMap) == 0x000050, "Wrong size on FCAUIEventMap");

// ScriptStruct keaton.CAWeaponVFXSetRow
// 0x0030 (0x0038 - 0x0008)
struct FCAWeaponVFXSetRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UCAWeaponVFXSet>         M_weapon_vfx_set;                                  // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAWeaponVFXSetRow) == 0x000008, "Wrong alignment on FCAWeaponVFXSetRow");
static_assert(sizeof(FCAWeaponVFXSetRow) == 0x000038, "Wrong size on FCAWeaponVFXSetRow");
static_assert(offsetof(FCAWeaponVFXSetRow, M_weapon_vfx_set) == 0x000008, "Member 'FCAWeaponVFXSetRow::M_weapon_vfx_set' has a wrong offset!");

// ScriptStruct keaton.ReplicatedSpringArmData
// 0x001C (0x001C - 0x0000)
struct FReplicatedSpringArmData final
{
public:
	struct FVector_NetQuantize                    M_base_offset;                                     // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    M_socket_offset;                                   // 0x000C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        M_target_arm_length;                               // 0x0018(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicatedSpringArmData) == 0x000004, "Wrong alignment on FReplicatedSpringArmData");
static_assert(sizeof(FReplicatedSpringArmData) == 0x00001C, "Wrong size on FReplicatedSpringArmData");
static_assert(offsetof(FReplicatedSpringArmData, M_base_offset) == 0x000000, "Member 'FReplicatedSpringArmData::M_base_offset' has a wrong offset!");
static_assert(offsetof(FReplicatedSpringArmData, M_socket_offset) == 0x00000C, "Member 'FReplicatedSpringArmData::M_socket_offset' has a wrong offset!");
static_assert(offsetof(FReplicatedSpringArmData, M_target_arm_length) == 0x000018, "Member 'FReplicatedSpringArmData::M_target_arm_length' has a wrong offset!");

// ScriptStruct keaton.SpringArmData
// 0x0020 (0x0028 - 0x0008)
struct FSpringArmData final : public FTableRowBase
{
public:
	struct FVector                                M_base_offset;                                     // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_socket_offset;                                   // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_target_arm_length;                               // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpringArmData) == 0x000008, "Wrong alignment on FSpringArmData");
static_assert(sizeof(FSpringArmData) == 0x000028, "Wrong size on FSpringArmData");
static_assert(offsetof(FSpringArmData, M_base_offset) == 0x000008, "Member 'FSpringArmData::M_base_offset' has a wrong offset!");
static_assert(offsetof(FSpringArmData, M_socket_offset) == 0x000014, "Member 'FSpringArmData::M_socket_offset' has a wrong offset!");
static_assert(offsetof(FSpringArmData, M_target_arm_length) == 0x000020, "Member 'FSpringArmData::M_target_arm_length' has a wrong offset!");

// ScriptStruct keaton.ZeroGDirectionalIndicatorData
// 0x0058 (0x0058 - 0x0000)
struct FZeroGDirectionalIndicatorData final
{
public:
	struct FVector                                M_normal;                                          // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_pos;                                             // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_boost_pos;                                       // 0x0018(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_boost_normal;                                    // 0x0024(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_boost_pos_is_valid;                              // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_gravhook_pos;                                    // 0x0034(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_safe_pos;                                        // 0x0040(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_in_range;                                     // 0x004C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_avoiding;                                     // 0x004D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_valid;                                        // 0x004E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F[0x1];                                       // 0x004F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  M_gravhook_actor;                                  // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZeroGDirectionalIndicatorData) == 0x000004, "Wrong alignment on FZeroGDirectionalIndicatorData");
static_assert(sizeof(FZeroGDirectionalIndicatorData) == 0x000058, "Wrong size on FZeroGDirectionalIndicatorData");
static_assert(offsetof(FZeroGDirectionalIndicatorData, M_normal) == 0x000000, "Member 'FZeroGDirectionalIndicatorData::M_normal' has a wrong offset!");
static_assert(offsetof(FZeroGDirectionalIndicatorData, M_pos) == 0x00000C, "Member 'FZeroGDirectionalIndicatorData::M_pos' has a wrong offset!");
static_assert(offsetof(FZeroGDirectionalIndicatorData, M_boost_pos) == 0x000018, "Member 'FZeroGDirectionalIndicatorData::M_boost_pos' has a wrong offset!");
static_assert(offsetof(FZeroGDirectionalIndicatorData, M_boost_normal) == 0x000024, "Member 'FZeroGDirectionalIndicatorData::M_boost_normal' has a wrong offset!");
static_assert(offsetof(FZeroGDirectionalIndicatorData, M_boost_pos_is_valid) == 0x000030, "Member 'FZeroGDirectionalIndicatorData::M_boost_pos_is_valid' has a wrong offset!");
static_assert(offsetof(FZeroGDirectionalIndicatorData, M_gravhook_pos) == 0x000034, "Member 'FZeroGDirectionalIndicatorData::M_gravhook_pos' has a wrong offset!");
static_assert(offsetof(FZeroGDirectionalIndicatorData, M_safe_pos) == 0x000040, "Member 'FZeroGDirectionalIndicatorData::M_safe_pos' has a wrong offset!");
static_assert(offsetof(FZeroGDirectionalIndicatorData, M_is_in_range) == 0x00004C, "Member 'FZeroGDirectionalIndicatorData::M_is_in_range' has a wrong offset!");
static_assert(offsetof(FZeroGDirectionalIndicatorData, M_is_avoiding) == 0x00004D, "Member 'FZeroGDirectionalIndicatorData::M_is_avoiding' has a wrong offset!");
static_assert(offsetof(FZeroGDirectionalIndicatorData, M_is_valid) == 0x00004E, "Member 'FZeroGDirectionalIndicatorData::M_is_valid' has a wrong offset!");
static_assert(offsetof(FZeroGDirectionalIndicatorData, M_gravhook_actor) == 0x000050, "Member 'FZeroGDirectionalIndicatorData::M_gravhook_actor' has a wrong offset!");

// ScriptStruct keaton.ExtractionRegionInfo
// 0x0008 (0x0008 - 0x0000)
struct FExtractionRegionInfo final
{
public:
	float                                         M_max_size;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_size;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExtractionRegionInfo) == 0x000004, "Wrong alignment on FExtractionRegionInfo");
static_assert(sizeof(FExtractionRegionInfo) == 0x000008, "Wrong size on FExtractionRegionInfo");
static_assert(offsetof(FExtractionRegionInfo, M_max_size) == 0x000000, "Member 'FExtractionRegionInfo::M_max_size' has a wrong offset!");
static_assert(offsetof(FExtractionRegionInfo, M_min_size) == 0x000004, "Member 'FExtractionRegionInfo::M_min_size' has a wrong offset!");

// ScriptStruct keaton.PlayerInputReplicatedData
// 0x0001 (0x0001 - 0x0000)
struct FPlayerInputReplicatedData final
{
public:
	uint8                                         M_player_movement_input_active;                    // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerInputReplicatedData) == 0x000001, "Wrong alignment on FPlayerInputReplicatedData");
static_assert(sizeof(FPlayerInputReplicatedData) == 0x000001, "Wrong size on FPlayerInputReplicatedData");
static_assert(offsetof(FPlayerInputReplicatedData, M_player_movement_input_active) == 0x000000, "Member 'FPlayerInputReplicatedData::M_player_movement_input_active' has a wrong offset!");

// ScriptStruct keaton.CAServicesMapOption
// 0x0018 (0x0018 - 0x0000)
struct FCAServicesMapOption final
{
public:
	struct FCAGameDatabaseRowHandle               M_handle;                                          // 0x0000(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAServicesMapOption) == 0x000004, "Wrong alignment on FCAServicesMapOption");
static_assert(sizeof(FCAServicesMapOption) == 0x000018, "Wrong size on FCAServicesMapOption");
static_assert(offsetof(FCAServicesMapOption, M_handle) == 0x000000, "Member 'FCAServicesMapOption::M_handle' has a wrong offset!");

// ScriptStruct keaton.CAServicesLevelReward
// 0x001C (0x001C - 0x0000)
struct FCAServicesLevelReward final
{
public:
	int32                                         M_level_up_xp_threshold;                           // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_reward_package;                                  // 0x0004(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAServicesLevelReward) == 0x000004, "Wrong alignment on FCAServicesLevelReward");
static_assert(sizeof(FCAServicesLevelReward) == 0x00001C, "Wrong size on FCAServicesLevelReward");
static_assert(offsetof(FCAServicesLevelReward, M_level_up_xp_threshold) == 0x000000, "Member 'FCAServicesLevelReward::M_level_up_xp_threshold' has a wrong offset!");
static_assert(offsetof(FCAServicesLevelReward, M_reward_package) == 0x000004, "Member 'FCAServicesLevelReward::M_reward_package' has a wrong offset!");

// ScriptStruct keaton.CAServicesScoreThreshold
// 0x0030 (0x0030 - 0x0000)
struct FCAServicesScoreThreshold final
{
public:
	int32                                         M_xp_threshold;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAServicesItemEvent                   M_reward;                                          // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAServicesScoreThreshold) == 0x000008, "Wrong alignment on FCAServicesScoreThreshold");
static_assert(sizeof(FCAServicesScoreThreshold) == 0x000030, "Wrong size on FCAServicesScoreThreshold");
static_assert(offsetof(FCAServicesScoreThreshold, M_xp_threshold) == 0x000000, "Member 'FCAServicesScoreThreshold::M_xp_threshold' has a wrong offset!");
static_assert(offsetof(FCAServicesScoreThreshold, M_reward) == 0x000008, "Member 'FCAServicesScoreThreshold::M_reward' has a wrong offset!");

// ScriptStruct keaton.CAServicesGameTableRow
// 0x0048 (0x0050 - 0x0008)
struct FCAServicesGameTableRow final : public FTableRowBase
{
public:
	TArray<struct FCAServicesMapOption>           M_maps;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAServicesLevelReward>         M_player_levels;                                   // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAServicesLevelReward>         M_prestige_levels;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint64                                        M_reward_currency_services_item_id;                // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAServicesScoreThreshold>      M_score_thresholds;                                // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAServicesGameTableRow) == 0x000008, "Wrong alignment on FCAServicesGameTableRow");
static_assert(sizeof(FCAServicesGameTableRow) == 0x000050, "Wrong size on FCAServicesGameTableRow");
static_assert(offsetof(FCAServicesGameTableRow, M_maps) == 0x000008, "Member 'FCAServicesGameTableRow::M_maps' has a wrong offset!");
static_assert(offsetof(FCAServicesGameTableRow, M_player_levels) == 0x000018, "Member 'FCAServicesGameTableRow::M_player_levels' has a wrong offset!");
static_assert(offsetof(FCAServicesGameTableRow, M_prestige_levels) == 0x000028, "Member 'FCAServicesGameTableRow::M_prestige_levels' has a wrong offset!");
static_assert(offsetof(FCAServicesGameTableRow, M_reward_currency_services_item_id) == 0x000038, "Member 'FCAServicesGameTableRow::M_reward_currency_services_item_id' has a wrong offset!");
static_assert(offsetof(FCAServicesGameTableRow, M_score_thresholds) == 0x000040, "Member 'FCAServicesGameTableRow::M_score_thresholds' has a wrong offset!");

// ScriptStruct keaton.ExecutionContext
// 0x0020 (0x0020 - 0x0000)
struct FExecutionContext final
{
public:
	class ACACharacter_MainPlayer*                Executioner;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALevelSequenceActor*                    Sequence_actor;                                    // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASkeletalMeshActor*                     Executioner_skeletal_mesh;                         // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASkeletalMeshActor*                     Victim_skeletal_mesh;                              // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExecutionContext) == 0x000008, "Wrong alignment on FExecutionContext");
static_assert(sizeof(FExecutionContext) == 0x000020, "Wrong size on FExecutionContext");
static_assert(offsetof(FExecutionContext, Executioner) == 0x000000, "Member 'FExecutionContext::Executioner' has a wrong offset!");
static_assert(offsetof(FExecutionContext, Sequence_actor) == 0x000008, "Member 'FExecutionContext::Sequence_actor' has a wrong offset!");
static_assert(offsetof(FExecutionContext, Executioner_skeletal_mesh) == 0x000010, "Member 'FExecutionContext::Executioner_skeletal_mesh' has a wrong offset!");
static_assert(offsetof(FExecutionContext, Victim_skeletal_mesh) == 0x000018, "Member 'FExecutionContext::Victim_skeletal_mesh' has a wrong offset!");

// ScriptStruct keaton.CAMatchResultSubRewards
// 0x0010 (0x0010 - 0x0000)
struct FCAMatchResultSubRewards final
{
public:
	class FName                                   M_currency;                                        // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_value;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMatchResultSubRewards) == 0x000004, "Wrong alignment on FCAMatchResultSubRewards");
static_assert(sizeof(FCAMatchResultSubRewards) == 0x000010, "Wrong size on FCAMatchResultSubRewards");
static_assert(offsetof(FCAMatchResultSubRewards, M_currency) == 0x000000, "Member 'FCAMatchResultSubRewards::M_currency' has a wrong offset!");
static_assert(offsetof(FCAMatchResultSubRewards, M_value) == 0x00000C, "Member 'FCAMatchResultSubRewards::M_value' has a wrong offset!");

// ScriptStruct keaton.ReplicatedSkeletalMeshSet
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FReplicatedSkeletalMeshSet final
{
public:
	uint8                                         M_index;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicatedSkeletalMeshSet) == 0x000008, "Wrong alignment on FReplicatedSkeletalMeshSet");
static_assert(sizeof(FReplicatedSkeletalMeshSet) == 0x000010, "Wrong size on FReplicatedSkeletalMeshSet");
static_assert(offsetof(FReplicatedSkeletalMeshSet, M_index) == 0x000000, "Member 'FReplicatedSkeletalMeshSet::M_index' has a wrong offset!");

// ScriptStruct keaton.CARecentOnlineUser
// 0x0018 (0x0018 - 0x0000)
struct FCARecentOnlineUser final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         M_last_seen_ts;                                    // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARecentOnlineUser) == 0x000008, "Wrong alignment on FCARecentOnlineUser");
static_assert(sizeof(FCARecentOnlineUser) == 0x000018, "Wrong size on FCARecentOnlineUser");
static_assert(offsetof(FCARecentOnlineUser, M_last_seen_ts) == 0x000010, "Member 'FCARecentOnlineUser::M_last_seen_ts' has a wrong offset!");

// ScriptStruct keaton.SkeletalMeshSet
// 0x0040 (0x0040 - 0x0000)
struct FSkeletalMeshSet final
{
public:
	class USkeletalMesh*                          M_FP_mesh;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          M_TP_mesh;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          M_collapsed_TP_mesh;                               // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAOverrideMaterial>            M_override_materials;                              // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_stolen_identifier_tag;                           // 0x0028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_real_id_of_disguised_character;                  // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_real_id_of_copied_character;                     // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkeletalMeshSet) == 0x000008, "Wrong alignment on FSkeletalMeshSet");
static_assert(sizeof(FSkeletalMeshSet) == 0x000040, "Wrong size on FSkeletalMeshSet");
static_assert(offsetof(FSkeletalMeshSet, M_FP_mesh) == 0x000000, "Member 'FSkeletalMeshSet::M_FP_mesh' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshSet, M_TP_mesh) == 0x000008, "Member 'FSkeletalMeshSet::M_TP_mesh' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshSet, M_collapsed_TP_mesh) == 0x000010, "Member 'FSkeletalMeshSet::M_collapsed_TP_mesh' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshSet, M_override_materials) == 0x000018, "Member 'FSkeletalMeshSet::M_override_materials' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshSet, M_stolen_identifier_tag) == 0x000028, "Member 'FSkeletalMeshSet::M_stolen_identifier_tag' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshSet, M_real_id_of_disguised_character) == 0x000034, "Member 'FSkeletalMeshSet::M_real_id_of_disguised_character' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshSet, M_real_id_of_copied_character) == 0x000038, "Member 'FSkeletalMeshSet::M_real_id_of_copied_character' has a wrong offset!");

// ScriptStruct keaton.CARequiredPoolSizeData
// 0x0014 (0x0014 - 0x0000)
struct FCARequiredPoolSizeData final
{
public:
	struct FGameplayTag                           M_mission_trigger;                                 // 0x0000(0x000C)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_mission_trigger_id;                              // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_pool_size;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARequiredPoolSizeData) == 0x000004, "Wrong alignment on FCARequiredPoolSizeData");
static_assert(sizeof(FCARequiredPoolSizeData) == 0x000014, "Wrong size on FCARequiredPoolSizeData");
static_assert(offsetof(FCARequiredPoolSizeData, M_mission_trigger) == 0x000000, "Member 'FCARequiredPoolSizeData::M_mission_trigger' has a wrong offset!");
static_assert(offsetof(FCARequiredPoolSizeData, M_mission_trigger_id) == 0x00000C, "Member 'FCARequiredPoolSizeData::M_mission_trigger_id' has a wrong offset!");
static_assert(offsetof(FCARequiredPoolSizeData, M_pool_size) == 0x000010, "Member 'FCARequiredPoolSizeData::M_pool_size' has a wrong offset!");

// ScriptStruct keaton.AirMovementPredictedImpactData
// 0x002C (0x002C - 0x0000)
struct FAirMovementPredictedImpactData final
{
public:
	bool                                          M_has_impact;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_normal;                                          // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_location;                                        // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_impact_point;                                    // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_time_to_impact;                                  // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAirMovementPredictedImpactData) == 0x000004, "Wrong alignment on FAirMovementPredictedImpactData");
static_assert(sizeof(FAirMovementPredictedImpactData) == 0x00002C, "Wrong size on FAirMovementPredictedImpactData");
static_assert(offsetof(FAirMovementPredictedImpactData, M_has_impact) == 0x000000, "Member 'FAirMovementPredictedImpactData::M_has_impact' has a wrong offset!");
static_assert(offsetof(FAirMovementPredictedImpactData, M_normal) == 0x000004, "Member 'FAirMovementPredictedImpactData::M_normal' has a wrong offset!");
static_assert(offsetof(FAirMovementPredictedImpactData, M_location) == 0x000010, "Member 'FAirMovementPredictedImpactData::M_location' has a wrong offset!");
static_assert(offsetof(FAirMovementPredictedImpactData, M_impact_point) == 0x00001C, "Member 'FAirMovementPredictedImpactData::M_impact_point' has a wrong offset!");
static_assert(offsetof(FAirMovementPredictedImpactData, M_time_to_impact) == 0x000028, "Member 'FAirMovementPredictedImpactData::M_time_to_impact' has a wrong offset!");

// ScriptStruct keaton.MovementConstraintCone
// 0x0030 (0x0030 - 0x0000)
struct FMovementConstraintCone final
{
public:
	struct FVector                                M_cone_direction;                                  // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_cone_angle;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_hard_cone_angle;                                 // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_vertical_angle;                                  // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_hard_vertical_angle;                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_constraint_enabled;                              // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_blend_in_angular_speed;                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_cone_direction_is_world_target_point;            // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_cone_direction_is_actor;                         // 0x0025(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        M_actor_component;                                 // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovementConstraintCone) == 0x000008, "Wrong alignment on FMovementConstraintCone");
static_assert(sizeof(FMovementConstraintCone) == 0x000030, "Wrong size on FMovementConstraintCone");
static_assert(offsetof(FMovementConstraintCone, M_cone_direction) == 0x000000, "Member 'FMovementConstraintCone::M_cone_direction' has a wrong offset!");
static_assert(offsetof(FMovementConstraintCone, M_cone_angle) == 0x00000C, "Member 'FMovementConstraintCone::M_cone_angle' has a wrong offset!");
static_assert(offsetof(FMovementConstraintCone, M_hard_cone_angle) == 0x000010, "Member 'FMovementConstraintCone::M_hard_cone_angle' has a wrong offset!");
static_assert(offsetof(FMovementConstraintCone, M_vertical_angle) == 0x000014, "Member 'FMovementConstraintCone::M_vertical_angle' has a wrong offset!");
static_assert(offsetof(FMovementConstraintCone, M_hard_vertical_angle) == 0x000018, "Member 'FMovementConstraintCone::M_hard_vertical_angle' has a wrong offset!");
static_assert(offsetof(FMovementConstraintCone, M_constraint_enabled) == 0x00001C, "Member 'FMovementConstraintCone::M_constraint_enabled' has a wrong offset!");
static_assert(offsetof(FMovementConstraintCone, M_blend_in_angular_speed) == 0x000020, "Member 'FMovementConstraintCone::M_blend_in_angular_speed' has a wrong offset!");
static_assert(offsetof(FMovementConstraintCone, M_cone_direction_is_world_target_point) == 0x000024, "Member 'FMovementConstraintCone::M_cone_direction_is_world_target_point' has a wrong offset!");
static_assert(offsetof(FMovementConstraintCone, M_cone_direction_is_actor) == 0x000025, "Member 'FMovementConstraintCone::M_cone_direction_is_actor' has a wrong offset!");
static_assert(offsetof(FMovementConstraintCone, M_actor_component) == 0x000028, "Member 'FMovementConstraintCone::M_actor_component' has a wrong offset!");

// ScriptStruct keaton.CAAINPCJumpData
// 0x0024 (0x0024 - 0x0000)
struct alignas(0x04) FCAAINPCJumpData final
{
public:
	uint16                                        M_index;                                           // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x22];                                       // 0x0002(0x0022)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAINPCJumpData) == 0x000004, "Wrong alignment on FCAAINPCJumpData");
static_assert(sizeof(FCAAINPCJumpData) == 0x000024, "Wrong size on FCAAINPCJumpData");
static_assert(offsetof(FCAAINPCJumpData, M_index) == 0x000000, "Member 'FCAAINPCJumpData::M_index' has a wrong offset!");

// ScriptStruct keaton.DroneData
// 0x0078 (0x0078 - 0x0000)
struct FDroneData final
{
public:
	bool                                          M_perform_lean;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Max_lean_pitch;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max_lean_roll;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_to_pitch_ratio;                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_to_roll_ratio;                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min_speed_for_lean;                                // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_new_lean;                                        // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Acceleration_max;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration_smoothing;                            // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Upright_factor;                                    // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lean_angle_max;                                    // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Heading_velocity_factor;                           // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation_interp_speed;                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation_PID_P;                                    // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation_PID_D;                                    // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity_last;                                     // 0x003C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Acceleration_smoothed;                             // 0x0048(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Ideal_up_vector;                                   // 0x0054(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Smoothed_rotation;                                 // 0x0060(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Angular_velocity;                                  // 0x006C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDroneData) == 0x000004, "Wrong alignment on FDroneData");
static_assert(sizeof(FDroneData) == 0x000078, "Wrong size on FDroneData");
static_assert(offsetof(FDroneData, M_perform_lean) == 0x000000, "Member 'FDroneData::M_perform_lean' has a wrong offset!");
static_assert(offsetof(FDroneData, Max_lean_pitch) == 0x000004, "Member 'FDroneData::Max_lean_pitch' has a wrong offset!");
static_assert(offsetof(FDroneData, Max_lean_roll) == 0x000008, "Member 'FDroneData::Max_lean_roll' has a wrong offset!");
static_assert(offsetof(FDroneData, Speed_to_pitch_ratio) == 0x00000C, "Member 'FDroneData::Speed_to_pitch_ratio' has a wrong offset!");
static_assert(offsetof(FDroneData, Speed_to_roll_ratio) == 0x000010, "Member 'FDroneData::Speed_to_roll_ratio' has a wrong offset!");
static_assert(offsetof(FDroneData, Min_speed_for_lean) == 0x000014, "Member 'FDroneData::Min_speed_for_lean' has a wrong offset!");
static_assert(offsetof(FDroneData, M_new_lean) == 0x000018, "Member 'FDroneData::M_new_lean' has a wrong offset!");
static_assert(offsetof(FDroneData, Acceleration_max) == 0x00001C, "Member 'FDroneData::Acceleration_max' has a wrong offset!");
static_assert(offsetof(FDroneData, Acceleration_smoothing) == 0x000020, "Member 'FDroneData::Acceleration_smoothing' has a wrong offset!");
static_assert(offsetof(FDroneData, Upright_factor) == 0x000024, "Member 'FDroneData::Upright_factor' has a wrong offset!");
static_assert(offsetof(FDroneData, Lean_angle_max) == 0x000028, "Member 'FDroneData::Lean_angle_max' has a wrong offset!");
static_assert(offsetof(FDroneData, Heading_velocity_factor) == 0x00002C, "Member 'FDroneData::Heading_velocity_factor' has a wrong offset!");
static_assert(offsetof(FDroneData, Rotation_interp_speed) == 0x000030, "Member 'FDroneData::Rotation_interp_speed' has a wrong offset!");
static_assert(offsetof(FDroneData, Rotation_PID_P) == 0x000034, "Member 'FDroneData::Rotation_PID_P' has a wrong offset!");
static_assert(offsetof(FDroneData, Rotation_PID_D) == 0x000038, "Member 'FDroneData::Rotation_PID_D' has a wrong offset!");
static_assert(offsetof(FDroneData, Velocity_last) == 0x00003C, "Member 'FDroneData::Velocity_last' has a wrong offset!");
static_assert(offsetof(FDroneData, Acceleration_smoothed) == 0x000048, "Member 'FDroneData::Acceleration_smoothed' has a wrong offset!");
static_assert(offsetof(FDroneData, Ideal_up_vector) == 0x000054, "Member 'FDroneData::Ideal_up_vector' has a wrong offset!");
static_assert(offsetof(FDroneData, Smoothed_rotation) == 0x000060, "Member 'FDroneData::Smoothed_rotation' has a wrong offset!");
static_assert(offsetof(FDroneData, Angular_velocity) == 0x00006C, "Member 'FDroneData::Angular_velocity' has a wrong offset!");

// ScriptStruct keaton.CACharacterAbilityData
// 0x0070 (0x0070 - 0x0000)
struct FCACharacterAbilityData final
{
public:
	ECAAbilityType                                M_ability_type;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_ability_class;                                   // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCAInventoryItem>        M_ability_inventory_item_ammo_type;                // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ability_ammo_cost;                               // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCACharacterAbilityData) == 0x000008, "Wrong alignment on FCACharacterAbilityData");
static_assert(sizeof(FCACharacterAbilityData) == 0x000070, "Wrong size on FCACharacterAbilityData");
static_assert(offsetof(FCACharacterAbilityData, M_ability_type) == 0x000000, "Member 'FCACharacterAbilityData::M_ability_type' has a wrong offset!");
static_assert(offsetof(FCACharacterAbilityData, M_ability_class) == 0x000008, "Member 'FCACharacterAbilityData::M_ability_class' has a wrong offset!");
static_assert(offsetof(FCACharacterAbilityData, M_ability_inventory_item_ammo_type) == 0x000038, "Member 'FCACharacterAbilityData::M_ability_inventory_item_ammo_type' has a wrong offset!");
static_assert(offsetof(FCACharacterAbilityData, M_ability_ammo_cost) == 0x000068, "Member 'FCACharacterAbilityData::M_ability_ammo_cost' has a wrong offset!");

// ScriptStruct keaton.CAFlashbangUpgradeData
// 0x0030 (0x0030 - 0x0000)
struct FCAFlashbangUpgradeData final
{
public:
	int32                                         M_tactical_level;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_multiplier_zero_g;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             M_flash_impact_parameters;                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bounced;                                         // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAFlashbangBounceData>         M_bounce_data;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ACAExplosionEffect>         M_explosion_effect;                                // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFlashbangUpgradeData) == 0x000008, "Wrong alignment on FCAFlashbangUpgradeData");
static_assert(sizeof(FCAFlashbangUpgradeData) == 0x000030, "Wrong size on FCAFlashbangUpgradeData");
static_assert(offsetof(FCAFlashbangUpgradeData, M_tactical_level) == 0x000000, "Member 'FCAFlashbangUpgradeData::M_tactical_level' has a wrong offset!");
static_assert(offsetof(FCAFlashbangUpgradeData, M_multiplier_zero_g) == 0x000004, "Member 'FCAFlashbangUpgradeData::M_multiplier_zero_g' has a wrong offset!");
static_assert(offsetof(FCAFlashbangUpgradeData, M_flash_impact_parameters) == 0x000008, "Member 'FCAFlashbangUpgradeData::M_flash_impact_parameters' has a wrong offset!");
static_assert(offsetof(FCAFlashbangUpgradeData, M_bounced) == 0x000010, "Member 'FCAFlashbangUpgradeData::M_bounced' has a wrong offset!");
static_assert(offsetof(FCAFlashbangUpgradeData, M_bounce_data) == 0x000018, "Member 'FCAFlashbangUpgradeData::M_bounce_data' has a wrong offset!");
static_assert(offsetof(FCAFlashbangUpgradeData, M_explosion_effect) == 0x000028, "Member 'FCAFlashbangUpgradeData::M_explosion_effect' has a wrong offset!");

// ScriptStruct keaton.CACharacterAudioTableRow
// 0x0018 (0x0020 - 0x0008)
struct FCACharacterAudioTableRow final : public FTableRowBase
{
public:
	float                                         BaseThreat;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombatThreat;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryThreat;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearBaseThreat;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxThreatRange;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThreatDeadZone;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACharacterAudioTableRow) == 0x000008, "Wrong alignment on FCACharacterAudioTableRow");
static_assert(sizeof(FCACharacterAudioTableRow) == 0x000020, "Wrong size on FCACharacterAudioTableRow");
static_assert(offsetof(FCACharacterAudioTableRow, BaseThreat) == 0x000008, "Member 'FCACharacterAudioTableRow::BaseThreat' has a wrong offset!");
static_assert(offsetof(FCACharacterAudioTableRow, CombatThreat) == 0x00000C, "Member 'FCACharacterAudioTableRow::CombatThreat' has a wrong offset!");
static_assert(offsetof(FCACharacterAudioTableRow, SecondaryThreat) == 0x000010, "Member 'FCACharacterAudioTableRow::SecondaryThreat' has a wrong offset!");
static_assert(offsetof(FCACharacterAudioTableRow, NearBaseThreat) == 0x000014, "Member 'FCACharacterAudioTableRow::NearBaseThreat' has a wrong offset!");
static_assert(offsetof(FCACharacterAudioTableRow, MaxThreatRange) == 0x000018, "Member 'FCACharacterAudioTableRow::MaxThreatRange' has a wrong offset!");
static_assert(offsetof(FCACharacterAudioTableRow, ThreatDeadZone) == 0x00001C, "Member 'FCACharacterAudioTableRow::ThreatDeadZone' has a wrong offset!");

// ScriptStruct keaton.CAServicesResultForUser
// 0x0034 (0x0034 - 0x0000)
struct alignas(0x04) FCAServicesResultForUser final
{
public:
	uint8                                         Pad_0[0x34];                                       // 0x0000(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAServicesResultForUser) == 0x000004, "Wrong alignment on FCAServicesResultForUser");
static_assert(sizeof(FCAServicesResultForUser) == 0x000034, "Wrong size on FCAServicesResultForUser");

// ScriptStruct keaton.CAMountablePart
// 0x0040 (0x0040 - 0x0000)
struct FCAMountablePart final
{
public:
	class FName                                   M_socket_name;                                     // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_uses_external_mesh;                              // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        M_mesh;                                            // 0x0010(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_explosion_effect_row_name;                       // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_on_destruction_audio_event;                      // 0x003C(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMountablePart) == 0x000008, "Wrong alignment on FCAMountablePart");
static_assert(sizeof(FCAMountablePart) == 0x000040, "Wrong size on FCAMountablePart");
static_assert(offsetof(FCAMountablePart, M_socket_name) == 0x000000, "Member 'FCAMountablePart::M_socket_name' has a wrong offset!");
static_assert(offsetof(FCAMountablePart, M_uses_external_mesh) == 0x00000C, "Member 'FCAMountablePart::M_uses_external_mesh' has a wrong offset!");
static_assert(offsetof(FCAMountablePart, M_mesh) == 0x000010, "Member 'FCAMountablePart::M_mesh' has a wrong offset!");
static_assert(offsetof(FCAMountablePart, M_explosion_effect_row_name) == 0x000030, "Member 'FCAMountablePart::M_explosion_effect_row_name' has a wrong offset!");
static_assert(offsetof(FCAMountablePart, M_on_destruction_audio_event) == 0x00003C, "Member 'FCAMountablePart::M_on_destruction_audio_event' has a wrong offset!");

// ScriptStruct keaton.CARagdollSetup
// 0x0018 (0x0018 - 0x0000)
struct FCARagdollSetup final
{
public:
	bool                                          M_ragdoll_on_death;                                // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsAsset*                          M_ragdoll_physics_asset;                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ragdoll_lifespan;                                // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCARagdollSetup) == 0x000008, "Wrong alignment on FCARagdollSetup");
static_assert(sizeof(FCARagdollSetup) == 0x000018, "Wrong size on FCARagdollSetup");
static_assert(offsetof(FCARagdollSetup, M_ragdoll_on_death) == 0x000000, "Member 'FCARagdollSetup::M_ragdoll_on_death' has a wrong offset!");
static_assert(offsetof(FCARagdollSetup, M_ragdoll_physics_asset) == 0x000008, "Member 'FCARagdollSetup::M_ragdoll_physics_asset' has a wrong offset!");
static_assert(offsetof(FCARagdollSetup, M_ragdoll_lifespan) == 0x000010, "Member 'FCARagdollSetup::M_ragdoll_lifespan' has a wrong offset!");

// ScriptStruct keaton.CACharacterData
// 0x0220 (0x0228 - 0x0008)
struct FCACharacterData : public FTableRowBase
{
public:
	struct FCAText                                M_name;                                            // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_description;                                     // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           M_base_mesh_third_person;                          // 0x0050(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAMountablePart>               M_mountable_parts;                                 // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCARagdollSetup                        M_ragdoll_setup;                                   // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_death_timer;                                     // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_start_death_timer_after_animation;               // 0x00AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_death_effect_template;                           // 0x00B0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAHitBones*                            M_hit_bones;                                       // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_base_anim_blueprint_third_person;                // 0x00E8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_dialogue_name;                                   // 0x0118(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_dialogue_type;                                   // 0x0124(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_dialogue_variants;                               // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_sfx_variants;                                    // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_large_damage_value;                              // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   M_permanent_tags;                                  // 0x0140(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FAttributeInitialisationInfo           M_initialisation_info;                             // 0x0150(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCAAbilitySet>           M_initial_ability_set;                             // 0x0198(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCAAbilitySet>           M_additional_ability_set;                          // 0x01C8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_audio_component_class;                           // 0x01F8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACharacterData) == 0x000008, "Wrong alignment on FCACharacterData");
static_assert(sizeof(FCACharacterData) == 0x000228, "Wrong size on FCACharacterData");
static_assert(offsetof(FCACharacterData, M_name) == 0x000008, "Member 'FCACharacterData::M_name' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_description) == 0x000038, "Member 'FCACharacterData::M_description' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_base_mesh_third_person) == 0x000050, "Member 'FCACharacterData::M_base_mesh_third_person' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_mountable_parts) == 0x000080, "Member 'FCACharacterData::M_mountable_parts' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_ragdoll_setup) == 0x000090, "Member 'FCACharacterData::M_ragdoll_setup' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_death_timer) == 0x0000A8, "Member 'FCACharacterData::M_death_timer' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_start_death_timer_after_animation) == 0x0000AC, "Member 'FCACharacterData::M_start_death_timer_after_animation' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_death_effect_template) == 0x0000B0, "Member 'FCACharacterData::M_death_effect_template' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_hit_bones) == 0x0000E0, "Member 'FCACharacterData::M_hit_bones' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_base_anim_blueprint_third_person) == 0x0000E8, "Member 'FCACharacterData::M_base_anim_blueprint_third_person' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_dialogue_name) == 0x000118, "Member 'FCACharacterData::M_dialogue_name' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_dialogue_type) == 0x000124, "Member 'FCACharacterData::M_dialogue_type' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_dialogue_variants) == 0x000130, "Member 'FCACharacterData::M_dialogue_variants' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_sfx_variants) == 0x000134, "Member 'FCACharacterData::M_sfx_variants' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_large_damage_value) == 0x000138, "Member 'FCACharacterData::M_large_damage_value' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_permanent_tags) == 0x000140, "Member 'FCACharacterData::M_permanent_tags' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_initialisation_info) == 0x000150, "Member 'FCACharacterData::M_initialisation_info' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_initial_ability_set) == 0x000198, "Member 'FCACharacterData::M_initial_ability_set' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_additional_ability_set) == 0x0001C8, "Member 'FCACharacterData::M_additional_ability_set' has a wrong offset!");
static_assert(offsetof(FCACharacterData, M_audio_component_class) == 0x0001F8, "Member 'FCACharacterData::M_audio_component_class' has a wrong offset!");

// ScriptStruct keaton.CARotatingMovementComponentConfiguration
// 0x0020 (0x0028 - 0x0008)
struct FCARotatingMovementComponentConfiguration final : public FTableRowBase
{
public:
	struct FRotator                               RotationRate;                                      // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                PivotTranslation;                                  // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRotationInLocalSpace : 1;                         // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_start_with_random_rotation;                      // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_start_with_random_rotation_with_roll;            // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCARotatingMovementComponentConfiguration) == 0x000008, "Wrong alignment on FCARotatingMovementComponentConfiguration");
static_assert(sizeof(FCARotatingMovementComponentConfiguration) == 0x000028, "Wrong size on FCARotatingMovementComponentConfiguration");
static_assert(offsetof(FCARotatingMovementComponentConfiguration, RotationRate) == 0x000008, "Member 'FCARotatingMovementComponentConfiguration::RotationRate' has a wrong offset!");
static_assert(offsetof(FCARotatingMovementComponentConfiguration, PivotTranslation) == 0x000014, "Member 'FCARotatingMovementComponentConfiguration::PivotTranslation' has a wrong offset!");
static_assert(offsetof(FCARotatingMovementComponentConfiguration, M_start_with_random_rotation) == 0x000024, "Member 'FCARotatingMovementComponentConfiguration::M_start_with_random_rotation' has a wrong offset!");
static_assert(offsetof(FCARotatingMovementComponentConfiguration, M_start_with_random_rotation_with_roll) == 0x000025, "Member 'FCARotatingMovementComponentConfiguration::M_start_with_random_rotation_with_roll' has a wrong offset!");

// ScriptStruct keaton.CAEffectLoadout
// 0x0050 (0x0050 - 0x0000)
struct FCAEffectLoadout final
{
public:
	TMap<class FName, class UObject*>             Effect_actors;                                     // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAEffectLoadout) == 0x000008, "Wrong alignment on FCAEffectLoadout");
static_assert(sizeof(FCAEffectLoadout) == 0x000050, "Wrong size on FCAEffectLoadout");
static_assert(offsetof(FCAEffectLoadout, Effect_actors) == 0x000000, "Member 'FCAEffectLoadout::Effect_actors' has a wrong offset!");

// ScriptStruct keaton.CACharacterCombatEventDebugData
// 0x000C (0x000C - 0x0000)
struct FCACharacterCombatEventDebugData final
{
public:
	EFCACharacterCombatEventType                  M_type;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_damage;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_was_head_shot;                                   // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_was_fatal;                                       // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCACharacterCombatEventDebugData) == 0x000004, "Wrong alignment on FCACharacterCombatEventDebugData");
static_assert(sizeof(FCACharacterCombatEventDebugData) == 0x00000C, "Wrong size on FCACharacterCombatEventDebugData");
static_assert(offsetof(FCACharacterCombatEventDebugData, M_type) == 0x000000, "Member 'FCACharacterCombatEventDebugData::M_type' has a wrong offset!");
static_assert(offsetof(FCACharacterCombatEventDebugData, M_damage) == 0x000004, "Member 'FCACharacterCombatEventDebugData::M_damage' has a wrong offset!");
static_assert(offsetof(FCACharacterCombatEventDebugData, M_was_head_shot) == 0x000008, "Member 'FCACharacterCombatEventDebugData::M_was_head_shot' has a wrong offset!");
static_assert(offsetof(FCACharacterCombatEventDebugData, M_was_fatal) == 0x000009, "Member 'FCACharacterCombatEventDebugData::M_was_fatal' has a wrong offset!");

// ScriptStruct keaton.CANPCDebugUIInfo
// 0x0020 (0x0020 - 0x0000)
struct FCANPCDebugUIInfo final
{
public:
	float                                         M_sight_gauge_level;                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_hearing_gauge_level;                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_damage_gauge_level;                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_weapon_gauge_level;                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_touch_gauge_level;                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_awareness_gauge_level;                           // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_sight_gauge_threshold;                           // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_hearing_gauge_threshold;                         // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_damage_gauge_threshold;                          // 0x001A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_weapon_gauge_threshold;                          // 0x001B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_touch_gauge_threshold;                           // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_awareness_gauge_state;                           // 0x001D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_perception_state;                                // 0x001E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCDebugUIInfo) == 0x000004, "Wrong alignment on FCANPCDebugUIInfo");
static_assert(sizeof(FCANPCDebugUIInfo) == 0x000020, "Wrong size on FCANPCDebugUIInfo");
static_assert(offsetof(FCANPCDebugUIInfo, M_sight_gauge_level) == 0x000000, "Member 'FCANPCDebugUIInfo::M_sight_gauge_level' has a wrong offset!");
static_assert(offsetof(FCANPCDebugUIInfo, M_hearing_gauge_level) == 0x000004, "Member 'FCANPCDebugUIInfo::M_hearing_gauge_level' has a wrong offset!");
static_assert(offsetof(FCANPCDebugUIInfo, M_damage_gauge_level) == 0x000008, "Member 'FCANPCDebugUIInfo::M_damage_gauge_level' has a wrong offset!");
static_assert(offsetof(FCANPCDebugUIInfo, M_weapon_gauge_level) == 0x00000C, "Member 'FCANPCDebugUIInfo::M_weapon_gauge_level' has a wrong offset!");
static_assert(offsetof(FCANPCDebugUIInfo, M_touch_gauge_level) == 0x000010, "Member 'FCANPCDebugUIInfo::M_touch_gauge_level' has a wrong offset!");
static_assert(offsetof(FCANPCDebugUIInfo, M_awareness_gauge_level) == 0x000014, "Member 'FCANPCDebugUIInfo::M_awareness_gauge_level' has a wrong offset!");
static_assert(offsetof(FCANPCDebugUIInfo, M_sight_gauge_threshold) == 0x000018, "Member 'FCANPCDebugUIInfo::M_sight_gauge_threshold' has a wrong offset!");
static_assert(offsetof(FCANPCDebugUIInfo, M_hearing_gauge_threshold) == 0x000019, "Member 'FCANPCDebugUIInfo::M_hearing_gauge_threshold' has a wrong offset!");
static_assert(offsetof(FCANPCDebugUIInfo, M_damage_gauge_threshold) == 0x00001A, "Member 'FCANPCDebugUIInfo::M_damage_gauge_threshold' has a wrong offset!");
static_assert(offsetof(FCANPCDebugUIInfo, M_weapon_gauge_threshold) == 0x00001B, "Member 'FCANPCDebugUIInfo::M_weapon_gauge_threshold' has a wrong offset!");
static_assert(offsetof(FCANPCDebugUIInfo, M_touch_gauge_threshold) == 0x00001C, "Member 'FCANPCDebugUIInfo::M_touch_gauge_threshold' has a wrong offset!");
static_assert(offsetof(FCANPCDebugUIInfo, M_awareness_gauge_state) == 0x00001D, "Member 'FCANPCDebugUIInfo::M_awareness_gauge_state' has a wrong offset!");
static_assert(offsetof(FCANPCDebugUIInfo, M_perception_state) == 0x00001E, "Member 'FCANPCDebugUIInfo::M_perception_state' has a wrong offset!");

// ScriptStruct keaton.CASecurityModuleArray
// 0x0010 (0x0010 - 0x0000)
struct FCASecurityModuleArray final
{
public:
	TArray<class ACASecurityModule*>              M_security_modules;                                // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASecurityModuleArray) == 0x000008, "Wrong alignment on FCASecurityModuleArray");
static_assert(sizeof(FCASecurityModuleArray) == 0x000010, "Wrong size on FCASecurityModuleArray");
static_assert(offsetof(FCASecurityModuleArray, M_security_modules) == 0x000000, "Member 'FCASecurityModuleArray::M_security_modules' has a wrong offset!");

// ScriptStruct keaton.CACharacterDebugDrawItem
// 0x0050 (0x0050 - 0x0000)
struct FCACharacterDebugDrawItem final
{
public:
	ECADebugDrawTypes                             M_debug_draw_type;                                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    M_pos;                                             // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    M_end_pos;                                         // 0x0010(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_debug_string;                                    // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 M_colour;                                          // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_radius;                                          // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          M_segments;                                        // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_angle;                                           // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_thickness;                                       // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECADebugItems                                 M_parent_item;                                     // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_parent_item_selected;                            // 0x0045(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_duration;                                        // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCACharacterDebugDrawItem) == 0x000008, "Wrong alignment on FCACharacterDebugDrawItem");
static_assert(sizeof(FCACharacterDebugDrawItem) == 0x000050, "Wrong size on FCACharacterDebugDrawItem");
static_assert(offsetof(FCACharacterDebugDrawItem, M_debug_draw_type) == 0x000000, "Member 'FCACharacterDebugDrawItem::M_debug_draw_type' has a wrong offset!");
static_assert(offsetof(FCACharacterDebugDrawItem, M_pos) == 0x000004, "Member 'FCACharacterDebugDrawItem::M_pos' has a wrong offset!");
static_assert(offsetof(FCACharacterDebugDrawItem, M_end_pos) == 0x000010, "Member 'FCACharacterDebugDrawItem::M_end_pos' has a wrong offset!");
static_assert(offsetof(FCACharacterDebugDrawItem, M_debug_string) == 0x000020, "Member 'FCACharacterDebugDrawItem::M_debug_string' has a wrong offset!");
static_assert(offsetof(FCACharacterDebugDrawItem, M_colour) == 0x000030, "Member 'FCACharacterDebugDrawItem::M_colour' has a wrong offset!");
static_assert(offsetof(FCACharacterDebugDrawItem, M_radius) == 0x000034, "Member 'FCACharacterDebugDrawItem::M_radius' has a wrong offset!");
static_assert(offsetof(FCACharacterDebugDrawItem, M_segments) == 0x000038, "Member 'FCACharacterDebugDrawItem::M_segments' has a wrong offset!");
static_assert(offsetof(FCACharacterDebugDrawItem, M_angle) == 0x00003C, "Member 'FCACharacterDebugDrawItem::M_angle' has a wrong offset!");
static_assert(offsetof(FCACharacterDebugDrawItem, M_thickness) == 0x000040, "Member 'FCACharacterDebugDrawItem::M_thickness' has a wrong offset!");
static_assert(offsetof(FCACharacterDebugDrawItem, M_parent_item) == 0x000044, "Member 'FCACharacterDebugDrawItem::M_parent_item' has a wrong offset!");
static_assert(offsetof(FCACharacterDebugDrawItem, M_parent_item_selected) == 0x000045, "Member 'FCACharacterDebugDrawItem::M_parent_item_selected' has a wrong offset!");
static_assert(offsetof(FCACharacterDebugDrawItem, M_duration) == 0x000048, "Member 'FCACharacterDebugDrawItem::M_duration' has a wrong offset!");

// ScriptStruct keaton.CAMemberTaskMotivationActivationPhaseData
// 0x0010 (0x0010 - 0x0000)
struct FCAMemberTaskMotivationActivationPhaseData final
{
public:
	TArray<class UCAMotivationActivationPhase*>   M_motivation_activation_phases;                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMemberTaskMotivationActivationPhaseData) == 0x000008, "Wrong alignment on FCAMemberTaskMotivationActivationPhaseData");
static_assert(sizeof(FCAMemberTaskMotivationActivationPhaseData) == 0x000010, "Wrong size on FCAMemberTaskMotivationActivationPhaseData");
static_assert(offsetof(FCAMemberTaskMotivationActivationPhaseData, M_motivation_activation_phases) == 0x000000, "Member 'FCAMemberTaskMotivationActivationPhaseData::M_motivation_activation_phases' has a wrong offset!");

// ScriptStruct keaton.CANPCDebugNodeHistoryItem
// 0x0020 (0x0020 - 0x0000)
struct FCANPCDebugNodeHistoryItem final
{
public:
	class FString                                 M_txt;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_pos;                                             // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCDebugNodeHistoryItem) == 0x000008, "Wrong alignment on FCANPCDebugNodeHistoryItem");
static_assert(sizeof(FCANPCDebugNodeHistoryItem) == 0x000020, "Wrong size on FCANPCDebugNodeHistoryItem");
static_assert(offsetof(FCANPCDebugNodeHistoryItem, M_txt) == 0x000000, "Member 'FCANPCDebugNodeHistoryItem::M_txt' has a wrong offset!");
static_assert(offsetof(FCANPCDebugNodeHistoryItem, M_pos) == 0x000010, "Member 'FCANPCDebugNodeHistoryItem::M_pos' has a wrong offset!");

// ScriptStruct keaton.CALogicParser
// 0x0010 (0x0010 - 0x0000)
struct FCALogicParser final
{
public:
	TArray<bool>                                  Constants;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALogicParser) == 0x000008, "Wrong alignment on FCALogicParser");
static_assert(sizeof(FCALogicParser) == 0x000010, "Wrong size on FCALogicParser");
static_assert(offsetof(FCALogicParser, Constants) == 0x000000, "Member 'FCALogicParser::Constants' has a wrong offset!");

// ScriptStruct keaton.CACharacterImpactEffectRow
// 0x0030 (0x0038 - 0x0008)
struct FCACharacterImpactEffectRow final : public FTableRowBase
{
public:
	class UNiagaraSystem*                         Niagara_system_template;                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         Niagara_payload_system_template;                   // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Single_particle_system_per_cluster;                // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Spawn_delay;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Glancing_threshold_degrees_range;                  // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Trace_effect_row_name;                             // 0x0028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAAudioSwitchValueType                Audio_material_switch_override;                    // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACharacterImpactEffectRow) == 0x000008, "Wrong alignment on FCACharacterImpactEffectRow");
static_assert(sizeof(FCACharacterImpactEffectRow) == 0x000038, "Wrong size on FCACharacterImpactEffectRow");
static_assert(offsetof(FCACharacterImpactEffectRow, Niagara_system_template) == 0x000008, "Member 'FCACharacterImpactEffectRow::Niagara_system_template' has a wrong offset!");
static_assert(offsetof(FCACharacterImpactEffectRow, Niagara_payload_system_template) == 0x000010, "Member 'FCACharacterImpactEffectRow::Niagara_payload_system_template' has a wrong offset!");
static_assert(offsetof(FCACharacterImpactEffectRow, Single_particle_system_per_cluster) == 0x000018, "Member 'FCACharacterImpactEffectRow::Single_particle_system_per_cluster' has a wrong offset!");
static_assert(offsetof(FCACharacterImpactEffectRow, Spawn_delay) == 0x00001C, "Member 'FCACharacterImpactEffectRow::Spawn_delay' has a wrong offset!");
static_assert(offsetof(FCACharacterImpactEffectRow, Glancing_threshold_degrees_range) == 0x000020, "Member 'FCACharacterImpactEffectRow::Glancing_threshold_degrees_range' has a wrong offset!");
static_assert(offsetof(FCACharacterImpactEffectRow, Trace_effect_row_name) == 0x000028, "Member 'FCACharacterImpactEffectRow::Trace_effect_row_name' has a wrong offset!");
static_assert(offsetof(FCACharacterImpactEffectRow, Audio_material_switch_override) == 0x000034, "Member 'FCACharacterImpactEffectRow::Audio_material_switch_override' has a wrong offset!");

// ScriptStruct keaton.CAMovementDataBaseRowPair
// 0x001C (0x001C - 0x0000)
struct FCAMovementDataBaseRowPair final
{
public:
	struct FCAGameDatabaseRowHandle               M_table;                                           // 0x0000(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ECAPlayerAbilityMode                          M_mode;                                            // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementDataBaseRowPair) == 0x000004, "Wrong alignment on FCAMovementDataBaseRowPair");
static_assert(sizeof(FCAMovementDataBaseRowPair) == 0x00001C, "Wrong size on FCAMovementDataBaseRowPair");
static_assert(offsetof(FCAMovementDataBaseRowPair, M_table) == 0x000000, "Member 'FCAMovementDataBaseRowPair::M_table' has a wrong offset!");
static_assert(offsetof(FCAMovementDataBaseRowPair, M_mode) == 0x000018, "Member 'FCAMovementDataBaseRowPair::M_mode' has a wrong offset!");

// ScriptStruct keaton.CAMovementModeTransitionTableRow
// 0x0030 (0x0038 - 0x0008)
struct FCAMovementModeTransitionTableRow final : public FTableRowBase
{
public:
	ECAPlayerAbilityMode                          Mode;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Undefined;                                         // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            NPC;                                               // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Loco;                                              // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Sprint;                                            // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            CrouchedLoco;                                      // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Slide;                                             // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Fall;                                              // 0x000F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Jump;                                              // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            LowTraverse;                                       // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            HighTraverse;                                      // 0x0012(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            ZeroG_Attached;                                    // 0x0013(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            ZeroG_TakeOff;                                     // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            ZeroG_Flying;                                      // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            ZeroG_GravHook;                                    // 0x0016(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            MagBoots;                                          // 0x0017(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            MagBoots_Sprint;                                   // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            MagBoots_Crouch;                                   // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            MagBoots_Fall;                                     // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            FreeCam;                                           // 0x001B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Downed;                                            // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Heal;                                              // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Revive;                                            // 0x001E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Freeze;                                            // 0x001F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Emote;                                             // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Melee;                                             // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Fire;                                              // 0x0022(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            ADS;                                               // 0x0023(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Reload;                                            // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Next_Weapon;                                       // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Next_weapon_mode;                                  // 0x0026(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Use;                                               // 0x0027(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            UseDowned;                                         // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            UseAnimated;                                       // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Gadget;                                            // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            GadgetB;                                           // 0x002B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            GadgetThrown;                                      // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            GadgetStatic;                                      // 0x002D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Ability_No_Hands;                                  // 0x002E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Ability_One_Hand;                                  // 0x002F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Ability_Two_Hands;                                 // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Anim_Only;                                         // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Electrocuted;                                      // 0x0032(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Foamed;                                            // 0x0033(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Map;                                               // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATransitionState                            Spray;                                             // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementModeTransitionTableRow) == 0x000008, "Wrong alignment on FCAMovementModeTransitionTableRow");
static_assert(sizeof(FCAMovementModeTransitionTableRow) == 0x000038, "Wrong size on FCAMovementModeTransitionTableRow");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Mode) == 0x000008, "Member 'FCAMovementModeTransitionTableRow::Mode' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Undefined) == 0x000009, "Member 'FCAMovementModeTransitionTableRow::Undefined' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, NPC) == 0x00000A, "Member 'FCAMovementModeTransitionTableRow::NPC' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Loco) == 0x00000B, "Member 'FCAMovementModeTransitionTableRow::Loco' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Sprint) == 0x00000C, "Member 'FCAMovementModeTransitionTableRow::Sprint' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, CrouchedLoco) == 0x00000D, "Member 'FCAMovementModeTransitionTableRow::CrouchedLoco' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Slide) == 0x00000E, "Member 'FCAMovementModeTransitionTableRow::Slide' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Fall) == 0x00000F, "Member 'FCAMovementModeTransitionTableRow::Fall' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Jump) == 0x000010, "Member 'FCAMovementModeTransitionTableRow::Jump' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, LowTraverse) == 0x000011, "Member 'FCAMovementModeTransitionTableRow::LowTraverse' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, HighTraverse) == 0x000012, "Member 'FCAMovementModeTransitionTableRow::HighTraverse' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, ZeroG_Attached) == 0x000013, "Member 'FCAMovementModeTransitionTableRow::ZeroG_Attached' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, ZeroG_TakeOff) == 0x000014, "Member 'FCAMovementModeTransitionTableRow::ZeroG_TakeOff' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, ZeroG_Flying) == 0x000015, "Member 'FCAMovementModeTransitionTableRow::ZeroG_Flying' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, ZeroG_GravHook) == 0x000016, "Member 'FCAMovementModeTransitionTableRow::ZeroG_GravHook' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, MagBoots) == 0x000017, "Member 'FCAMovementModeTransitionTableRow::MagBoots' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, MagBoots_Sprint) == 0x000018, "Member 'FCAMovementModeTransitionTableRow::MagBoots_Sprint' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, MagBoots_Crouch) == 0x000019, "Member 'FCAMovementModeTransitionTableRow::MagBoots_Crouch' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, MagBoots_Fall) == 0x00001A, "Member 'FCAMovementModeTransitionTableRow::MagBoots_Fall' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, FreeCam) == 0x00001B, "Member 'FCAMovementModeTransitionTableRow::FreeCam' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Downed) == 0x00001C, "Member 'FCAMovementModeTransitionTableRow::Downed' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Heal) == 0x00001D, "Member 'FCAMovementModeTransitionTableRow::Heal' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Revive) == 0x00001E, "Member 'FCAMovementModeTransitionTableRow::Revive' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Freeze) == 0x00001F, "Member 'FCAMovementModeTransitionTableRow::Freeze' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Emote) == 0x000020, "Member 'FCAMovementModeTransitionTableRow::Emote' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Melee) == 0x000021, "Member 'FCAMovementModeTransitionTableRow::Melee' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Fire) == 0x000022, "Member 'FCAMovementModeTransitionTableRow::Fire' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, ADS) == 0x000023, "Member 'FCAMovementModeTransitionTableRow::ADS' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Reload) == 0x000024, "Member 'FCAMovementModeTransitionTableRow::Reload' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Next_Weapon) == 0x000025, "Member 'FCAMovementModeTransitionTableRow::Next_Weapon' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Next_weapon_mode) == 0x000026, "Member 'FCAMovementModeTransitionTableRow::Next_weapon_mode' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Use) == 0x000027, "Member 'FCAMovementModeTransitionTableRow::Use' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, UseDowned) == 0x000028, "Member 'FCAMovementModeTransitionTableRow::UseDowned' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, UseAnimated) == 0x000029, "Member 'FCAMovementModeTransitionTableRow::UseAnimated' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Gadget) == 0x00002A, "Member 'FCAMovementModeTransitionTableRow::Gadget' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, GadgetB) == 0x00002B, "Member 'FCAMovementModeTransitionTableRow::GadgetB' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, GadgetThrown) == 0x00002C, "Member 'FCAMovementModeTransitionTableRow::GadgetThrown' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, GadgetStatic) == 0x00002D, "Member 'FCAMovementModeTransitionTableRow::GadgetStatic' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Ability_No_Hands) == 0x00002E, "Member 'FCAMovementModeTransitionTableRow::Ability_No_Hands' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Ability_One_Hand) == 0x00002F, "Member 'FCAMovementModeTransitionTableRow::Ability_One_Hand' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Ability_Two_Hands) == 0x000030, "Member 'FCAMovementModeTransitionTableRow::Ability_Two_Hands' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Anim_Only) == 0x000031, "Member 'FCAMovementModeTransitionTableRow::Anim_Only' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Electrocuted) == 0x000032, "Member 'FCAMovementModeTransitionTableRow::Electrocuted' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Foamed) == 0x000033, "Member 'FCAMovementModeTransitionTableRow::Foamed' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Map) == 0x000034, "Member 'FCAMovementModeTransitionTableRow::Map' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionTableRow, Spray) == 0x000035, "Member 'FCAMovementModeTransitionTableRow::Spray' has a wrong offset!");

// ScriptStruct keaton.CAPickupOptions
// 0x0060 (0x0060 - 0x0000)
struct FCAPickupOptions final
{
public:
	TSoftClassPtr<class UClass>                   M_default_pickup_class;                            // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_default_tactical_pickup_class;                   // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPickupOptions) == 0x000008, "Wrong alignment on FCAPickupOptions");
static_assert(sizeof(FCAPickupOptions) == 0x000060, "Wrong size on FCAPickupOptions");
static_assert(offsetof(FCAPickupOptions, M_default_pickup_class) == 0x000000, "Member 'FCAPickupOptions::M_default_pickup_class' has a wrong offset!");
static_assert(offsetof(FCAPickupOptions, M_default_tactical_pickup_class) == 0x000030, "Member 'FCAPickupOptions::M_default_tactical_pickup_class' has a wrong offset!");

// ScriptStruct keaton.CAMovementModeTransitionParentsTableRow
// 0x0018 (0x0020 - 0x0008)
struct FCAMovementModeTransitionParentsTableRow final : public FTableRowBase
{
public:
	class FName                                   M_parent;                                          // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_table;                                           // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMovementModeTransitionParentsTableRow) == 0x000008, "Wrong alignment on FCAMovementModeTransitionParentsTableRow");
static_assert(sizeof(FCAMovementModeTransitionParentsTableRow) == 0x000020, "Wrong size on FCAMovementModeTransitionParentsTableRow");
static_assert(offsetof(FCAMovementModeTransitionParentsTableRow, M_parent) == 0x000008, "Member 'FCAMovementModeTransitionParentsTableRow::M_parent' has a wrong offset!");
static_assert(offsetof(FCAMovementModeTransitionParentsTableRow, M_table) == 0x000014, "Member 'FCAMovementModeTransitionParentsTableRow::M_table' has a wrong offset!");

// ScriptStruct keaton.CARewardDistributionGroupingToOwnerData
// 0x0020 (0x0020 - 0x0000)
struct FCARewardDistributionGroupingToOwnerData final
{
public:
	struct FDataTableRowHandle                    M_reward_distribution_grouping;                    // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 M_reward_distribution_grouping_owner;              // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARewardDistributionGroupingToOwnerData) == 0x000008, "Wrong alignment on FCARewardDistributionGroupingToOwnerData");
static_assert(sizeof(FCARewardDistributionGroupingToOwnerData) == 0x000020, "Wrong size on FCARewardDistributionGroupingToOwnerData");
static_assert(offsetof(FCARewardDistributionGroupingToOwnerData, M_reward_distribution_grouping) == 0x000000, "Member 'FCARewardDistributionGroupingToOwnerData::M_reward_distribution_grouping' has a wrong offset!");
static_assert(offsetof(FCARewardDistributionGroupingToOwnerData, M_reward_distribution_grouping_owner) == 0x000018, "Member 'FCARewardDistributionGroupingToOwnerData::M_reward_distribution_grouping_owner' has a wrong offset!");

// ScriptStruct keaton.CARewardCountData
// 0x0014 (0x0014 - 0x0000)
struct FCARewardCountData final
{
public:
	struct FGameplayTag                           M_reward_tag;                                      // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_count;                                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_spawn_on_initialisation;                         // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCARewardCountData) == 0x000004, "Wrong alignment on FCARewardCountData");
static_assert(sizeof(FCARewardCountData) == 0x000014, "Wrong size on FCARewardCountData");
static_assert(offsetof(FCARewardCountData, M_reward_tag) == 0x000000, "Member 'FCARewardCountData::M_reward_tag' has a wrong offset!");
static_assert(offsetof(FCARewardCountData, M_count) == 0x00000C, "Member 'FCARewardCountData::M_count' has a wrong offset!");
static_assert(offsetof(FCARewardCountData, M_spawn_on_initialisation) == 0x000010, "Member 'FCARewardCountData::M_spawn_on_initialisation' has a wrong offset!");

// ScriptStruct keaton.CACurrentRewardSetAmountUsedPair
// 0x0020 (0x0020 - 0x0000)
struct FCACurrentRewardSetAmountUsedPair final
{
public:
	TArray<class AActor*>                         M_grouping_owners;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         M_current_user_sources;                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACurrentRewardSetAmountUsedPair) == 0x000008, "Wrong alignment on FCACurrentRewardSetAmountUsedPair");
static_assert(sizeof(FCACurrentRewardSetAmountUsedPair) == 0x000020, "Wrong size on FCACurrentRewardSetAmountUsedPair");
static_assert(offsetof(FCACurrentRewardSetAmountUsedPair, M_grouping_owners) == 0x000000, "Member 'FCACurrentRewardSetAmountUsedPair::M_grouping_owners' has a wrong offset!");
static_assert(offsetof(FCACurrentRewardSetAmountUsedPair, M_current_user_sources) == 0x000010, "Member 'FCACurrentRewardSetAmountUsedPair::M_current_user_sources' has a wrong offset!");

// ScriptStruct keaton.CARewardSetData
// 0x0040 (0x0048 - 0x0008)
struct FCARewardSetData final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_enabled;                                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCARewardCountData>             M_reward_count;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         M_weight;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_use_limit;                                       // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCACurrentRewardSetAmountUsedPair> M_current_amounts_used;                            // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARewardSetData) == 0x000008, "Wrong alignment on FCARewardSetData");
static_assert(sizeof(FCARewardSetData) == 0x000048, "Wrong size on FCARewardSetData");
static_assert(offsetof(FCARewardSetData, M_enabled) == 0x000018, "Member 'FCARewardSetData::M_enabled' has a wrong offset!");
static_assert(offsetof(FCARewardSetData, M_reward_count) == 0x000020, "Member 'FCARewardSetData::M_reward_count' has a wrong offset!");
static_assert(offsetof(FCARewardSetData, M_weight) == 0x000030, "Member 'FCARewardSetData::M_weight' has a wrong offset!");
static_assert(offsetof(FCARewardSetData, M_use_limit) == 0x000034, "Member 'FCARewardSetData::M_use_limit' has a wrong offset!");
static_assert(offsetof(FCARewardSetData, M_current_amounts_used) == 0x000038, "Member 'FCARewardSetData::M_current_amounts_used' has a wrong offset!");

// ScriptStruct keaton.CARewardSourceToDistributionCache
// 0x0078 (0x0078 - 0x0000)
struct FCARewardSourceToDistributionCache final
{
public:
	class AActor*                                 M_reward_source;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCARewardDistributionTableEntry        M_reward_distribution;                             // 0x0008(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FCARewardDistributionGroupingToOwnerData> M_reward_distribution_grouping;                    // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCARewardSetData                       M_reward_set;                                      // 0x0030(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARewardSourceToDistributionCache) == 0x000008, "Wrong alignment on FCARewardSourceToDistributionCache");
static_assert(sizeof(FCARewardSourceToDistributionCache) == 0x000078, "Wrong size on FCARewardSourceToDistributionCache");
static_assert(offsetof(FCARewardSourceToDistributionCache, M_reward_source) == 0x000000, "Member 'FCARewardSourceToDistributionCache::M_reward_source' has a wrong offset!");
static_assert(offsetof(FCARewardSourceToDistributionCache, M_reward_distribution) == 0x000008, "Member 'FCARewardSourceToDistributionCache::M_reward_distribution' has a wrong offset!");
static_assert(offsetof(FCARewardSourceToDistributionCache, M_reward_distribution_grouping) == 0x000020, "Member 'FCARewardSourceToDistributionCache::M_reward_distribution_grouping' has a wrong offset!");
static_assert(offsetof(FCARewardSourceToDistributionCache, M_reward_set) == 0x000030, "Member 'FCARewardSourceToDistributionCache::M_reward_set' has a wrong offset!");

// ScriptStruct keaton.CAFSMQueueItem
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FCAFSMQueueItem final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAFSMQueueItem) == 0x000008, "Wrong alignment on FCAFSMQueueItem");
static_assert(sizeof(FCAFSMQueueItem) == 0x000048, "Wrong size on FCAFSMQueueItem");

// ScriptStruct keaton.CACharacterSignifianceProperties
// 0x0008 (0x0008 - 0x0000)
struct FCACharacterSignifianceProperties final
{
public:
	ECharacterSignificanceLevel                   M_significance;                                    // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_movement_simulation_rate;                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACharacterSignifianceProperties) == 0x000004, "Wrong alignment on FCACharacterSignifianceProperties");
static_assert(sizeof(FCACharacterSignifianceProperties) == 0x000008, "Wrong size on FCACharacterSignifianceProperties");
static_assert(offsetof(FCACharacterSignifianceProperties, M_significance) == 0x000000, "Member 'FCACharacterSignifianceProperties::M_significance' has a wrong offset!");
static_assert(offsetof(FCACharacterSignifianceProperties, M_movement_simulation_rate) == 0x000004, "Member 'FCACharacterSignifianceProperties::M_movement_simulation_rate' has a wrong offset!");

// ScriptStruct keaton.CAPoolData
// 0x0040 (0x0040 - 0x0000)
struct FCAPoolData final
{
public:
	class FString                                 M_ship_name;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_game_mode_id;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_create_new_npc_when_pool_empty;                  // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_set_pool_size_manually;                          // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_pool_size;                                       // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_auto_set_pool_buffer_size;                       // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_pool_buffer_size;                                // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCARequiredPoolSizeData>        M_pool_size_data;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPoolData) == 0x000008, "Wrong alignment on FCAPoolData");
static_assert(sizeof(FCAPoolData) == 0x000040, "Wrong size on FCAPoolData");
static_assert(offsetof(FCAPoolData, M_ship_name) == 0x000000, "Member 'FCAPoolData::M_ship_name' has a wrong offset!");
static_assert(offsetof(FCAPoolData, M_game_mode_id) == 0x000010, "Member 'FCAPoolData::M_game_mode_id' has a wrong offset!");
static_assert(offsetof(FCAPoolData, M_create_new_npc_when_pool_empty) == 0x000020, "Member 'FCAPoolData::M_create_new_npc_when_pool_empty' has a wrong offset!");
static_assert(offsetof(FCAPoolData, M_set_pool_size_manually) == 0x000021, "Member 'FCAPoolData::M_set_pool_size_manually' has a wrong offset!");
static_assert(offsetof(FCAPoolData, M_pool_size) == 0x000024, "Member 'FCAPoolData::M_pool_size' has a wrong offset!");
static_assert(offsetof(FCAPoolData, M_auto_set_pool_buffer_size) == 0x000028, "Member 'FCAPoolData::M_auto_set_pool_buffer_size' has a wrong offset!");
static_assert(offsetof(FCAPoolData, M_pool_buffer_size) == 0x00002C, "Member 'FCAPoolData::M_pool_buffer_size' has a wrong offset!");
static_assert(offsetof(FCAPoolData, M_pool_size_data) == 0x000030, "Member 'FCAPoolData::M_pool_size_data' has a wrong offset!");

// ScriptStruct keaton.CASpawnNPCTypeLookup
// 0x00A0 (0x00A8 - 0x0008)
struct FCASpawnNPCTypeLookup final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0xC];                                        // 0x0008(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	ECANPCType                                    M_npc_type;                                        // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFeatureObjectPtr                      NPCAsset;                                          // 0x0018(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_set_pool_size_data_manually;                     // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_pool_size;                                       // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAPoolData>                    M_pool_data;                                       // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_create_new_npc_when_pool_empty;                  // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_spawn_priority;                                  // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_spawn_token_value;                               // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCASpawnNPCTypeLookup) == 0x000008, "Wrong alignment on FCASpawnNPCTypeLookup");
static_assert(sizeof(FCASpawnNPCTypeLookup) == 0x0000A8, "Wrong size on FCASpawnNPCTypeLookup");
static_assert(offsetof(FCASpawnNPCTypeLookup, M_npc_type) == 0x000014, "Member 'FCASpawnNPCTypeLookup::M_npc_type' has a wrong offset!");
static_assert(offsetof(FCASpawnNPCTypeLookup, NPCAsset) == 0x000018, "Member 'FCASpawnNPCTypeLookup::NPCAsset' has a wrong offset!");
static_assert(offsetof(FCASpawnNPCTypeLookup, M_set_pool_size_data_manually) == 0x000080, "Member 'FCASpawnNPCTypeLookup::M_set_pool_size_data_manually' has a wrong offset!");
static_assert(offsetof(FCASpawnNPCTypeLookup, M_pool_size) == 0x000084, "Member 'FCASpawnNPCTypeLookup::M_pool_size' has a wrong offset!");
static_assert(offsetof(FCASpawnNPCTypeLookup, M_pool_data) == 0x000088, "Member 'FCASpawnNPCTypeLookup::M_pool_data' has a wrong offset!");
static_assert(offsetof(FCASpawnNPCTypeLookup, M_create_new_npc_when_pool_empty) == 0x000098, "Member 'FCASpawnNPCTypeLookup::M_create_new_npc_when_pool_empty' has a wrong offset!");
static_assert(offsetof(FCASpawnNPCTypeLookup, M_spawn_priority) == 0x00009C, "Member 'FCASpawnNPCTypeLookup::M_spawn_priority' has a wrong offset!");
static_assert(offsetof(FCASpawnNPCTypeLookup, M_spawn_token_value) == 0x0000A0, "Member 'FCASpawnNPCTypeLookup::M_spawn_token_value' has a wrong offset!");

// ScriptStruct keaton.DownedLocomotionState
// 0x0070 (0x0070 - 0x0000)
struct FDownedLocomotionState final
{
public:
	float                                         Heading_delta;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Current_heading;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Current_turn_rate;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aiming_yaw;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Turn_to_move_ratio;                                // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Ground_point;                                      // 0x0014(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Ground_hand_point;                                 // 0x0020(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Ground_normal;                                     // 0x002C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Ground_sample_offset;                              // 0x0038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Local_velocity;                                    // 0x0044(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Slope_rotator;                                     // 0x0050(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Hand_rotator;                                      // 0x005C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Have_ground;                                       // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_downed;                                         // 0x0069(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Current_turn_rate_multiplier;                      // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDownedLocomotionState) == 0x000004, "Wrong alignment on FDownedLocomotionState");
static_assert(sizeof(FDownedLocomotionState) == 0x000070, "Wrong size on FDownedLocomotionState");
static_assert(offsetof(FDownedLocomotionState, Heading_delta) == 0x000000, "Member 'FDownedLocomotionState::Heading_delta' has a wrong offset!");
static_assert(offsetof(FDownedLocomotionState, Current_heading) == 0x000004, "Member 'FDownedLocomotionState::Current_heading' has a wrong offset!");
static_assert(offsetof(FDownedLocomotionState, Current_turn_rate) == 0x000008, "Member 'FDownedLocomotionState::Current_turn_rate' has a wrong offset!");
static_assert(offsetof(FDownedLocomotionState, Aiming_yaw) == 0x00000C, "Member 'FDownedLocomotionState::Aiming_yaw' has a wrong offset!");
static_assert(offsetof(FDownedLocomotionState, Turn_to_move_ratio) == 0x000010, "Member 'FDownedLocomotionState::Turn_to_move_ratio' has a wrong offset!");
static_assert(offsetof(FDownedLocomotionState, Ground_point) == 0x000014, "Member 'FDownedLocomotionState::Ground_point' has a wrong offset!");
static_assert(offsetof(FDownedLocomotionState, Ground_hand_point) == 0x000020, "Member 'FDownedLocomotionState::Ground_hand_point' has a wrong offset!");
static_assert(offsetof(FDownedLocomotionState, Ground_normal) == 0x00002C, "Member 'FDownedLocomotionState::Ground_normal' has a wrong offset!");
static_assert(offsetof(FDownedLocomotionState, Ground_sample_offset) == 0x000038, "Member 'FDownedLocomotionState::Ground_sample_offset' has a wrong offset!");
static_assert(offsetof(FDownedLocomotionState, Local_velocity) == 0x000044, "Member 'FDownedLocomotionState::Local_velocity' has a wrong offset!");
static_assert(offsetof(FDownedLocomotionState, Slope_rotator) == 0x000050, "Member 'FDownedLocomotionState::Slope_rotator' has a wrong offset!");
static_assert(offsetof(FDownedLocomotionState, Hand_rotator) == 0x00005C, "Member 'FDownedLocomotionState::Hand_rotator' has a wrong offset!");
static_assert(offsetof(FDownedLocomotionState, Have_ground) == 0x000068, "Member 'FDownedLocomotionState::Have_ground' has a wrong offset!");
static_assert(offsetof(FDownedLocomotionState, Is_downed) == 0x000069, "Member 'FDownedLocomotionState::Is_downed' has a wrong offset!");
static_assert(offsetof(FDownedLocomotionState, Current_turn_rate_multiplier) == 0x00006C, "Member 'FDownedLocomotionState::Current_turn_rate_multiplier' has a wrong offset!");

// ScriptStruct keaton.CAFoamActorConfiguration
// 0x00A8 (0x00B0 - 0x0008)
struct FCAFoamActorConfiguration final : public FTableRowBase
{
public:
	TSubclassOf<class AActor>                     M_FoamActorClass;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_CollisionProfileName;                            // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            M_HealthEffect;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_HealthDataTag;                                   // 0x0028(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_KillTag;                                         // 0x0034(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_HealthMagnitude;                                 // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            M_DamageEffect;                                    // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            M_SelfDegradationDamageEffect;                     // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_BlobDamageThreshold;                             // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_FoamDestructionPercentageThreshold;              // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_FoamScale;                                       // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_FormingTime;                                     // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_HardeningTime;                                   // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_RadiusMinimumSeparationPercentage;               // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_AllowFriendlyFire;                               // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_CanTransferToOtherActors;                        // 0x0071(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_CanTransferToOtherFoamWhileForming;              // 0x0072(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_FullySupported;                                  // 0x0073(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_BlockFoamOnSpaceCheck;                           // 0x0074(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_FormAllBlobsAtSameTime;                          // 0x0075(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_ShouldFormFoamInstantly;                         // 0x0076(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IgnoreAlignmentOwnerForLOSChecks;                // 0x0077(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_AttachFoamSpawnedToAlignmentComponentOwner;      // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        M_BlobSpawnLocations;                              // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                M_AdjacentActorOffset;                             // 0x0090(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_allow_new_structures_on_max_health;              // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_allow_vertical_on_horizontal;                    // 0x009D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_allow_horizontal_on_vertical;                    // 0x009E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F[0x1];                                       // 0x009F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAAlignmentPoint>              M_alignment_points;                                // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFoamActorConfiguration) == 0x000008, "Wrong alignment on FCAFoamActorConfiguration");
static_assert(sizeof(FCAFoamActorConfiguration) == 0x0000B0, "Wrong size on FCAFoamActorConfiguration");
static_assert(offsetof(FCAFoamActorConfiguration, M_FoamActorClass) == 0x000008, "Member 'FCAFoamActorConfiguration::M_FoamActorClass' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_CollisionProfileName) == 0x000010, "Member 'FCAFoamActorConfiguration::M_CollisionProfileName' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_HealthEffect) == 0x000020, "Member 'FCAFoamActorConfiguration::M_HealthEffect' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_HealthDataTag) == 0x000028, "Member 'FCAFoamActorConfiguration::M_HealthDataTag' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_KillTag) == 0x000034, "Member 'FCAFoamActorConfiguration::M_KillTag' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_HealthMagnitude) == 0x000040, "Member 'FCAFoamActorConfiguration::M_HealthMagnitude' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_DamageEffect) == 0x000048, "Member 'FCAFoamActorConfiguration::M_DamageEffect' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_SelfDegradationDamageEffect) == 0x000050, "Member 'FCAFoamActorConfiguration::M_SelfDegradationDamageEffect' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_BlobDamageThreshold) == 0x000058, "Member 'FCAFoamActorConfiguration::M_BlobDamageThreshold' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_FoamDestructionPercentageThreshold) == 0x00005C, "Member 'FCAFoamActorConfiguration::M_FoamDestructionPercentageThreshold' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_FoamScale) == 0x000060, "Member 'FCAFoamActorConfiguration::M_FoamScale' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_FormingTime) == 0x000064, "Member 'FCAFoamActorConfiguration::M_FormingTime' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_HardeningTime) == 0x000068, "Member 'FCAFoamActorConfiguration::M_HardeningTime' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_RadiusMinimumSeparationPercentage) == 0x00006C, "Member 'FCAFoamActorConfiguration::M_RadiusMinimumSeparationPercentage' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_AllowFriendlyFire) == 0x000070, "Member 'FCAFoamActorConfiguration::M_AllowFriendlyFire' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_CanTransferToOtherActors) == 0x000071, "Member 'FCAFoamActorConfiguration::M_CanTransferToOtherActors' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_CanTransferToOtherFoamWhileForming) == 0x000072, "Member 'FCAFoamActorConfiguration::M_CanTransferToOtherFoamWhileForming' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_FullySupported) == 0x000073, "Member 'FCAFoamActorConfiguration::M_FullySupported' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_BlockFoamOnSpaceCheck) == 0x000074, "Member 'FCAFoamActorConfiguration::M_BlockFoamOnSpaceCheck' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_FormAllBlobsAtSameTime) == 0x000075, "Member 'FCAFoamActorConfiguration::M_FormAllBlobsAtSameTime' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_ShouldFormFoamInstantly) == 0x000076, "Member 'FCAFoamActorConfiguration::M_ShouldFormFoamInstantly' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_IgnoreAlignmentOwnerForLOSChecks) == 0x000077, "Member 'FCAFoamActorConfiguration::M_IgnoreAlignmentOwnerForLOSChecks' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_AttachFoamSpawnedToAlignmentComponentOwner) == 0x000078, "Member 'FCAFoamActorConfiguration::M_AttachFoamSpawnedToAlignmentComponentOwner' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_BlobSpawnLocations) == 0x000080, "Member 'FCAFoamActorConfiguration::M_BlobSpawnLocations' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_AdjacentActorOffset) == 0x000090, "Member 'FCAFoamActorConfiguration::M_AdjacentActorOffset' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_allow_new_structures_on_max_health) == 0x00009C, "Member 'FCAFoamActorConfiguration::M_allow_new_structures_on_max_health' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_allow_vertical_on_horizontal) == 0x00009D, "Member 'FCAFoamActorConfiguration::M_allow_vertical_on_horizontal' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_allow_horizontal_on_vertical) == 0x00009E, "Member 'FCAFoamActorConfiguration::M_allow_horizontal_on_vertical' has a wrong offset!");
static_assert(offsetof(FCAFoamActorConfiguration, M_alignment_points) == 0x0000A0, "Member 'FCAFoamActorConfiguration::M_alignment_points' has a wrong offset!");

// ScriptStruct keaton.CAMovementModeAnalyticsData
// 0x0008 (0x0008 - 0x0000)
struct FCAMovementModeAnalyticsData final
{
public:
	float                                         M_movement_time;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_movement_distance;                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMovementModeAnalyticsData) == 0x000004, "Wrong alignment on FCAMovementModeAnalyticsData");
static_assert(sizeof(FCAMovementModeAnalyticsData) == 0x000008, "Wrong size on FCAMovementModeAnalyticsData");
static_assert(offsetof(FCAMovementModeAnalyticsData, M_movement_time) == 0x000000, "Member 'FCAMovementModeAnalyticsData::M_movement_time' has a wrong offset!");
static_assert(offsetof(FCAMovementModeAnalyticsData, M_movement_distance) == 0x000004, "Member 'FCAMovementModeAnalyticsData::M_movement_distance' has a wrong offset!");

// ScriptStruct keaton.CANPCTypeToName
// 0x0038 (0x0038 - 0x0000)
struct FCANPCTypeToName final
{
public:
	ECANPCType                                    M_npc_type;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_npc_name_loc_key;                                // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANPCTypeToName) == 0x000008, "Wrong alignment on FCANPCTypeToName");
static_assert(sizeof(FCANPCTypeToName) == 0x000038, "Wrong size on FCANPCTypeToName");
static_assert(offsetof(FCANPCTypeToName, M_npc_type) == 0x000000, "Member 'FCANPCTypeToName::M_npc_type' has a wrong offset!");
static_assert(offsetof(FCANPCTypeToName, M_npc_name_loc_key) == 0x000008, "Member 'FCANPCTypeToName::M_npc_name_loc_key' has a wrong offset!");

// ScriptStruct keaton.CAFrontendGameModeAppearanceTableRow
// 0x0058 (0x0060 - 0x0008)
struct FCAFrontendGameModeAppearanceTableRow final : public FTableRowBase
{
public:
	ECAGameModeType                               M_associated_type;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      M_icon_material;                                   // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           M_primary_color;                                   // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           M_secondary_color;                                 // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFrontendGameModeAppearanceTableRow) == 0x000008, "Wrong alignment on FCAFrontendGameModeAppearanceTableRow");
static_assert(sizeof(FCAFrontendGameModeAppearanceTableRow) == 0x000060, "Wrong size on FCAFrontendGameModeAppearanceTableRow");
static_assert(offsetof(FCAFrontendGameModeAppearanceTableRow, M_associated_type) == 0x000008, "Member 'FCAFrontendGameModeAppearanceTableRow::M_associated_type' has a wrong offset!");
static_assert(offsetof(FCAFrontendGameModeAppearanceTableRow, M_icon_material) == 0x000010, "Member 'FCAFrontendGameModeAppearanceTableRow::M_icon_material' has a wrong offset!");
static_assert(offsetof(FCAFrontendGameModeAppearanceTableRow, M_primary_color) == 0x000040, "Member 'FCAFrontendGameModeAppearanceTableRow::M_primary_color' has a wrong offset!");
static_assert(offsetof(FCAFrontendGameModeAppearanceTableRow, M_secondary_color) == 0x000050, "Member 'FCAFrontendGameModeAppearanceTableRow::M_secondary_color' has a wrong offset!");

// ScriptStruct keaton.CAUIWeaponStats
// 0x0014 (0x0014 - 0x0000)
struct FCAUIWeaponStats final
{
public:
	float                                         M_damage_per_shot;                                 // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_accuracy;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fire_rate;                                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_recoil;                                          // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_clip_size;                                       // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAUIWeaponStats) == 0x000004, "Wrong alignment on FCAUIWeaponStats");
static_assert(sizeof(FCAUIWeaponStats) == 0x000014, "Wrong size on FCAUIWeaponStats");
static_assert(offsetof(FCAUIWeaponStats, M_damage_per_shot) == 0x000000, "Member 'FCAUIWeaponStats::M_damage_per_shot' has a wrong offset!");
static_assert(offsetof(FCAUIWeaponStats, M_accuracy) == 0x000004, "Member 'FCAUIWeaponStats::M_accuracy' has a wrong offset!");
static_assert(offsetof(FCAUIWeaponStats, M_fire_rate) == 0x000008, "Member 'FCAUIWeaponStats::M_fire_rate' has a wrong offset!");
static_assert(offsetof(FCAUIWeaponStats, M_recoil) == 0x00000C, "Member 'FCAUIWeaponStats::M_recoil' has a wrong offset!");
static_assert(offsetof(FCAUIWeaponStats, M_clip_size) == 0x000010, "Member 'FCAUIWeaponStats::M_clip_size' has a wrong offset!");

// ScriptStruct keaton.PadMovement
// 0x001C (0x001C - 0x0000)
struct FPadMovement final
{
public:
	float                                         M_speed;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_acceleration_mode;                               // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_acceleration;                                    // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_whip;                                        // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_whip_delay;                                      // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_whip_ramp_up_time;                               // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_whip_speed;                                      // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPadMovement) == 0x000004, "Wrong alignment on FPadMovement");
static_assert(sizeof(FPadMovement) == 0x00001C, "Wrong size on FPadMovement");
static_assert(offsetof(FPadMovement, M_speed) == 0x000000, "Member 'FPadMovement::M_speed' has a wrong offset!");
static_assert(offsetof(FPadMovement, M_acceleration_mode) == 0x000004, "Member 'FPadMovement::M_acceleration_mode' has a wrong offset!");
static_assert(offsetof(FPadMovement, M_acceleration) == 0x000008, "Member 'FPadMovement::M_acceleration' has a wrong offset!");
static_assert(offsetof(FPadMovement, M_use_whip) == 0x00000C, "Member 'FPadMovement::M_use_whip' has a wrong offset!");
static_assert(offsetof(FPadMovement, M_whip_delay) == 0x000010, "Member 'FPadMovement::M_whip_delay' has a wrong offset!");
static_assert(offsetof(FPadMovement, M_whip_ramp_up_time) == 0x000014, "Member 'FPadMovement::M_whip_ramp_up_time' has a wrong offset!");
static_assert(offsetof(FPadMovement, M_whip_speed) == 0x000018, "Member 'FPadMovement::M_whip_speed' has a wrong offset!");

// ScriptStruct keaton.PadMovementPair
// 0x003C (0x003C - 0x0000)
struct FPadMovementPair final
{
public:
	struct FPadMovement                           M_yaw;                                             // 0x0000(0x001C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPadMovement                           M_pitch;                                           // 0x001C(0x001C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_zg_mpy;                                          // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPadMovementPair) == 0x000004, "Wrong alignment on FPadMovementPair");
static_assert(sizeof(FPadMovementPair) == 0x00003C, "Wrong size on FPadMovementPair");
static_assert(offsetof(FPadMovementPair, M_yaw) == 0x000000, "Member 'FPadMovementPair::M_yaw' has a wrong offset!");
static_assert(offsetof(FPadMovementPair, M_pitch) == 0x00001C, "Member 'FPadMovementPair::M_pitch' has a wrong offset!");
static_assert(offsetof(FPadMovementPair, M_zg_mpy) == 0x000038, "Member 'FPadMovementPair::M_zg_mpy' has a wrong offset!");

// ScriptStruct keaton.GamepadSetting
// 0x00FC (0x00FC - 0x0000)
struct FGamepadSetting final
{
public:
	int32                                         SprintStyle;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPadDeadZone                           M_camera_dead_zone;                                // 0x0004(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPadDeadZone                           M_movement_dead_zone;                              // 0x0014(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_curve_factor;                                    // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPadMovementPair                       M_movement_standard;                               // 0x0028(0x003C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPadMovementPair                       M_movement_ADS;                                    // 0x0064(0x003C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPadMovementPair                       M_movement_sprint;                                 // 0x00A0(0x003C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_aim_assist_enabled;                              // 0x00DC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bullet_magnetism_enabled;                        // 0x00DD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE[0x2];                                       // 0x00DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_aim_assist_friction_player;                      // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_aim_assist_friction_other;                       // 0x00E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_aim_assist_rotation_player;                      // 0x00E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_aim_assist_rotation_other;                       // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_left_inverted;                                   // 0x00F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_right_inverted;                                  // 0x00F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RumbleOverride;                                    // 0x00F2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RumbleCategory_Abilities;                          // 0x00F3(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RumbleCategory_Damage;                             // 0x00F4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RumbleCategory_Environment;                        // 0x00F5(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RumbleCategory_Gunplay;                            // 0x00F6(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RumbleCategory_Interactions;                       // 0x00F7(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RumbleCategory_Movement;                           // 0x00F8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGamepadSetting) == 0x000004, "Wrong alignment on FGamepadSetting");
static_assert(sizeof(FGamepadSetting) == 0x0000FC, "Wrong size on FGamepadSetting");
static_assert(offsetof(FGamepadSetting, SprintStyle) == 0x000000, "Member 'FGamepadSetting::SprintStyle' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, M_camera_dead_zone) == 0x000004, "Member 'FGamepadSetting::M_camera_dead_zone' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, M_movement_dead_zone) == 0x000014, "Member 'FGamepadSetting::M_movement_dead_zone' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, M_curve_factor) == 0x000024, "Member 'FGamepadSetting::M_curve_factor' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, M_movement_standard) == 0x000028, "Member 'FGamepadSetting::M_movement_standard' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, M_movement_ADS) == 0x000064, "Member 'FGamepadSetting::M_movement_ADS' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, M_movement_sprint) == 0x0000A0, "Member 'FGamepadSetting::M_movement_sprint' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, M_aim_assist_enabled) == 0x0000DC, "Member 'FGamepadSetting::M_aim_assist_enabled' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, M_bullet_magnetism_enabled) == 0x0000DD, "Member 'FGamepadSetting::M_bullet_magnetism_enabled' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, M_aim_assist_friction_player) == 0x0000E0, "Member 'FGamepadSetting::M_aim_assist_friction_player' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, M_aim_assist_friction_other) == 0x0000E4, "Member 'FGamepadSetting::M_aim_assist_friction_other' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, M_aim_assist_rotation_player) == 0x0000E8, "Member 'FGamepadSetting::M_aim_assist_rotation_player' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, M_aim_assist_rotation_other) == 0x0000EC, "Member 'FGamepadSetting::M_aim_assist_rotation_other' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, M_left_inverted) == 0x0000F0, "Member 'FGamepadSetting::M_left_inverted' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, M_right_inverted) == 0x0000F1, "Member 'FGamepadSetting::M_right_inverted' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, RumbleOverride) == 0x0000F2, "Member 'FGamepadSetting::RumbleOverride' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, RumbleCategory_Abilities) == 0x0000F3, "Member 'FGamepadSetting::RumbleCategory_Abilities' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, RumbleCategory_Damage) == 0x0000F4, "Member 'FGamepadSetting::RumbleCategory_Damage' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, RumbleCategory_Environment) == 0x0000F5, "Member 'FGamepadSetting::RumbleCategory_Environment' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, RumbleCategory_Gunplay) == 0x0000F6, "Member 'FGamepadSetting::RumbleCategory_Gunplay' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, RumbleCategory_Interactions) == 0x0000F7, "Member 'FGamepadSetting::RumbleCategory_Interactions' has a wrong offset!");
static_assert(offsetof(FGamepadSetting, RumbleCategory_Movement) == 0x0000F8, "Member 'FGamepadSetting::RumbleCategory_Movement' has a wrong offset!");

// ScriptStruct keaton.CASectionWidgetArray
// 0x0010 (0x0010 - 0x0000)
struct FCASectionWidgetArray final
{
public:
	TArray<class UCAHUDHideableWidget*>           M_section_widgets;                                 // 0x0000(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASectionWidgetArray) == 0x000008, "Wrong alignment on FCASectionWidgetArray");
static_assert(sizeof(FCASectionWidgetArray) == 0x000010, "Wrong size on FCASectionWidgetArray");
static_assert(offsetof(FCASectionWidgetArray, M_section_widgets) == 0x000000, "Member 'FCASectionWidgetArray::M_section_widgets' has a wrong offset!");

// ScriptStruct keaton.CAScoreThresholdUIData
// 0x0068 (0x0070 - 0x0008)
struct FCAScoreThresholdUIData final : public FTableRowBase
{
public:
	int32                                         M_threshold_index;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_display_text;                                    // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_icon;                                            // 0x0040(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAScoreThresholdUIData) == 0x000008, "Wrong alignment on FCAScoreThresholdUIData");
static_assert(sizeof(FCAScoreThresholdUIData) == 0x000070, "Wrong size on FCAScoreThresholdUIData");
static_assert(offsetof(FCAScoreThresholdUIData, M_threshold_index) == 0x000008, "Member 'FCAScoreThresholdUIData::M_threshold_index' has a wrong offset!");
static_assert(offsetof(FCAScoreThresholdUIData, M_display_text) == 0x000010, "Member 'FCAScoreThresholdUIData::M_display_text' has a wrong offset!");
static_assert(offsetof(FCAScoreThresholdUIData, M_icon) == 0x000040, "Member 'FCAScoreThresholdUIData::M_icon' has a wrong offset!");

// ScriptStruct keaton.CAStatCategoryUIData
// 0x0040 (0x0040 - 0x0000)
struct FCAStatCategoryUIData final
{
public:
	struct FCAText                                M_category_label;                                  // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_reward_type_categories;                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAStatCategoryUIData) == 0x000008, "Wrong alignment on FCAStatCategoryUIData");
static_assert(sizeof(FCAStatCategoryUIData) == 0x000040, "Wrong size on FCAStatCategoryUIData");
static_assert(offsetof(FCAStatCategoryUIData, M_category_label) == 0x000000, "Member 'FCAStatCategoryUIData::M_category_label' has a wrong offset!");
static_assert(offsetof(FCAStatCategoryUIData, M_reward_type_categories) == 0x000030, "Member 'FCAStatCategoryUIData::M_reward_type_categories' has a wrong offset!");

// ScriptStruct keaton.CALocTabNameToGuidTableRow
// 0x0010 (0x0018 - 0x0008)
struct FCALocTabNameToGuidTableRow final : public FTableRowBase
{
public:
	class FString                                 M_table_guid;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALocTabNameToGuidTableRow) == 0x000008, "Wrong alignment on FCALocTabNameToGuidTableRow");
static_assert(sizeof(FCALocTabNameToGuidTableRow) == 0x000018, "Wrong size on FCALocTabNameToGuidTableRow");
static_assert(offsetof(FCALocTabNameToGuidTableRow, M_table_guid) == 0x000008, "Member 'FCALocTabNameToGuidTableRow::M_table_guid' has a wrong offset!");

// ScriptStruct keaton.CADialogueLogInfo
// 0x0030 (0x0030 - 0x0000)
struct FCADialogueLogInfo final
{
public:
	class FString                                 M_rule_name;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_speaker_name;                                    // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_response_name;                                   // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADialogueLogInfo) == 0x000008, "Wrong alignment on FCADialogueLogInfo");
static_assert(sizeof(FCADialogueLogInfo) == 0x000030, "Wrong size on FCADialogueLogInfo");
static_assert(offsetof(FCADialogueLogInfo, M_rule_name) == 0x000000, "Member 'FCADialogueLogInfo::M_rule_name' has a wrong offset!");
static_assert(offsetof(FCADialogueLogInfo, M_speaker_name) == 0x000010, "Member 'FCADialogueLogInfo::M_speaker_name' has a wrong offset!");
static_assert(offsetof(FCADialogueLogInfo, M_response_name) == 0x000020, "Member 'FCADialogueLogInfo::M_response_name' has a wrong offset!");

// ScriptStruct keaton.CAHUDScreenLockDataTableRow
// 0x0008 (0x0010 - 0x0008)
struct FCAHUDScreenLockDataTableRow final : public FTableRowBase
{
public:
	TSubclassOf<class UCAHUDGameplayEffect>       M_screen_lock_gameplay_effect;                     // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDScreenLockDataTableRow) == 0x000008, "Wrong alignment on FCAHUDScreenLockDataTableRow");
static_assert(sizeof(FCAHUDScreenLockDataTableRow) == 0x000010, "Wrong size on FCAHUDScreenLockDataTableRow");
static_assert(offsetof(FCAHUDScreenLockDataTableRow, M_screen_lock_gameplay_effect) == 0x000008, "Member 'FCAHUDScreenLockDataTableRow::M_screen_lock_gameplay_effect' has a wrong offset!");

// ScriptStruct keaton.CALootContainerCount
// 0x0010 (0x0010 - 0x0000)
struct FCALootContainerCount final
{
public:
	class FName                                   Container;                                         // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALootContainerCount) == 0x000004, "Wrong alignment on FCALootContainerCount");
static_assert(sizeof(FCALootContainerCount) == 0x000010, "Wrong size on FCALootContainerCount");
static_assert(offsetof(FCALootContainerCount, Container) == 0x000000, "Member 'FCALootContainerCount::Container' has a wrong offset!");
static_assert(offsetof(FCALootContainerCount, Count) == 0x00000C, "Member 'FCALootContainerCount::Count' has a wrong offset!");

// ScriptStruct keaton.SysSensorCallbackFunction
// 0x001C (0x001C - 0x0000)
struct FSysSensorCallbackFunction final
{
public:
	TDelegate<void(const struct FSysSensorCallbackDataBase& Sensor_callback_data)> M_callback;                                        // 0x0000(0x0014)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_blocking;                                        // 0x0014(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_expiry_game_time;                                // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSysSensorCallbackFunction) == 0x000004, "Wrong alignment on FSysSensorCallbackFunction");
static_assert(sizeof(FSysSensorCallbackFunction) == 0x00001C, "Wrong size on FSysSensorCallbackFunction");
static_assert(offsetof(FSysSensorCallbackFunction, M_callback) == 0x000000, "Member 'FSysSensorCallbackFunction::M_callback' has a wrong offset!");
static_assert(offsetof(FSysSensorCallbackFunction, M_blocking) == 0x000014, "Member 'FSysSensorCallbackFunction::M_blocking' has a wrong offset!");
static_assert(offsetof(FSysSensorCallbackFunction, M_expiry_game_time) == 0x000018, "Member 'FSysSensorCallbackFunction::M_expiry_game_time' has a wrong offset!");

// ScriptStruct keaton.CAHUDScreenManagementDataTableRow
// 0x0010 (0x0018 - 0x0008)
struct FCAHUDScreenManagementDataTableRow final : public FTableRowBase
{
public:
	TSubclassOf<class UCAHUDGameplayEffect>       M_screen_gameplay_effect_class;                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCAHUDBaseWidget>           M_screen_widget_class;                             // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDScreenManagementDataTableRow) == 0x000008, "Wrong alignment on FCAHUDScreenManagementDataTableRow");
static_assert(sizeof(FCAHUDScreenManagementDataTableRow) == 0x000018, "Wrong size on FCAHUDScreenManagementDataTableRow");
static_assert(offsetof(FCAHUDScreenManagementDataTableRow, M_screen_gameplay_effect_class) == 0x000008, "Member 'FCAHUDScreenManagementDataTableRow::M_screen_gameplay_effect_class' has a wrong offset!");
static_assert(offsetof(FCAHUDScreenManagementDataTableRow, M_screen_widget_class) == 0x000010, "Member 'FCAHUDScreenManagementDataTableRow::M_screen_widget_class' has a wrong offset!");

// ScriptStruct keaton.CALockedOnTargetData
// 0x000C (0x000C - 0x0000)
struct FCALockedOnTargetData final
{
public:
	float                                         M_TimeRemainingUntilRemoval;                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  M_actor;                                           // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALockedOnTargetData) == 0x000004, "Wrong alignment on FCALockedOnTargetData");
static_assert(sizeof(FCALockedOnTargetData) == 0x00000C, "Wrong size on FCALockedOnTargetData");
static_assert(offsetof(FCALockedOnTargetData, M_TimeRemainingUntilRemoval) == 0x000000, "Member 'FCALockedOnTargetData::M_TimeRemainingUntilRemoval' has a wrong offset!");
static_assert(offsetof(FCALockedOnTargetData, M_actor) == 0x000004, "Member 'FCALockedOnTargetData::M_actor' has a wrong offset!");

// ScriptStruct keaton.CAOnboardingMessageTableRow
// 0x00F0 (0x00F8 - 0x0008)
struct FCAOnboardingMessageTableRow final : public FTableRowBase
{
public:
	float                                         M_close_popup_time;                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_title_loc_key;                                   // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   M_title_not_localised;                             // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_message_loc_key;                                 // 0x0058(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_message_loc_key_controller;                      // 0x0088(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   M_message_not_localised;                           // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAHUDInputData>                M_icon_data_array;                                 // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAHUDInputData>                M_icon_data_array_controller;                      // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             M_image;                                           // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAOnboardingMessageTableRow) == 0x000008, "Wrong alignment on FCAOnboardingMessageTableRow");
static_assert(sizeof(FCAOnboardingMessageTableRow) == 0x0000F8, "Wrong size on FCAOnboardingMessageTableRow");
static_assert(offsetof(FCAOnboardingMessageTableRow, M_close_popup_time) == 0x000008, "Member 'FCAOnboardingMessageTableRow::M_close_popup_time' has a wrong offset!");
static_assert(offsetof(FCAOnboardingMessageTableRow, M_title_loc_key) == 0x000010, "Member 'FCAOnboardingMessageTableRow::M_title_loc_key' has a wrong offset!");
static_assert(offsetof(FCAOnboardingMessageTableRow, M_title_not_localised) == 0x000040, "Member 'FCAOnboardingMessageTableRow::M_title_not_localised' has a wrong offset!");
static_assert(offsetof(FCAOnboardingMessageTableRow, M_message_loc_key) == 0x000058, "Member 'FCAOnboardingMessageTableRow::M_message_loc_key' has a wrong offset!");
static_assert(offsetof(FCAOnboardingMessageTableRow, M_message_loc_key_controller) == 0x000088, "Member 'FCAOnboardingMessageTableRow::M_message_loc_key_controller' has a wrong offset!");
static_assert(offsetof(FCAOnboardingMessageTableRow, M_message_not_localised) == 0x0000B8, "Member 'FCAOnboardingMessageTableRow::M_message_not_localised' has a wrong offset!");
static_assert(offsetof(FCAOnboardingMessageTableRow, M_icon_data_array) == 0x0000D0, "Member 'FCAOnboardingMessageTableRow::M_icon_data_array' has a wrong offset!");
static_assert(offsetof(FCAOnboardingMessageTableRow, M_icon_data_array_controller) == 0x0000E0, "Member 'FCAOnboardingMessageTableRow::M_icon_data_array_controller' has a wrong offset!");
static_assert(offsetof(FCAOnboardingMessageTableRow, M_image) == 0x0000F0, "Member 'FCAOnboardingMessageTableRow::M_image' has a wrong offset!");

// ScriptStruct keaton.CAGameplayEffectContainerSpec
// 0x0038 (0x0038 - 0x0000)
struct FCAGameplayEffectContainerSpec final
{
public:
	struct FGameplayAbilityTargetDataHandle       M_target_data;                                     // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectSpecHandle>      M_target_gameplay_effect_specs;                    // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAGameplayEffectContainerSpec) == 0x000008, "Wrong alignment on FCAGameplayEffectContainerSpec");
static_assert(sizeof(FCAGameplayEffectContainerSpec) == 0x000038, "Wrong size on FCAGameplayEffectContainerSpec");
static_assert(offsetof(FCAGameplayEffectContainerSpec, M_target_data) == 0x000000, "Member 'FCAGameplayEffectContainerSpec::M_target_data' has a wrong offset!");
static_assert(offsetof(FCAGameplayEffectContainerSpec, M_target_gameplay_effect_specs) == 0x000028, "Member 'FCAGameplayEffectContainerSpec::M_target_gameplay_effect_specs' has a wrong offset!");

// ScriptStruct keaton.CATextWithInputTableRow
// 0x0068 (0x0070 - 0x0008)
struct FCATextWithInputTableRow final : public FTableRowBase
{
public:
	struct FCAText                                M_indicator_text;                                  // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   M_debug_indicator_text;                            // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAHUDInputData>                M_indicator_icon_data_array;                       // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAHUDInputData>                M_gamepad_indicator_icon_data_array_override;      // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATextWithInputTableRow) == 0x000008, "Wrong alignment on FCATextWithInputTableRow");
static_assert(sizeof(FCATextWithInputTableRow) == 0x000070, "Wrong size on FCATextWithInputTableRow");
static_assert(offsetof(FCATextWithInputTableRow, M_indicator_text) == 0x000008, "Member 'FCATextWithInputTableRow::M_indicator_text' has a wrong offset!");
static_assert(offsetof(FCATextWithInputTableRow, M_debug_indicator_text) == 0x000038, "Member 'FCATextWithInputTableRow::M_debug_indicator_text' has a wrong offset!");
static_assert(offsetof(FCATextWithInputTableRow, M_indicator_icon_data_array) == 0x000050, "Member 'FCATextWithInputTableRow::M_indicator_icon_data_array' has a wrong offset!");
static_assert(offsetof(FCATextWithInputTableRow, M_gamepad_indicator_icon_data_array_override) == 0x000060, "Member 'FCATextWithInputTableRow::M_gamepad_indicator_icon_data_array_override' has a wrong offset!");

// ScriptStruct keaton.CAScreenRequest
// 0x0080 (0x0080 - 0x0000)
struct FCAScreenRequest final
{
public:
	struct FCAGameDatabaseTypedRowHandle          M_handle;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	ECADisplaySlot                                M_display_slot;                                    // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_mediator;                                        // 0x0008(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_focus_on_show;                                   // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x47];                                      // 0x0039(0x0047)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAScreenRequest) == 0x000008, "Wrong alignment on FCAScreenRequest");
static_assert(sizeof(FCAScreenRequest) == 0x000080, "Wrong size on FCAScreenRequest");
static_assert(offsetof(FCAScreenRequest, M_handle) == 0x000000, "Member 'FCAScreenRequest::M_handle' has a wrong offset!");
static_assert(offsetof(FCAScreenRequest, M_display_slot) == 0x000004, "Member 'FCAScreenRequest::M_display_slot' has a wrong offset!");
static_assert(offsetof(FCAScreenRequest, M_mediator) == 0x000008, "Member 'FCAScreenRequest::M_mediator' has a wrong offset!");
static_assert(offsetof(FCAScreenRequest, M_focus_on_show) == 0x000038, "Member 'FCAScreenRequest::M_focus_on_show' has a wrong offset!");

// ScriptStruct keaton.CAEffectMapWithSetByCallerTags
// 0x0060 (0x0060 - 0x0000)
struct FCAEffectMapWithSetByCallerTags final
{
public:
	TMap<struct FGameplayTag, TSubclassOf<class UGameplayEffect>> M_effects_by_tag;                                  // 0x0000(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FCASetByCallerWithMagnitude>    M_shared_set_by_caller_magnitudes;                 // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAEffectMapWithSetByCallerTags) == 0x000008, "Wrong alignment on FCAEffectMapWithSetByCallerTags");
static_assert(sizeof(FCAEffectMapWithSetByCallerTags) == 0x000060, "Wrong size on FCAEffectMapWithSetByCallerTags");
static_assert(offsetof(FCAEffectMapWithSetByCallerTags, M_effects_by_tag) == 0x000000, "Member 'FCAEffectMapWithSetByCallerTags::M_effects_by_tag' has a wrong offset!");
static_assert(offsetof(FCAEffectMapWithSetByCallerTags, M_shared_set_by_caller_magnitudes) == 0x000050, "Member 'FCAEffectMapWithSetByCallerTags::M_shared_set_by_caller_magnitudes' has a wrong offset!");

// ScriptStruct keaton.CAGMCItemLevelUpDefinition
// 0x0078 (0x0078 - 0x0000)
struct FCAGMCItemLevelUpDefinition final
{
public:
	float                                         M_exp_to_reach_this_level;                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAEffectMapWithSetByCallerTags> M_effect_map_with_set_by_caller_tags;              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            M_effect_icon;                                     // 0x0018(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAText                                M_effect_description;                              // 0x0048(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAGMCItemLevelUpDefinition) == 0x000008, "Wrong alignment on FCAGMCItemLevelUpDefinition");
static_assert(sizeof(FCAGMCItemLevelUpDefinition) == 0x000078, "Wrong size on FCAGMCItemLevelUpDefinition");
static_assert(offsetof(FCAGMCItemLevelUpDefinition, M_exp_to_reach_this_level) == 0x000000, "Member 'FCAGMCItemLevelUpDefinition::M_exp_to_reach_this_level' has a wrong offset!");
static_assert(offsetof(FCAGMCItemLevelUpDefinition, M_effect_map_with_set_by_caller_tags) == 0x000008, "Member 'FCAGMCItemLevelUpDefinition::M_effect_map_with_set_by_caller_tags' has a wrong offset!");
static_assert(offsetof(FCAGMCItemLevelUpDefinition, M_effect_icon) == 0x000018, "Member 'FCAGMCItemLevelUpDefinition::M_effect_icon' has a wrong offset!");
static_assert(offsetof(FCAGMCItemLevelUpDefinition, M_effect_description) == 0x000048, "Member 'FCAGMCItemLevelUpDefinition::M_effect_description' has a wrong offset!");

// ScriptStruct keaton.CAGMCItemLevelUpDataRow
// 0x0090 (0x0098 - 0x0008)
struct FCAGMCItemLevelUpDataRow final : public FTableRowBase
{
public:
	TArray<struct FCAGMCItemLevelUpDefinition>    M_per_item_level_up_definitions;                   // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TSubclassOf<class UGameplayEffect>> M_level_up_gameplay_effect_map;                    // 0x0018(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FCAText                                M_short_item_description;                          // 0x0068(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAGMCItemLevelUpDataRow) == 0x000008, "Wrong alignment on FCAGMCItemLevelUpDataRow");
static_assert(sizeof(FCAGMCItemLevelUpDataRow) == 0x000098, "Wrong size on FCAGMCItemLevelUpDataRow");
static_assert(offsetof(FCAGMCItemLevelUpDataRow, M_per_item_level_up_definitions) == 0x000008, "Member 'FCAGMCItemLevelUpDataRow::M_per_item_level_up_definitions' has a wrong offset!");
static_assert(offsetof(FCAGMCItemLevelUpDataRow, M_level_up_gameplay_effect_map) == 0x000018, "Member 'FCAGMCItemLevelUpDataRow::M_level_up_gameplay_effect_map' has a wrong offset!");
static_assert(offsetof(FCAGMCItemLevelUpDataRow, M_short_item_description) == 0x000068, "Member 'FCAGMCItemLevelUpDataRow::M_short_item_description' has a wrong offset!");

// ScriptStruct keaton.CAOnboardingTaskDataTableRow
// 0x0030 (0x0038 - 0x0008)
struct FCAOnboardingTaskDataTableRow final : public FTableRowBase
{
public:
	struct FCAText                                M_task_desc;                                       // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAOnboardingTaskDataTableRow) == 0x000008, "Wrong alignment on FCAOnboardingTaskDataTableRow");
static_assert(sizeof(FCAOnboardingTaskDataTableRow) == 0x000038, "Wrong size on FCAOnboardingTaskDataTableRow");
static_assert(offsetof(FCAOnboardingTaskDataTableRow, M_task_desc) == 0x000008, "Member 'FCAOnboardingTaskDataTableRow::M_task_desc' has a wrong offset!");

// ScriptStruct keaton.CACosmeticDefinitionTableRow
// 0x0068 (0x01A8 - 0x0140)
struct FCACosmeticDefinitionTableRow final : public FCACosmeticDefinitionBaseTableRow
{
public:
	struct FFeatureKeyItem                        M_feature;                                         // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           M_collapsed_TP_mesh;                               // 0x0148(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           M_frontend_mesh;                                   // 0x0178(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACosmeticDefinitionTableRow) == 0x000008, "Wrong alignment on FCACosmeticDefinitionTableRow");
static_assert(sizeof(FCACosmeticDefinitionTableRow) == 0x0001A8, "Wrong size on FCACosmeticDefinitionTableRow");
static_assert(offsetof(FCACosmeticDefinitionTableRow, M_feature) == 0x000140, "Member 'FCACosmeticDefinitionTableRow::M_feature' has a wrong offset!");
static_assert(offsetof(FCACosmeticDefinitionTableRow, M_collapsed_TP_mesh) == 0x000148, "Member 'FCACosmeticDefinitionTableRow::M_collapsed_TP_mesh' has a wrong offset!");
static_assert(offsetof(FCACosmeticDefinitionTableRow, M_frontend_mesh) == 0x000178, "Member 'FCACosmeticDefinitionTableRow::M_frontend_mesh' has a wrong offset!");

// ScriptStruct keaton.DeviceStateSyncData
// 0x0008 (0x0008 - 0x0000)
struct FDeviceStateSyncData final
{
public:
	bool                                          M_remote_status;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_remote_suspended;                                // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_remote_disabled;                                 // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_remote_progress;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeviceStateSyncData) == 0x000004, "Wrong alignment on FDeviceStateSyncData");
static_assert(sizeof(FDeviceStateSyncData) == 0x000008, "Wrong size on FDeviceStateSyncData");
static_assert(offsetof(FDeviceStateSyncData, M_remote_status) == 0x000000, "Member 'FDeviceStateSyncData::M_remote_status' has a wrong offset!");
static_assert(offsetof(FDeviceStateSyncData, M_remote_suspended) == 0x000001, "Member 'FDeviceStateSyncData::M_remote_suspended' has a wrong offset!");
static_assert(offsetof(FDeviceStateSyncData, M_remote_disabled) == 0x000002, "Member 'FDeviceStateSyncData::M_remote_disabled' has a wrong offset!");
static_assert(offsetof(FDeviceStateSyncData, M_remote_progress) == 0x000004, "Member 'FDeviceStateSyncData::M_remote_progress' has a wrong offset!");

// ScriptStruct keaton.CAQueueDefinitionTableRow
// 0x0160 (0x0168 - 0x0008)
struct FCAQueueDefinitionTableRow final : public FTableRowBase
{
public:
	ECAReleaseState                               M_release_state;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFeatureKeyItem                        M_feature;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAText                                M_display_name;                                    // 0x0010(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_display_description;                             // 0x0040(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_display_type;                                    // 0x0070(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ECAGameModeType                               M_game_mode_type;                                  // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_game_mode_hint;                                  // 0x00A8(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_map_featured_image;                              // 0x00D8(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_icon;                                            // 0x0108(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCAGameModeConfiguration> M_gamemode_configuration;                          // 0x0138(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAQueueDefinitionTableRow) == 0x000008, "Wrong alignment on FCAQueueDefinitionTableRow");
static_assert(sizeof(FCAQueueDefinitionTableRow) == 0x000168, "Wrong size on FCAQueueDefinitionTableRow");
static_assert(offsetof(FCAQueueDefinitionTableRow, M_release_state) == 0x000008, "Member 'FCAQueueDefinitionTableRow::M_release_state' has a wrong offset!");
static_assert(offsetof(FCAQueueDefinitionTableRow, M_feature) == 0x00000C, "Member 'FCAQueueDefinitionTableRow::M_feature' has a wrong offset!");
static_assert(offsetof(FCAQueueDefinitionTableRow, M_display_name) == 0x000010, "Member 'FCAQueueDefinitionTableRow::M_display_name' has a wrong offset!");
static_assert(offsetof(FCAQueueDefinitionTableRow, M_display_description) == 0x000040, "Member 'FCAQueueDefinitionTableRow::M_display_description' has a wrong offset!");
static_assert(offsetof(FCAQueueDefinitionTableRow, M_display_type) == 0x000070, "Member 'FCAQueueDefinitionTableRow::M_display_type' has a wrong offset!");
static_assert(offsetof(FCAQueueDefinitionTableRow, M_game_mode_type) == 0x0000A0, "Member 'FCAQueueDefinitionTableRow::M_game_mode_type' has a wrong offset!");
static_assert(offsetof(FCAQueueDefinitionTableRow, M_game_mode_hint) == 0x0000A8, "Member 'FCAQueueDefinitionTableRow::M_game_mode_hint' has a wrong offset!");
static_assert(offsetof(FCAQueueDefinitionTableRow, M_map_featured_image) == 0x0000D8, "Member 'FCAQueueDefinitionTableRow::M_map_featured_image' has a wrong offset!");
static_assert(offsetof(FCAQueueDefinitionTableRow, M_icon) == 0x000108, "Member 'FCAQueueDefinitionTableRow::M_icon' has a wrong offset!");
static_assert(offsetof(FCAQueueDefinitionTableRow, M_gamemode_configuration) == 0x000138, "Member 'FCAQueueDefinitionTableRow::M_gamemode_configuration' has a wrong offset!");

// ScriptStruct keaton.CAGMCItemLevelUpData
// 0x0040 (0x0040 - 0x0000)
struct FCAGMCItemLevelUpData final
{
public:
	TSoftObjectPtr<class UCAInventoryItem>        M_inventory_item;                                  // 0x0000(0x0030)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAGMCItemLevelUpDefinition>    M_item_levels;                                     // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAGMCItemLevelUpData) == 0x000008, "Wrong alignment on FCAGMCItemLevelUpData");
static_assert(sizeof(FCAGMCItemLevelUpData) == 0x000040, "Wrong size on FCAGMCItemLevelUpData");
static_assert(offsetof(FCAGMCItemLevelUpData, M_inventory_item) == 0x000000, "Member 'FCAGMCItemLevelUpData::M_inventory_item' has a wrong offset!");
static_assert(offsetof(FCAGMCItemLevelUpData, M_item_levels) == 0x000030, "Member 'FCAGMCItemLevelUpData::M_item_levels' has a wrong offset!");

// ScriptStruct keaton.CAMapDefinitionTableRow
// 0x0150 (0x0158 - 0x0008)
struct FCAMapDefinitionTableRow final : public FTableRowBase
{
public:
	ECAReleaseState                               M_release_state;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_game_map;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAText                                M_display_name;                                    // 0x0020(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_map_image;                                       // 0x0050(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_background_texture;                              // 0x0080(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            M_background_brush;                                // 0x00B0(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_debug_mm_queue_handle;                           // 0x0140(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMapDefinitionTableRow) == 0x000008, "Wrong alignment on FCAMapDefinitionTableRow");
static_assert(sizeof(FCAMapDefinitionTableRow) == 0x000158, "Wrong size on FCAMapDefinitionTableRow");
static_assert(offsetof(FCAMapDefinitionTableRow, M_release_state) == 0x000008, "Member 'FCAMapDefinitionTableRow::M_release_state' has a wrong offset!");
static_assert(offsetof(FCAMapDefinitionTableRow, M_game_map) == 0x000010, "Member 'FCAMapDefinitionTableRow::M_game_map' has a wrong offset!");
static_assert(offsetof(FCAMapDefinitionTableRow, M_display_name) == 0x000020, "Member 'FCAMapDefinitionTableRow::M_display_name' has a wrong offset!");
static_assert(offsetof(FCAMapDefinitionTableRow, M_map_image) == 0x000050, "Member 'FCAMapDefinitionTableRow::M_map_image' has a wrong offset!");
static_assert(offsetof(FCAMapDefinitionTableRow, M_background_texture) == 0x000080, "Member 'FCAMapDefinitionTableRow::M_background_texture' has a wrong offset!");
static_assert(offsetof(FCAMapDefinitionTableRow, M_background_brush) == 0x0000B0, "Member 'FCAMapDefinitionTableRow::M_background_brush' has a wrong offset!");
static_assert(offsetof(FCAMapDefinitionTableRow, M_debug_mm_queue_handle) == 0x000140, "Member 'FCAMapDefinitionTableRow::M_debug_mm_queue_handle' has a wrong offset!");

// ScriptStruct keaton.CAServicesSlotOption
// 0x0058 (0x0058 - 0x0000)
struct FCAServicesSlotOption final
{
public:
	struct FCAGameDatabaseRowHandle               M_handle;                                          // 0x0000(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 M_equip_me;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_disabled;                                     // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_owned;                                        // 0x0029(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAObtainableOption>            M_obtain_options;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_slots;                                           // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ECAAvailableVia                               M_available_via;                                   // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAServicesSlotOption) == 0x000008, "Wrong alignment on FCAServicesSlotOption");
static_assert(sizeof(FCAServicesSlotOption) == 0x000058, "Wrong size on FCAServicesSlotOption");
static_assert(offsetof(FCAServicesSlotOption, M_handle) == 0x000000, "Member 'FCAServicesSlotOption::M_handle' has a wrong offset!");
static_assert(offsetof(FCAServicesSlotOption, M_equip_me) == 0x000018, "Member 'FCAServicesSlotOption::M_equip_me' has a wrong offset!");
static_assert(offsetof(FCAServicesSlotOption, M_is_disabled) == 0x000028, "Member 'FCAServicesSlotOption::M_is_disabled' has a wrong offset!");
static_assert(offsetof(FCAServicesSlotOption, M_is_owned) == 0x000029, "Member 'FCAServicesSlotOption::M_is_owned' has a wrong offset!");
static_assert(offsetof(FCAServicesSlotOption, M_obtain_options) == 0x000030, "Member 'FCAServicesSlotOption::M_obtain_options' has a wrong offset!");
static_assert(offsetof(FCAServicesSlotOption, M_slots) == 0x000040, "Member 'FCAServicesSlotOption::M_slots' has a wrong offset!");
static_assert(offsetof(FCAServicesSlotOption, M_available_via) == 0x000050, "Member 'FCAServicesSlotOption::M_available_via' has a wrong offset!");

// ScriptStruct keaton.CAPlayerLevelAssetTableRow
// 0x0078 (0x0080 - 0x0008)
struct FCAPlayerLevelAssetTableRow final : public FTableRowBase
{
public:
	struct FCAText                                M_rank_name;                                       // 0x0008(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_rank_icon;                                       // 0x0038(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_profile_rewards_handle;                          // 0x0068(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPlayerLevelAssetTableRow) == 0x000008, "Wrong alignment on FCAPlayerLevelAssetTableRow");
static_assert(sizeof(FCAPlayerLevelAssetTableRow) == 0x000080, "Wrong size on FCAPlayerLevelAssetTableRow");
static_assert(offsetof(FCAPlayerLevelAssetTableRow, M_rank_name) == 0x000008, "Member 'FCAPlayerLevelAssetTableRow::M_rank_name' has a wrong offset!");
static_assert(offsetof(FCAPlayerLevelAssetTableRow, M_rank_icon) == 0x000038, "Member 'FCAPlayerLevelAssetTableRow::M_rank_icon' has a wrong offset!");
static_assert(offsetof(FCAPlayerLevelAssetTableRow, M_profile_rewards_handle) == 0x000068, "Member 'FCAPlayerLevelAssetTableRow::M_profile_rewards_handle' has a wrong offset!");

// ScriptStruct keaton.CAPlayerProfileStatsRow
// 0x0090 (0x0098 - 0x0008)
struct FCAPlayerProfileStatsRow final : public FTableRowBase
{
public:
	struct FCAText                                M_display_text;                                    // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FCAText                                M_suffix;                                          // 0x0038(0x0030)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_icon;                                            // 0x0068(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPlayerProfileStatsRow) == 0x000008, "Wrong alignment on FCAPlayerProfileStatsRow");
static_assert(sizeof(FCAPlayerProfileStatsRow) == 0x000098, "Wrong size on FCAPlayerProfileStatsRow");
static_assert(offsetof(FCAPlayerProfileStatsRow, M_display_text) == 0x000008, "Member 'FCAPlayerProfileStatsRow::M_display_text' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileStatsRow, M_suffix) == 0x000038, "Member 'FCAPlayerProfileStatsRow::M_suffix' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileStatsRow, M_icon) == 0x000068, "Member 'FCAPlayerProfileStatsRow::M_icon' has a wrong offset!");

// ScriptStruct keaton.CAControllerSymbolData
// 0x0040 (0x0040 - 0x0000)
struct FCAControllerSymbolData final
{
public:
	class FText                                   M_symbol;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_is_animated;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_symbol_2;                                        // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_symbol_delay;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_symbol_delay_2;                                  // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAControllerSymbolData) == 0x000008, "Wrong alignment on FCAControllerSymbolData");
static_assert(sizeof(FCAControllerSymbolData) == 0x000040, "Wrong size on FCAControllerSymbolData");
static_assert(offsetof(FCAControllerSymbolData, M_symbol) == 0x000000, "Member 'FCAControllerSymbolData::M_symbol' has a wrong offset!");
static_assert(offsetof(FCAControllerSymbolData, M_is_animated) == 0x000018, "Member 'FCAControllerSymbolData::M_is_animated' has a wrong offset!");
static_assert(offsetof(FCAControllerSymbolData, M_symbol_2) == 0x000020, "Member 'FCAControllerSymbolData::M_symbol_2' has a wrong offset!");
static_assert(offsetof(FCAControllerSymbolData, M_symbol_delay) == 0x000038, "Member 'FCAControllerSymbolData::M_symbol_delay' has a wrong offset!");
static_assert(offsetof(FCAControllerSymbolData, M_symbol_delay_2) == 0x00003C, "Member 'FCAControllerSymbolData::M_symbol_delay_2' has a wrong offset!");

// ScriptStruct keaton.CAControllerSymbolTableRow
// 0x00C0 (0x00C8 - 0x0008)
struct FCAControllerSymbolTableRow final : public FTableRowBase
{
public:
	struct FCAControllerSymbolData                M_xbox_symbol_data;                                // 0x0008(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAControllerSymbolData                M_ps_symbol_data;                                  // 0x0048(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAControllerSymbolData                M_kb_symbol_data;                                  // 0x0088(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAControllerSymbolTableRow) == 0x000008, "Wrong alignment on FCAControllerSymbolTableRow");
static_assert(sizeof(FCAControllerSymbolTableRow) == 0x0000C8, "Wrong size on FCAControllerSymbolTableRow");
static_assert(offsetof(FCAControllerSymbolTableRow, M_xbox_symbol_data) == 0x000008, "Member 'FCAControllerSymbolTableRow::M_xbox_symbol_data' has a wrong offset!");
static_assert(offsetof(FCAControllerSymbolTableRow, M_ps_symbol_data) == 0x000048, "Member 'FCAControllerSymbolTableRow::M_ps_symbol_data' has a wrong offset!");
static_assert(offsetof(FCAControllerSymbolTableRow, M_kb_symbol_data) == 0x000088, "Member 'FCAControllerSymbolTableRow::M_kb_symbol_data' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_Crouch
// 0x0010 (0x0020 - 0x0010)
struct FCAMovementData_Crouch final : public FCAMovementModeData
{
public:
	uint8                                         Pad_10[0x4];                                       // 0x0010(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_half_height;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_speed;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementData_Crouch) == 0x000008, "Wrong alignment on FCAMovementData_Crouch");
static_assert(sizeof(FCAMovementData_Crouch) == 0x000020, "Wrong size on FCAMovementData_Crouch");
static_assert(offsetof(FCAMovementData_Crouch, M_half_height) == 0x000014, "Member 'FCAMovementData_Crouch::M_half_height' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Crouch, M_max_speed) == 0x000018, "Member 'FCAMovementData_Crouch::M_max_speed' has a wrong offset!");

// ScriptStruct keaton.CATimingBarStyle
// 0x0120 (0x0128 - 0x0008)
struct FCATimingBarStyle final : public FSlateWidgetStyle
{
public:
	struct FSlateBrush                            BackgroundImage;                                   // 0x0008(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            FillImage;                                         // 0x0098(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATimingBarStyle) == 0x000008, "Wrong alignment on FCATimingBarStyle");
static_assert(sizeof(FCATimingBarStyle) == 0x000128, "Wrong size on FCATimingBarStyle");
static_assert(offsetof(FCATimingBarStyle, BackgroundImage) == 0x000008, "Member 'FCATimingBarStyle::BackgroundImage' has a wrong offset!");
static_assert(offsetof(FCATimingBarStyle, FillImage) == 0x000098, "Member 'FCATimingBarStyle::FillImage' has a wrong offset!");

// ScriptStruct keaton.CABattleResultDetailsMissions
// 0x0010 (0x0010 - 0x0000)
struct FCABattleResultDetailsMissions final
{
public:
	TArray<int64>                                 Change;                                            // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCABattleResultDetailsMissions) == 0x000008, "Wrong alignment on FCABattleResultDetailsMissions");
static_assert(sizeof(FCABattleResultDetailsMissions) == 0x000010, "Wrong size on FCABattleResultDetailsMissions");
static_assert(offsetof(FCABattleResultDetailsMissions, Change) == 0x000000, "Member 'FCABattleResultDetailsMissions::Change' has a wrong offset!");

// ScriptStruct keaton.CABattleResultDetails
// 0x0168 (0x0168 - 0x0000)
struct FCABattleResultDetails final
{
public:
	class FString                                 battle_map_key;                                    // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Duration;                                          // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Player_name;                                       // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Alliance_id;                                       // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Result;                                            // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Victory_mean;                                      // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         badges;                                            // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int64                                         Specialist_item_id;                                // 0x0060(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FCABattleResultDetailsMissions> Missions;                                          // 0x0068(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            Mvp_statistics;                                    // 0x00B8(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    General_statistics;                                // 0x0108(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 Team_emoji;                                        // 0x0158(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCABattleResultDetails) == 0x000008, "Wrong alignment on FCABattleResultDetails");
static_assert(sizeof(FCABattleResultDetails) == 0x000168, "Wrong size on FCABattleResultDetails");
static_assert(offsetof(FCABattleResultDetails, battle_map_key) == 0x000000, "Member 'FCABattleResultDetails::battle_map_key' has a wrong offset!");
static_assert(offsetof(FCABattleResultDetails, Duration) == 0x000010, "Member 'FCABattleResultDetails::Duration' has a wrong offset!");
static_assert(offsetof(FCABattleResultDetails, Player_name) == 0x000018, "Member 'FCABattleResultDetails::Player_name' has a wrong offset!");
static_assert(offsetof(FCABattleResultDetails, Alliance_id) == 0x000028, "Member 'FCABattleResultDetails::Alliance_id' has a wrong offset!");
static_assert(offsetof(FCABattleResultDetails, Result) == 0x000030, "Member 'FCABattleResultDetails::Result' has a wrong offset!");
static_assert(offsetof(FCABattleResultDetails, Victory_mean) == 0x000040, "Member 'FCABattleResultDetails::Victory_mean' has a wrong offset!");
static_assert(offsetof(FCABattleResultDetails, badges) == 0x000050, "Member 'FCABattleResultDetails::badges' has a wrong offset!");
static_assert(offsetof(FCABattleResultDetails, Specialist_item_id) == 0x000060, "Member 'FCABattleResultDetails::Specialist_item_id' has a wrong offset!");
static_assert(offsetof(FCABattleResultDetails, Missions) == 0x000068, "Member 'FCABattleResultDetails::Missions' has a wrong offset!");
static_assert(offsetof(FCABattleResultDetails, Mvp_statistics) == 0x0000B8, "Member 'FCABattleResultDetails::Mvp_statistics' has a wrong offset!");
static_assert(offsetof(FCABattleResultDetails, General_statistics) == 0x000108, "Member 'FCABattleResultDetails::General_statistics' has a wrong offset!");
static_assert(offsetof(FCABattleResultDetails, Team_emoji) == 0x000158, "Member 'FCABattleResultDetails::Team_emoji' has a wrong offset!");

// ScriptStruct keaton.CACurrencyAssetTableRow
// 0x0118 (0x0120 - 0x0008)
struct FCACurrencyAssetTableRow final : public FTableRowBase
{
public:
	class FName                                   M_service_key;                                     // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_display_name;                                    // 0x0018(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   M_symbol;                                          // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   M_id;                                              // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   M_richtext_formating;                              // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_locale_formatting;                               // 0x0090(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_icon;                                            // 0x00C0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_reward_image;                                    // 0x00F0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACurrencyAssetTableRow) == 0x000008, "Wrong alignment on FCACurrencyAssetTableRow");
static_assert(sizeof(FCACurrencyAssetTableRow) == 0x000120, "Wrong size on FCACurrencyAssetTableRow");
static_assert(offsetof(FCACurrencyAssetTableRow, M_service_key) == 0x000008, "Member 'FCACurrencyAssetTableRow::M_service_key' has a wrong offset!");
static_assert(offsetof(FCACurrencyAssetTableRow, M_display_name) == 0x000018, "Member 'FCACurrencyAssetTableRow::M_display_name' has a wrong offset!");
static_assert(offsetof(FCACurrencyAssetTableRow, M_symbol) == 0x000048, "Member 'FCACurrencyAssetTableRow::M_symbol' has a wrong offset!");
static_assert(offsetof(FCACurrencyAssetTableRow, M_id) == 0x000060, "Member 'FCACurrencyAssetTableRow::M_id' has a wrong offset!");
static_assert(offsetof(FCACurrencyAssetTableRow, M_richtext_formating) == 0x000078, "Member 'FCACurrencyAssetTableRow::M_richtext_formating' has a wrong offset!");
static_assert(offsetof(FCACurrencyAssetTableRow, M_locale_formatting) == 0x000090, "Member 'FCACurrencyAssetTableRow::M_locale_formatting' has a wrong offset!");
static_assert(offsetof(FCACurrencyAssetTableRow, M_icon) == 0x0000C0, "Member 'FCACurrencyAssetTableRow::M_icon' has a wrong offset!");
static_assert(offsetof(FCACurrencyAssetTableRow, M_reward_image) == 0x0000F0, "Member 'FCACurrencyAssetTableRow::M_reward_image' has a wrong offset!");

// ScriptStruct keaton.DamageMultipliersPerPlayer
// 0x0014 (0x0014 - 0x0000)
struct FDamageMultipliersPerPlayer final
{
public:
	struct FCADamageOptions                       M_damage_multipliers;                              // 0x0000(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint32                                        M_players_number;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageMultipliersPerPlayer) == 0x000004, "Wrong alignment on FDamageMultipliersPerPlayer");
static_assert(sizeof(FDamageMultipliersPerPlayer) == 0x000014, "Wrong size on FDamageMultipliersPerPlayer");
static_assert(offsetof(FDamageMultipliersPerPlayer, M_damage_multipliers) == 0x000000, "Member 'FDamageMultipliersPerPlayer::M_damage_multipliers' has a wrong offset!");
static_assert(offsetof(FDamageMultipliersPerPlayer, M_players_number) == 0x000010, "Member 'FDamageMultipliersPerPlayer::M_players_number' has a wrong offset!");

// ScriptStruct keaton.CAAttributeInitialisationTableEffects
// 0x0008 (0x0010 - 0x0008)
struct FCAAttributeInitialisationTableEffects final : public FTableRowBase
{
public:
	float                                         TeleportOutTime;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportInTime;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAttributeInitialisationTableEffects) == 0x000008, "Wrong alignment on FCAAttributeInitialisationTableEffects");
static_assert(sizeof(FCAAttributeInitialisationTableEffects) == 0x000010, "Wrong size on FCAAttributeInitialisationTableEffects");
static_assert(offsetof(FCAAttributeInitialisationTableEffects, TeleportOutTime) == 0x000008, "Member 'FCAAttributeInitialisationTableEffects::TeleportOutTime' has a wrong offset!");
static_assert(offsetof(FCAAttributeInitialisationTableEffects, TeleportInTime) == 0x00000C, "Member 'FCAAttributeInitialisationTableEffects::TeleportInTime' has a wrong offset!");

// ScriptStruct keaton.CAEquipmentDependant
// 0x0040 (0x0048 - 0x0008)
struct FCAEquipmentDependant final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UCAInventoryItem>        M_inventory_item;                                  // 0x0008(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_amount;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_respawn_amount;                                  // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_max_amount;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAEquipmentDependant) == 0x000008, "Wrong alignment on FCAEquipmentDependant");
static_assert(sizeof(FCAEquipmentDependant) == 0x000048, "Wrong size on FCAEquipmentDependant");
static_assert(offsetof(FCAEquipmentDependant, M_inventory_item) == 0x000008, "Member 'FCAEquipmentDependant::M_inventory_item' has a wrong offset!");
static_assert(offsetof(FCAEquipmentDependant, M_amount) == 0x000038, "Member 'FCAEquipmentDependant::M_amount' has a wrong offset!");
static_assert(offsetof(FCAEquipmentDependant, M_respawn_amount) == 0x00003C, "Member 'FCAEquipmentDependant::M_respawn_amount' has a wrong offset!");
static_assert(offsetof(FCAEquipmentDependant, M_max_amount) == 0x000040, "Member 'FCAEquipmentDependant::M_max_amount' has a wrong offset!");

// ScriptStruct keaton.CAEquipmentDefinitionTableRow
// 0x0138 (0x0140 - 0x0008)
struct FCAEquipmentDefinitionTableRow final : public FTableRowBase
{
public:
	ECAReleaseState                               M_release_state;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCAInventoryItem>        M_inventory_item_asset_reference;                  // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAEquipmentDependant>          M_dependents;                                      // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_display_name;                                    // 0x0050(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_description;                                     // 0x0080(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_summary;                                         // 0x00B0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_weapon_image;                                    // 0x00E0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_frontend_weapon_image;                           // 0x0110(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAEquipmentDefinitionTableRow) == 0x000008, "Wrong alignment on FCAEquipmentDefinitionTableRow");
static_assert(sizeof(FCAEquipmentDefinitionTableRow) == 0x000140, "Wrong size on FCAEquipmentDefinitionTableRow");
static_assert(offsetof(FCAEquipmentDefinitionTableRow, M_release_state) == 0x000008, "Member 'FCAEquipmentDefinitionTableRow::M_release_state' has a wrong offset!");
static_assert(offsetof(FCAEquipmentDefinitionTableRow, M_inventory_item_asset_reference) == 0x000010, "Member 'FCAEquipmentDefinitionTableRow::M_inventory_item_asset_reference' has a wrong offset!");
static_assert(offsetof(FCAEquipmentDefinitionTableRow, M_dependents) == 0x000040, "Member 'FCAEquipmentDefinitionTableRow::M_dependents' has a wrong offset!");
static_assert(offsetof(FCAEquipmentDefinitionTableRow, M_display_name) == 0x000050, "Member 'FCAEquipmentDefinitionTableRow::M_display_name' has a wrong offset!");
static_assert(offsetof(FCAEquipmentDefinitionTableRow, M_description) == 0x000080, "Member 'FCAEquipmentDefinitionTableRow::M_description' has a wrong offset!");
static_assert(offsetof(FCAEquipmentDefinitionTableRow, M_summary) == 0x0000B0, "Member 'FCAEquipmentDefinitionTableRow::M_summary' has a wrong offset!");
static_assert(offsetof(FCAEquipmentDefinitionTableRow, M_weapon_image) == 0x0000E0, "Member 'FCAEquipmentDefinitionTableRow::M_weapon_image' has a wrong offset!");
static_assert(offsetof(FCAEquipmentDefinitionTableRow, M_frontend_weapon_image) == 0x000110, "Member 'FCAEquipmentDefinitionTableRow::M_frontend_weapon_image' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_ZGDF_SpeedEntry
// 0x00A8 (0x00A8 - 0x0000)
struct FCAMovementData_ZGDF_SpeedEntry final
{
public:
	float                                         M_angle;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_speed_delta_when_no_curve;                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     M_speed_curve;                                     // 0x0008(0x0088)(Edit, NativeAccessSpecifierPublic)
	TArray<float>                                 M_repeated_press_modifier;                         // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementData_ZGDF_SpeedEntry) == 0x000008, "Wrong alignment on FCAMovementData_ZGDF_SpeedEntry");
static_assert(sizeof(FCAMovementData_ZGDF_SpeedEntry) == 0x0000A8, "Wrong size on FCAMovementData_ZGDF_SpeedEntry");
static_assert(offsetof(FCAMovementData_ZGDF_SpeedEntry, M_angle) == 0x000000, "Member 'FCAMovementData_ZGDF_SpeedEntry::M_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZGDF_SpeedEntry, M_speed_delta_when_no_curve) == 0x000004, "Member 'FCAMovementData_ZGDF_SpeedEntry::M_speed_delta_when_no_curve' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZGDF_SpeedEntry, M_speed_curve) == 0x000008, "Member 'FCAMovementData_ZGDF_SpeedEntry::M_speed_curve' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZGDF_SpeedEntry, M_repeated_press_modifier) == 0x000090, "Member 'FCAMovementData_ZGDF_SpeedEntry::M_repeated_press_modifier' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_ZGDF_DurationEntry
// 0x00A8 (0x00A8 - 0x0000)
struct FCAMovementData_ZGDF_DurationEntry final
{
public:
	float                                         M_angle;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_duration_when_no_curve;                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     M_duration_curve;                                  // 0x0008(0x0088)(Edit, NativeAccessSpecifierPublic)
	TArray<float>                                 M_repeated_press_modifier;                         // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementData_ZGDF_DurationEntry) == 0x000008, "Wrong alignment on FCAMovementData_ZGDF_DurationEntry");
static_assert(sizeof(FCAMovementData_ZGDF_DurationEntry) == 0x0000A8, "Wrong size on FCAMovementData_ZGDF_DurationEntry");
static_assert(offsetof(FCAMovementData_ZGDF_DurationEntry, M_angle) == 0x000000, "Member 'FCAMovementData_ZGDF_DurationEntry::M_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZGDF_DurationEntry, M_duration_when_no_curve) == 0x000004, "Member 'FCAMovementData_ZGDF_DurationEntry::M_duration_when_no_curve' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZGDF_DurationEntry, M_duration_curve) == 0x000008, "Member 'FCAMovementData_ZGDF_DurationEntry::M_duration_curve' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZGDF_DurationEntry, M_repeated_press_modifier) == 0x000090, "Member 'FCAMovementData_ZGDF_DurationEntry::M_repeated_press_modifier' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_ZGDF_TargetTurnEntry
// 0x00A8 (0x00A8 - 0x0000)
struct FCAMovementData_ZGDF_TargetTurnEntry final
{
public:
	float                                         M_angle;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_turn_when_no_curve;                              // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     M_turn_curve;                                      // 0x0008(0x0088)(Edit, NativeAccessSpecifierPublic)
	TArray<float>                                 M_repeated_press_modifier;                         // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementData_ZGDF_TargetTurnEntry) == 0x000008, "Wrong alignment on FCAMovementData_ZGDF_TargetTurnEntry");
static_assert(sizeof(FCAMovementData_ZGDF_TargetTurnEntry) == 0x0000A8, "Wrong size on FCAMovementData_ZGDF_TargetTurnEntry");
static_assert(offsetof(FCAMovementData_ZGDF_TargetTurnEntry, M_angle) == 0x000000, "Member 'FCAMovementData_ZGDF_TargetTurnEntry::M_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZGDF_TargetTurnEntry, M_turn_when_no_curve) == 0x000004, "Member 'FCAMovementData_ZGDF_TargetTurnEntry::M_turn_when_no_curve' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZGDF_TargetTurnEntry, M_turn_curve) == 0x000008, "Member 'FCAMovementData_ZGDF_TargetTurnEntry::M_turn_curve' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZGDF_TargetTurnEntry, M_repeated_press_modifier) == 0x000090, "Member 'FCAMovementData_ZGDF_TargetTurnEntry::M_repeated_press_modifier' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_ZeroGDirectionalForce
// 0x0058 (0x0058 - 0x0000)
struct FCAMovementData_ZeroGDirectionalForce final
{
public:
	bool                                          M_should_use;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAMovementData_ZGDF_SpeedEntry> M_speed_mapping;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAMovementData_ZGDF_DurationEntry> M_duration_mapping;                                // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAMovementData_ZGDF_TargetTurnEntry> M_target_turn_mapping;                             // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_sustain_time;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_double_press_excluded;                           // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_repeated_press_cancellation_angle;               // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_repeated_press_cancelled_level;                  // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_total_boosts;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_boost_recharge_time;                             // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_boost_recharge_delay;                            // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_lock_to_initial_direction;                       // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_fully_recharge_on_landing;                       // 0x0055(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_wall_sliding_during_boost;                       // 0x0056(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_show_turn;                                       // 0x0057(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMovementData_ZeroGDirectionalForce) == 0x000008, "Wrong alignment on FCAMovementData_ZeroGDirectionalForce");
static_assert(sizeof(FCAMovementData_ZeroGDirectionalForce) == 0x000058, "Wrong size on FCAMovementData_ZeroGDirectionalForce");
static_assert(offsetof(FCAMovementData_ZeroGDirectionalForce, M_should_use) == 0x000000, "Member 'FCAMovementData_ZeroGDirectionalForce::M_should_use' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGDirectionalForce, M_speed_mapping) == 0x000008, "Member 'FCAMovementData_ZeroGDirectionalForce::M_speed_mapping' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGDirectionalForce, M_duration_mapping) == 0x000018, "Member 'FCAMovementData_ZeroGDirectionalForce::M_duration_mapping' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGDirectionalForce, M_target_turn_mapping) == 0x000028, "Member 'FCAMovementData_ZeroGDirectionalForce::M_target_turn_mapping' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGDirectionalForce, M_sustain_time) == 0x000038, "Member 'FCAMovementData_ZeroGDirectionalForce::M_sustain_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGDirectionalForce, M_double_press_excluded) == 0x00003C, "Member 'FCAMovementData_ZeroGDirectionalForce::M_double_press_excluded' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGDirectionalForce, M_repeated_press_cancellation_angle) == 0x000040, "Member 'FCAMovementData_ZeroGDirectionalForce::M_repeated_press_cancellation_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGDirectionalForce, M_repeated_press_cancelled_level) == 0x000044, "Member 'FCAMovementData_ZeroGDirectionalForce::M_repeated_press_cancelled_level' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGDirectionalForce, M_total_boosts) == 0x000048, "Member 'FCAMovementData_ZeroGDirectionalForce::M_total_boosts' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGDirectionalForce, M_boost_recharge_time) == 0x00004C, "Member 'FCAMovementData_ZeroGDirectionalForce::M_boost_recharge_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGDirectionalForce, M_boost_recharge_delay) == 0x000050, "Member 'FCAMovementData_ZeroGDirectionalForce::M_boost_recharge_delay' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGDirectionalForce, M_lock_to_initial_direction) == 0x000054, "Member 'FCAMovementData_ZeroGDirectionalForce::M_lock_to_initial_direction' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGDirectionalForce, M_fully_recharge_on_landing) == 0x000055, "Member 'FCAMovementData_ZeroGDirectionalForce::M_fully_recharge_on_landing' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGDirectionalForce, M_wall_sliding_during_boost) == 0x000056, "Member 'FCAMovementData_ZeroGDirectionalForce::M_wall_sliding_during_boost' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGDirectionalForce, M_show_turn) == 0x000057, "Member 'FCAMovementData_ZeroGDirectionalForce::M_show_turn' has a wrong offset!");

// ScriptStruct keaton.CATargetScoreByRules
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FCATargetScoreByRules final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCATargetScoreByRules) == 0x000008, "Wrong alignment on FCATargetScoreByRules");
static_assert(sizeof(FCATargetScoreByRules) == 0x000028, "Wrong size on FCATargetScoreByRules");

// ScriptStruct keaton.CANPCTypeRecord
// 0x0068 (0x0068 - 0x0000)
struct FCANPCTypeRecord final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECANPCCountType, struct FCANPCCountChangeRecordArray> M_counts;                                          // 0x0018(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANPCTypeRecord) == 0x000008, "Wrong alignment on FCANPCTypeRecord");
static_assert(sizeof(FCANPCTypeRecord) == 0x000068, "Wrong size on FCANPCTypeRecord");
static_assert(offsetof(FCANPCTypeRecord, M_counts) == 0x000018, "Member 'FCANPCTypeRecord::M_counts' has a wrong offset!");

// ScriptStruct keaton.CAPrimitive
// 0x0060 (0x0060 - 0x0000)
struct FCAPrimitive final
{
public:
	ECACollisionPrimitiveType                     M_primitive;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_radius;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_zone_id;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_minimum;                                         // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_maximum;                                         // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0xC];                                       // 0x0024(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_transform;                                       // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPrimitive) == 0x000010, "Wrong alignment on FCAPrimitive");
static_assert(sizeof(FCAPrimitive) == 0x000060, "Wrong size on FCAPrimitive");
static_assert(offsetof(FCAPrimitive, M_primitive) == 0x000000, "Member 'FCAPrimitive::M_primitive' has a wrong offset!");
static_assert(offsetof(FCAPrimitive, M_radius) == 0x000004, "Member 'FCAPrimitive::M_radius' has a wrong offset!");
static_assert(offsetof(FCAPrimitive, M_zone_id) == 0x000008, "Member 'FCAPrimitive::M_zone_id' has a wrong offset!");
static_assert(offsetof(FCAPrimitive, M_minimum) == 0x00000C, "Member 'FCAPrimitive::M_minimum' has a wrong offset!");
static_assert(offsetof(FCAPrimitive, M_maximum) == 0x000018, "Member 'FCAPrimitive::M_maximum' has a wrong offset!");
static_assert(offsetof(FCAPrimitive, M_transform) == 0x000030, "Member 'FCAPrimitive::M_transform' has a wrong offset!");

// ScriptStruct keaton.CASlotData
// 0x0010 (0x0010 - 0x0000)
struct FCASlotData final
{
public:
	int32                                         M_current_level;                                   // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_current_exp;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_slot_space_available;                            // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_current_item_level_up_data_index;                // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASlotData) == 0x000004, "Wrong alignment on FCASlotData");
static_assert(sizeof(FCASlotData) == 0x000010, "Wrong size on FCASlotData");
static_assert(offsetof(FCASlotData, M_current_level) == 0x000000, "Member 'FCASlotData::M_current_level' has a wrong offset!");
static_assert(offsetof(FCASlotData, M_current_exp) == 0x000004, "Member 'FCASlotData::M_current_exp' has a wrong offset!");
static_assert(offsetof(FCASlotData, M_slot_space_available) == 0x000008, "Member 'FCASlotData::M_slot_space_available' has a wrong offset!");
static_assert(offsetof(FCASlotData, M_current_item_level_up_data_index) == 0x00000C, "Member 'FCASlotData::M_current_item_level_up_data_index' has a wrong offset!");

// ScriptStruct keaton.CAColourDefinitionTableRow
// 0x0010 (0x0018 - 0x0008)
struct FCAColourDefinitionTableRow final : public FTableRowBase
{
public:
	struct FLinearColor                           M_colour;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAColourDefinitionTableRow) == 0x000008, "Wrong alignment on FCAColourDefinitionTableRow");
static_assert(sizeof(FCAColourDefinitionTableRow) == 0x000018, "Wrong size on FCAColourDefinitionTableRow");
static_assert(offsetof(FCAColourDefinitionTableRow, M_colour) == 0x000008, "Member 'FCAColourDefinitionTableRow::M_colour' has a wrong offset!");

// ScriptStruct keaton.CACombatEffectRow
// 0x0008 (0x0010 - 0x0008)
struct FCACombatEffectRow final : public FTableRowBase
{
public:
	class UNiagaraSystem*                         Niagara_system_template;                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACombatEffectRow) == 0x000008, "Wrong alignment on FCACombatEffectRow");
static_assert(sizeof(FCACombatEffectRow) == 0x000010, "Wrong size on FCACombatEffectRow");
static_assert(offsetof(FCACombatEffectRow, Niagara_system_template) == 0x000008, "Member 'FCACombatEffectRow::Niagara_system_template' has a wrong offset!");

// ScriptStruct keaton.DialogueQueuedRequest
// 0x0038 (0x0038 - 0x0000)
struct FDialogueQueuedRequest final
{
public:
	struct FVector_NetQuantize                    M_position;                                        // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            M_speaker;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACACharacter*                           M_character;                                       // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_wwise_hash;                                      // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_queue_life_time;                                 // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x4];                                       // 0x0028(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         M_team_id;                                         // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAAudioDialoguePriority                      M_priority;                                        // 0x002D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_global;                                       // 0x002E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_sfx;                                          // 0x002F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_interrupt_equal_priority;                        // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDialogueQueuedRequest) == 0x000008, "Wrong alignment on FDialogueQueuedRequest");
static_assert(sizeof(FDialogueQueuedRequest) == 0x000038, "Wrong size on FDialogueQueuedRequest");
static_assert(offsetof(FDialogueQueuedRequest, M_position) == 0x000000, "Member 'FDialogueQueuedRequest::M_position' has a wrong offset!");
static_assert(offsetof(FDialogueQueuedRequest, M_speaker) == 0x000010, "Member 'FDialogueQueuedRequest::M_speaker' has a wrong offset!");
static_assert(offsetof(FDialogueQueuedRequest, M_character) == 0x000018, "Member 'FDialogueQueuedRequest::M_character' has a wrong offset!");
static_assert(offsetof(FDialogueQueuedRequest, M_wwise_hash) == 0x000020, "Member 'FDialogueQueuedRequest::M_wwise_hash' has a wrong offset!");
static_assert(offsetof(FDialogueQueuedRequest, M_queue_life_time) == 0x000024, "Member 'FDialogueQueuedRequest::M_queue_life_time' has a wrong offset!");
static_assert(offsetof(FDialogueQueuedRequest, M_team_id) == 0x00002C, "Member 'FDialogueQueuedRequest::M_team_id' has a wrong offset!");
static_assert(offsetof(FDialogueQueuedRequest, M_priority) == 0x00002D, "Member 'FDialogueQueuedRequest::M_priority' has a wrong offset!");
static_assert(offsetof(FDialogueQueuedRequest, M_is_global) == 0x00002E, "Member 'FDialogueQueuedRequest::M_is_global' has a wrong offset!");
static_assert(offsetof(FDialogueQueuedRequest, M_is_sfx) == 0x00002F, "Member 'FDialogueQueuedRequest::M_is_sfx' has a wrong offset!");
static_assert(offsetof(FDialogueQueuedRequest, M_interrupt_equal_priority) == 0x000030, "Member 'FDialogueQueuedRequest::M_interrupt_equal_priority' has a wrong offset!");

// ScriptStruct keaton.NPCAimManagerReplicatedAimingData
// 0x0014 (0x0014 - 0x0000)
struct FNPCAimManagerReplicatedAimingData final
{
public:
	struct FRotator                               M_relative_rotation;                               // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_dist;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_rotation_in_combat;                              // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_rotation_changing_target;                        // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_rotation_tracking_aim_active;                    // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCAimManagerReplicatedAimingData) == 0x000004, "Wrong alignment on FNPCAimManagerReplicatedAimingData");
static_assert(sizeof(FNPCAimManagerReplicatedAimingData) == 0x000014, "Wrong size on FNPCAimManagerReplicatedAimingData");
static_assert(offsetof(FNPCAimManagerReplicatedAimingData, M_relative_rotation) == 0x000000, "Member 'FNPCAimManagerReplicatedAimingData::M_relative_rotation' has a wrong offset!");
static_assert(offsetof(FNPCAimManagerReplicatedAimingData, M_dist) == 0x00000C, "Member 'FNPCAimManagerReplicatedAimingData::M_dist' has a wrong offset!");
static_assert(offsetof(FNPCAimManagerReplicatedAimingData, M_rotation_in_combat) == 0x000010, "Member 'FNPCAimManagerReplicatedAimingData::M_rotation_in_combat' has a wrong offset!");
static_assert(offsetof(FNPCAimManagerReplicatedAimingData, M_rotation_changing_target) == 0x000011, "Member 'FNPCAimManagerReplicatedAimingData::M_rotation_changing_target' has a wrong offset!");
static_assert(offsetof(FNPCAimManagerReplicatedAimingData, M_rotation_tracking_aim_active) == 0x000012, "Member 'FNPCAimManagerReplicatedAimingData::M_rotation_tracking_aim_active' has a wrong offset!");

// ScriptStruct keaton.QosPingAddress
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FQosPingAddress final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQosPingAddress) == 0x000008, "Wrong alignment on FQosPingAddress");
static_assert(sizeof(FQosPingAddress) == 0x000028, "Wrong size on FQosPingAddress");

// ScriptStruct keaton.CANPCAttackData
// 0x0020 (0x0020 - 0x0000)
struct FCANPCAttackData final
{
public:
	class AActor*                                 M_attacker_actor;                                  // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_target_actor;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCAttackData) == 0x000008, "Wrong alignment on FCANPCAttackData");
static_assert(sizeof(FCANPCAttackData) == 0x000020, "Wrong size on FCANPCAttackData");
static_assert(offsetof(FCANPCAttackData, M_attacker_actor) == 0x000000, "Member 'FCANPCAttackData::M_attacker_actor' has a wrong offset!");
static_assert(offsetof(FCANPCAttackData, M_target_actor) == 0x000008, "Member 'FCANPCAttackData::M_target_actor' has a wrong offset!");

// ScriptStruct keaton.CADialogueState
// 0x0003 (0x0003 - 0x0000)
struct FCADialogueState final
{
public:
	ECADialogueState                              M_dialogue_state;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x2];                                        // 0x0001(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADialogueState) == 0x000001, "Wrong alignment on FCADialogueState");
static_assert(sizeof(FCADialogueState) == 0x000003, "Wrong size on FCADialogueState");
static_assert(offsetof(FCADialogueState, M_dialogue_state) == 0x000000, "Member 'FCADialogueState::M_dialogue_state' has a wrong offset!");

// ScriptStruct keaton.CABuffHandleCollection
// 0x0018 (0x0018 - 0x0000)
struct FCABuffHandleCollection final
{
public:
	TArray<struct FCABuffHandle>                  M_buff_handles;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         M_handles_per_buff_count;                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCABuffHandleCollection) == 0x000008, "Wrong alignment on FCABuffHandleCollection");
static_assert(sizeof(FCABuffHandleCollection) == 0x000018, "Wrong size on FCABuffHandleCollection");
static_assert(offsetof(FCABuffHandleCollection, M_buff_handles) == 0x000000, "Member 'FCABuffHandleCollection::M_buff_handles' has a wrong offset!");
static_assert(offsetof(FCABuffHandleCollection, M_handles_per_buff_count) == 0x000010, "Member 'FCABuffHandleCollection::M_handles_per_buff_count' has a wrong offset!");

// ScriptStruct keaton.CANPCGoalData
// 0x0028 (0x0028 - 0x0000)
struct FCANPCGoalData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCANPCGoal*>                     M_goals;                                           // 0x0018(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANPCGoalData) == 0x000008, "Wrong alignment on FCANPCGoalData");
static_assert(sizeof(FCANPCGoalData) == 0x000028, "Wrong size on FCANPCGoalData");
static_assert(offsetof(FCANPCGoalData, M_goals) == 0x000018, "Member 'FCANPCGoalData::M_goals' has a wrong offset!");

// ScriptStruct keaton.ScreenshotJsonFile
// 0x0020 (0x0020 - 0x0000)
struct FScreenshotJsonFile final
{
public:
	class FString                                 M_filename;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_mean_square_error;                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_different_pixel_percentage;                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_passed;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScreenshotJsonFile) == 0x000008, "Wrong alignment on FScreenshotJsonFile");
static_assert(sizeof(FScreenshotJsonFile) == 0x000020, "Wrong size on FScreenshotJsonFile");
static_assert(offsetof(FScreenshotJsonFile, M_filename) == 0x000000, "Member 'FScreenshotJsonFile::M_filename' has a wrong offset!");
static_assert(offsetof(FScreenshotJsonFile, M_mean_square_error) == 0x000010, "Member 'FScreenshotJsonFile::M_mean_square_error' has a wrong offset!");
static_assert(offsetof(FScreenshotJsonFile, M_different_pixel_percentage) == 0x000014, "Member 'FScreenshotJsonFile::M_different_pixel_percentage' has a wrong offset!");
static_assert(offsetof(FScreenshotJsonFile, M_passed) == 0x000018, "Member 'FScreenshotJsonFile::M_passed' has a wrong offset!");

// ScriptStruct keaton.ScreenshotData
// 0x0040 (0x0040 - 0x0000)
struct FScreenshotData final
{
public:
	class FString                                 M_computer_name;                                   // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_day;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_month;                                           // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_year;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_hour;                                            // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_minute;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_second;                                          // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_changelist;                                      // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FScreenshotJsonFile>            M_day_shots;                                       // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotData) == 0x000008, "Wrong alignment on FScreenshotData");
static_assert(sizeof(FScreenshotData) == 0x000040, "Wrong size on FScreenshotData");
static_assert(offsetof(FScreenshotData, M_computer_name) == 0x000000, "Member 'FScreenshotData::M_computer_name' has a wrong offset!");
static_assert(offsetof(FScreenshotData, M_day) == 0x000010, "Member 'FScreenshotData::M_day' has a wrong offset!");
static_assert(offsetof(FScreenshotData, M_month) == 0x000014, "Member 'FScreenshotData::M_month' has a wrong offset!");
static_assert(offsetof(FScreenshotData, M_year) == 0x000018, "Member 'FScreenshotData::M_year' has a wrong offset!");
static_assert(offsetof(FScreenshotData, M_hour) == 0x00001C, "Member 'FScreenshotData::M_hour' has a wrong offset!");
static_assert(offsetof(FScreenshotData, M_minute) == 0x000020, "Member 'FScreenshotData::M_minute' has a wrong offset!");
static_assert(offsetof(FScreenshotData, M_second) == 0x000024, "Member 'FScreenshotData::M_second' has a wrong offset!");
static_assert(offsetof(FScreenshotData, M_changelist) == 0x000028, "Member 'FScreenshotData::M_changelist' has a wrong offset!");
static_assert(offsetof(FScreenshotData, M_day_shots) == 0x000030, "Member 'FScreenshotData::M_day_shots' has a wrong offset!");

// ScriptStruct keaton.CANPCActiveGoalFulfillmentTrackerData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FCANPCActiveGoalFulfillmentTrackerData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCActiveGoalFulfillmentTrackerData) == 0x000004, "Wrong alignment on FCANPCActiveGoalFulfillmentTrackerData");
static_assert(sizeof(FCANPCActiveGoalFulfillmentTrackerData) == 0x000008, "Wrong size on FCANPCActiveGoalFulfillmentTrackerData");

// ScriptStruct keaton.CALootSourceData
// 0x0010 (0x0010 - 0x0000)
struct FCALootSourceData final
{
public:
	float                                         M_loot_value;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_vault_hack_time;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_hero_loot_count;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_max_pickup_count;                                // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALootSourceData) == 0x000004, "Wrong alignment on FCALootSourceData");
static_assert(sizeof(FCALootSourceData) == 0x000010, "Wrong size on FCALootSourceData");
static_assert(offsetof(FCALootSourceData, M_loot_value) == 0x000000, "Member 'FCALootSourceData::M_loot_value' has a wrong offset!");
static_assert(offsetof(FCALootSourceData, M_vault_hack_time) == 0x000004, "Member 'FCALootSourceData::M_vault_hack_time' has a wrong offset!");
static_assert(offsetof(FCALootSourceData, M_hero_loot_count) == 0x000008, "Member 'FCALootSourceData::M_hero_loot_count' has a wrong offset!");
static_assert(offsetof(FCALootSourceData, M_max_pickup_count) == 0x00000C, "Member 'FCALootSourceData::M_max_pickup_count' has a wrong offset!");

// ScriptStruct keaton.CANPCGoalArrayWrapper
// 0x0010 (0x0010 - 0x0000)
struct FCANPCGoalArrayWrapper final
{
public:
	TArray<class UCANPCGoal*>                     M_goals;                                           // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANPCGoalArrayWrapper) == 0x000008, "Wrong alignment on FCANPCGoalArrayWrapper");
static_assert(sizeof(FCANPCGoalArrayWrapper) == 0x000010, "Wrong size on FCANPCGoalArrayWrapper");
static_assert(offsetof(FCANPCGoalArrayWrapper, M_goals) == 0x000000, "Member 'FCANPCGoalArrayWrapper::M_goals' has a wrong offset!");

// ScriptStruct keaton.CATagSenseScalar
// 0x0014 (0x0014 - 0x0000)
struct FCATagSenseScalar final
{
public:
	struct FGameplayTag                           M_gameplay_tag;                                    // 0x0000(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fill_rate_scalar;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_decay_rate_scalar;                               // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATagSenseScalar) == 0x000004, "Wrong alignment on FCATagSenseScalar");
static_assert(sizeof(FCATagSenseScalar) == 0x000014, "Wrong size on FCATagSenseScalar");
static_assert(offsetof(FCATagSenseScalar, M_gameplay_tag) == 0x000000, "Member 'FCATagSenseScalar::M_gameplay_tag' has a wrong offset!");
static_assert(offsetof(FCATagSenseScalar, M_fill_rate_scalar) == 0x00000C, "Member 'FCATagSenseScalar::M_fill_rate_scalar' has a wrong offset!");
static_assert(offsetof(FCATagSenseScalar, M_decay_rate_scalar) == 0x000010, "Member 'FCATagSenseScalar::M_decay_rate_scalar' has a wrong offset!");

// ScriptStruct keaton.CASenseSet
// 0x0060 (0x0068 - 0x0008)
struct FCASenseSet final : public FTableRowBase
{
public:
	float                                         M_sense_radius_noncombat;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sense_radius_combat;                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_lose_sense_radius_modifier;                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sense_thresholds_idle[0x3];                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sense_fill_rate_unaware;                         // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sense_decay_rate_unaware;                        // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sense_thresholds_combat[0x3];                    // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sense_fill_rate_combat;                          // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sense_decay_rate_combat;                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCATagSenseScalar>              M_owner_gameplay_tag_scalars;                      // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCATagSenseScalar>              M_target_gameplay_tag_scalars;                     // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         M_sense_fill_rate_suspicious;                      // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sense_decay_rate_suspicious;                     // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASenseSet) == 0x000008, "Wrong alignment on FCASenseSet");
static_assert(sizeof(FCASenseSet) == 0x000068, "Wrong size on FCASenseSet");
static_assert(offsetof(FCASenseSet, M_sense_radius_noncombat) == 0x000008, "Member 'FCASenseSet::M_sense_radius_noncombat' has a wrong offset!");
static_assert(offsetof(FCASenseSet, M_sense_radius_combat) == 0x00000C, "Member 'FCASenseSet::M_sense_radius_combat' has a wrong offset!");
static_assert(offsetof(FCASenseSet, M_lose_sense_radius_modifier) == 0x000010, "Member 'FCASenseSet::M_lose_sense_radius_modifier' has a wrong offset!");
static_assert(offsetof(FCASenseSet, M_sense_thresholds_idle) == 0x000014, "Member 'FCASenseSet::M_sense_thresholds_idle' has a wrong offset!");
static_assert(offsetof(FCASenseSet, M_sense_fill_rate_unaware) == 0x000020, "Member 'FCASenseSet::M_sense_fill_rate_unaware' has a wrong offset!");
static_assert(offsetof(FCASenseSet, M_sense_decay_rate_unaware) == 0x000024, "Member 'FCASenseSet::M_sense_decay_rate_unaware' has a wrong offset!");
static_assert(offsetof(FCASenseSet, M_sense_thresholds_combat) == 0x000028, "Member 'FCASenseSet::M_sense_thresholds_combat' has a wrong offset!");
static_assert(offsetof(FCASenseSet, M_sense_fill_rate_combat) == 0x000034, "Member 'FCASenseSet::M_sense_fill_rate_combat' has a wrong offset!");
static_assert(offsetof(FCASenseSet, M_sense_decay_rate_combat) == 0x000038, "Member 'FCASenseSet::M_sense_decay_rate_combat' has a wrong offset!");
static_assert(offsetof(FCASenseSet, M_owner_gameplay_tag_scalars) == 0x000040, "Member 'FCASenseSet::M_owner_gameplay_tag_scalars' has a wrong offset!");
static_assert(offsetof(FCASenseSet, M_target_gameplay_tag_scalars) == 0x000050, "Member 'FCASenseSet::M_target_gameplay_tag_scalars' has a wrong offset!");
static_assert(offsetof(FCASenseSet, M_sense_fill_rate_suspicious) == 0x000060, "Member 'FCASenseSet::M_sense_fill_rate_suspicious' has a wrong offset!");
static_assert(offsetof(FCASenseSet, M_sense_decay_rate_suspicious) == 0x000064, "Member 'FCASenseSet::M_sense_decay_rate_suspicious' has a wrong offset!");

// ScriptStruct keaton.CANPCTargetObjectData
// 0x0020 (0x0020 - 0x0000)
struct FCANPCTargetObjectData final
{
public:
	class AActor*                                 M_actor;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCTargetObjectData) == 0x000008, "Wrong alignment on FCANPCTargetObjectData");
static_assert(sizeof(FCANPCTargetObjectData) == 0x000020, "Wrong size on FCANPCTargetObjectData");
static_assert(offsetof(FCANPCTargetObjectData, M_actor) == 0x000000, "Member 'FCANPCTargetObjectData::M_actor' has a wrong offset!");

// ScriptStruct keaton.CATargetLOSData
// 0x0010 (0x0010 - 0x0000)
struct FCATargetLOSData final
{
public:
	class AActor*                                 M_target;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCATargetLOSData) == 0x000008, "Wrong alignment on FCATargetLOSData");
static_assert(sizeof(FCATargetLOSData) == 0x000010, "Wrong size on FCATargetLOSData");
static_assert(offsetof(FCATargetLOSData, M_target) == 0x000000, "Member 'FCATargetLOSData::M_target' has a wrong offset!");

// ScriptStruct keaton.CAAttributeInitialisationTableHealth
// 0x0030 (0x0038 - 0x0008)
struct FCAAttributeInitialisationTableHealth final : public FTableRowBase
{
public:
	bool                                          UseHealthSet;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HealthSegment;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Health;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHealth;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAdvancedHealthSet;                              // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InjuredHealth;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DownedHealth;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAttributeSet;                                   // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseArmourSet;                                      // 0x0025(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaticArmour;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicArmour;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicMaxArmour;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmourSegment;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAttributeInitialisationTableHealth) == 0x000008, "Wrong alignment on FCAAttributeInitialisationTableHealth");
static_assert(sizeof(FCAAttributeInitialisationTableHealth) == 0x000038, "Wrong size on FCAAttributeInitialisationTableHealth");
static_assert(offsetof(FCAAttributeInitialisationTableHealth, UseHealthSet) == 0x000008, "Member 'FCAAttributeInitialisationTableHealth::UseHealthSet' has a wrong offset!");
static_assert(offsetof(FCAAttributeInitialisationTableHealth, HealthSegment) == 0x00000C, "Member 'FCAAttributeInitialisationTableHealth::HealthSegment' has a wrong offset!");
static_assert(offsetof(FCAAttributeInitialisationTableHealth, Health) == 0x000010, "Member 'FCAAttributeInitialisationTableHealth::Health' has a wrong offset!");
static_assert(offsetof(FCAAttributeInitialisationTableHealth, MaxHealth) == 0x000014, "Member 'FCAAttributeInitialisationTableHealth::MaxHealth' has a wrong offset!");
static_assert(offsetof(FCAAttributeInitialisationTableHealth, UseAdvancedHealthSet) == 0x000018, "Member 'FCAAttributeInitialisationTableHealth::UseAdvancedHealthSet' has a wrong offset!");
static_assert(offsetof(FCAAttributeInitialisationTableHealth, InjuredHealth) == 0x00001C, "Member 'FCAAttributeInitialisationTableHealth::InjuredHealth' has a wrong offset!");
static_assert(offsetof(FCAAttributeInitialisationTableHealth, DownedHealth) == 0x000020, "Member 'FCAAttributeInitialisationTableHealth::DownedHealth' has a wrong offset!");
static_assert(offsetof(FCAAttributeInitialisationTableHealth, UseAttributeSet) == 0x000024, "Member 'FCAAttributeInitialisationTableHealth::UseAttributeSet' has a wrong offset!");
static_assert(offsetof(FCAAttributeInitialisationTableHealth, UseArmourSet) == 0x000025, "Member 'FCAAttributeInitialisationTableHealth::UseArmourSet' has a wrong offset!");
static_assert(offsetof(FCAAttributeInitialisationTableHealth, StaticArmour) == 0x000028, "Member 'FCAAttributeInitialisationTableHealth::StaticArmour' has a wrong offset!");
static_assert(offsetof(FCAAttributeInitialisationTableHealth, DynamicArmour) == 0x00002C, "Member 'FCAAttributeInitialisationTableHealth::DynamicArmour' has a wrong offset!");
static_assert(offsetof(FCAAttributeInitialisationTableHealth, DynamicMaxArmour) == 0x000030, "Member 'FCAAttributeInitialisationTableHealth::DynamicMaxArmour' has a wrong offset!");
static_assert(offsetof(FCAAttributeInitialisationTableHealth, ArmourSegment) == 0x000034, "Member 'FCAAttributeInitialisationTableHealth::ArmourSegment' has a wrong offset!");

// ScriptStruct keaton.CANPCCriticalHitData
// 0x0068 (0x0068 - 0x0000)
struct FCANPCCriticalHitData final
{
public:
	class FName                                   M_bone_name;                                       // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           M_additional_bone_names;                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ECriticalHitTriggerSource                     M_trigger_source;                                  // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_crit_multiplier;                                 // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECriticalHitWeaponMultiplier                  M_weapon_multiplier;                               // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBodyPart                                     M_body_part;                                       // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAAmputationLimb                             M_limb;                                            // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffect>>    M_on_hit_gameplay_effects;                         // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_health_pool;                                     // 0x0040(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_always_apply_critical_multiplier;                // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_blocking_health_pool;                            // 0x0050(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_priority_for_bullet_magnetism;                // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_bullet_magnetism_halo;                           // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCCriticalHitData) == 0x000008, "Wrong alignment on FCANPCCriticalHitData");
static_assert(sizeof(FCANPCCriticalHitData) == 0x000068, "Wrong size on FCANPCCriticalHitData");
static_assert(offsetof(FCANPCCriticalHitData, M_bone_name) == 0x000000, "Member 'FCANPCCriticalHitData::M_bone_name' has a wrong offset!");
static_assert(offsetof(FCANPCCriticalHitData, M_additional_bone_names) == 0x000010, "Member 'FCANPCCriticalHitData::M_additional_bone_names' has a wrong offset!");
static_assert(offsetof(FCANPCCriticalHitData, M_trigger_source) == 0x000020, "Member 'FCANPCCriticalHitData::M_trigger_source' has a wrong offset!");
static_assert(offsetof(FCANPCCriticalHitData, M_crit_multiplier) == 0x000024, "Member 'FCANPCCriticalHitData::M_crit_multiplier' has a wrong offset!");
static_assert(offsetof(FCANPCCriticalHitData, M_weapon_multiplier) == 0x000028, "Member 'FCANPCCriticalHitData::M_weapon_multiplier' has a wrong offset!");
static_assert(offsetof(FCANPCCriticalHitData, M_body_part) == 0x000029, "Member 'FCANPCCriticalHitData::M_body_part' has a wrong offset!");
static_assert(offsetof(FCANPCCriticalHitData, M_limb) == 0x00002A, "Member 'FCANPCCriticalHitData::M_limb' has a wrong offset!");
static_assert(offsetof(FCANPCCriticalHitData, M_on_hit_gameplay_effects) == 0x000030, "Member 'FCANPCCriticalHitData::M_on_hit_gameplay_effects' has a wrong offset!");
static_assert(offsetof(FCANPCCriticalHitData, M_health_pool) == 0x000040, "Member 'FCANPCCriticalHitData::M_health_pool' has a wrong offset!");
static_assert(offsetof(FCANPCCriticalHitData, M_always_apply_critical_multiplier) == 0x00004C, "Member 'FCANPCCriticalHitData::M_always_apply_critical_multiplier' has a wrong offset!");
static_assert(offsetof(FCANPCCriticalHitData, M_blocking_health_pool) == 0x000050, "Member 'FCANPCCriticalHitData::M_blocking_health_pool' has a wrong offset!");
static_assert(offsetof(FCANPCCriticalHitData, M_is_priority_for_bullet_magnetism) == 0x00005C, "Member 'FCANPCCriticalHitData::M_is_priority_for_bullet_magnetism' has a wrong offset!");
static_assert(offsetof(FCANPCCriticalHitData, M_bullet_magnetism_halo) == 0x000060, "Member 'FCANPCCriticalHitData::M_bullet_magnetism_halo' has a wrong offset!");

// ScriptStruct keaton.CARuntimeNPCCriticalHitData
// 0x0078 (0x0078 - 0x0000)
struct FCARuntimeNPCCriticalHitData final
{
public:
	struct FCANPCCriticalHitData                  M_info;                                            // 0x0000(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            M_associated_components;                           // 0x0068(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARuntimeNPCCriticalHitData) == 0x000008, "Wrong alignment on FCARuntimeNPCCriticalHitData");
static_assert(sizeof(FCARuntimeNPCCriticalHitData) == 0x000078, "Wrong size on FCARuntimeNPCCriticalHitData");
static_assert(offsetof(FCARuntimeNPCCriticalHitData, M_info) == 0x000000, "Member 'FCARuntimeNPCCriticalHitData::M_info' has a wrong offset!");
static_assert(offsetof(FCARuntimeNPCCriticalHitData, M_associated_components) == 0x000068, "Member 'FCARuntimeNPCCriticalHitData::M_associated_components' has a wrong offset!");

// ScriptStruct keaton.SysAreaEvents
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FSysAreaEvents final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSysAreaEvents) == 0x000008, "Wrong alignment on FSysAreaEvents");
static_assert(sizeof(FSysAreaEvents) == 0x000010, "Wrong size on FSysAreaEvents");

// ScriptStruct keaton.SysEventsOfType
// 0x0050 (0x0050 - 0x0000)
struct FSysEventsOfType final
{
public:
	TMap<class ACASysAreaBase*, struct FSysAreaEvents> M_area_events_of_type;                             // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSysEventsOfType) == 0x000008, "Wrong alignment on FSysEventsOfType");
static_assert(sizeof(FSysEventsOfType) == 0x000050, "Wrong size on FSysEventsOfType");
static_assert(offsetof(FSysEventsOfType, M_area_events_of_type) == 0x000000, "Member 'FSysEventsOfType::M_area_events_of_type' has a wrong offset!");

// ScriptStruct keaton.CAGameplayAbilityTargetData_FoamBlobDestroyed
// 0x0010 (0x0018 - 0x0008)
struct FCAGameplayAbilityTargetData_FoamBlobDestroyed final : public FGameplayAbilityTargetData
{
public:
	struct FVector_NetQuantize                    M_location;                                        // 0x0008(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_chain_id;                                        // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAGameplayAbilityTargetData_FoamBlobDestroyed) == 0x000008, "Wrong alignment on FCAGameplayAbilityTargetData_FoamBlobDestroyed");
static_assert(sizeof(FCAGameplayAbilityTargetData_FoamBlobDestroyed) == 0x000018, "Wrong size on FCAGameplayAbilityTargetData_FoamBlobDestroyed");
static_assert(offsetof(FCAGameplayAbilityTargetData_FoamBlobDestroyed, M_location) == 0x000008, "Member 'FCAGameplayAbilityTargetData_FoamBlobDestroyed::M_location' has a wrong offset!");
static_assert(offsetof(FCAGameplayAbilityTargetData_FoamBlobDestroyed, M_chain_id) == 0x000014, "Member 'FCAGameplayAbilityTargetData_FoamBlobDestroyed::M_chain_id' has a wrong offset!");

// ScriptStruct keaton.CAColourPaletteItem
// 0x0048 (0x0048 - 0x0000)
struct FCAColourPaletteItem final
{
public:
	class FText                                   M_display_name;                                    // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCACustomisationColourPalette> M_value;                                           // 0x0018(0x0030)(Deprecated, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAColourPaletteItem) == 0x000008, "Wrong alignment on FCAColourPaletteItem");
static_assert(sizeof(FCAColourPaletteItem) == 0x000048, "Wrong size on FCAColourPaletteItem");
static_assert(offsetof(FCAColourPaletteItem, M_display_name) == 0x000000, "Member 'FCAColourPaletteItem::M_display_name' has a wrong offset!");
static_assert(offsetof(FCAColourPaletteItem, M_value) == 0x000018, "Member 'FCAColourPaletteItem::M_value' has a wrong offset!");

// ScriptStruct keaton.ReplicatedSplineSettings
// 0x0010 (0x0010 - 0x0000)
struct FReplicatedSplineSettings final
{
public:
	class USplineComponent*                       Spline_component;                                  // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spline_speed;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicatedSplineSettings) == 0x000008, "Wrong alignment on FReplicatedSplineSettings");
static_assert(sizeof(FReplicatedSplineSettings) == 0x000010, "Wrong size on FReplicatedSplineSettings");
static_assert(offsetof(FReplicatedSplineSettings, Spline_component) == 0x000000, "Member 'FReplicatedSplineSettings::Spline_component' has a wrong offset!");
static_assert(offsetof(FReplicatedSplineSettings, Spline_speed) == 0x000008, "Member 'FReplicatedSplineSettings::Spline_speed' has a wrong offset!");

// ScriptStruct keaton.CAEmissiveSlot
// 0x0018 (0x0018 - 0x0000)
struct FCAEmissiveSlot final
{
public:
	class FName                                   M_name;                                            // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_material_slot;                                   // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAEmissiveSlot) == 0x000004, "Wrong alignment on FCAEmissiveSlot");
static_assert(sizeof(FCAEmissiveSlot) == 0x000018, "Wrong size on FCAEmissiveSlot");
static_assert(offsetof(FCAEmissiveSlot, M_name) == 0x000000, "Member 'FCAEmissiveSlot::M_name' has a wrong offset!");
static_assert(offsetof(FCAEmissiveSlot, M_material_slot) == 0x00000C, "Member 'FCAEmissiveSlot::M_material_slot' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_Downed
// 0x0040 (0x0050 - 0x0010)
struct FCAMovementData_Downed final : public FCAMovementModeData
{
public:
	float                                         M_zerog_flying_speed;                              // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zerog_flying_deceleration;                       // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zerog_downwards_force;                           // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zerog_initial_pitch;                             // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zerog_no_attach_timeout;                         // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zerog_no_magboots_timeout;                       // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_zerog_no_attach_bounce_limit;                    // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_camera_angle_magboots_to_wall_crawl;             // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_wall_push_time;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_speed_crawling;                              // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCASubCapsuleData                      M_sub_capsule;                                     // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMovementData_Downed) == 0x000008, "Wrong alignment on FCAMovementData_Downed");
static_assert(sizeof(FCAMovementData_Downed) == 0x000050, "Wrong size on FCAMovementData_Downed");
static_assert(offsetof(FCAMovementData_Downed, M_zerog_flying_speed) == 0x000010, "Member 'FCAMovementData_Downed::M_zerog_flying_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Downed, M_zerog_flying_deceleration) == 0x000014, "Member 'FCAMovementData_Downed::M_zerog_flying_deceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Downed, M_zerog_downwards_force) == 0x000018, "Member 'FCAMovementData_Downed::M_zerog_downwards_force' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Downed, M_zerog_initial_pitch) == 0x00001C, "Member 'FCAMovementData_Downed::M_zerog_initial_pitch' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Downed, M_zerog_no_attach_timeout) == 0x000020, "Member 'FCAMovementData_Downed::M_zerog_no_attach_timeout' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Downed, M_zerog_no_magboots_timeout) == 0x000024, "Member 'FCAMovementData_Downed::M_zerog_no_magboots_timeout' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Downed, M_zerog_no_attach_bounce_limit) == 0x000028, "Member 'FCAMovementData_Downed::M_zerog_no_attach_bounce_limit' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Downed, M_camera_angle_magboots_to_wall_crawl) == 0x00002C, "Member 'FCAMovementData_Downed::M_camera_angle_magboots_to_wall_crawl' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Downed, M_wall_push_time) == 0x000030, "Member 'FCAMovementData_Downed::M_wall_push_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Downed, M_max_speed_crawling) == 0x000034, "Member 'FCAMovementData_Downed::M_max_speed_crawling' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Downed, M_sub_capsule) == 0x000038, "Member 'FCAMovementData_Downed::M_sub_capsule' has a wrong offset!");

// ScriptStruct keaton.CACustomisationStaticMesh
// 0x0018 (0x0018 - 0x0000)
struct FCACustomisationStaticMesh final
{
public:
	class UStaticMesh*                            M_static_mesh;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_translucency_sort_priority;                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_socket_name;                                     // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACustomisationStaticMesh) == 0x000008, "Wrong alignment on FCACustomisationStaticMesh");
static_assert(sizeof(FCACustomisationStaticMesh) == 0x000018, "Wrong size on FCACustomisationStaticMesh");
static_assert(offsetof(FCACustomisationStaticMesh, M_static_mesh) == 0x000000, "Member 'FCACustomisationStaticMesh::M_static_mesh' has a wrong offset!");
static_assert(offsetof(FCACustomisationStaticMesh, M_translucency_sort_priority) == 0x000008, "Member 'FCACustomisationStaticMesh::M_translucency_sort_priority' has a wrong offset!");
static_assert(offsetof(FCACustomisationStaticMesh, M_socket_name) == 0x00000C, "Member 'FCACustomisationStaticMesh::M_socket_name' has a wrong offset!");

// ScriptStruct keaton.CACustomisationSkeletalMesh
// 0x0020 (0x0020 - 0x0000)
struct FCACustomisationSkeletalMesh final
{
public:
	class USkeletalMesh*                          M_skeletal_mesh;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_translucency_sort_priority;                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCACustomisationAnimInstance> M_custom_anim_class;                               // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_has_physics;                                     // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCACustomisationSkeletalMesh) == 0x000008, "Wrong alignment on FCACustomisationSkeletalMesh");
static_assert(sizeof(FCACustomisationSkeletalMesh) == 0x000020, "Wrong size on FCACustomisationSkeletalMesh");
static_assert(offsetof(FCACustomisationSkeletalMesh, M_skeletal_mesh) == 0x000000, "Member 'FCACustomisationSkeletalMesh::M_skeletal_mesh' has a wrong offset!");
static_assert(offsetof(FCACustomisationSkeletalMesh, M_translucency_sort_priority) == 0x000008, "Member 'FCACustomisationSkeletalMesh::M_translucency_sort_priority' has a wrong offset!");
static_assert(offsetof(FCACustomisationSkeletalMesh, M_custom_anim_class) == 0x000010, "Member 'FCACustomisationSkeletalMesh::M_custom_anim_class' has a wrong offset!");
static_assert(offsetof(FCACustomisationSkeletalMesh, M_has_physics) == 0x000018, "Member 'FCACustomisationSkeletalMesh::M_has_physics' has a wrong offset!");

// ScriptStruct keaton.CACustomisationProperty
// 0x0010 (0x0010 - 0x0000)
struct FCACustomisationProperty final
{
public:
	class FName                                   M_name;                                            // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_value;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACustomisationProperty) == 0x000004, "Wrong alignment on FCACustomisationProperty");
static_assert(sizeof(FCACustomisationProperty) == 0x000010, "Wrong size on FCACustomisationProperty");
static_assert(offsetof(FCACustomisationProperty, M_name) == 0x000000, "Member 'FCACustomisationProperty::M_name' has a wrong offset!");
static_assert(offsetof(FCACustomisationProperty, M_value) == 0x00000C, "Member 'FCACustomisationProperty::M_value' has a wrong offset!");

// ScriptStruct keaton.CVarTest
// 0x0030 (0x0030 - 0x0000)
struct FCVarTest final
{
public:
	class FString                                 M_cvar;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_value;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCVarTest) == 0x000008, "Wrong alignment on FCVarTest");
static_assert(sizeof(FCVarTest) == 0x000030, "Wrong size on FCVarTest");
static_assert(offsetof(FCVarTest, M_cvar) == 0x000000, "Member 'FCVarTest::M_cvar' has a wrong offset!");
static_assert(offsetof(FCVarTest, M_value) == 0x000010, "Member 'FCVarTest::M_value' has a wrong offset!");

// ScriptStruct keaton.CAServicesSpecialistMasteryTableRow
// 0x0018 (0x00D8 - 0x00C0)
struct FCAServicesSpecialistMasteryTableRow final : public FCAServicesChallengeTableRow
{
public:
	struct FCAGameDatabaseRowHandle               M_specialist_handle;                               // 0x00C0(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAServicesSpecialistMasteryTableRow) == 0x000008, "Wrong alignment on FCAServicesSpecialistMasteryTableRow");
static_assert(sizeof(FCAServicesSpecialistMasteryTableRow) == 0x0000D8, "Wrong size on FCAServicesSpecialistMasteryTableRow");
static_assert(offsetof(FCAServicesSpecialistMasteryTableRow, M_specialist_handle) == 0x0000C0, "Member 'FCAServicesSpecialistMasteryTableRow::M_specialist_handle' has a wrong offset!");

// ScriptStruct keaton.CADamageBatchData
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FCADamageBatchData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_base_damage;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_armour_damage;                                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_damage_done;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_hit_point_damage;                                // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_crit_armour_damage;                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADamageBatchData) == 0x000008, "Wrong alignment on FCADamageBatchData");
static_assert(sizeof(FCADamageBatchData) == 0x000028, "Wrong size on FCADamageBatchData");
static_assert(offsetof(FCADamageBatchData, M_base_damage) == 0x000010, "Member 'FCADamageBatchData::M_base_damage' has a wrong offset!");
static_assert(offsetof(FCADamageBatchData, M_armour_damage) == 0x000014, "Member 'FCADamageBatchData::M_armour_damage' has a wrong offset!");
static_assert(offsetof(FCADamageBatchData, M_damage_done) == 0x000018, "Member 'FCADamageBatchData::M_damage_done' has a wrong offset!");
static_assert(offsetof(FCADamageBatchData, M_hit_point_damage) == 0x00001C, "Member 'FCADamageBatchData::M_hit_point_damage' has a wrong offset!");
static_assert(offsetof(FCADamageBatchData, M_crit_armour_damage) == 0x000020, "Member 'FCADamageBatchData::M_crit_armour_damage' has a wrong offset!");

// ScriptStruct keaton.CADamageGameplayEventTableValueRow
// 0x0010 (0x0018 - 0x0008)
struct FCADamageGameplayEventTableValueRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Flags;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADamageGameplayEventTableValueRow) == 0x000008, "Wrong alignment on FCADamageGameplayEventTableValueRow");
static_assert(sizeof(FCADamageGameplayEventTableValueRow) == 0x000018, "Wrong size on FCADamageGameplayEventTableValueRow");
static_assert(offsetof(FCADamageGameplayEventTableValueRow, Tag) == 0x000008, "Member 'FCADamageGameplayEventTableValueRow::Tag' has a wrong offset!");
static_assert(offsetof(FCADamageGameplayEventTableValueRow, Flags) == 0x000014, "Member 'FCADamageGameplayEventTableValueRow::Flags' has a wrong offset!");

// ScriptStruct keaton.CAServicesErrorLookup
// 0x0010 (0x0018 - 0x0008)
struct FCAServicesErrorLookup final : public FTableRowBase
{
public:
	struct FCAGameDatabaseTypedRowHandle          M_notification_data;                               // 0x0008(0x0004)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	ECAServicesErrorResponse                      M_confirm_response;                                // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAUIEventType                                M_confirm_custom_event;                            // 0x000D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAServicesErrorResponse                      M_cancel_response;                                 // 0x000E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAUIEventType                                M_cancel_custom_event;                             // 0x000F(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAServicesErrorResponse                      M_third_response;                                  // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAUIEventType                                M_third_custom_event;                              // 0x0011(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAServicesErrorLookup) == 0x000008, "Wrong alignment on FCAServicesErrorLookup");
static_assert(sizeof(FCAServicesErrorLookup) == 0x000018, "Wrong size on FCAServicesErrorLookup");
static_assert(offsetof(FCAServicesErrorLookup, M_notification_data) == 0x000008, "Member 'FCAServicesErrorLookup::M_notification_data' has a wrong offset!");
static_assert(offsetof(FCAServicesErrorLookup, M_confirm_response) == 0x00000C, "Member 'FCAServicesErrorLookup::M_confirm_response' has a wrong offset!");
static_assert(offsetof(FCAServicesErrorLookup, M_confirm_custom_event) == 0x00000D, "Member 'FCAServicesErrorLookup::M_confirm_custom_event' has a wrong offset!");
static_assert(offsetof(FCAServicesErrorLookup, M_cancel_response) == 0x00000E, "Member 'FCAServicesErrorLookup::M_cancel_response' has a wrong offset!");
static_assert(offsetof(FCAServicesErrorLookup, M_cancel_custom_event) == 0x00000F, "Member 'FCAServicesErrorLookup::M_cancel_custom_event' has a wrong offset!");
static_assert(offsetof(FCAServicesErrorLookup, M_third_response) == 0x000010, "Member 'FCAServicesErrorLookup::M_third_response' has a wrong offset!");
static_assert(offsetof(FCAServicesErrorLookup, M_third_custom_event) == 0x000011, "Member 'FCAServicesErrorLookup::M_third_custom_event' has a wrong offset!");

// ScriptStruct keaton.CADeathContext
// 0x0318 (0x0318 - 0x0000)
struct FCADeathContext final
{
public:
	ECADeathSource                                Death_source;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNetworkedHit                          Hit;                                               // 0x0008(0x0068)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    Death_gameplay_effect_spec;                        // 0x0070(0x0298)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Damage_magnitude;                                  // 0x0308(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Killed_by;                                         // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADeathContext) == 0x000008, "Wrong alignment on FCADeathContext");
static_assert(sizeof(FCADeathContext) == 0x000318, "Wrong size on FCADeathContext");
static_assert(offsetof(FCADeathContext, Death_source) == 0x000000, "Member 'FCADeathContext::Death_source' has a wrong offset!");
static_assert(offsetof(FCADeathContext, Hit) == 0x000008, "Member 'FCADeathContext::Hit' has a wrong offset!");
static_assert(offsetof(FCADeathContext, Death_gameplay_effect_spec) == 0x000070, "Member 'FCADeathContext::Death_gameplay_effect_spec' has a wrong offset!");
static_assert(offsetof(FCADeathContext, Damage_magnitude) == 0x000308, "Member 'FCADeathContext::Damage_magnitude' has a wrong offset!");
static_assert(offsetof(FCADeathContext, Killed_by) == 0x000310, "Member 'FCADeathContext::Killed_by' has a wrong offset!");

// ScriptStruct keaton.CustomWeaponDamageParams
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FCustomWeaponDamageParams final
{
public:
	TWeakObjectPtr<class UCurveFloat>             M_custom_damage_curve;                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_weapon_range;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x14];                                       // 0x000C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomWeaponDamageParams) == 0x000008, "Wrong alignment on FCustomWeaponDamageParams");
static_assert(sizeof(FCustomWeaponDamageParams) == 0x000020, "Wrong size on FCustomWeaponDamageParams");
static_assert(offsetof(FCustomWeaponDamageParams, M_custom_damage_curve) == 0x000000, "Member 'FCustomWeaponDamageParams::M_custom_damage_curve' has a wrong offset!");
static_assert(offsetof(FCustomWeaponDamageParams, M_weapon_range) == 0x000008, "Member 'FCustomWeaponDamageParams::M_weapon_range' has a wrong offset!");

// ScriptStruct keaton.DebugData
// 0x0004 (0x0004 - 0x0000)
struct FDebugData final
{
public:
	uint32                                        M_flags;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugData) == 0x000004, "Wrong alignment on FDebugData");
static_assert(sizeof(FDebugData) == 0x000004, "Wrong size on FDebugData");
static_assert(offsetof(FDebugData, M_flags) == 0x000000, "Member 'FDebugData::M_flags' has a wrong offset!");

// ScriptStruct keaton.CAFriendsPlayerCardInfo
// 0x00B0 (0x00B0 - 0x0000)
struct FCAFriendsPlayerCardInfo final
{
public:
	class FText                                   M_player_name;                                     // 0x0000(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_platform_icon;                                   // 0x0018(0x0030)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_player_platform;                                 // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_player_status;                                   // 0x0060(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          M_is_online;                                       // 0x0078(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAUIFriendInviteStatus                       M_invite_status;                                   // 0x0079(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_user_id_as_string;                               // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_prestige_level;                                  // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x1C];                                      // 0x0094(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAFriendsPlayerCardInfo) == 0x000008, "Wrong alignment on FCAFriendsPlayerCardInfo");
static_assert(sizeof(FCAFriendsPlayerCardInfo) == 0x0000B0, "Wrong size on FCAFriendsPlayerCardInfo");
static_assert(offsetof(FCAFriendsPlayerCardInfo, M_player_name) == 0x000000, "Member 'FCAFriendsPlayerCardInfo::M_player_name' has a wrong offset!");
static_assert(offsetof(FCAFriendsPlayerCardInfo, M_platform_icon) == 0x000018, "Member 'FCAFriendsPlayerCardInfo::M_platform_icon' has a wrong offset!");
static_assert(offsetof(FCAFriendsPlayerCardInfo, M_player_platform) == 0x000048, "Member 'FCAFriendsPlayerCardInfo::M_player_platform' has a wrong offset!");
static_assert(offsetof(FCAFriendsPlayerCardInfo, M_player_status) == 0x000060, "Member 'FCAFriendsPlayerCardInfo::M_player_status' has a wrong offset!");
static_assert(offsetof(FCAFriendsPlayerCardInfo, M_is_online) == 0x000078, "Member 'FCAFriendsPlayerCardInfo::M_is_online' has a wrong offset!");
static_assert(offsetof(FCAFriendsPlayerCardInfo, M_invite_status) == 0x000079, "Member 'FCAFriendsPlayerCardInfo::M_invite_status' has a wrong offset!");
static_assert(offsetof(FCAFriendsPlayerCardInfo, M_user_id_as_string) == 0x000080, "Member 'FCAFriendsPlayerCardInfo::M_user_id_as_string' has a wrong offset!");
static_assert(offsetof(FCAFriendsPlayerCardInfo, M_prestige_level) == 0x000090, "Member 'FCAFriendsPlayerCardInfo::M_prestige_level' has a wrong offset!");

// ScriptStruct keaton.CADebugTextCollector
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FCADebugTextCollector final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADebugTextCollector) == 0x000008, "Wrong alignment on FCADebugTextCollector");
static_assert(sizeof(FCADebugTextCollector) == 0x000018, "Wrong size on FCADebugTextCollector");

// ScriptStruct keaton.CATeamEmojiRow
// 0x0008 (0x0010 - 0x0008)
struct FCATeamEmojiRow final : public FTableRowBase
{
public:
	class UTexture2D*                             M_team_emoji_icon;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATeamEmojiRow) == 0x000008, "Wrong alignment on FCATeamEmojiRow");
static_assert(sizeof(FCATeamEmojiRow) == 0x000010, "Wrong size on FCATeamEmojiRow");
static_assert(offsetof(FCATeamEmojiRow, M_team_emoji_icon) == 0x000008, "Member 'FCATeamEmojiRow::M_team_emoji_icon' has a wrong offset!");

// ScriptStruct keaton.CAServicesDebugInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FCAServicesDebugInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAServicesDebugInfo) == 0x000008, "Wrong alignment on FCAServicesDebugInfo");
static_assert(sizeof(FCAServicesDebugInfo) == 0x000020, "Wrong size on FCAServicesDebugInfo");

// ScriptStruct keaton.CAGMCItemSlot
// 0x0130 (0x0130 - 0x0000)
struct FCAGMCItemSlot final
{
public:
	struct FGameplayTag                           M_slot_tag;                                        // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            M_resource_trickle;                                // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_resource_trickle_tag;                            // 0x0018(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAGMCSlotAttributeSet                 M_slot_attributes;                                 // 0x0028(0x00A8)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            M_throw_action_block_effect;                       // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAEffectWithSetByCallerTags           M_refill_GE;                                       // 0x00D8(0x0040)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UCAInventoryItem*                       M_held_item_ptr;                                   // 0x0118(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCALevelUpMetadata*                     M_held_item_metadata;                              // 0x0120(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_item_max_level;                                  // 0x0128(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_item_current_level;                              // 0x012C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAGMCItemSlot) == 0x000008, "Wrong alignment on FCAGMCItemSlot");
static_assert(sizeof(FCAGMCItemSlot) == 0x000130, "Wrong size on FCAGMCItemSlot");
static_assert(offsetof(FCAGMCItemSlot, M_slot_tag) == 0x000000, "Member 'FCAGMCItemSlot::M_slot_tag' has a wrong offset!");
static_assert(offsetof(FCAGMCItemSlot, M_resource_trickle) == 0x000010, "Member 'FCAGMCItemSlot::M_resource_trickle' has a wrong offset!");
static_assert(offsetof(FCAGMCItemSlot, M_resource_trickle_tag) == 0x000018, "Member 'FCAGMCItemSlot::M_resource_trickle_tag' has a wrong offset!");
static_assert(offsetof(FCAGMCItemSlot, M_slot_attributes) == 0x000028, "Member 'FCAGMCItemSlot::M_slot_attributes' has a wrong offset!");
static_assert(offsetof(FCAGMCItemSlot, M_throw_action_block_effect) == 0x0000D0, "Member 'FCAGMCItemSlot::M_throw_action_block_effect' has a wrong offset!");
static_assert(offsetof(FCAGMCItemSlot, M_refill_GE) == 0x0000D8, "Member 'FCAGMCItemSlot::M_refill_GE' has a wrong offset!");
static_assert(offsetof(FCAGMCItemSlot, M_held_item_ptr) == 0x000118, "Member 'FCAGMCItemSlot::M_held_item_ptr' has a wrong offset!");
static_assert(offsetof(FCAGMCItemSlot, M_held_item_metadata) == 0x000120, "Member 'FCAGMCItemSlot::M_held_item_metadata' has a wrong offset!");
static_assert(offsetof(FCAGMCItemSlot, M_item_max_level) == 0x000128, "Member 'FCAGMCItemSlot::M_item_max_level' has a wrong offset!");
static_assert(offsetof(FCAGMCItemSlot, M_item_current_level) == 0x00012C, "Member 'FCAGMCItemSlot::M_item_current_level' has a wrong offset!");

// ScriptStruct keaton.InitialLoadoutInfo
// 0x0040 (0x0040 - 0x0000)
struct FInitialLoadoutInfo final
{
public:
	class UCAInventoryItem*                       M_item;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_skin;                                            // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_cosmetic;                                        // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_amount;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_respawn_amount;                                  // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_max_amount;                                      // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECALoadoutSlot                                M_slot_type;                                       // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_item_definition_id;                              // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInitialLoadoutInfo) == 0x000008, "Wrong alignment on FInitialLoadoutInfo");
static_assert(sizeof(FInitialLoadoutInfo) == 0x000040, "Wrong size on FInitialLoadoutInfo");
static_assert(offsetof(FInitialLoadoutInfo, M_item) == 0x000000, "Member 'FInitialLoadoutInfo::M_item' has a wrong offset!");
static_assert(offsetof(FInitialLoadoutInfo, M_skin) == 0x000008, "Member 'FInitialLoadoutInfo::M_skin' has a wrong offset!");
static_assert(offsetof(FInitialLoadoutInfo, M_cosmetic) == 0x000014, "Member 'FInitialLoadoutInfo::M_cosmetic' has a wrong offset!");
static_assert(offsetof(FInitialLoadoutInfo, M_amount) == 0x000020, "Member 'FInitialLoadoutInfo::M_amount' has a wrong offset!");
static_assert(offsetof(FInitialLoadoutInfo, M_respawn_amount) == 0x000024, "Member 'FInitialLoadoutInfo::M_respawn_amount' has a wrong offset!");
static_assert(offsetof(FInitialLoadoutInfo, M_max_amount) == 0x000028, "Member 'FInitialLoadoutInfo::M_max_amount' has a wrong offset!");
static_assert(offsetof(FInitialLoadoutInfo, M_slot_type) == 0x00002C, "Member 'FInitialLoadoutInfo::M_slot_type' has a wrong offset!");
static_assert(offsetof(FInitialLoadoutInfo, M_item_definition_id) == 0x000030, "Member 'FInitialLoadoutInfo::M_item_definition_id' has a wrong offset!");

// ScriptStruct keaton.CADefaultPlayerInventoryData
// 0x0038 (0x0040 - 0x0008)
struct FCADefaultPlayerInventoryData final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UCAInventoryItem>        M_equipment;                                       // 0x0008(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x4];                                       // 0x0038(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	ECALoadoutSlot                                M_type;                                            // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADefaultPlayerInventoryData) == 0x000008, "Wrong alignment on FCADefaultPlayerInventoryData");
static_assert(sizeof(FCADefaultPlayerInventoryData) == 0x000040, "Wrong size on FCADefaultPlayerInventoryData");
static_assert(offsetof(FCADefaultPlayerInventoryData, M_equipment) == 0x000008, "Member 'FCADefaultPlayerInventoryData::M_equipment' has a wrong offset!");
static_assert(offsetof(FCADefaultPlayerInventoryData, M_type) == 0x00003C, "Member 'FCADefaultPlayerInventoryData::M_type' has a wrong offset!");

// ScriptStruct keaton.CAServicesCheatCommand
// 0x0030 (0x0030 - 0x0000)
struct FCAServicesCheatCommand final
{
public:
	class FString                                 M_command;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_description;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_services_event;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAServicesCheatCommand) == 0x000008, "Wrong alignment on FCAServicesCheatCommand");
static_assert(sizeof(FCAServicesCheatCommand) == 0x000030, "Wrong size on FCAServicesCheatCommand");
static_assert(offsetof(FCAServicesCheatCommand, M_command) == 0x000000, "Member 'FCAServicesCheatCommand::M_command' has a wrong offset!");
static_assert(offsetof(FCAServicesCheatCommand, M_description) == 0x000010, "Member 'FCAServicesCheatCommand::M_description' has a wrong offset!");
static_assert(offsetof(FCAServicesCheatCommand, M_services_event) == 0x000020, "Member 'FCAServicesCheatCommand::M_services_event' has a wrong offset!");

// ScriptStruct keaton.CAUnstableReactionCandidateTransforms
// 0x0010 (0x0010 - 0x0000)
struct FCAUnstableReactionCandidateTransforms final
{
public:
	TArray<struct FTransform>                     M_transforms;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAUnstableReactionCandidateTransforms) == 0x000008, "Wrong alignment on FCAUnstableReactionCandidateTransforms");
static_assert(sizeof(FCAUnstableReactionCandidateTransforms) == 0x000010, "Wrong size on FCAUnstableReactionCandidateTransforms");
static_assert(offsetof(FCAUnstableReactionCandidateTransforms, M_transforms) == 0x000000, "Member 'FCAUnstableReactionCandidateTransforms::M_transforms' has a wrong offset!");

// ScriptStruct keaton.CAMeshLightSlot
// 0x0028 (0x0028 - 0x0000)
struct FCAMeshLightSlot final
{
public:
	class UMeshComponent*                         Mesh;                                              // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Material_slot_index;                               // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               Dynamic_material;                                  // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min_intensity_range;                               // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max_intensity_range;                               // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULightComponent*                        Light_component;                                   // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMeshLightSlot) == 0x000008, "Wrong alignment on FCAMeshLightSlot");
static_assert(sizeof(FCAMeshLightSlot) == 0x000028, "Wrong size on FCAMeshLightSlot");
static_assert(offsetof(FCAMeshLightSlot, Mesh) == 0x000000, "Member 'FCAMeshLightSlot::Mesh' has a wrong offset!");
static_assert(offsetof(FCAMeshLightSlot, Material_slot_index) == 0x000008, "Member 'FCAMeshLightSlot::Material_slot_index' has a wrong offset!");
static_assert(offsetof(FCAMeshLightSlot, Dynamic_material) == 0x000010, "Member 'FCAMeshLightSlot::Dynamic_material' has a wrong offset!");
static_assert(offsetof(FCAMeshLightSlot, Min_intensity_range) == 0x000018, "Member 'FCAMeshLightSlot::Min_intensity_range' has a wrong offset!");
static_assert(offsetof(FCAMeshLightSlot, Max_intensity_range) == 0x00001C, "Member 'FCAMeshLightSlot::Max_intensity_range' has a wrong offset!");
static_assert(offsetof(FCAMeshLightSlot, Light_component) == 0x000020, "Member 'FCAMeshLightSlot::Light_component' has a wrong offset!");

// ScriptStruct keaton.CADialogueDataTable
// 0x0030 (0x0038 - 0x0008)
struct FCADialogueDataTable final : public FTableRowBase
{
public:
	class FString                                 RulePath;                                          // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResponsePath;                                      // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterName;                                     // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADialogueDataTable) == 0x000008, "Wrong alignment on FCADialogueDataTable");
static_assert(sizeof(FCADialogueDataTable) == 0x000038, "Wrong size on FCADialogueDataTable");
static_assert(offsetof(FCADialogueDataTable, RulePath) == 0x000008, "Member 'FCADialogueDataTable::RulePath' has a wrong offset!");
static_assert(offsetof(FCADialogueDataTable, ResponsePath) == 0x000018, "Member 'FCADialogueDataTable::ResponsePath' has a wrong offset!");
static_assert(offsetof(FCADialogueDataTable, CharacterName) == 0x000028, "Member 'FCADialogueDataTable::CharacterName' has a wrong offset!");

// ScriptStruct keaton.CADialogueEventTableRow
// 0x0010 (0x0018 - 0x0008)
struct FCADialogueEventTableRow final : public FTableRowBase
{
public:
	uint16                                        EventValue;                                        // 0x0008(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EventHash;                                         // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADialogueEventTableRow) == 0x000008, "Wrong alignment on FCADialogueEventTableRow");
static_assert(sizeof(FCADialogueEventTableRow) == 0x000018, "Wrong size on FCADialogueEventTableRow");
static_assert(offsetof(FCADialogueEventTableRow, EventValue) == 0x000008, "Member 'FCADialogueEventTableRow::EventValue' has a wrong offset!");
static_assert(offsetof(FCADialogueEventTableRow, EventHash) == 0x00000C, "Member 'FCADialogueEventTableRow::EventHash' has a wrong offset!");

// ScriptStruct keaton.CADialogueTableRow
// 0x01A0 (0x01A8 - 0x0008)
struct FCADialogueTableRow final : public FTableRowBase
{
public:
	struct FCAText                                M_title;                                           // 0x0008(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_message;                                         // 0x0038(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_appear_audio;                                    // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_confirm_text;                                    // 0x0070(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_confirm_audio;                                   // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_cancel_text;                                     // 0x00A8(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_cancel_audio;                                    // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_third_option_text;                               // 0x00E0(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAPlatformSpecificOptionText>  M_third_option_platform_specific_texts;            // 0x0110(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseTypedRowHandle          M_screen_handle;                                   // 0x0120(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	ECANotificationPriority                       M_priority;                                        // 0x0124(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_screen_time;                                     // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_mediator;                                        // 0x0130(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_image;                                           // 0x0160(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           M_colour;                                          // 0x0190(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_add_to_notification_history;                     // 0x01A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_show_avatar;                                     // 0x01A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A2[0x6];                                      // 0x01A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADialogueTableRow) == 0x000008, "Wrong alignment on FCADialogueTableRow");
static_assert(sizeof(FCADialogueTableRow) == 0x0001A8, "Wrong size on FCADialogueTableRow");
static_assert(offsetof(FCADialogueTableRow, M_title) == 0x000008, "Member 'FCADialogueTableRow::M_title' has a wrong offset!");
static_assert(offsetof(FCADialogueTableRow, M_message) == 0x000038, "Member 'FCADialogueTableRow::M_message' has a wrong offset!");
static_assert(offsetof(FCADialogueTableRow, M_appear_audio) == 0x000068, "Member 'FCADialogueTableRow::M_appear_audio' has a wrong offset!");
static_assert(offsetof(FCADialogueTableRow, M_confirm_text) == 0x000070, "Member 'FCADialogueTableRow::M_confirm_text' has a wrong offset!");
static_assert(offsetof(FCADialogueTableRow, M_confirm_audio) == 0x0000A0, "Member 'FCADialogueTableRow::M_confirm_audio' has a wrong offset!");
static_assert(offsetof(FCADialogueTableRow, M_cancel_text) == 0x0000A8, "Member 'FCADialogueTableRow::M_cancel_text' has a wrong offset!");
static_assert(offsetof(FCADialogueTableRow, M_cancel_audio) == 0x0000D8, "Member 'FCADialogueTableRow::M_cancel_audio' has a wrong offset!");
static_assert(offsetof(FCADialogueTableRow, M_third_option_text) == 0x0000E0, "Member 'FCADialogueTableRow::M_third_option_text' has a wrong offset!");
static_assert(offsetof(FCADialogueTableRow, M_third_option_platform_specific_texts) == 0x000110, "Member 'FCADialogueTableRow::M_third_option_platform_specific_texts' has a wrong offset!");
static_assert(offsetof(FCADialogueTableRow, M_screen_handle) == 0x000120, "Member 'FCADialogueTableRow::M_screen_handle' has a wrong offset!");
static_assert(offsetof(FCADialogueTableRow, M_priority) == 0x000124, "Member 'FCADialogueTableRow::M_priority' has a wrong offset!");
static_assert(offsetof(FCADialogueTableRow, M_screen_time) == 0x000128, "Member 'FCADialogueTableRow::M_screen_time' has a wrong offset!");
static_assert(offsetof(FCADialogueTableRow, M_mediator) == 0x000130, "Member 'FCADialogueTableRow::M_mediator' has a wrong offset!");
static_assert(offsetof(FCADialogueTableRow, M_image) == 0x000160, "Member 'FCADialogueTableRow::M_image' has a wrong offset!");
static_assert(offsetof(FCADialogueTableRow, M_colour) == 0x000190, "Member 'FCADialogueTableRow::M_colour' has a wrong offset!");
static_assert(offsetof(FCADialogueTableRow, M_add_to_notification_history) == 0x0001A0, "Member 'FCADialogueTableRow::M_add_to_notification_history' has a wrong offset!");
static_assert(offsetof(FCADialogueTableRow, M_show_avatar) == 0x0001A1, "Member 'FCADialogueTableRow::M_show_avatar' has a wrong offset!");

// ScriptStruct keaton.CADialogueRelationshipData
// 0x0018 (0x0020 - 0x0008)
struct FCADialogueRelationshipData final : public FTableRowBase
{
public:
	struct FCAAudioSwitchValueType                Specialist;                                        // 0x0008(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAAudioSwitchValueType>        Relationships;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADialogueRelationshipData) == 0x000008, "Wrong alignment on FCADialogueRelationshipData");
static_assert(sizeof(FCADialogueRelationshipData) == 0x000020, "Wrong size on FCADialogueRelationshipData");
static_assert(offsetof(FCADialogueRelationshipData, Specialist) == 0x000008, "Member 'FCADialogueRelationshipData::Specialist' has a wrong offset!");
static_assert(offsetof(FCADialogueRelationshipData, Relationships) == 0x000010, "Member 'FCADialogueRelationshipData::Relationships' has a wrong offset!");

// ScriptStruct keaton.CADialogueRuleData
// 0x0020 (0x0028 - 0x0008)
struct FCADialogueRuleData final : public FTableRowBase
{
public:
	struct FCAHashableString                      RuleName;                                          // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAHashableString                      Key;                                               // 0x000C(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAHashableString                      Operator;                                          // 0x0010(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAHashableString                      Value;                                             // 0x0014(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScoreModifier;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAHashableString                      Scope;                                             // 0x001C(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAHashableString                      ValueType;                                         // 0x0020(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADialogueRuleData) == 0x000008, "Wrong alignment on FCADialogueRuleData");
static_assert(sizeof(FCADialogueRuleData) == 0x000028, "Wrong size on FCADialogueRuleData");
static_assert(offsetof(FCADialogueRuleData, RuleName) == 0x000008, "Member 'FCADialogueRuleData::RuleName' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleData, Key) == 0x00000C, "Member 'FCADialogueRuleData::Key' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleData, Operator) == 0x000010, "Member 'FCADialogueRuleData::Operator' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleData, Value) == 0x000014, "Member 'FCADialogueRuleData::Value' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleData, ScoreModifier) == 0x000018, "Member 'FCADialogueRuleData::ScoreModifier' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleData, Scope) == 0x00001C, "Member 'FCADialogueRuleData::Scope' has a wrong offset!");
static_assert(offsetof(FCADialogueRuleData, ValueType) == 0x000020, "Member 'FCADialogueRuleData::ValueType' has a wrong offset!");

// ScriptStruct keaton.CADialogueSpecialistInfo
// 0x0020 (0x0028 - 0x0008)
struct FCADialogueSpecialistInfo final : public FTableRowBase
{
public:
	class FName                                   DialogueName;                                      // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAGender                                     Gender;                                            // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DialoguePrefix;                                    // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADialogueSpecialistInfo) == 0x000008, "Wrong alignment on FCADialogueSpecialistInfo");
static_assert(sizeof(FCADialogueSpecialistInfo) == 0x000028, "Wrong size on FCADialogueSpecialistInfo");
static_assert(offsetof(FCADialogueSpecialistInfo, DialogueName) == 0x000008, "Member 'FCADialogueSpecialistInfo::DialogueName' has a wrong offset!");
static_assert(offsetof(FCADialogueSpecialistInfo, Gender) == 0x000014, "Member 'FCADialogueSpecialistInfo::Gender' has a wrong offset!");
static_assert(offsetof(FCADialogueSpecialistInfo, DialoguePrefix) == 0x000018, "Member 'FCADialogueSpecialistInfo::DialoguePrefix' has a wrong offset!");

// ScriptStruct keaton.CADragQueenAbilityBalancingTableRow
// 0x0008 (0x0010 - 0x0008)
struct FCADragQueenAbilityBalancingTableRow final : public FTableRowBase
{
public:
	ECADragQueenBalancingVariableType             M_variable_type;                                   // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_value;                                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADragQueenAbilityBalancingTableRow) == 0x000008, "Wrong alignment on FCADragQueenAbilityBalancingTableRow");
static_assert(sizeof(FCADragQueenAbilityBalancingTableRow) == 0x000010, "Wrong size on FCADragQueenAbilityBalancingTableRow");
static_assert(offsetof(FCADragQueenAbilityBalancingTableRow, M_variable_type) == 0x000008, "Member 'FCADragQueenAbilityBalancingTableRow::M_variable_type' has a wrong offset!");
static_assert(offsetof(FCADragQueenAbilityBalancingTableRow, M_value) == 0x00000C, "Member 'FCADragQueenAbilityBalancingTableRow::M_value' has a wrong offset!");

// ScriptStruct keaton.CAImpactEffectRequest
// 0x00C8 (0x00C8 - 0x0000)
struct FCAImpactEffectRequest final
{
public:
	class ACAImpactEffect*                        Impact_effect;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit_result;                                        // 0x0008(0x0090)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FInstantHitImpactMetaData              Meta_data;                                         // 0x0098(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAImpactEffectRequest) == 0x000008, "Wrong alignment on FCAImpactEffectRequest");
static_assert(sizeof(FCAImpactEffectRequest) == 0x0000C8, "Wrong size on FCAImpactEffectRequest");
static_assert(offsetof(FCAImpactEffectRequest, Impact_effect) == 0x000000, "Member 'FCAImpactEffectRequest::Impact_effect' has a wrong offset!");
static_assert(offsetof(FCAImpactEffectRequest, Hit_result) == 0x000008, "Member 'FCAImpactEffectRequest::Hit_result' has a wrong offset!");
static_assert(offsetof(FCAImpactEffectRequest, Meta_data) == 0x000098, "Member 'FCAImpactEffectRequest::Meta_data' has a wrong offset!");

// ScriptStruct keaton.CAEmitterEnabledState
// 0x0010 (0x0010 - 0x0000)
struct FCAEmitterEnabledState final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x000C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAEmitterEnabledState) == 0x000004, "Wrong alignment on FCAEmitterEnabledState");
static_assert(sizeof(FCAEmitterEnabledState) == 0x000010, "Wrong size on FCAEmitterEnabledState");
static_assert(offsetof(FCAEmitterEnabledState, Name) == 0x000000, "Member 'FCAEmitterEnabledState::Name' has a wrong offset!");
static_assert(offsetof(FCAEmitterEnabledState, Enabled) == 0x00000C, "Member 'FCAEmitterEnabledState::Enabled' has a wrong offset!");

// ScriptStruct keaton.CAEquiptmentCosmeticData
// 0x00E8 (0x00E8 - 0x0000)
struct FCAEquiptmentCosmeticData final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           M_mesh_1p;                                         // 0x0000(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           M_mesh_3p;                                         // 0x0030(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             M_static_mesh;                                     // 0x0060(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAOverrideMaterial>            M_override_materials;                              // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_magazine_physics_prop;                           // 0x00A0(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           M_magazine_alt_mesh;                               // 0x00B8(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAEquiptmentCosmeticData) == 0x000008, "Wrong alignment on FCAEquiptmentCosmeticData");
static_assert(sizeof(FCAEquiptmentCosmeticData) == 0x0000E8, "Wrong size on FCAEquiptmentCosmeticData");
static_assert(offsetof(FCAEquiptmentCosmeticData, M_mesh_1p) == 0x000000, "Member 'FCAEquiptmentCosmeticData::M_mesh_1p' has a wrong offset!");
static_assert(offsetof(FCAEquiptmentCosmeticData, M_mesh_3p) == 0x000030, "Member 'FCAEquiptmentCosmeticData::M_mesh_3p' has a wrong offset!");
static_assert(offsetof(FCAEquiptmentCosmeticData, M_static_mesh) == 0x000060, "Member 'FCAEquiptmentCosmeticData::M_static_mesh' has a wrong offset!");
static_assert(offsetof(FCAEquiptmentCosmeticData, M_override_materials) == 0x000090, "Member 'FCAEquiptmentCosmeticData::M_override_materials' has a wrong offset!");
static_assert(offsetof(FCAEquiptmentCosmeticData, M_magazine_physics_prop) == 0x0000A0, "Member 'FCAEquiptmentCosmeticData::M_magazine_physics_prop' has a wrong offset!");
static_assert(offsetof(FCAEquiptmentCosmeticData, M_magazine_alt_mesh) == 0x0000B8, "Member 'FCAEquiptmentCosmeticData::M_magazine_alt_mesh' has a wrong offset!");

// ScriptStruct keaton.EquipmentAbilitiesInfo
// 0x0008 (0x0008 - 0x0000)
struct FEquipmentAbilitiesInfo final
{
public:
	class ACAEquipmentBase*                       M_equipment;                                       // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipmentAbilitiesInfo) == 0x000008, "Wrong alignment on FEquipmentAbilitiesInfo");
static_assert(sizeof(FEquipmentAbilitiesInfo) == 0x000008, "Wrong size on FEquipmentAbilitiesInfo");
static_assert(offsetof(FEquipmentAbilitiesInfo, M_equipment) == 0x000000, "Member 'FEquipmentAbilitiesInfo::M_equipment' has a wrong offset!");

// ScriptStruct keaton.MountingInfo
// 0x0070 (0x0070 - 0x0000)
struct FMountingInfo final
{
public:
	EEquipmentSlotID                              M_slot_id;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_mounting_type;                                   // 0x0004(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEquipmentSlotPriority                        M_slot_priority;                                   // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_socket_name_fp;                                  // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_socket_name_tp;                                  // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        M_scene_component_fp;                              // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        M_scene_component_tp;                              // 0x0038(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             M_fake_socket_transform;                           // 0x0040(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMountingInfo) == 0x000010, "Wrong alignment on FMountingInfo");
static_assert(sizeof(FMountingInfo) == 0x000070, "Wrong size on FMountingInfo");
static_assert(offsetof(FMountingInfo, M_slot_id) == 0x000000, "Member 'FMountingInfo::M_slot_id' has a wrong offset!");
static_assert(offsetof(FMountingInfo, M_mounting_type) == 0x000004, "Member 'FMountingInfo::M_mounting_type' has a wrong offset!");
static_assert(offsetof(FMountingInfo, M_slot_priority) == 0x000010, "Member 'FMountingInfo::M_slot_priority' has a wrong offset!");
static_assert(offsetof(FMountingInfo, M_socket_name_fp) == 0x000014, "Member 'FMountingInfo::M_socket_name_fp' has a wrong offset!");
static_assert(offsetof(FMountingInfo, M_socket_name_tp) == 0x000020, "Member 'FMountingInfo::M_socket_name_tp' has a wrong offset!");
static_assert(offsetof(FMountingInfo, M_scene_component_fp) == 0x000030, "Member 'FMountingInfo::M_scene_component_fp' has a wrong offset!");
static_assert(offsetof(FMountingInfo, M_scene_component_tp) == 0x000038, "Member 'FMountingInfo::M_scene_component_tp' has a wrong offset!");
static_assert(offsetof(FMountingInfo, M_fake_socket_transform) == 0x000040, "Member 'FMountingInfo::M_fake_socket_transform' has a wrong offset!");

// ScriptStruct keaton.EquipmentSlotCompatibility
// 0x0002 (0x0002 - 0x0000)
struct FEquipmentSlotCompatibility final
{
public:
	EEquipmentSlotID                              M_slot_id_one;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEquipmentSlotID                              M_slot_id_two;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipmentSlotCompatibility) == 0x000001, "Wrong alignment on FEquipmentSlotCompatibility");
static_assert(sizeof(FEquipmentSlotCompatibility) == 0x000002, "Wrong size on FEquipmentSlotCompatibility");
static_assert(offsetof(FEquipmentSlotCompatibility, M_slot_id_one) == 0x000000, "Member 'FEquipmentSlotCompatibility::M_slot_id_one' has a wrong offset!");
static_assert(offsetof(FEquipmentSlotCompatibility, M_slot_id_two) == 0x000001, "Member 'FEquipmentSlotCompatibility::M_slot_id_two' has a wrong offset!");

// ScriptStruct keaton.ExtraInputData
// 0x0074 (0x0074 - 0x0000)
struct alignas(0x04) FExtraInputData final
{
public:
	uint8                                         Pad_0[0x74];                                       // 0x0000(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExtraInputData) == 0x000004, "Wrong alignment on FExtraInputData");
static_assert(sizeof(FExtraInputData) == 0x000074, "Wrong size on FExtraInputData");

// ScriptStruct keaton.CAFastPathDebrisCharacterMovementImpulse
// 0x0020 (0x0020 - 0x0000)
struct FCAFastPathDebrisCharacterMovementImpulse final
{
public:
	struct FVector                                Movement_start;                                    // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Movement_end;                                      // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Character_radius;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFastPathDebrisCharacterMovementImpulse) == 0x000004, "Wrong alignment on FCAFastPathDebrisCharacterMovementImpulse");
static_assert(sizeof(FCAFastPathDebrisCharacterMovementImpulse) == 0x000020, "Wrong size on FCAFastPathDebrisCharacterMovementImpulse");
static_assert(offsetof(FCAFastPathDebrisCharacterMovementImpulse, Movement_start) == 0x000000, "Member 'FCAFastPathDebrisCharacterMovementImpulse::Movement_start' has a wrong offset!");
static_assert(offsetof(FCAFastPathDebrisCharacterMovementImpulse, Movement_end) == 0x00000C, "Member 'FCAFastPathDebrisCharacterMovementImpulse::Movement_end' has a wrong offset!");
static_assert(offsetof(FCAFastPathDebrisCharacterMovementImpulse, Strength) == 0x000018, "Member 'FCAFastPathDebrisCharacterMovementImpulse::Strength' has a wrong offset!");
static_assert(offsetof(FCAFastPathDebrisCharacterMovementImpulse, Character_radius) == 0x00001C, "Member 'FCAFastPathDebrisCharacterMovementImpulse::Character_radius' has a wrong offset!");

// ScriptStruct keaton.CAFastPathDebrisPointImpulse
// 0x0010 (0x0010 - 0x0000)
struct FCAFastPathDebrisPointImpulse final
{
public:
	struct FVector                                Origin;                                            // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Kgs_of_tnt;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFastPathDebrisPointImpulse) == 0x000004, "Wrong alignment on FCAFastPathDebrisPointImpulse");
static_assert(sizeof(FCAFastPathDebrisPointImpulse) == 0x000010, "Wrong size on FCAFastPathDebrisPointImpulse");
static_assert(offsetof(FCAFastPathDebrisPointImpulse, Origin) == 0x000000, "Member 'FCAFastPathDebrisPointImpulse::Origin' has a wrong offset!");
static_assert(offsetof(FCAFastPathDebrisPointImpulse, Kgs_of_tnt) == 0x00000C, "Member 'FCAFastPathDebrisPointImpulse::Kgs_of_tnt' has a wrong offset!");

// ScriptStruct keaton.CAFastPathInstanceTrackingStats
// 0x000C (0x000C - 0x0000)
struct FCAFastPathInstanceTrackingStats final
{
public:
	uint32                                        M_instance_capacity;                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_peak_instance_count;                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_peak_free_instance_count;                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFastPathInstanceTrackingStats) == 0x000004, "Wrong alignment on FCAFastPathInstanceTrackingStats");
static_assert(sizeof(FCAFastPathInstanceTrackingStats) == 0x00000C, "Wrong size on FCAFastPathInstanceTrackingStats");
static_assert(offsetof(FCAFastPathInstanceTrackingStats, M_instance_capacity) == 0x000000, "Member 'FCAFastPathInstanceTrackingStats::M_instance_capacity' has a wrong offset!");
static_assert(offsetof(FCAFastPathInstanceTrackingStats, M_peak_instance_count) == 0x000004, "Member 'FCAFastPathInstanceTrackingStats::M_peak_instance_count' has a wrong offset!");
static_assert(offsetof(FCAFastPathInstanceTrackingStats, M_peak_free_instance_count) == 0x000008, "Member 'FCAFastPathInstanceTrackingStats::M_peak_free_instance_count' has a wrong offset!");

// ScriptStruct keaton.CALoadedFoamPercentageEffects
// 0x0020 (0x0020 - 0x0000)
struct FCALoadedFoamPercentageEffects final
{
public:
	float                                         M_apply_effects_at_percentage;                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffect>>    M_effects;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          M_applied;                                         // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCALoadedFoamPercentageEffects) == 0x000008, "Wrong alignment on FCALoadedFoamPercentageEffects");
static_assert(sizeof(FCALoadedFoamPercentageEffects) == 0x000020, "Wrong size on FCALoadedFoamPercentageEffects");
static_assert(offsetof(FCALoadedFoamPercentageEffects, M_apply_effects_at_percentage) == 0x000000, "Member 'FCALoadedFoamPercentageEffects::M_apply_effects_at_percentage' has a wrong offset!");
static_assert(offsetof(FCALoadedFoamPercentageEffects, M_effects) == 0x000008, "Member 'FCALoadedFoamPercentageEffects::M_effects' has a wrong offset!");
static_assert(offsetof(FCALoadedFoamPercentageEffects, M_applied) == 0x000018, "Member 'FCALoadedFoamPercentageEffects::M_applied' has a wrong offset!");

// ScriptStruct keaton.CAFragGrenadeLevelData
// 0x0018 (0x0018 - 0x0000)
struct FCAFragGrenadeLevelData final
{
public:
	int32                                         M_upgrade_level;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAAOEDetonationType                          Detonation_type;                                   // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAFragGrenadeLevelDataRow>     M_damage_data;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFragGrenadeLevelData) == 0x000008, "Wrong alignment on FCAFragGrenadeLevelData");
static_assert(sizeof(FCAFragGrenadeLevelData) == 0x000018, "Wrong size on FCAFragGrenadeLevelData");
static_assert(offsetof(FCAFragGrenadeLevelData, M_upgrade_level) == 0x000000, "Member 'FCAFragGrenadeLevelData::M_upgrade_level' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeLevelData, Detonation_type) == 0x000004, "Member 'FCAFragGrenadeLevelData::Detonation_type' has a wrong offset!");
static_assert(offsetof(FCAFragGrenadeLevelData, M_damage_data) == 0x000008, "Member 'FCAFragGrenadeLevelData::M_damage_data' has a wrong offset!");

// ScriptStruct keaton.CAFlowStateData
// 0x0050 (0x0058 - 0x0008)
struct FCAFlowStateData final : public FTableRowBase
{
public:
	TArray<struct FCAFSMTransitionMapping>        M_transitions;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_logic;                                           // 0x0018(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_tags;                                            // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFlowStateData) == 0x000008, "Wrong alignment on FCAFlowStateData");
static_assert(sizeof(FCAFlowStateData) == 0x000058, "Wrong size on FCAFlowStateData");
static_assert(offsetof(FCAFlowStateData, M_transitions) == 0x000008, "Member 'FCAFlowStateData::M_transitions' has a wrong offset!");
static_assert(offsetof(FCAFlowStateData, M_logic) == 0x000018, "Member 'FCAFlowStateData::M_logic' has a wrong offset!");
static_assert(offsetof(FCAFlowStateData, M_tags) == 0x000048, "Member 'FCAFlowStateData::M_tags' has a wrong offset!");

// ScriptStruct keaton.CAUITransitionData
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FCAUITransitionData final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAUITransitionData) == 0x000008, "Wrong alignment on FCAUITransitionData");
static_assert(sizeof(FCAUITransitionData) == 0x000030, "Wrong size on FCAUITransitionData");

// ScriptStruct keaton.CALoadingScreenData
// 0x0308 (0x0308 - 0x0000)
struct FCALoadingScreenData final
{
public:
	struct FCAText                                M_map_loading_text;                                // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FCAText                                M_waiting_on_players;                              // 0x0030(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            M_bg_brush;                                        // 0x0060(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         M_map_name_font;                                   // 0x00F0(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         M_description_font;                                // 0x0148(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            M_loading_spinner_brush;                           // 0x01A0(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            M_text_bg_brush;                                   // 0x0230(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColor                           M_description_text_colour;                         // 0x02C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                M_throbber_offset;                                 // 0x02D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                M_description_offset;                              // 0x02E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_text_wrap_length;                                // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4[0x14];                                     // 0x02F4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCALoadingScreenData) == 0x000008, "Wrong alignment on FCALoadingScreenData");
static_assert(sizeof(FCALoadingScreenData) == 0x000308, "Wrong size on FCALoadingScreenData");
static_assert(offsetof(FCALoadingScreenData, M_map_loading_text) == 0x000000, "Member 'FCALoadingScreenData::M_map_loading_text' has a wrong offset!");
static_assert(offsetof(FCALoadingScreenData, M_waiting_on_players) == 0x000030, "Member 'FCALoadingScreenData::M_waiting_on_players' has a wrong offset!");
static_assert(offsetof(FCALoadingScreenData, M_bg_brush) == 0x000060, "Member 'FCALoadingScreenData::M_bg_brush' has a wrong offset!");
static_assert(offsetof(FCALoadingScreenData, M_map_name_font) == 0x0000F0, "Member 'FCALoadingScreenData::M_map_name_font' has a wrong offset!");
static_assert(offsetof(FCALoadingScreenData, M_description_font) == 0x000148, "Member 'FCALoadingScreenData::M_description_font' has a wrong offset!");
static_assert(offsetof(FCALoadingScreenData, M_loading_spinner_brush) == 0x0001A0, "Member 'FCALoadingScreenData::M_loading_spinner_brush' has a wrong offset!");
static_assert(offsetof(FCALoadingScreenData, M_text_bg_brush) == 0x000230, "Member 'FCALoadingScreenData::M_text_bg_brush' has a wrong offset!");
static_assert(offsetof(FCALoadingScreenData, M_description_text_colour) == 0x0002C0, "Member 'FCALoadingScreenData::M_description_text_colour' has a wrong offset!");
static_assert(offsetof(FCALoadingScreenData, M_throbber_offset) == 0x0002D0, "Member 'FCALoadingScreenData::M_throbber_offset' has a wrong offset!");
static_assert(offsetof(FCALoadingScreenData, M_description_offset) == 0x0002E0, "Member 'FCALoadingScreenData::M_description_offset' has a wrong offset!");
static_assert(offsetof(FCALoadingScreenData, M_text_wrap_length) == 0x0002F0, "Member 'FCALoadingScreenData::M_text_wrap_length' has a wrong offset!");

// ScriptStruct keaton.CAMapConfiguration
// 0x0040 (0x0040 - 0x0000)
struct FCAMapConfiguration final
{
public:
	class FString                                 M_map_name;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCAGameModeMapConfiguration> M_game_mode_map_configuration;                     // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMapConfiguration) == 0x000008, "Wrong alignment on FCAMapConfiguration");
static_assert(sizeof(FCAMapConfiguration) == 0x000040, "Wrong size on FCAMapConfiguration");
static_assert(offsetof(FCAMapConfiguration, M_map_name) == 0x000000, "Member 'FCAMapConfiguration::M_map_name' has a wrong offset!");
static_assert(offsetof(FCAMapConfiguration, M_game_mode_map_configuration) == 0x000010, "Member 'FCAMapConfiguration::M_game_mode_map_configuration' has a wrong offset!");

// ScriptStruct keaton.CAPlayerOptions
// 0x0020 (0x0020 - 0x0000)
struct FCAPlayerOptions final
{
public:
	float                                         M_player_health_scaling_percentage;                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_allow_downed_state;                              // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_self_revive_cooldown_time_in_seconds;            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_self_revive_allow_ability_activation_cooldown_in_seconds; // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_player_elimination;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_player_failed;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_player_success;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_player_respawn;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPlayerOptions) == 0x000004, "Wrong alignment on FCAPlayerOptions");
static_assert(sizeof(FCAPlayerOptions) == 0x000020, "Wrong size on FCAPlayerOptions");
static_assert(offsetof(FCAPlayerOptions, M_player_health_scaling_percentage) == 0x000000, "Member 'FCAPlayerOptions::M_player_health_scaling_percentage' has a wrong offset!");
static_assert(offsetof(FCAPlayerOptions, M_allow_downed_state) == 0x000004, "Member 'FCAPlayerOptions::M_allow_downed_state' has a wrong offset!");
static_assert(offsetof(FCAPlayerOptions, M_self_revive_cooldown_time_in_seconds) == 0x000008, "Member 'FCAPlayerOptions::M_self_revive_cooldown_time_in_seconds' has a wrong offset!");
static_assert(offsetof(FCAPlayerOptions, M_self_revive_allow_ability_activation_cooldown_in_seconds) == 0x00000C, "Member 'FCAPlayerOptions::M_self_revive_allow_ability_activation_cooldown_in_seconds' has a wrong offset!");
static_assert(offsetof(FCAPlayerOptions, M_player_elimination) == 0x000010, "Member 'FCAPlayerOptions::M_player_elimination' has a wrong offset!");
static_assert(offsetof(FCAPlayerOptions, M_player_failed) == 0x000014, "Member 'FCAPlayerOptions::M_player_failed' has a wrong offset!");
static_assert(offsetof(FCAPlayerOptions, M_player_success) == 0x000018, "Member 'FCAPlayerOptions::M_player_success' has a wrong offset!");
static_assert(offsetof(FCAPlayerOptions, M_player_respawn) == 0x00001C, "Member 'FCAPlayerOptions::M_player_respawn' has a wrong offset!");

// ScriptStruct keaton.CAMatchOptions
// 0x0020 (0x0020 - 0x0000)
struct FCAMatchOptions final
{
public:
	int8                                          M_opening_countdown_duration;                      // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          M_space_jump_opening_countdown_duration;           // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          M_black_screen_transition_from_space_jump_max_time; // 0x0002(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_min_percentage_of_players_needed_to_start_the_game; // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_match_end_time_dilation;                         // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_duration_of_match_end_flow;                      // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_time_limit_in_seconds;                           // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_must_have_winning_team;                          // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_team_size;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_max_teams;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMatchOptions) == 0x000004, "Wrong alignment on FCAMatchOptions");
static_assert(sizeof(FCAMatchOptions) == 0x000020, "Wrong size on FCAMatchOptions");
static_assert(offsetof(FCAMatchOptions, M_opening_countdown_duration) == 0x000000, "Member 'FCAMatchOptions::M_opening_countdown_duration' has a wrong offset!");
static_assert(offsetof(FCAMatchOptions, M_space_jump_opening_countdown_duration) == 0x000001, "Member 'FCAMatchOptions::M_space_jump_opening_countdown_duration' has a wrong offset!");
static_assert(offsetof(FCAMatchOptions, M_black_screen_transition_from_space_jump_max_time) == 0x000002, "Member 'FCAMatchOptions::M_black_screen_transition_from_space_jump_max_time' has a wrong offset!");
static_assert(offsetof(FCAMatchOptions, M_min_percentage_of_players_needed_to_start_the_game) == 0x000004, "Member 'FCAMatchOptions::M_min_percentage_of_players_needed_to_start_the_game' has a wrong offset!");
static_assert(offsetof(FCAMatchOptions, M_match_end_time_dilation) == 0x000008, "Member 'FCAMatchOptions::M_match_end_time_dilation' has a wrong offset!");
static_assert(offsetof(FCAMatchOptions, M_duration_of_match_end_flow) == 0x00000C, "Member 'FCAMatchOptions::M_duration_of_match_end_flow' has a wrong offset!");
static_assert(offsetof(FCAMatchOptions, M_time_limit_in_seconds) == 0x000010, "Member 'FCAMatchOptions::M_time_limit_in_seconds' has a wrong offset!");
static_assert(offsetof(FCAMatchOptions, M_must_have_winning_team) == 0x000014, "Member 'FCAMatchOptions::M_must_have_winning_team' has a wrong offset!");
static_assert(offsetof(FCAMatchOptions, M_team_size) == 0x000018, "Member 'FCAMatchOptions::M_team_size' has a wrong offset!");
static_assert(offsetof(FCAMatchOptions, M_max_teams) == 0x00001C, "Member 'FCAMatchOptions::M_max_teams' has a wrong offset!");

// ScriptStruct keaton.CAGameOptions
// 0x0220 (0x0228 - 0x0008)
struct FCAGameOptions final : public FTableRowBase
{
public:
	TArray<struct FCAMapConfiguration>            M_maps_configuration;                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAPickupOptions                       M_pickup_options;                                  // 0x0018(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAExtractionOptions                   M_extraction_options;                              // 0x0078(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCARespawnOptions                      M_respawn_options;                                 // 0x00D8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAPlayerOptions                       M_player_options;                                  // 0x00F8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCANPCOptions>           M_npc_options;                                     // 0x0118(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCANPCOptions*                          M_loaded_npc_options;                              // 0x0148(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCADamageOptions                       M_damage_options;                                  // 0x0150(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAMatchOptions                        M_match_options;                                   // 0x0160(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_is_PvE_only;                                     // 0x0180(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x3];                                      // 0x0181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_foam_structures_limit;                           // 0x0184(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTimedEvent>                    M_events;                                          // 0x0188(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              M_reward_categories_weights;                       // 0x0198(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              M_match_result_type_categories;                    // 0x01C8(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              M_entity_legend_table;                             // 0x01F8(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAGameOptions) == 0x000008, "Wrong alignment on FCAGameOptions");
static_assert(sizeof(FCAGameOptions) == 0x000228, "Wrong size on FCAGameOptions");
static_assert(offsetof(FCAGameOptions, M_maps_configuration) == 0x000008, "Member 'FCAGameOptions::M_maps_configuration' has a wrong offset!");
static_assert(offsetof(FCAGameOptions, M_pickup_options) == 0x000018, "Member 'FCAGameOptions::M_pickup_options' has a wrong offset!");
static_assert(offsetof(FCAGameOptions, M_extraction_options) == 0x000078, "Member 'FCAGameOptions::M_extraction_options' has a wrong offset!");
static_assert(offsetof(FCAGameOptions, M_respawn_options) == 0x0000D8, "Member 'FCAGameOptions::M_respawn_options' has a wrong offset!");
static_assert(offsetof(FCAGameOptions, M_player_options) == 0x0000F8, "Member 'FCAGameOptions::M_player_options' has a wrong offset!");
static_assert(offsetof(FCAGameOptions, M_npc_options) == 0x000118, "Member 'FCAGameOptions::M_npc_options' has a wrong offset!");
static_assert(offsetof(FCAGameOptions, M_loaded_npc_options) == 0x000148, "Member 'FCAGameOptions::M_loaded_npc_options' has a wrong offset!");
static_assert(offsetof(FCAGameOptions, M_damage_options) == 0x000150, "Member 'FCAGameOptions::M_damage_options' has a wrong offset!");
static_assert(offsetof(FCAGameOptions, M_match_options) == 0x000160, "Member 'FCAGameOptions::M_match_options' has a wrong offset!");
static_assert(offsetof(FCAGameOptions, M_is_PvE_only) == 0x000180, "Member 'FCAGameOptions::M_is_PvE_only' has a wrong offset!");
static_assert(offsetof(FCAGameOptions, M_foam_structures_limit) == 0x000184, "Member 'FCAGameOptions::M_foam_structures_limit' has a wrong offset!");
static_assert(offsetof(FCAGameOptions, M_events) == 0x000188, "Member 'FCAGameOptions::M_events' has a wrong offset!");
static_assert(offsetof(FCAGameOptions, M_reward_categories_weights) == 0x000198, "Member 'FCAGameOptions::M_reward_categories_weights' has a wrong offset!");
static_assert(offsetof(FCAGameOptions, M_match_result_type_categories) == 0x0001C8, "Member 'FCAGameOptions::M_match_result_type_categories' has a wrong offset!");
static_assert(offsetof(FCAGameOptions, M_entity_legend_table) == 0x0001F8, "Member 'FCAGameOptions::M_entity_legend_table' has a wrong offset!");

// ScriptStruct keaton.CAAbilityTweakParameter
// 0x0008 (0x0010 - 0x0008)
struct FCAAbilityTweakParameter final : public FTableRowBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAbilityTweakParameter) == 0x000008, "Wrong alignment on FCAAbilityTweakParameter");
static_assert(sizeof(FCAAbilityTweakParameter) == 0x000010, "Wrong size on FCAAbilityTweakParameter");
static_assert(offsetof(FCAAbilityTweakParameter, Value) == 0x000008, "Member 'FCAAbilityTweakParameter::Value' has a wrong offset!");

// ScriptStruct keaton.CAGameplayAbilityActorInfo
// 0x0000 (0x0050 - 0x0050)
struct FCAGameplayAbilityActorInfo final : public FGameplayAbilityActorInfo
{
};
static_assert(alignof(FCAGameplayAbilityActorInfo) == 0x000008, "Wrong alignment on FCAGameplayAbilityActorInfo");
static_assert(sizeof(FCAGameplayAbilityActorInfo) == 0x000050, "Wrong size on FCAGameplayAbilityActorInfo");

// ScriptStruct keaton.GameplayEffectTriggerDefinition
// 0x01A8 (0x01B0 - 0x0008)
struct FGameplayEffectTriggerDefinition final : public FTableRowBase
{
public:
	bool                                          M_trigger_switch;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAGameplayTriggerEvent                       M_trigger_event;                                   // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCASetByCallerWithMagnitude>    M_event_set_by_caller_tags;                        // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     M_event_attribute_multiplier;                      // 0x0020(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            M_event_value_curve_modifier;                      // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EThresholdCondition                           M_apply_event_condition;                           // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EThresholdCondition                           M_remove_event_condition;                          // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x2];                                       // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_apply_event_value;                               // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_remove_event_value;                              // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_gameplay_effect;                                 // 0x0070(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_period;                                          // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCASetByCallerWithMagnitude>    M_custom_set_by_caller_tags;                       // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     M_custom_attribute_multiplier;                     // 0x00B8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_allow_apply_if_active;                           // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_apply_on_trigger;                                // 0x00F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_consider_conditions_as_interval;                 // 0x00F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EThresholdType                                M_apply_threshold_type;                            // 0x00F3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EThresholdType                                M_remove_threshold_type;                           // 0x00F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EThresholdCondition                           M_apply_threshold_condition;                       // 0x00F5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EThresholdCondition                           M_remove_threshold_condition;                      // 0x00F6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F7[0x1];                                       // 0x00F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttribute                     M_check_gameplay_attribute;                        // 0x00F8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     M_apply_threshold_gameplay_attribute;              // 0x0130(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     M_remove_threshold_gameplay_attribute;             // 0x0168(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_apply_custom_attribute_threshold;                // 0x01A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_remove_custom_attribute_threshold;               // 0x01A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAPlayerMovementMetaMode                     M_required_movement_mode_type;                     // 0x01A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectTriggerDefinition) == 0x000008, "Wrong alignment on FGameplayEffectTriggerDefinition");
static_assert(sizeof(FGameplayEffectTriggerDefinition) == 0x0001B0, "Wrong size on FGameplayEffectTriggerDefinition");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_trigger_switch) == 0x000008, "Member 'FGameplayEffectTriggerDefinition::M_trigger_switch' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_trigger_event) == 0x000009, "Member 'FGameplayEffectTriggerDefinition::M_trigger_event' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_event_set_by_caller_tags) == 0x000010, "Member 'FGameplayEffectTriggerDefinition::M_event_set_by_caller_tags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_event_attribute_multiplier) == 0x000020, "Member 'FGameplayEffectTriggerDefinition::M_event_attribute_multiplier' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_event_value_curve_modifier) == 0x000058, "Member 'FGameplayEffectTriggerDefinition::M_event_value_curve_modifier' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_apply_event_condition) == 0x000060, "Member 'FGameplayEffectTriggerDefinition::M_apply_event_condition' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_remove_event_condition) == 0x000061, "Member 'FGameplayEffectTriggerDefinition::M_remove_event_condition' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_apply_event_value) == 0x000064, "Member 'FGameplayEffectTriggerDefinition::M_apply_event_value' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_remove_event_value) == 0x000068, "Member 'FGameplayEffectTriggerDefinition::M_remove_event_value' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_gameplay_effect) == 0x000070, "Member 'FGameplayEffectTriggerDefinition::M_gameplay_effect' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_period) == 0x0000A0, "Member 'FGameplayEffectTriggerDefinition::M_period' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_custom_set_by_caller_tags) == 0x0000A8, "Member 'FGameplayEffectTriggerDefinition::M_custom_set_by_caller_tags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_custom_attribute_multiplier) == 0x0000B8, "Member 'FGameplayEffectTriggerDefinition::M_custom_attribute_multiplier' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_allow_apply_if_active) == 0x0000F0, "Member 'FGameplayEffectTriggerDefinition::M_allow_apply_if_active' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_apply_on_trigger) == 0x0000F1, "Member 'FGameplayEffectTriggerDefinition::M_apply_on_trigger' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_consider_conditions_as_interval) == 0x0000F2, "Member 'FGameplayEffectTriggerDefinition::M_consider_conditions_as_interval' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_apply_threshold_type) == 0x0000F3, "Member 'FGameplayEffectTriggerDefinition::M_apply_threshold_type' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_remove_threshold_type) == 0x0000F4, "Member 'FGameplayEffectTriggerDefinition::M_remove_threshold_type' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_apply_threshold_condition) == 0x0000F5, "Member 'FGameplayEffectTriggerDefinition::M_apply_threshold_condition' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_remove_threshold_condition) == 0x0000F6, "Member 'FGameplayEffectTriggerDefinition::M_remove_threshold_condition' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_check_gameplay_attribute) == 0x0000F8, "Member 'FGameplayEffectTriggerDefinition::M_check_gameplay_attribute' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_apply_threshold_gameplay_attribute) == 0x000130, "Member 'FGameplayEffectTriggerDefinition::M_apply_threshold_gameplay_attribute' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_remove_threshold_gameplay_attribute) == 0x000168, "Member 'FGameplayEffectTriggerDefinition::M_remove_threshold_gameplay_attribute' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_apply_custom_attribute_threshold) == 0x0001A0, "Member 'FGameplayEffectTriggerDefinition::M_apply_custom_attribute_threshold' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_remove_custom_attribute_threshold) == 0x0001A4, "Member 'FGameplayEffectTriggerDefinition::M_remove_custom_attribute_threshold' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTriggerDefinition, M_required_movement_mode_type) == 0x0001A8, "Member 'FGameplayEffectTriggerDefinition::M_required_movement_mode_type' has a wrong offset!");

// ScriptStruct keaton.GameplayEffectItemDefinition
// 0x0060 (0x0068 - 0x0008)
struct FGameplayEffectItemDefinition final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UCAInventoryItem>        M_inventory_item;                                  // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAEffectWithSetByCallerTags>   M_effects_with_set_by_caller_tags;                 // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAWeaponBuffDefinition>        M_weapon_buffs;                                    // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_allow_apply_if_active;                           // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_remove_after_collect;                            // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_specific_slot;                                   // 0x005C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEffectItemDefinition) == 0x000008, "Wrong alignment on FGameplayEffectItemDefinition");
static_assert(sizeof(FGameplayEffectItemDefinition) == 0x000068, "Wrong size on FGameplayEffectItemDefinition");
static_assert(offsetof(FGameplayEffectItemDefinition, M_inventory_item) == 0x000008, "Member 'FGameplayEffectItemDefinition::M_inventory_item' has a wrong offset!");
static_assert(offsetof(FGameplayEffectItemDefinition, M_effects_with_set_by_caller_tags) == 0x000038, "Member 'FGameplayEffectItemDefinition::M_effects_with_set_by_caller_tags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectItemDefinition, M_weapon_buffs) == 0x000048, "Member 'FGameplayEffectItemDefinition::M_weapon_buffs' has a wrong offset!");
static_assert(offsetof(FGameplayEffectItemDefinition, M_allow_apply_if_active) == 0x000058, "Member 'FGameplayEffectItemDefinition::M_allow_apply_if_active' has a wrong offset!");
static_assert(offsetof(FGameplayEffectItemDefinition, M_remove_after_collect) == 0x000059, "Member 'FGameplayEffectItemDefinition::M_remove_after_collect' has a wrong offset!");
static_assert(offsetof(FGameplayEffectItemDefinition, M_specific_slot) == 0x00005C, "Member 'FGameplayEffectItemDefinition::M_specific_slot' has a wrong offset!");

// ScriptStruct keaton.GameplayEffectPickupDefinition
// 0x0048 (0x0050 - 0x0008)
struct FGameplayEffectPickupDefinition final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UCAInventoryItem>        M_inventory_item;                                  // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAEffectWithSetByCallerTags>   M_effects_with_set_by_caller_tags;                 // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_allow_apply_if_active;                           // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_remove_after_collect;                            // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectPickupDefinition) == 0x000008, "Wrong alignment on FGameplayEffectPickupDefinition");
static_assert(sizeof(FGameplayEffectPickupDefinition) == 0x000050, "Wrong size on FGameplayEffectPickupDefinition");
static_assert(offsetof(FGameplayEffectPickupDefinition, M_inventory_item) == 0x000008, "Member 'FGameplayEffectPickupDefinition::M_inventory_item' has a wrong offset!");
static_assert(offsetof(FGameplayEffectPickupDefinition, M_effects_with_set_by_caller_tags) == 0x000038, "Member 'FGameplayEffectPickupDefinition::M_effects_with_set_by_caller_tags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectPickupDefinition, M_allow_apply_if_active) == 0x000048, "Member 'FGameplayEffectPickupDefinition::M_allow_apply_if_active' has a wrong offset!");
static_assert(offsetof(FGameplayEffectPickupDefinition, M_remove_after_collect) == 0x000049, "Member 'FGameplayEffectPickupDefinition::M_remove_after_collect' has a wrong offset!");

// ScriptStruct keaton.ItemLimitReplenishPickupDefinition
// 0x0088 (0x0090 - 0x0008)
struct FItemLimitReplenishPickupDefinition final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UCAInventoryItem>        M_inventory_item;                                  // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UCAInventoryItem>, float> M_replenish_inventory_item_limits;                 // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_remove_after_collect;                            // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemLimitReplenishPickupDefinition) == 0x000008, "Wrong alignment on FItemLimitReplenishPickupDefinition");
static_assert(sizeof(FItemLimitReplenishPickupDefinition) == 0x000090, "Wrong size on FItemLimitReplenishPickupDefinition");
static_assert(offsetof(FItemLimitReplenishPickupDefinition, M_inventory_item) == 0x000008, "Member 'FItemLimitReplenishPickupDefinition::M_inventory_item' has a wrong offset!");
static_assert(offsetof(FItemLimitReplenishPickupDefinition, M_replenish_inventory_item_limits) == 0x000038, "Member 'FItemLimitReplenishPickupDefinition::M_replenish_inventory_item_limits' has a wrong offset!");
static_assert(offsetof(FItemLimitReplenishPickupDefinition, M_remove_after_collect) == 0x000088, "Member 'FItemLimitReplenishPickupDefinition::M_remove_after_collect' has a wrong offset!");

// ScriptStruct keaton.CAWeaponBuffLocalisationDefinition
// 0x0040 (0x0048 - 0x0008)
struct FCAWeaponBuffLocalisationDefinition final : public FTableRowBase
{
public:
	ECAWeaponBuffDisplayedCategory                M_buff_displayed_category;                         // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_description;                                     // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_is_hidden;                                       // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_show_inversed_if_not_hidden;                     // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAWeaponBuffLocalisationDefinition) == 0x000008, "Wrong alignment on FCAWeaponBuffLocalisationDefinition");
static_assert(sizeof(FCAWeaponBuffLocalisationDefinition) == 0x000048, "Wrong size on FCAWeaponBuffLocalisationDefinition");
static_assert(offsetof(FCAWeaponBuffLocalisationDefinition, M_buff_displayed_category) == 0x000008, "Member 'FCAWeaponBuffLocalisationDefinition::M_buff_displayed_category' has a wrong offset!");
static_assert(offsetof(FCAWeaponBuffLocalisationDefinition, M_description) == 0x000010, "Member 'FCAWeaponBuffLocalisationDefinition::M_description' has a wrong offset!");
static_assert(offsetof(FCAWeaponBuffLocalisationDefinition, M_is_hidden) == 0x000040, "Member 'FCAWeaponBuffLocalisationDefinition::M_is_hidden' has a wrong offset!");
static_assert(offsetof(FCAWeaponBuffLocalisationDefinition, M_show_inversed_if_not_hidden) == 0x000041, "Member 'FCAWeaponBuffLocalisationDefinition::M_show_inversed_if_not_hidden' has a wrong offset!");

// ScriptStruct keaton.CAGameplayAbilityTargetData_Projectile
// 0x0098 (0x00A0 - 0x0008)
struct FCAGameplayAbilityTargetData_Projectile final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetingLocationInfo  SourceLocation;                                    // 0x0010(0x0080)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FProjectileMetaData                    M_projectile_meta_data;                            // 0x0090(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0xC];                                       // 0x0094(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAGameplayAbilityTargetData_Projectile) == 0x000010, "Wrong alignment on FCAGameplayAbilityTargetData_Projectile");
static_assert(sizeof(FCAGameplayAbilityTargetData_Projectile) == 0x0000A0, "Wrong size on FCAGameplayAbilityTargetData_Projectile");
static_assert(offsetof(FCAGameplayAbilityTargetData_Projectile, SourceLocation) == 0x000010, "Member 'FCAGameplayAbilityTargetData_Projectile::SourceLocation' has a wrong offset!");
static_assert(offsetof(FCAGameplayAbilityTargetData_Projectile, M_projectile_meta_data) == 0x000090, "Member 'FCAGameplayAbilityTargetData_Projectile::M_projectile_meta_data' has a wrong offset!");

// ScriptStruct keaton.CAGameplayEffectContext
// 0x0050 (0x00C0 - 0x0070)
struct FCAGameplayEffectContext final : public FGameplayEffectContext
{
public:
	struct FCustomWeaponDamageParams              M_custom_weapon_params;                            // 0x0070(0x0020)(Protected, NativeAccessSpecifierProtected)
	struct FInstantHitImpactMetaData              M_instant_hit_meta_data;                           // 0x0090(0x0030)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FCAGameplayEffectContext) == 0x000008, "Wrong alignment on FCAGameplayEffectContext");
static_assert(sizeof(FCAGameplayEffectContext) == 0x0000C0, "Wrong size on FCAGameplayEffectContext");
static_assert(offsetof(FCAGameplayEffectContext, M_custom_weapon_params) == 0x000070, "Member 'FCAGameplayEffectContext::M_custom_weapon_params' has a wrong offset!");
static_assert(offsetof(FCAGameplayEffectContext, M_instant_hit_meta_data) == 0x000090, "Member 'FCAGameplayEffectContext::M_instant_hit_meta_data' has a wrong offset!");

// ScriptStruct keaton.CAGameplayExecutionData
// 0x0090 (0x0090 - 0x0000)
struct FCAGameplayExecutionData final
{
public:
	TSoftObjectPtr<class UAnimMontage>            M_executioner_anim_montage;                        // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            M_victim_anim_montage;                             // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULevelSequence>          M_camera_option;                                   // 0x0060(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAGameplayExecutionData) == 0x000008, "Wrong alignment on FCAGameplayExecutionData");
static_assert(sizeof(FCAGameplayExecutionData) == 0x000090, "Wrong size on FCAGameplayExecutionData");
static_assert(offsetof(FCAGameplayExecutionData, M_executioner_anim_montage) == 0x000000, "Member 'FCAGameplayExecutionData::M_executioner_anim_montage' has a wrong offset!");
static_assert(offsetof(FCAGameplayExecutionData, M_victim_anim_montage) == 0x000030, "Member 'FCAGameplayExecutionData::M_victim_anim_montage' has a wrong offset!");
static_assert(offsetof(FCAGameplayExecutionData, M_camera_option) == 0x000060, "Member 'FCAGameplayExecutionData::M_camera_option' has a wrong offset!");

// ScriptStruct keaton.TransitionProgressUpdate
// 0x0010 (0x0010 - 0x0000)
struct FTransitionProgressUpdate final
{
public:
	struct FCASynchronisedState                   M_Active;                                          // 0x0000(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCASynchronisedState                   M_Suspended;                                       // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransitionProgressUpdate) == 0x000004, "Wrong alignment on FTransitionProgressUpdate");
static_assert(sizeof(FTransitionProgressUpdate) == 0x000010, "Wrong size on FTransitionProgressUpdate");
static_assert(offsetof(FTransitionProgressUpdate, M_Active) == 0x000000, "Member 'FTransitionProgressUpdate::M_Active' has a wrong offset!");
static_assert(offsetof(FTransitionProgressUpdate, M_Suspended) == 0x000008, "Member 'FTransitionProgressUpdate::M_Suspended' has a wrong offset!");

// ScriptStruct keaton.CAAILoDRuleSet
// 0x0010 (0x0010 - 0x0000)
struct FCAAILoDRuleSet final
{
public:
	TArray<struct FCAAILoDRule>                   M_lod_rules;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAILoDRuleSet) == 0x000008, "Wrong alignment on FCAAILoDRuleSet");
static_assert(sizeof(FCAAILoDRuleSet) == 0x000010, "Wrong size on FCAAILoDRuleSet");
static_assert(offsetof(FCAAILoDRuleSet, M_lod_rules) == 0x000000, "Member 'FCAAILoDRuleSet::M_lod_rules' has a wrong offset!");

// ScriptStruct keaton.CATagFloatMap
// 0x0050 (0x0050 - 0x0000)
struct FCATagFloatMap final
{
public:
	TMap<struct FGameplayTag, float>              M_map;                                             // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATagFloatMap) == 0x000008, "Wrong alignment on FCATagFloatMap");
static_assert(sizeof(FCATagFloatMap) == 0x000050, "Wrong size on FCATagFloatMap");
static_assert(offsetof(FCATagFloatMap, M_map) == 0x000000, "Member 'FCATagFloatMap::M_map' has a wrong offset!");

// ScriptStruct keaton.CANPCTypeInclusionSetting
// 0x0028 (0x0028 - 0x0000)
struct FCANPCTypeInclusionSetting final
{
public:
	ECAInclusionSetting                           M_inclusion_setting;                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECANPCType>                            M_exceptions_S;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACACharacter_NPC>>   M_exceptions_resolved;                             // 0x0018(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANPCTypeInclusionSetting) == 0x000008, "Wrong alignment on FCANPCTypeInclusionSetting");
static_assert(sizeof(FCANPCTypeInclusionSetting) == 0x000028, "Wrong size on FCANPCTypeInclusionSetting");
static_assert(offsetof(FCANPCTypeInclusionSetting, M_inclusion_setting) == 0x000000, "Member 'FCANPCTypeInclusionSetting::M_inclusion_setting' has a wrong offset!");
static_assert(offsetof(FCANPCTypeInclusionSetting, M_exceptions_S) == 0x000008, "Member 'FCANPCTypeInclusionSetting::M_exceptions_S' has a wrong offset!");
static_assert(offsetof(FCANPCTypeInclusionSetting, M_exceptions_resolved) == 0x000018, "Member 'FCANPCTypeInclusionSetting::M_exceptions_resolved' has a wrong offset!");

// ScriptStruct keaton.CANPCTargetObjectDataEntry
// 0x0058 (0x0058 - 0x0000)
struct FCANPCTargetObjectDataEntry final
{
public:
	struct FCANPCTypeInclusionSetting             M_npc_types;                                       // 0x0000(0x0028)(Edit, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             M_target_types;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FCATargetObjectTargetingRule>   M_targeting_rules;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ECANPCTargetObjectAttackType                  M_attack_type;                                     // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECANPCTargetObjectMoveAcceptanceType          M_target_oject_move_acceptance_type;               // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_distance_to_keep_from_target_object;             // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_requires_line_of_sight;                          // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECANPCTargetObjectPriority                    M_priority;                                        // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCTargetObjectDataEntry) == 0x000008, "Wrong alignment on FCANPCTargetObjectDataEntry");
static_assert(sizeof(FCANPCTargetObjectDataEntry) == 0x000058, "Wrong size on FCANPCTargetObjectDataEntry");
static_assert(offsetof(FCANPCTargetObjectDataEntry, M_npc_types) == 0x000000, "Member 'FCANPCTargetObjectDataEntry::M_npc_types' has a wrong offset!");
static_assert(offsetof(FCANPCTargetObjectDataEntry, M_target_types) == 0x000028, "Member 'FCANPCTargetObjectDataEntry::M_target_types' has a wrong offset!");
static_assert(offsetof(FCANPCTargetObjectDataEntry, M_targeting_rules) == 0x000038, "Member 'FCANPCTargetObjectDataEntry::M_targeting_rules' has a wrong offset!");
static_assert(offsetof(FCANPCTargetObjectDataEntry, M_attack_type) == 0x000048, "Member 'FCANPCTargetObjectDataEntry::M_attack_type' has a wrong offset!");
static_assert(offsetof(FCANPCTargetObjectDataEntry, M_target_oject_move_acceptance_type) == 0x000049, "Member 'FCANPCTargetObjectDataEntry::M_target_oject_move_acceptance_type' has a wrong offset!");
static_assert(offsetof(FCANPCTargetObjectDataEntry, M_distance_to_keep_from_target_object) == 0x00004C, "Member 'FCANPCTargetObjectDataEntry::M_distance_to_keep_from_target_object' has a wrong offset!");
static_assert(offsetof(FCANPCTargetObjectDataEntry, M_requires_line_of_sight) == 0x000050, "Member 'FCANPCTargetObjectDataEntry::M_requires_line_of_sight' has a wrong offset!");
static_assert(offsetof(FCANPCTargetObjectDataEntry, M_priority) == 0x000051, "Member 'FCANPCTargetObjectDataEntry::M_priority' has a wrong offset!");

// ScriptStruct keaton.CAHUDActivityData
// 0x0040 (0x0040 - 0x0000)
struct FCAHUDActivityData final
{
public:
	struct FLinearColor                           M_colour;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAText                                M_text;                                            // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDActivityData) == 0x000008, "Wrong alignment on FCAHUDActivityData");
static_assert(sizeof(FCAHUDActivityData) == 0x000040, "Wrong size on FCAHUDActivityData");
static_assert(offsetof(FCAHUDActivityData, M_colour) == 0x000000, "Member 'FCAHUDActivityData::M_colour' has a wrong offset!");
static_assert(offsetof(FCAHUDActivityData, M_text) == 0x000010, "Member 'FCAHUDActivityData::M_text' has a wrong offset!");

// ScriptStruct keaton.CAHUDArcLensProviderWidgetData
// 0x0001 (0x0001 - 0x0000)
struct FCAHUDArcLensProviderWidgetData final
{
public:
	bool                                          M_skip_occlusion_check;                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDArcLensProviderWidgetData) == 0x000001, "Wrong alignment on FCAHUDArcLensProviderWidgetData");
static_assert(sizeof(FCAHUDArcLensProviderWidgetData) == 0x000001, "Wrong size on FCAHUDArcLensProviderWidgetData");
static_assert(offsetof(FCAHUDArcLensProviderWidgetData, M_skip_occlusion_check) == 0x000000, "Member 'FCAHUDArcLensProviderWidgetData::M_skip_occlusion_check' has a wrong offset!");

// ScriptStruct keaton.CAHUDArcLensCache
// 0x0010 (0x0010 - 0x0000)
struct FCAHUDArcLensCache final
{
public:
	TArray<class UCAArcLensWidgetBase*>           M_widgets;                                         // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDArcLensCache) == 0x000008, "Wrong alignment on FCAHUDArcLensCache");
static_assert(sizeof(FCAHUDArcLensCache) == 0x000010, "Wrong size on FCAHUDArcLensCache");
static_assert(offsetof(FCAHUDArcLensCache, M_widgets) == 0x000000, "Member 'FCAHUDArcLensCache::M_widgets' has a wrong offset!");

// ScriptStruct keaton.BreachingToolClassesTableRow
// 0x0068 (0x0070 - 0x0008)
struct FBreachingToolClassesTableRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UCAInventoryItem>        M_breaching_tool_class;                            // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_breaching_tool_icon;                             // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_breaching_tool_lvl;                              // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBreachingToolClassesTableRow) == 0x000008, "Wrong alignment on FBreachingToolClassesTableRow");
static_assert(sizeof(FBreachingToolClassesTableRow) == 0x000070, "Wrong size on FBreachingToolClassesTableRow");
static_assert(offsetof(FBreachingToolClassesTableRow, M_breaching_tool_class) == 0x000008, "Member 'FBreachingToolClassesTableRow::M_breaching_tool_class' has a wrong offset!");
static_assert(offsetof(FBreachingToolClassesTableRow, M_breaching_tool_icon) == 0x000038, "Member 'FBreachingToolClassesTableRow::M_breaching_tool_icon' has a wrong offset!");
static_assert(offsetof(FBreachingToolClassesTableRow, M_breaching_tool_lvl) == 0x000068, "Member 'FBreachingToolClassesTableRow::M_breaching_tool_lvl' has a wrong offset!");

// ScriptStruct keaton.CAHUDCompassAngleBoundary
// 0x0020 (0x0020 - 0x0000)
struct FCAHUDCompassAngleBoundary final
{
public:
	float                                         M_min_angle;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_angle;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_angle_label;                                     // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDCompassAngleBoundary) == 0x000008, "Wrong alignment on FCAHUDCompassAngleBoundary");
static_assert(sizeof(FCAHUDCompassAngleBoundary) == 0x000020, "Wrong size on FCAHUDCompassAngleBoundary");
static_assert(offsetof(FCAHUDCompassAngleBoundary, M_min_angle) == 0x000000, "Member 'FCAHUDCompassAngleBoundary::M_min_angle' has a wrong offset!");
static_assert(offsetof(FCAHUDCompassAngleBoundary, M_max_angle) == 0x000004, "Member 'FCAHUDCompassAngleBoundary::M_max_angle' has a wrong offset!");
static_assert(offsetof(FCAHUDCompassAngleBoundary, M_angle_label) == 0x000008, "Member 'FCAHUDCompassAngleBoundary::M_angle_label' has a wrong offset!");

// ScriptStruct keaton.HUDCompassItem
// 0x0020 (0x0020 - 0x0000)
struct FHUDCompassItem final
{
public:
	ECompassItemType                              M_type;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECompassItemPlacement                         M_placement;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_direction;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_actor;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_location;                                        // 0x0010(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_threat_progress;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHUDCompassItem) == 0x000008, "Wrong alignment on FHUDCompassItem");
static_assert(sizeof(FHUDCompassItem) == 0x000020, "Wrong size on FHUDCompassItem");
static_assert(offsetof(FHUDCompassItem, M_type) == 0x000000, "Member 'FHUDCompassItem::M_type' has a wrong offset!");
static_assert(offsetof(FHUDCompassItem, M_placement) == 0x000001, "Member 'FHUDCompassItem::M_placement' has a wrong offset!");
static_assert(offsetof(FHUDCompassItem, M_direction) == 0x000004, "Member 'FHUDCompassItem::M_direction' has a wrong offset!");
static_assert(offsetof(FHUDCompassItem, M_actor) == 0x000008, "Member 'FHUDCompassItem::M_actor' has a wrong offset!");
static_assert(offsetof(FHUDCompassItem, M_location) == 0x000010, "Member 'FHUDCompassItem::M_location' has a wrong offset!");
static_assert(offsetof(FHUDCompassItem, M_threat_progress) == 0x00001C, "Member 'FHUDCompassItem::M_threat_progress' has a wrong offset!");

// ScriptStruct keaton.CAHUDConstantRow
// 0x0008 (0x0010 - 0x0008)
struct FCAHUDConstantRow final : public FTableRowBase
{
public:
	float                                         M_value;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAHUDConstantRow) == 0x000008, "Wrong alignment on FCAHUDConstantRow");
static_assert(sizeof(FCAHUDConstantRow) == 0x000010, "Wrong size on FCAHUDConstantRow");
static_assert(offsetof(FCAHUDConstantRow, M_value) == 0x000008, "Member 'FCAHUDConstantRow::M_value' has a wrong offset!");

// ScriptStruct keaton.CAHUDDisguiseRow
// 0x0030 (0x0038 - 0x0008)
struct FCAHUDDisguiseRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UTexture2D>              M_disguise_portrait;                               // 0x0008(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDDisguiseRow) == 0x000008, "Wrong alignment on FCAHUDDisguiseRow");
static_assert(sizeof(FCAHUDDisguiseRow) == 0x000038, "Wrong size on FCAHUDDisguiseRow");
static_assert(offsetof(FCAHUDDisguiseRow, M_disguise_portrait) == 0x000008, "Member 'FCAHUDDisguiseRow::M_disguise_portrait' has a wrong offset!");

// ScriptStruct keaton.CAHUDNpcHealthBarVisibilityPerFOV
// 0x0002 (0x0002 - 0x0000)
struct FCAHUDNpcHealthBarVisibilityPerFOV final
{
public:
	ECAFovLevel                                   M_fov_level;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_health_bar_visible;                           // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDNpcHealthBarVisibilityPerFOV) == 0x000001, "Wrong alignment on FCAHUDNpcHealthBarVisibilityPerFOV");
static_assert(sizeof(FCAHUDNpcHealthBarVisibilityPerFOV) == 0x000002, "Wrong size on FCAHUDNpcHealthBarVisibilityPerFOV");
static_assert(offsetof(FCAHUDNpcHealthBarVisibilityPerFOV, M_fov_level) == 0x000000, "Member 'FCAHUDNpcHealthBarVisibilityPerFOV::M_fov_level' has a wrong offset!");
static_assert(offsetof(FCAHUDNpcHealthBarVisibilityPerFOV, M_is_health_bar_visible) == 0x000001, "Member 'FCAHUDNpcHealthBarVisibilityPerFOV::M_is_health_bar_visible' has a wrong offset!");

// ScriptStruct keaton.CAHUDNpcHealthBarRow
// 0x0018 (0x0020 - 0x0008)
struct FCAHUDNpcHealthBarRow final : public FTableRowBase
{
public:
	ECAHUDDistanceLevel                           M_distance_level;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAHUDNpcHealthBarVisibilityPerFOV> M_health_bar_visibility_data;                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDNpcHealthBarRow) == 0x000008, "Wrong alignment on FCAHUDNpcHealthBarRow");
static_assert(sizeof(FCAHUDNpcHealthBarRow) == 0x000020, "Wrong size on FCAHUDNpcHealthBarRow");
static_assert(offsetof(FCAHUDNpcHealthBarRow, M_distance_level) == 0x000008, "Member 'FCAHUDNpcHealthBarRow::M_distance_level' has a wrong offset!");
static_assert(offsetof(FCAHUDNpcHealthBarRow, M_health_bar_visibility_data) == 0x000010, "Member 'FCAHUDNpcHealthBarRow::M_health_bar_visibility_data' has a wrong offset!");

// ScriptStruct keaton.CAHealthBarDistanceValues
// 0x0008 (0x0008 - 0x0000)
struct FCAHealthBarDistanceValues final
{
public:
	ECAHUDDistanceLevel                           M_distance_level;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_min_distance_in_meters;                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHealthBarDistanceValues) == 0x000004, "Wrong alignment on FCAHealthBarDistanceValues");
static_assert(sizeof(FCAHealthBarDistanceValues) == 0x000008, "Wrong size on FCAHealthBarDistanceValues");
static_assert(offsetof(FCAHealthBarDistanceValues, M_distance_level) == 0x000000, "Member 'FCAHealthBarDistanceValues::M_distance_level' has a wrong offset!");
static_assert(offsetof(FCAHealthBarDistanceValues, M_min_distance_in_meters) == 0x000004, "Member 'FCAHealthBarDistanceValues::M_min_distance_in_meters' has a wrong offset!");

// ScriptStruct keaton.CAHUDHealthBarDistanceRow
// 0x0018 (0x0020 - 0x0008)
struct FCAHUDHealthBarDistanceRow final : public FTableRowBase
{
public:
	ECAFovActorType                               M_fov_actor_type;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAHealthBarDistanceValues>     M_health_bar_distance_data;                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDHealthBarDistanceRow) == 0x000008, "Wrong alignment on FCAHUDHealthBarDistanceRow");
static_assert(sizeof(FCAHUDHealthBarDistanceRow) == 0x000020, "Wrong size on FCAHUDHealthBarDistanceRow");
static_assert(offsetof(FCAHUDHealthBarDistanceRow, M_fov_actor_type) == 0x000008, "Member 'FCAHUDHealthBarDistanceRow::M_fov_actor_type' has a wrong offset!");
static_assert(offsetof(FCAHUDHealthBarDistanceRow, M_health_bar_distance_data) == 0x000010, "Member 'FCAHUDHealthBarDistanceRow::M_health_bar_distance_data' has a wrong offset!");

// ScriptStruct keaton.CAFovData
// 0x00B0 (0x00B0 - 0x0000)
struct FCAFovData final
{
public:
	ECAFovLevel                                   M_fov_level;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_screen_area_percentage;                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_opacity;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_opacity_when_aiming;                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<float, float>                            M_opacity_with_distance;                           // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<float, float>                            M_opacity_with_distance_when_aiming;               // 0x0060(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFovData) == 0x000008, "Wrong alignment on FCAFovData");
static_assert(sizeof(FCAFovData) == 0x0000B0, "Wrong size on FCAFovData");
static_assert(offsetof(FCAFovData, M_fov_level) == 0x000000, "Member 'FCAFovData::M_fov_level' has a wrong offset!");
static_assert(offsetof(FCAFovData, M_screen_area_percentage) == 0x000004, "Member 'FCAFovData::M_screen_area_percentage' has a wrong offset!");
static_assert(offsetof(FCAFovData, M_opacity) == 0x000008, "Member 'FCAFovData::M_opacity' has a wrong offset!");
static_assert(offsetof(FCAFovData, M_opacity_when_aiming) == 0x00000C, "Member 'FCAFovData::M_opacity_when_aiming' has a wrong offset!");
static_assert(offsetof(FCAFovData, M_opacity_with_distance) == 0x000010, "Member 'FCAFovData::M_opacity_with_distance' has a wrong offset!");
static_assert(offsetof(FCAFovData, M_opacity_with_distance_when_aiming) == 0x000060, "Member 'FCAFovData::M_opacity_with_distance_when_aiming' has a wrong offset!");

// ScriptStruct keaton.CAFovConfigTableRow
// 0x00B0 (0x00B8 - 0x0008)
struct FCAFovConfigTableRow final : public FTableRowBase
{
public:
	struct FCAFovData                             M_data;                                            // 0x0008(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFovConfigTableRow) == 0x000008, "Wrong alignment on FCAFovConfigTableRow");
static_assert(sizeof(FCAFovConfigTableRow) == 0x0000B8, "Wrong size on FCAFovConfigTableRow");
static_assert(offsetof(FCAFovConfigTableRow, M_data) == 0x000008, "Member 'FCAFovConfigTableRow::M_data' has a wrong offset!");

// ScriptStruct keaton.CAHUDEquipmentInfo
// 0x0060 (0x0068 - 0x0008)
struct FCAHUDEquipmentInfo final : public FCAHUDBaseDataStruct
{
public:
	struct FCAText                                M_name;                                            // 0x0008(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_image;                                           // 0x0038(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDEquipmentInfo) == 0x000008, "Wrong alignment on FCAHUDEquipmentInfo");
static_assert(sizeof(FCAHUDEquipmentInfo) == 0x000068, "Wrong size on FCAHUDEquipmentInfo");
static_assert(offsetof(FCAHUDEquipmentInfo, M_name) == 0x000008, "Member 'FCAHUDEquipmentInfo::M_name' has a wrong offset!");
static_assert(offsetof(FCAHUDEquipmentInfo, M_image) == 0x000038, "Member 'FCAHUDEquipmentInfo::M_image' has a wrong offset!");

// ScriptStruct keaton.CAHUDMinimapDataStruct
// 0x0018 (0x0020 - 0x0008)
struct FCAHUDMinimapDataStruct final : public FCAHUDBaseDataStruct
{
public:
	class FString                                 Deck_name;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num_icons;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAHUDMinimapDataStruct) == 0x000008, "Wrong alignment on FCAHUDMinimapDataStruct");
static_assert(sizeof(FCAHUDMinimapDataStruct) == 0x000020, "Wrong size on FCAHUDMinimapDataStruct");
static_assert(offsetof(FCAHUDMinimapDataStruct, Deck_name) == 0x000008, "Member 'FCAHUDMinimapDataStruct::Deck_name' has a wrong offset!");
static_assert(offsetof(FCAHUDMinimapDataStruct, Num_icons) == 0x000018, "Member 'FCAHUDMinimapDataStruct::Num_icons' has a wrong offset!");

// ScriptStruct keaton.CAHUDAmmoStruct
// 0x0018 (0x0020 - 0x0008)
struct FCAHUDAmmoStruct final : public FCAHUDBaseDataStruct
{
public:
	class FString                                 Ammo_name;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Clip_size;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Velocity;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDAmmoStruct) == 0x000008, "Wrong alignment on FCAHUDAmmoStruct");
static_assert(sizeof(FCAHUDAmmoStruct) == 0x000020, "Wrong size on FCAHUDAmmoStruct");
static_assert(offsetof(FCAHUDAmmoStruct, Ammo_name) == 0x000008, "Member 'FCAHUDAmmoStruct::Ammo_name' has a wrong offset!");
static_assert(offsetof(FCAHUDAmmoStruct, Clip_size) == 0x000018, "Member 'FCAHUDAmmoStruct::Clip_size' has a wrong offset!");
static_assert(offsetof(FCAHUDAmmoStruct, Velocity) == 0x00001C, "Member 'FCAHUDAmmoStruct::Velocity' has a wrong offset!");

// ScriptStruct keaton.CAHUDInputTextStyles
// 0x0090 (0x0090 - 0x0000)
struct FCAHUDInputTextStyles final
{
public:
	struct FCAGameDatabaseRowHandle               M_controller_icon_text_style_handle;               // 0x0000(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_controller_text_style_handle;                    // 0x0018(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_keyboard_key_text_style_handle;                  // 0x0030(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_mouse_icon_text_style_handle;                    // 0x0048(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_icon_if_keyboard_text_style_handle;              // 0x0060(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_icon_if_controller_text_style_handle;            // 0x0078(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDInputTextStyles) == 0x000004, "Wrong alignment on FCAHUDInputTextStyles");
static_assert(sizeof(FCAHUDInputTextStyles) == 0x000090, "Wrong size on FCAHUDInputTextStyles");
static_assert(offsetof(FCAHUDInputTextStyles, M_controller_icon_text_style_handle) == 0x000000, "Member 'FCAHUDInputTextStyles::M_controller_icon_text_style_handle' has a wrong offset!");
static_assert(offsetof(FCAHUDInputTextStyles, M_controller_text_style_handle) == 0x000018, "Member 'FCAHUDInputTextStyles::M_controller_text_style_handle' has a wrong offset!");
static_assert(offsetof(FCAHUDInputTextStyles, M_keyboard_key_text_style_handle) == 0x000030, "Member 'FCAHUDInputTextStyles::M_keyboard_key_text_style_handle' has a wrong offset!");
static_assert(offsetof(FCAHUDInputTextStyles, M_mouse_icon_text_style_handle) == 0x000048, "Member 'FCAHUDInputTextStyles::M_mouse_icon_text_style_handle' has a wrong offset!");
static_assert(offsetof(FCAHUDInputTextStyles, M_icon_if_keyboard_text_style_handle) == 0x000060, "Member 'FCAHUDInputTextStyles::M_icon_if_keyboard_text_style_handle' has a wrong offset!");
static_assert(offsetof(FCAHUDInputTextStyles, M_icon_if_controller_text_style_handle) == 0x000078, "Member 'FCAHUDInputTextStyles::M_icon_if_controller_text_style_handle' has a wrong offset!");

// ScriptStruct keaton.CAHUDInventoryItemsStaticConfig
// 0x0080 (0x0080 - 0x0000)
struct FCAHUDInventoryItemsStaticConfig final
{
public:
	struct FCAText                                M_input_prompt_text;                               // 0x0000(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FCAHUDInputData>                M_ability_inputs;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAHUDInputData>                M_gamepad_ability_inputs;                          // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_ability_type_text;                               // 0x0050(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDInventoryItemsStaticConfig) == 0x000008, "Wrong alignment on FCAHUDInventoryItemsStaticConfig");
static_assert(sizeof(FCAHUDInventoryItemsStaticConfig) == 0x000080, "Wrong size on FCAHUDInventoryItemsStaticConfig");
static_assert(offsetof(FCAHUDInventoryItemsStaticConfig, M_input_prompt_text) == 0x000000, "Member 'FCAHUDInventoryItemsStaticConfig::M_input_prompt_text' has a wrong offset!");
static_assert(offsetof(FCAHUDInventoryItemsStaticConfig, M_ability_inputs) == 0x000030, "Member 'FCAHUDInventoryItemsStaticConfig::M_ability_inputs' has a wrong offset!");
static_assert(offsetof(FCAHUDInventoryItemsStaticConfig, M_gamepad_ability_inputs) == 0x000040, "Member 'FCAHUDInventoryItemsStaticConfig::M_gamepad_ability_inputs' has a wrong offset!");
static_assert(offsetof(FCAHUDInventoryItemsStaticConfig, M_ability_type_text) == 0x000050, "Member 'FCAHUDInventoryItemsStaticConfig::M_ability_type_text' has a wrong offset!");

// ScriptStruct keaton.ZoneLabelData
// 0x0048 (0x0048 - 0x0000)
struct FZoneLabelData final
{
public:
	struct FVector                                M_position;                                        // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_loc_text_fallback;                               // 0x0010(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          M_override_text;                                   // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZoneLabelData) == 0x000008, "Wrong alignment on FZoneLabelData");
static_assert(sizeof(FZoneLabelData) == 0x000048, "Wrong size on FZoneLabelData");
static_assert(offsetof(FZoneLabelData, M_position) == 0x000000, "Member 'FZoneLabelData::M_position' has a wrong offset!");
static_assert(offsetof(FZoneLabelData, M_loc_text_fallback) == 0x000010, "Member 'FZoneLabelData::M_loc_text_fallback' has a wrong offset!");
static_assert(offsetof(FZoneLabelData, M_override_text) == 0x000040, "Member 'FZoneLabelData::M_override_text' has a wrong offset!");

// ScriptStruct keaton.CALevelMapsRow
// 0x00F8 (0x0100 - 0x0008)
struct FCALevelMapsRow final : public FTableRowBase
{
public:
	struct FFeatureKeyItem                        M_feature;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_level_name;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_map_texture;                                     // 0x0020(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_viewpoint_location;                              // 0x0050(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_viewpoint_rotation;                              // 0x005C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FZoneLabelData>                 M_zones_data;                                      // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_map_class;                                       // 0x0078(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FVector, class FName>             M_map_colours;                                     // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          M_should_show_vault_markers;                       // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCALevelMapsRow) == 0x000008, "Wrong alignment on FCALevelMapsRow");
static_assert(sizeof(FCALevelMapsRow) == 0x000100, "Wrong size on FCALevelMapsRow");
static_assert(offsetof(FCALevelMapsRow, M_feature) == 0x000008, "Member 'FCALevelMapsRow::M_feature' has a wrong offset!");
static_assert(offsetof(FCALevelMapsRow, M_level_name) == 0x000010, "Member 'FCALevelMapsRow::M_level_name' has a wrong offset!");
static_assert(offsetof(FCALevelMapsRow, M_map_texture) == 0x000020, "Member 'FCALevelMapsRow::M_map_texture' has a wrong offset!");
static_assert(offsetof(FCALevelMapsRow, M_viewpoint_location) == 0x000050, "Member 'FCALevelMapsRow::M_viewpoint_location' has a wrong offset!");
static_assert(offsetof(FCALevelMapsRow, M_viewpoint_rotation) == 0x00005C, "Member 'FCALevelMapsRow::M_viewpoint_rotation' has a wrong offset!");
static_assert(offsetof(FCALevelMapsRow, M_zones_data) == 0x000068, "Member 'FCALevelMapsRow::M_zones_data' has a wrong offset!");
static_assert(offsetof(FCALevelMapsRow, M_map_class) == 0x000078, "Member 'FCALevelMapsRow::M_map_class' has a wrong offset!");
static_assert(offsetof(FCALevelMapsRow, M_map_colours) == 0x0000A8, "Member 'FCALevelMapsRow::M_map_colours' has a wrong offset!");
static_assert(offsetof(FCALevelMapsRow, M_should_show_vault_markers) == 0x0000F8, "Member 'FCALevelMapsRow::M_should_show_vault_markers' has a wrong offset!");

// ScriptStruct keaton.CAHUDPerkActivity
// 0x0014 (0x0014 - 0x0000)
struct FCAHUDPerkActivity final
{
public:
	class FName                                   M_perk_name;                                       // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_active;                                       // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_payload_value;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDPerkActivity) == 0x000004, "Wrong alignment on FCAHUDPerkActivity");
static_assert(sizeof(FCAHUDPerkActivity) == 0x000014, "Wrong size on FCAHUDPerkActivity");
static_assert(offsetof(FCAHUDPerkActivity, M_perk_name) == 0x000000, "Member 'FCAHUDPerkActivity::M_perk_name' has a wrong offset!");
static_assert(offsetof(FCAHUDPerkActivity, M_is_active) == 0x00000C, "Member 'FCAHUDPerkActivity::M_is_active' has a wrong offset!");
static_assert(offsetof(FCAHUDPerkActivity, M_payload_value) == 0x000010, "Member 'FCAHUDPerkActivity::M_payload_value' has a wrong offset!");

// ScriptStruct keaton.CASupplyLevelTableRow
// 0x0040 (0x0048 - 0x0008)
struct FCASupplyLevelTableRow final : public FTableRowBase
{
public:
	ECASupplyLevel                                M_supply_level;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_min_crate_quantity;                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_max_crate_quantity;                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_supply_level_loc_key;                            // 0x0018(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASupplyLevelTableRow) == 0x000008, "Wrong alignment on FCASupplyLevelTableRow");
static_assert(sizeof(FCASupplyLevelTableRow) == 0x000048, "Wrong size on FCASupplyLevelTableRow");
static_assert(offsetof(FCASupplyLevelTableRow, M_supply_level) == 0x000008, "Member 'FCASupplyLevelTableRow::M_supply_level' has a wrong offset!");
static_assert(offsetof(FCASupplyLevelTableRow, M_min_crate_quantity) == 0x00000C, "Member 'FCASupplyLevelTableRow::M_min_crate_quantity' has a wrong offset!");
static_assert(offsetof(FCASupplyLevelTableRow, M_max_crate_quantity) == 0x000010, "Member 'FCASupplyLevelTableRow::M_max_crate_quantity' has a wrong offset!");
static_assert(offsetof(FCASupplyLevelTableRow, M_supply_level_loc_key) == 0x000018, "Member 'FCASupplyLevelTableRow::M_supply_level_loc_key' has a wrong offset!");

// ScriptStruct keaton.CAPickupCelebrationUIData
// 0x00A8 (0x00B0 - 0x0008)
struct FCAPickupCelebrationUIData final : public FTableRowBase
{
public:
	class UTexture2D*                             M_primary_texture;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             M_secondary_texture;                               // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_spatial_texture;                                 // 0x0018(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAText                                M_header;                                          // 0x0048(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_sub_header;                                      // 0x0078(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_audio_event;                                     // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPickupCelebrationUIData) == 0x000008, "Wrong alignment on FCAPickupCelebrationUIData");
static_assert(sizeof(FCAPickupCelebrationUIData) == 0x0000B0, "Wrong size on FCAPickupCelebrationUIData");
static_assert(offsetof(FCAPickupCelebrationUIData, M_primary_texture) == 0x000008, "Member 'FCAPickupCelebrationUIData::M_primary_texture' has a wrong offset!");
static_assert(offsetof(FCAPickupCelebrationUIData, M_secondary_texture) == 0x000010, "Member 'FCAPickupCelebrationUIData::M_secondary_texture' has a wrong offset!");
static_assert(offsetof(FCAPickupCelebrationUIData, M_spatial_texture) == 0x000018, "Member 'FCAPickupCelebrationUIData::M_spatial_texture' has a wrong offset!");
static_assert(offsetof(FCAPickupCelebrationUIData, M_header) == 0x000048, "Member 'FCAPickupCelebrationUIData::M_header' has a wrong offset!");
static_assert(offsetof(FCAPickupCelebrationUIData, M_sub_header) == 0x000078, "Member 'FCAPickupCelebrationUIData::M_sub_header' has a wrong offset!");
static_assert(offsetof(FCAPickupCelebrationUIData, M_audio_event) == 0x0000A8, "Member 'FCAPickupCelebrationUIData::M_audio_event' has a wrong offset!");

// ScriptStruct keaton.CAHUDSpatialShieldBarData
// 0x0014 (0x0014 - 0x0000)
struct FCAHUDSpatialShieldBarData final
{
public:
	float                                         M_armour;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_armour;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_amount;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_max_amount;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 M_item_color;                                      // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDSpatialShieldBarData) == 0x000004, "Wrong alignment on FCAHUDSpatialShieldBarData");
static_assert(sizeof(FCAHUDSpatialShieldBarData) == 0x000014, "Wrong size on FCAHUDSpatialShieldBarData");
static_assert(offsetof(FCAHUDSpatialShieldBarData, M_armour) == 0x000000, "Member 'FCAHUDSpatialShieldBarData::M_armour' has a wrong offset!");
static_assert(offsetof(FCAHUDSpatialShieldBarData, M_max_armour) == 0x000004, "Member 'FCAHUDSpatialShieldBarData::M_max_armour' has a wrong offset!");
static_assert(offsetof(FCAHUDSpatialShieldBarData, M_amount) == 0x000008, "Member 'FCAHUDSpatialShieldBarData::M_amount' has a wrong offset!");
static_assert(offsetof(FCAHUDSpatialShieldBarData, M_max_amount) == 0x00000C, "Member 'FCAHUDSpatialShieldBarData::M_max_amount' has a wrong offset!");
static_assert(offsetof(FCAHUDSpatialShieldBarData, M_item_color) == 0x000010, "Member 'FCAHUDSpatialShieldBarData::M_item_color' has a wrong offset!");

// ScriptStruct keaton.CAHUDPickupSpatialLabelInfo
// 0x00F0 (0x00F0 - 0x0000)
struct FCAHUDPickupSpatialLabelInfo final
{
public:
	struct FCAText                                M_pickup_label;                                    // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCAText                                M_swap_label;                                      // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCAText                                M_upgrade_label;                                   // 0x0060(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCAText                                M_inventory_full_label;                            // 0x0090(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCAText                                M_max_level_label;                                 // 0x00C0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDPickupSpatialLabelInfo) == 0x000008, "Wrong alignment on FCAHUDPickupSpatialLabelInfo");
static_assert(sizeof(FCAHUDPickupSpatialLabelInfo) == 0x0000F0, "Wrong size on FCAHUDPickupSpatialLabelInfo");
static_assert(offsetof(FCAHUDPickupSpatialLabelInfo, M_pickup_label) == 0x000000, "Member 'FCAHUDPickupSpatialLabelInfo::M_pickup_label' has a wrong offset!");
static_assert(offsetof(FCAHUDPickupSpatialLabelInfo, M_swap_label) == 0x000030, "Member 'FCAHUDPickupSpatialLabelInfo::M_swap_label' has a wrong offset!");
static_assert(offsetof(FCAHUDPickupSpatialLabelInfo, M_upgrade_label) == 0x000060, "Member 'FCAHUDPickupSpatialLabelInfo::M_upgrade_label' has a wrong offset!");
static_assert(offsetof(FCAHUDPickupSpatialLabelInfo, M_inventory_full_label) == 0x000090, "Member 'FCAHUDPickupSpatialLabelInfo::M_inventory_full_label' has a wrong offset!");
static_assert(offsetof(FCAHUDPickupSpatialLabelInfo, M_max_level_label) == 0x0000C0, "Member 'FCAHUDPickupSpatialLabelInfo::M_max_level_label' has a wrong offset!");

// ScriptStruct keaton.InventoryData
// 0x01E0 (0x01E0 - 0x0000)
struct FInventoryData final
{
public:
	struct FGuid                                  M_id;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_meta_data_class;                                 // 0x0010(0x0030)(Edit, BlueprintVisible, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_name;                                            // 0x0040(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UStaticMesh>             M_static_mesh;                                     // 0x0050(0x0030)(Edit, BlueprintVisible, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_default_max_amount;                              // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_max_stack;                                       // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_swappable;                                       // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_value;                                           // 0x008C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_item_type;                                       // 0x0090(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_item_slot;                                       // 0x009C(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAPickupMethod                               M_pickup_method;                                   // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_drop_on_death;                                   // 0x00A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_item_states;                                     // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ECAAllowItemState>                     M_allowed_states;                                  // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     M_stack_transforms;                                // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_should_be_highlighted;                           // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAOutlineColor                               M_highlight_colour;                                // 0x00D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x2];                                       // 0x00D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAAudioSwitchValueType                M_pickup_audio;                                    // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   M_dialogue_name;                                   // 0x00D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFItemRarityTier                              M_item_rarity;                                     // 0x00E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          M_niagara_pickup_beam_effect_asset;                // 0x00E8(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          M_niagara_ar_subscription_effect_asset;            // 0x0118(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          M_vault_niagara_effect_asset;                      // 0x0148(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          M_collected_niagara_template;                      // 0x0178(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_can_level_up;                                    // 0x01A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCAItemSlotData>         M_item_slot_data;                                  // 0x01B0(0x0030)(Edit, DisableEditOnInstance, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryData) == 0x000008, "Wrong alignment on FInventoryData");
static_assert(sizeof(FInventoryData) == 0x0001E0, "Wrong size on FInventoryData");
static_assert(offsetof(FInventoryData, M_id) == 0x000000, "Member 'FInventoryData::M_id' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_meta_data_class) == 0x000010, "Member 'FInventoryData::M_meta_data_class' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_name) == 0x000040, "Member 'FInventoryData::M_name' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_static_mesh) == 0x000050, "Member 'FInventoryData::M_static_mesh' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_default_max_amount) == 0x000080, "Member 'FInventoryData::M_default_max_amount' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_max_stack) == 0x000084, "Member 'FInventoryData::M_max_stack' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_swappable) == 0x000088, "Member 'FInventoryData::M_swappable' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_value) == 0x00008C, "Member 'FInventoryData::M_value' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_item_type) == 0x000090, "Member 'FInventoryData::M_item_type' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_item_slot) == 0x00009C, "Member 'FInventoryData::M_item_slot' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_pickup_method) == 0x0000A8, "Member 'FInventoryData::M_pickup_method' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_drop_on_death) == 0x0000A9, "Member 'FInventoryData::M_drop_on_death' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_item_states) == 0x0000AC, "Member 'FInventoryData::M_item_states' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_allowed_states) == 0x0000B0, "Member 'FInventoryData::M_allowed_states' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_stack_transforms) == 0x0000C0, "Member 'FInventoryData::M_stack_transforms' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_should_be_highlighted) == 0x0000D0, "Member 'FInventoryData::M_should_be_highlighted' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_highlight_colour) == 0x0000D1, "Member 'FInventoryData::M_highlight_colour' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_pickup_audio) == 0x0000D4, "Member 'FInventoryData::M_pickup_audio' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_dialogue_name) == 0x0000D8, "Member 'FInventoryData::M_dialogue_name' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_item_rarity) == 0x0000E4, "Member 'FInventoryData::M_item_rarity' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_niagara_pickup_beam_effect_asset) == 0x0000E8, "Member 'FInventoryData::M_niagara_pickup_beam_effect_asset' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_niagara_ar_subscription_effect_asset) == 0x000118, "Member 'FInventoryData::M_niagara_ar_subscription_effect_asset' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_vault_niagara_effect_asset) == 0x000148, "Member 'FInventoryData::M_vault_niagara_effect_asset' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_collected_niagara_template) == 0x000178, "Member 'FInventoryData::M_collected_niagara_template' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_can_level_up) == 0x0001A8, "Member 'FInventoryData::M_can_level_up' has a wrong offset!");
static_assert(offsetof(FInventoryData, M_item_slot_data) == 0x0001B0, "Member 'FInventoryData::M_item_slot_data' has a wrong offset!");

// ScriptStruct keaton.CAHUDSpatialItemInfoSource
// 0x0210 (0x0210 - 0x0000)
struct FCAHUDSpatialItemInfoSource final
{
public:
	ECAHUDPickupType                              M_pickup_type;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECAHUDPickupAction>                    M_pickup_actions;                                  // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UCAInventoryItem*                       M_item;                                            // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInventoryData                         M_item_data;                                       // 0x0020(0x01E0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_amount;                                          // 0x0200(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_level;                                           // 0x0204(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_armour;                                          // 0x0208(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_armour;                                      // 0x020C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDSpatialItemInfoSource) == 0x000008, "Wrong alignment on FCAHUDSpatialItemInfoSource");
static_assert(sizeof(FCAHUDSpatialItemInfoSource) == 0x000210, "Wrong size on FCAHUDSpatialItemInfoSource");
static_assert(offsetof(FCAHUDSpatialItemInfoSource, M_pickup_type) == 0x000000, "Member 'FCAHUDSpatialItemInfoSource::M_pickup_type' has a wrong offset!");
static_assert(offsetof(FCAHUDSpatialItemInfoSource, M_pickup_actions) == 0x000008, "Member 'FCAHUDSpatialItemInfoSource::M_pickup_actions' has a wrong offset!");
static_assert(offsetof(FCAHUDSpatialItemInfoSource, M_item) == 0x000018, "Member 'FCAHUDSpatialItemInfoSource::M_item' has a wrong offset!");
static_assert(offsetof(FCAHUDSpatialItemInfoSource, M_item_data) == 0x000020, "Member 'FCAHUDSpatialItemInfoSource::M_item_data' has a wrong offset!");
static_assert(offsetof(FCAHUDSpatialItemInfoSource, M_amount) == 0x000200, "Member 'FCAHUDSpatialItemInfoSource::M_amount' has a wrong offset!");
static_assert(offsetof(FCAHUDSpatialItemInfoSource, M_level) == 0x000204, "Member 'FCAHUDSpatialItemInfoSource::M_level' has a wrong offset!");
static_assert(offsetof(FCAHUDSpatialItemInfoSource, M_armour) == 0x000208, "Member 'FCAHUDSpatialItemInfoSource::M_armour' has a wrong offset!");
static_assert(offsetof(FCAHUDSpatialItemInfoSource, M_max_armour) == 0x00020C, "Member 'FCAHUDSpatialItemInfoSource::M_max_armour' has a wrong offset!");

// ScriptStruct keaton.CAHUDSectionEMPStatus
// 0x0018 (0x0018 - 0x0000)
struct FCAHUDSectionEMPStatus final
{
public:
	TArray<ECAHUDSection>                         M_hud_sections;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_under_emp;                                       // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAHUDSectionEMPStatus) == 0x000008, "Wrong alignment on FCAHUDSectionEMPStatus");
static_assert(sizeof(FCAHUDSectionEMPStatus) == 0x000018, "Wrong size on FCAHUDSectionEMPStatus");
static_assert(offsetof(FCAHUDSectionEMPStatus, M_hud_sections) == 0x000000, "Member 'FCAHUDSectionEMPStatus::M_hud_sections' has a wrong offset!");
static_assert(offsetof(FCAHUDSectionEMPStatus, M_under_emp) == 0x000010, "Member 'FCAHUDSectionEMPStatus::M_under_emp' has a wrong offset!");

// ScriptStruct keaton.CATargetModeColourTableRow
// 0x0008 (0x0010 - 0x0008)
struct FCATargetModeColourTableRow final : public FTableRowBase
{
public:
	ECAUI_ReticuleTargettingMode                  M_target_mode;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAOutlineColor                               M_colour;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCATargetModeColourTableRow) == 0x000008, "Wrong alignment on FCATargetModeColourTableRow");
static_assert(sizeof(FCATargetModeColourTableRow) == 0x000010, "Wrong size on FCATargetModeColourTableRow");
static_assert(offsetof(FCATargetModeColourTableRow, M_target_mode) == 0x000008, "Member 'FCATargetModeColourTableRow::M_target_mode' has a wrong offset!");
static_assert(offsetof(FCATargetModeColourTableRow, M_colour) == 0x000009, "Member 'FCATargetModeColourTableRow::M_colour' has a wrong offset!");

// ScriptStruct keaton.CAHUDArcLensTeammate
// 0x0018 (0x0018 - 0x0000)
struct FCAHUDArcLensTeammate final
{
public:
	class UCAArcLensTeammateDataProvider*         M_arc_lens_data_provider;                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAArcLensTeammateWidget*               M_widget;                                          // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAArcLensInspectableComponent*         M_inspect_component;                               // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHUDArcLensTeammate) == 0x000008, "Wrong alignment on FCAHUDArcLensTeammate");
static_assert(sizeof(FCAHUDArcLensTeammate) == 0x000018, "Wrong size on FCAHUDArcLensTeammate");
static_assert(offsetof(FCAHUDArcLensTeammate, M_arc_lens_data_provider) == 0x000000, "Member 'FCAHUDArcLensTeammate::M_arc_lens_data_provider' has a wrong offset!");
static_assert(offsetof(FCAHUDArcLensTeammate, M_widget) == 0x000008, "Member 'FCAHUDArcLensTeammate::M_widget' has a wrong offset!");
static_assert(offsetof(FCAHUDArcLensTeammate, M_inspect_component) == 0x000010, "Member 'FCAHUDArcLensTeammate::M_inspect_component' has a wrong offset!");

// ScriptStruct keaton.CAHUDArcLensServerTeammateState
// 0x0048 (0x0048 - 0x0000)
struct FCAHUDArcLensServerTeammateState final
{
public:
	int32                                         M_player_id;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_player_name;                                     // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_player_downed;                                   // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_player_killed;                                   // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_player_health_percent;                           // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_dynamic_max_health_norm;                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_health_segment_cap_norm;                         // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_num_health_segments;                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_player_percent_of_overall_max_armour;            // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_player_raw_health;                               // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_player_raw_max_health;                           // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_player_armour;                                   // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_cached_downed_threshold;                         // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_overall_armour;                              // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAHUDArcLensServerTeammateState) == 0x000008, "Wrong alignment on FCAHUDArcLensServerTeammateState");
static_assert(sizeof(FCAHUDArcLensServerTeammateState) == 0x000048, "Wrong size on FCAHUDArcLensServerTeammateState");
static_assert(offsetof(FCAHUDArcLensServerTeammateState, M_player_id) == 0x000000, "Member 'FCAHUDArcLensServerTeammateState::M_player_id' has a wrong offset!");
static_assert(offsetof(FCAHUDArcLensServerTeammateState, M_player_name) == 0x000008, "Member 'FCAHUDArcLensServerTeammateState::M_player_name' has a wrong offset!");
static_assert(offsetof(FCAHUDArcLensServerTeammateState, M_player_downed) == 0x000018, "Member 'FCAHUDArcLensServerTeammateState::M_player_downed' has a wrong offset!");
static_assert(offsetof(FCAHUDArcLensServerTeammateState, M_player_killed) == 0x000019, "Member 'FCAHUDArcLensServerTeammateState::M_player_killed' has a wrong offset!");
static_assert(offsetof(FCAHUDArcLensServerTeammateState, M_player_health_percent) == 0x00001C, "Member 'FCAHUDArcLensServerTeammateState::M_player_health_percent' has a wrong offset!");
static_assert(offsetof(FCAHUDArcLensServerTeammateState, M_dynamic_max_health_norm) == 0x000020, "Member 'FCAHUDArcLensServerTeammateState::M_dynamic_max_health_norm' has a wrong offset!");
static_assert(offsetof(FCAHUDArcLensServerTeammateState, M_health_segment_cap_norm) == 0x000024, "Member 'FCAHUDArcLensServerTeammateState::M_health_segment_cap_norm' has a wrong offset!");
static_assert(offsetof(FCAHUDArcLensServerTeammateState, M_num_health_segments) == 0x000028, "Member 'FCAHUDArcLensServerTeammateState::M_num_health_segments' has a wrong offset!");
static_assert(offsetof(FCAHUDArcLensServerTeammateState, M_player_percent_of_overall_max_armour) == 0x00002C, "Member 'FCAHUDArcLensServerTeammateState::M_player_percent_of_overall_max_armour' has a wrong offset!");
static_assert(offsetof(FCAHUDArcLensServerTeammateState, M_player_raw_health) == 0x000030, "Member 'FCAHUDArcLensServerTeammateState::M_player_raw_health' has a wrong offset!");
static_assert(offsetof(FCAHUDArcLensServerTeammateState, M_player_raw_max_health) == 0x000034, "Member 'FCAHUDArcLensServerTeammateState::M_player_raw_max_health' has a wrong offset!");
static_assert(offsetof(FCAHUDArcLensServerTeammateState, M_player_armour) == 0x000038, "Member 'FCAHUDArcLensServerTeammateState::M_player_armour' has a wrong offset!");
static_assert(offsetof(FCAHUDArcLensServerTeammateState, M_cached_downed_threshold) == 0x00003C, "Member 'FCAHUDArcLensServerTeammateState::M_cached_downed_threshold' has a wrong offset!");
static_assert(offsetof(FCAHUDArcLensServerTeammateState, M_max_overall_armour) == 0x000040, "Member 'FCAHUDArcLensServerTeammateState::M_max_overall_armour' has a wrong offset!");

// ScriptStruct keaton.HUDPlayerStat
// 0x0088 (0x0088 - 0x0000)
struct FHUDPlayerStat final
{
public:
	int32                                         M_player_id;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_player_name;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_specialist_name;                                 // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_player_guid;                                     // 0x0024(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_player_health;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_downed_health;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_dynamic_max_health;                              // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_health_segment_cap;                              // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_num_health_segments;                             // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_armour_name;                                     // 0x0044(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_player_armour;                                   // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_player_max_armour;                               // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_player_armour_pieces;                            // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_player_armour_pieces_max;                        // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_armour_segment_cap;                              // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_num_armour_segments;                             // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_player_downed;                                   // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_player_killed;                                   // 0x0069(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_ability_name;                                    // 0x006C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_ability_availability;                            // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_cash;                                            // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_detection_progress;                              // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_disconnected;                                    // 0x0084(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHUDPlayerStat) == 0x000008, "Wrong alignment on FHUDPlayerStat");
static_assert(sizeof(FHUDPlayerStat) == 0x000088, "Wrong size on FHUDPlayerStat");
static_assert(offsetof(FHUDPlayerStat, M_player_id) == 0x000000, "Member 'FHUDPlayerStat::M_player_id' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_player_name) == 0x000008, "Member 'FHUDPlayerStat::M_player_name' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_specialist_name) == 0x000018, "Member 'FHUDPlayerStat::M_specialist_name' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_player_guid) == 0x000024, "Member 'FHUDPlayerStat::M_player_guid' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_player_health) == 0x000030, "Member 'FHUDPlayerStat::M_player_health' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_downed_health) == 0x000034, "Member 'FHUDPlayerStat::M_downed_health' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_dynamic_max_health) == 0x000038, "Member 'FHUDPlayerStat::M_dynamic_max_health' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_health_segment_cap) == 0x00003C, "Member 'FHUDPlayerStat::M_health_segment_cap' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_num_health_segments) == 0x000040, "Member 'FHUDPlayerStat::M_num_health_segments' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_armour_name) == 0x000044, "Member 'FHUDPlayerStat::M_armour_name' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_player_armour) == 0x000050, "Member 'FHUDPlayerStat::M_player_armour' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_player_max_armour) == 0x000054, "Member 'FHUDPlayerStat::M_player_max_armour' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_player_armour_pieces) == 0x000058, "Member 'FHUDPlayerStat::M_player_armour_pieces' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_player_armour_pieces_max) == 0x00005C, "Member 'FHUDPlayerStat::M_player_armour_pieces_max' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_armour_segment_cap) == 0x000060, "Member 'FHUDPlayerStat::M_armour_segment_cap' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_num_armour_segments) == 0x000064, "Member 'FHUDPlayerStat::M_num_armour_segments' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_player_downed) == 0x000068, "Member 'FHUDPlayerStat::M_player_downed' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_player_killed) == 0x000069, "Member 'FHUDPlayerStat::M_player_killed' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_ability_name) == 0x00006C, "Member 'FHUDPlayerStat::M_ability_name' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_ability_availability) == 0x000078, "Member 'FHUDPlayerStat::M_ability_availability' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_cash) == 0x00007C, "Member 'FHUDPlayerStat::M_cash' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_detection_progress) == 0x000080, "Member 'FHUDPlayerStat::M_detection_progress' has a wrong offset!");
static_assert(offsetof(FHUDPlayerStat, M_disconnected) == 0x000084, "Member 'FHUDPlayerStat::M_disconnected' has a wrong offset!");

// ScriptStruct keaton.TeamVoiceInformation
// 0x0050 (0x0050 - 0x0000)
struct FTeamVoiceInformation final
{
public:
	TMap<class FString, class FString>            M_entries;                                         // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamVoiceInformation) == 0x000008, "Wrong alignment on FTeamVoiceInformation");
static_assert(sizeof(FTeamVoiceInformation) == 0x000050, "Wrong size on FTeamVoiceInformation");
static_assert(offsetof(FTeamVoiceInformation, M_entries) == 0x000000, "Member 'FTeamVoiceInformation::M_entries' has a wrong offset!");

// ScriptStruct keaton.TeamVoiceIndicatorContext
// 0x0058 (0x0058 - 0x0000)
struct FTeamVoiceIndicatorContext final
{
public:
	ETeamVoiceIndicatorMode                       M_mode;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTeamVoiceInformation                  M_team_voice_information;                          // 0x0008(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamVoiceIndicatorContext) == 0x000008, "Wrong alignment on FTeamVoiceIndicatorContext");
static_assert(sizeof(FTeamVoiceIndicatorContext) == 0x000058, "Wrong size on FTeamVoiceIndicatorContext");
static_assert(offsetof(FTeamVoiceIndicatorContext, M_mode) == 0x000000, "Member 'FTeamVoiceIndicatorContext::M_mode' has a wrong offset!");
static_assert(offsetof(FTeamVoiceIndicatorContext, M_team_voice_information) == 0x000008, "Member 'FTeamVoiceIndicatorContext::M_team_voice_information' has a wrong offset!");

// ScriptStruct keaton.CAHUDObjectiveRow
// 0x0070 (0x0078 - 0x0008)
struct FCAHUDObjectiveRow final : public FTableRowBase
{
public:
	ECAHUDThresholdObjective                      M_objective;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_objective_label;                                 // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_icon_texture;                                    // 0x0040(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_objective_hidden;                             // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAHUDObjectiveRow) == 0x000008, "Wrong alignment on FCAHUDObjectiveRow");
static_assert(sizeof(FCAHUDObjectiveRow) == 0x000078, "Wrong size on FCAHUDObjectiveRow");
static_assert(offsetof(FCAHUDObjectiveRow, M_objective) == 0x000008, "Member 'FCAHUDObjectiveRow::M_objective' has a wrong offset!");
static_assert(offsetof(FCAHUDObjectiveRow, M_objective_label) == 0x000010, "Member 'FCAHUDObjectiveRow::M_objective_label' has a wrong offset!");
static_assert(offsetof(FCAHUDObjectiveRow, M_icon_texture) == 0x000040, "Member 'FCAHUDObjectiveRow::M_icon_texture' has a wrong offset!");
static_assert(offsetof(FCAHUDObjectiveRow, M_is_objective_hidden) == 0x000070, "Member 'FCAHUDObjectiveRow::M_is_objective_hidden' has a wrong offset!");

// ScriptStruct keaton.CAXpKickerNPCData
// 0x0018 (0x0018 - 0x0000)
struct FCAXpKickerNPCData final
{
public:
	struct FGameplayTag                           M_npc_tag;                                         // 0x0000(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_reward_name;                                     // 0x000C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAXpKickerNPCData) == 0x000004, "Wrong alignment on FCAXpKickerNPCData");
static_assert(sizeof(FCAXpKickerNPCData) == 0x000018, "Wrong size on FCAXpKickerNPCData");
static_assert(offsetof(FCAXpKickerNPCData, M_npc_tag) == 0x000000, "Member 'FCAXpKickerNPCData::M_npc_tag' has a wrong offset!");
static_assert(offsetof(FCAXpKickerNPCData, M_reward_name) == 0x00000C, "Member 'FCAXpKickerNPCData::M_reward_name' has a wrong offset!");

// ScriptStruct keaton.CAXpKickerInfoRow
// 0x0030 (0x0038 - 0x0008)
struct FCAXpKickerInfoRow final : public FTableRowBase
{
public:
	struct FCAText                                M_text_prompt;                                     // 0x0008(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAXpKickerInfoRow) == 0x000008, "Wrong alignment on FCAXpKickerInfoRow");
static_assert(sizeof(FCAXpKickerInfoRow) == 0x000038, "Wrong size on FCAXpKickerInfoRow");
static_assert(offsetof(FCAXpKickerInfoRow, M_text_prompt) == 0x000008, "Member 'FCAXpKickerInfoRow::M_text_prompt' has a wrong offset!");

// ScriptStruct keaton.CAPrioritisedExceptionGroup
// 0x0010 (0x0010 - 0x0000)
struct FCAPrioritisedExceptionGroup final
{
public:
	TArray<struct FGameplayTag>                   M_exceptions;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPrioritisedExceptionGroup) == 0x000008, "Wrong alignment on FCAPrioritisedExceptionGroup");
static_assert(sizeof(FCAPrioritisedExceptionGroup) == 0x000010, "Wrong size on FCAPrioritisedExceptionGroup");
static_assert(offsetof(FCAPrioritisedExceptionGroup, M_exceptions) == 0x000000, "Member 'FCAPrioritisedExceptionGroup::M_exceptions' has a wrong offset!");

// ScriptStruct keaton.CAInclusionSetting
// 0x0028 (0x0028 - 0x0000)
struct FCAInclusionSetting final
{
public:
	ECAInclusionSetting                           M_inclusion_setting;                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_use_prioritised_exception_groups;                // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   M_exceptions;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FCAPrioritisedExceptionGroup>   M_prioritised_exception_groups;                    // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCAInclusionSetting) == 0x000008, "Wrong alignment on FCAInclusionSetting");
static_assert(sizeof(FCAInclusionSetting) == 0x000028, "Wrong size on FCAInclusionSetting");
static_assert(offsetof(FCAInclusionSetting, M_inclusion_setting) == 0x000000, "Member 'FCAInclusionSetting::M_inclusion_setting' has a wrong offset!");
static_assert(offsetof(FCAInclusionSetting, M_use_prioritised_exception_groups) == 0x000001, "Member 'FCAInclusionSetting::M_use_prioritised_exception_groups' has a wrong offset!");
static_assert(offsetof(FCAInclusionSetting, M_exceptions) == 0x000008, "Member 'FCAInclusionSetting::M_exceptions' has a wrong offset!");
static_assert(offsetof(FCAInclusionSetting, M_prioritised_exception_groups) == 0x000018, "Member 'FCAInclusionSetting::M_prioritised_exception_groups' has a wrong offset!");

// ScriptStruct keaton.CAInformationControlData
// 0x000C (0x000C - 0x0000)
struct FCAInformationControlData final
{
public:
	int32                                         M_entity_id;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCATeamID                              M_team_id;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAInformationControlLevel                    M_information_level;                               // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAInformationControlData) == 0x000004, "Wrong alignment on FCAInformationControlData");
static_assert(sizeof(FCAInformationControlData) == 0x00000C, "Wrong size on FCAInformationControlData");
static_assert(offsetof(FCAInformationControlData, M_entity_id) == 0x000000, "Member 'FCAInformationControlData::M_entity_id' has a wrong offset!");
static_assert(offsetof(FCAInformationControlData, M_team_id) == 0x000004, "Member 'FCAInformationControlData::M_team_id' has a wrong offset!");
static_assert(offsetof(FCAInformationControlData, M_information_level) == 0x000008, "Member 'FCAInformationControlData::M_information_level' has a wrong offset!");

// ScriptStruct keaton.CAInputBindingToTagMapping
// 0x0038 (0x0040 - 0x0008)
struct FCAInputBindingToTagMapping final : public FTableRowBase
{
public:
	class FName                                   M_action_name;                                     // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   M_tags_pressed;                                    // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   M_tags_released;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_is_toggle;                                       // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_send_to_server;                                  // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAInputMappingToggleGroup                    M_toggle_group;                                    // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAInputBindingToTagMapping) == 0x000008, "Wrong alignment on FCAInputBindingToTagMapping");
static_assert(sizeof(FCAInputBindingToTagMapping) == 0x000040, "Wrong size on FCAInputBindingToTagMapping");
static_assert(offsetof(FCAInputBindingToTagMapping, M_action_name) == 0x000008, "Member 'FCAInputBindingToTagMapping::M_action_name' has a wrong offset!");
static_assert(offsetof(FCAInputBindingToTagMapping, M_tags_pressed) == 0x000018, "Member 'FCAInputBindingToTagMapping::M_tags_pressed' has a wrong offset!");
static_assert(offsetof(FCAInputBindingToTagMapping, M_tags_released) == 0x000028, "Member 'FCAInputBindingToTagMapping::M_tags_released' has a wrong offset!");
static_assert(offsetof(FCAInputBindingToTagMapping, M_is_toggle) == 0x000038, "Member 'FCAInputBindingToTagMapping::M_is_toggle' has a wrong offset!");
static_assert(offsetof(FCAInputBindingToTagMapping, M_send_to_server) == 0x000039, "Member 'FCAInputBindingToTagMapping::M_send_to_server' has a wrong offset!");
static_assert(offsetof(FCAInputBindingToTagMapping, M_toggle_group) == 0x00003A, "Member 'FCAInputBindingToTagMapping::M_toggle_group' has a wrong offset!");

// ScriptStruct keaton.CAInputAxisKeyMapping
// 0x0048 (0x0048 - 0x0000)
struct FCAInputAxisKeyMapping final
{
public:
	class FName                                   AxisName;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0010(0x0020)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsDebug : 1;                                      // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RebindID;                                          // 0x0034(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreForRebinding;                                // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAInputAxisKeyMapping) == 0x000008, "Wrong alignment on FCAInputAxisKeyMapping");
static_assert(sizeof(FCAInputAxisKeyMapping) == 0x000048, "Wrong size on FCAInputAxisKeyMapping");
static_assert(offsetof(FCAInputAxisKeyMapping, AxisName) == 0x000000, "Member 'FCAInputAxisKeyMapping::AxisName' has a wrong offset!");
static_assert(offsetof(FCAInputAxisKeyMapping, Scale) == 0x00000C, "Member 'FCAInputAxisKeyMapping::Scale' has a wrong offset!");
static_assert(offsetof(FCAInputAxisKeyMapping, Key) == 0x000010, "Member 'FCAInputAxisKeyMapping::Key' has a wrong offset!");
static_assert(offsetof(FCAInputAxisKeyMapping, RebindID) == 0x000034, "Member 'FCAInputAxisKeyMapping::RebindID' has a wrong offset!");
static_assert(offsetof(FCAInputAxisKeyMapping, IgnoreForRebinding) == 0x000040, "Member 'FCAInputAxisKeyMapping::IgnoreForRebinding' has a wrong offset!");

// ScriptStruct keaton.CAInputActionKeyMapping
// 0x0040 (0x0040 - 0x0000)
struct FCAInputActionKeyMapping final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShift : 1;                                        // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCtrl : 1;                                         // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlt : 1;                                          // 0x000C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCmd : 1;                                          // 0x000C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsDebug : 1;                                      // 0x000C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RebindID;                                          // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreForRebinding;                                // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   Key;                                               // 0x0020(0x0020)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAInputActionKeyMapping) == 0x000008, "Wrong alignment on FCAInputActionKeyMapping");
static_assert(sizeof(FCAInputActionKeyMapping) == 0x000040, "Wrong size on FCAInputActionKeyMapping");
static_assert(offsetof(FCAInputActionKeyMapping, ActionName) == 0x000000, "Member 'FCAInputActionKeyMapping::ActionName' has a wrong offset!");
static_assert(offsetof(FCAInputActionKeyMapping, RebindID) == 0x000010, "Member 'FCAInputActionKeyMapping::RebindID' has a wrong offset!");
static_assert(offsetof(FCAInputActionKeyMapping, IgnoreForRebinding) == 0x00001C, "Member 'FCAInputActionKeyMapping::IgnoreForRebinding' has a wrong offset!");
static_assert(offsetof(FCAInputActionKeyMapping, Key) == 0x000020, "Member 'FCAInputActionKeyMapping::Key' has a wrong offset!");

// ScriptStruct keaton.CAInstrumentedTimerData
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FCAInstrumentedTimerData final
{
public:
	uint8                                         Pad_0[0x4C];                                       // 0x0000(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_max_frame_time_allowed;                          // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAInstrumentedTimerData) == 0x000008, "Wrong alignment on FCAInstrumentedTimerData");
static_assert(sizeof(FCAInstrumentedTimerData) == 0x000058, "Wrong size on FCAInstrumentedTimerData");
static_assert(offsetof(FCAInstrumentedTimerData, M_max_frame_time_allowed) == 0x00004C, "Member 'FCAInstrumentedTimerData::M_max_frame_time_allowed' has a wrong offset!");

// ScriptStruct keaton.CAInstrumentedTimerSetupData
// 0x0018 (0x0020 - 0x0008)
struct FCAInstrumentedTimerSetupData final : public FTableRowBase
{
public:
	ECAInstrumentTimerGroup                       M_group;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_sub_group;                                       // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_max_allowed_usecs;                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAInstrumentedTimerSetupData) == 0x000008, "Wrong alignment on FCAInstrumentedTimerSetupData");
static_assert(sizeof(FCAInstrumentedTimerSetupData) == 0x000020, "Wrong size on FCAInstrumentedTimerSetupData");
static_assert(offsetof(FCAInstrumentedTimerSetupData, M_group) == 0x000008, "Member 'FCAInstrumentedTimerSetupData::M_group' has a wrong offset!");
static_assert(offsetof(FCAInstrumentedTimerSetupData, M_sub_group) == 0x00000C, "Member 'FCAInstrumentedTimerSetupData::M_sub_group' has a wrong offset!");
static_assert(offsetof(FCAInstrumentedTimerSetupData, M_max_allowed_usecs) == 0x000018, "Member 'FCAInstrumentedTimerSetupData::M_max_allowed_usecs' has a wrong offset!");

// ScriptStruct keaton.CAActivityRewardDefinition
// 0x0088 (0x0090 - 0x0008)
struct FCAActivityRewardDefinition final : public FTableRowBase
{
public:
	struct FCAText                                M_name;                                            // 0x0008(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             M_icon;                                            // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAActivityRewardType                         M_type;                                            // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_reward_tag;                                      // 0x0044(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_offers;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_weight;                                          // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_time;                                        // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_time;                                        // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_reward;                                          // 0x0060(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAActivityRewardDefinition) == 0x000008, "Wrong alignment on FCAActivityRewardDefinition");
static_assert(sizeof(FCAActivityRewardDefinition) == 0x000090, "Wrong size on FCAActivityRewardDefinition");
static_assert(offsetof(FCAActivityRewardDefinition, M_name) == 0x000008, "Member 'FCAActivityRewardDefinition::M_name' has a wrong offset!");
static_assert(offsetof(FCAActivityRewardDefinition, M_icon) == 0x000038, "Member 'FCAActivityRewardDefinition::M_icon' has a wrong offset!");
static_assert(offsetof(FCAActivityRewardDefinition, M_type) == 0x000040, "Member 'FCAActivityRewardDefinition::M_type' has a wrong offset!");
static_assert(offsetof(FCAActivityRewardDefinition, M_reward_tag) == 0x000044, "Member 'FCAActivityRewardDefinition::M_reward_tag' has a wrong offset!");
static_assert(offsetof(FCAActivityRewardDefinition, M_offers) == 0x000050, "Member 'FCAActivityRewardDefinition::M_offers' has a wrong offset!");
static_assert(offsetof(FCAActivityRewardDefinition, M_weight) == 0x000054, "Member 'FCAActivityRewardDefinition::M_weight' has a wrong offset!");
static_assert(offsetof(FCAActivityRewardDefinition, M_min_time) == 0x000058, "Member 'FCAActivityRewardDefinition::M_min_time' has a wrong offset!");
static_assert(offsetof(FCAActivityRewardDefinition, M_max_time) == 0x00005C, "Member 'FCAActivityRewardDefinition::M_max_time' has a wrong offset!");
static_assert(offsetof(FCAActivityRewardDefinition, M_reward) == 0x000060, "Member 'FCAActivityRewardDefinition::M_reward' has a wrong offset!");

// ScriptStruct keaton.CADropItemsHelperData
// 0x0038 (0x0038 - 0x0000)
struct FCADropItemsHelperData final
{
public:
	TArray<struct FCAInventoryEntry>              M_items;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         M_max_distance;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_offset;                                          // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACAThrowableActor>          M_carrier;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_throw_velocity;                                  // 0x0028(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADropItemsHelperData) == 0x000008, "Wrong alignment on FCADropItemsHelperData");
static_assert(sizeof(FCADropItemsHelperData) == 0x000038, "Wrong size on FCADropItemsHelperData");
static_assert(offsetof(FCADropItemsHelperData, M_items) == 0x000000, "Member 'FCADropItemsHelperData::M_items' has a wrong offset!");
static_assert(offsetof(FCADropItemsHelperData, M_max_distance) == 0x000010, "Member 'FCADropItemsHelperData::M_max_distance' has a wrong offset!");
static_assert(offsetof(FCADropItemsHelperData, M_offset) == 0x000014, "Member 'FCADropItemsHelperData::M_offset' has a wrong offset!");
static_assert(offsetof(FCADropItemsHelperData, M_carrier) == 0x000020, "Member 'FCADropItemsHelperData::M_carrier' has a wrong offset!");
static_assert(offsetof(FCADropItemsHelperData, M_throw_velocity) == 0x000028, "Member 'FCADropItemsHelperData::M_throw_velocity' has a wrong offset!");

// ScriptStruct keaton.CAInventoryEntryArray
// 0x0020 (0x0020 - 0x0000)
struct FCAInventoryEntryArray final
{
public:
	FMulticastInlineDelegateProperty_             OnInventoryEntryChange;                            // 0x0000(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FCAInventoryEntry>              M_items;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCAInventoryEntryArray) == 0x000008, "Wrong alignment on FCAInventoryEntryArray");
static_assert(sizeof(FCAInventoryEntryArray) == 0x000020, "Wrong size on FCAInventoryEntryArray");
static_assert(offsetof(FCAInventoryEntryArray, OnInventoryEntryChange) == 0x000000, "Member 'FCAInventoryEntryArray::OnInventoryEntryChange' has a wrong offset!");
static_assert(offsetof(FCAInventoryEntryArray, M_items) == 0x000010, "Member 'FCAInventoryEntryArray::M_items' has a wrong offset!");

// ScriptStruct keaton.CAPickupThrowDirectionCalculationData
// 0x0028 (0x0028 - 0x0000)
struct FCAPickupThrowDirectionCalculationData final
{
public:
	class AActor*                                 M_instigator;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_pickups_number;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_angle_between_directions;                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_hit_block_distance;                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_upwards_inclination;                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_throw_speed;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_projectile_radius;                               // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_start_offset_distance;                           // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPickupThrowDirectionCalculationData) == 0x000008, "Wrong alignment on FCAPickupThrowDirectionCalculationData");
static_assert(sizeof(FCAPickupThrowDirectionCalculationData) == 0x000028, "Wrong size on FCAPickupThrowDirectionCalculationData");
static_assert(offsetof(FCAPickupThrowDirectionCalculationData, M_instigator) == 0x000000, "Member 'FCAPickupThrowDirectionCalculationData::M_instigator' has a wrong offset!");
static_assert(offsetof(FCAPickupThrowDirectionCalculationData, M_pickups_number) == 0x000008, "Member 'FCAPickupThrowDirectionCalculationData::M_pickups_number' has a wrong offset!");
static_assert(offsetof(FCAPickupThrowDirectionCalculationData, M_angle_between_directions) == 0x00000C, "Member 'FCAPickupThrowDirectionCalculationData::M_angle_between_directions' has a wrong offset!");
static_assert(offsetof(FCAPickupThrowDirectionCalculationData, M_hit_block_distance) == 0x000010, "Member 'FCAPickupThrowDirectionCalculationData::M_hit_block_distance' has a wrong offset!");
static_assert(offsetof(FCAPickupThrowDirectionCalculationData, M_upwards_inclination) == 0x000014, "Member 'FCAPickupThrowDirectionCalculationData::M_upwards_inclination' has a wrong offset!");
static_assert(offsetof(FCAPickupThrowDirectionCalculationData, M_throw_speed) == 0x000018, "Member 'FCAPickupThrowDirectionCalculationData::M_throw_speed' has a wrong offset!");
static_assert(offsetof(FCAPickupThrowDirectionCalculationData, M_projectile_radius) == 0x00001C, "Member 'FCAPickupThrowDirectionCalculationData::M_projectile_radius' has a wrong offset!");
static_assert(offsetof(FCAPickupThrowDirectionCalculationData, M_start_offset_distance) == 0x000020, "Member 'FCAPickupThrowDirectionCalculationData::M_start_offset_distance' has a wrong offset!");

// ScriptStruct keaton.CAPickupSpawnData
// 0x0090 (0x0090 - 0x0000)
struct FCAPickupSpawnData final
{
public:
	class AActor*                                 M_instigator;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_loot_source;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_owner;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAInventoryItem*                       M_item;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_from_slot;                                       // 0x0020(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_spawn_transform;                                 // 0x0030(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         M_amount;                                          // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCAInventoryMetadata*                   M_metadata;                                        // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_offset;                                          // 0x0070(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_distance;                                    // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_throw_velocity;                                  // 0x0080(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_thrown;                                          // 0x008C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPickupSpawnData) == 0x000010, "Wrong alignment on FCAPickupSpawnData");
static_assert(sizeof(FCAPickupSpawnData) == 0x000090, "Wrong size on FCAPickupSpawnData");
static_assert(offsetof(FCAPickupSpawnData, M_instigator) == 0x000000, "Member 'FCAPickupSpawnData::M_instigator' has a wrong offset!");
static_assert(offsetof(FCAPickupSpawnData, M_loot_source) == 0x000008, "Member 'FCAPickupSpawnData::M_loot_source' has a wrong offset!");
static_assert(offsetof(FCAPickupSpawnData, M_owner) == 0x000010, "Member 'FCAPickupSpawnData::M_owner' has a wrong offset!");
static_assert(offsetof(FCAPickupSpawnData, M_item) == 0x000018, "Member 'FCAPickupSpawnData::M_item' has a wrong offset!");
static_assert(offsetof(FCAPickupSpawnData, M_from_slot) == 0x000020, "Member 'FCAPickupSpawnData::M_from_slot' has a wrong offset!");
static_assert(offsetof(FCAPickupSpawnData, M_spawn_transform) == 0x000030, "Member 'FCAPickupSpawnData::M_spawn_transform' has a wrong offset!");
static_assert(offsetof(FCAPickupSpawnData, M_amount) == 0x000060, "Member 'FCAPickupSpawnData::M_amount' has a wrong offset!");
static_assert(offsetof(FCAPickupSpawnData, M_metadata) == 0x000068, "Member 'FCAPickupSpawnData::M_metadata' has a wrong offset!");
static_assert(offsetof(FCAPickupSpawnData, M_offset) == 0x000070, "Member 'FCAPickupSpawnData::M_offset' has a wrong offset!");
static_assert(offsetof(FCAPickupSpawnData, M_max_distance) == 0x00007C, "Member 'FCAPickupSpawnData::M_max_distance' has a wrong offset!");
static_assert(offsetof(FCAPickupSpawnData, M_throw_velocity) == 0x000080, "Member 'FCAPickupSpawnData::M_throw_velocity' has a wrong offset!");
static_assert(offsetof(FCAPickupSpawnData, M_thrown) == 0x00008C, "Member 'FCAPickupSpawnData::M_thrown' has a wrong offset!");

// ScriptStruct keaton.CAInventoryDefinition
// 0x0008 (0x0010 - 0x0008)
struct FCAInventoryDefinition final : public FTableRowBase
{
public:
	int32                                         M_value;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAInventoryDefinition) == 0x000008, "Wrong alignment on FCAInventoryDefinition");
static_assert(sizeof(FCAInventoryDefinition) == 0x000010, "Wrong size on FCAInventoryDefinition");
static_assert(offsetof(FCAInventoryDefinition, M_value) == 0x000008, "Member 'FCAInventoryDefinition::M_value' has a wrong offset!");

// ScriptStruct keaton.ItemListEntry
// 0x0001 (0x0001 - 0x0000)
struct FItemListEntry final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemListEntry) == 0x000001, "Wrong alignment on FItemListEntry");
static_assert(sizeof(FItemListEntry) == 0x000001, "Wrong size on FItemListEntry");

// ScriptStruct keaton.CAIdleJobMotivation
// 0x0010 (0x0010 - 0x0000)
struct FCAIdleJobMotivation final
{
public:
	struct FGameplayTag                           M_motivation;                                      // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_chance_to_apply;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAIdleJobMotivation) == 0x000004, "Wrong alignment on FCAIdleJobMotivation");
static_assert(sizeof(FCAIdleJobMotivation) == 0x000010, "Wrong size on FCAIdleJobMotivation");
static_assert(offsetof(FCAIdleJobMotivation, M_motivation) == 0x000000, "Member 'FCAIdleJobMotivation::M_motivation' has a wrong offset!");
static_assert(offsetof(FCAIdleJobMotivation, M_chance_to_apply) == 0x00000C, "Member 'FCAIdleJobMotivation::M_chance_to_apply' has a wrong offset!");

// ScriptStruct keaton.CALeaderboardsEntry
// 0x00A0 (0x00A0 - 0x0000)
struct FCALeaderboardsEntry final
{
public:
	int32                                         M_placement;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_number_of_wins;                                  // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_player_icon;                                     // 0x0008(0x0030)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_player_level;                                    // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_player_name;                                     // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_platform_icon;                                   // 0x0050(0x0030)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_win_ratio;                                       // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x1C];                                      // 0x0084(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCALeaderboardsEntry) == 0x000008, "Wrong alignment on FCALeaderboardsEntry");
static_assert(sizeof(FCALeaderboardsEntry) == 0x0000A0, "Wrong size on FCALeaderboardsEntry");
static_assert(offsetof(FCALeaderboardsEntry, M_placement) == 0x000000, "Member 'FCALeaderboardsEntry::M_placement' has a wrong offset!");
static_assert(offsetof(FCALeaderboardsEntry, M_number_of_wins) == 0x000004, "Member 'FCALeaderboardsEntry::M_number_of_wins' has a wrong offset!");
static_assert(offsetof(FCALeaderboardsEntry, M_player_icon) == 0x000008, "Member 'FCALeaderboardsEntry::M_player_icon' has a wrong offset!");
static_assert(offsetof(FCALeaderboardsEntry, M_player_level) == 0x000038, "Member 'FCALeaderboardsEntry::M_player_level' has a wrong offset!");
static_assert(offsetof(FCALeaderboardsEntry, M_player_name) == 0x000040, "Member 'FCALeaderboardsEntry::M_player_name' has a wrong offset!");
static_assert(offsetof(FCALeaderboardsEntry, M_platform_icon) == 0x000050, "Member 'FCALeaderboardsEntry::M_platform_icon' has a wrong offset!");
static_assert(offsetof(FCALeaderboardsEntry, M_win_ratio) == 0x000080, "Member 'FCALeaderboardsEntry::M_win_ratio' has a wrong offset!");

// ScriptStruct keaton.CALetsHaveBBQPerkBalancingTableRow
// 0x0008 (0x0010 - 0x0008)
struct FCALetsHaveBBQPerkBalancingTableRow final : public FTableRowBase
{
public:
	float                                         M_burn_duration;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_burn_damage_multiplier;                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALetsHaveBBQPerkBalancingTableRow) == 0x000008, "Wrong alignment on FCALetsHaveBBQPerkBalancingTableRow");
static_assert(sizeof(FCALetsHaveBBQPerkBalancingTableRow) == 0x000010, "Wrong size on FCALetsHaveBBQPerkBalancingTableRow");
static_assert(offsetof(FCALetsHaveBBQPerkBalancingTableRow, M_burn_duration) == 0x000008, "Member 'FCALetsHaveBBQPerkBalancingTableRow::M_burn_duration' has a wrong offset!");
static_assert(offsetof(FCALetsHaveBBQPerkBalancingTableRow, M_burn_damage_multiplier) == 0x00000C, "Member 'FCALetsHaveBBQPerkBalancingTableRow::M_burn_damage_multiplier' has a wrong offset!");

// ScriptStruct keaton.CALightingState
// 0x0020 (0x0020 - 0x0000)
struct FCALightingState final
{
public:
	struct FGameplayTag                           M_status_tag;                                      // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 M_tint;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_intensity;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCAAnimatedLightBehaviour*              M_animated_behaviour;                              // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALightingState) == 0x000008, "Wrong alignment on FCALightingState");
static_assert(sizeof(FCALightingState) == 0x000020, "Wrong size on FCALightingState");
static_assert(offsetof(FCALightingState, M_status_tag) == 0x000000, "Member 'FCALightingState::M_status_tag' has a wrong offset!");
static_assert(offsetof(FCALightingState, M_tint) == 0x00000C, "Member 'FCALightingState::M_tint' has a wrong offset!");
static_assert(offsetof(FCALightingState, M_intensity) == 0x000010, "Member 'FCALightingState::M_intensity' has a wrong offset!");
static_assert(offsetof(FCALightingState, M_animated_behaviour) == 0x000018, "Member 'FCALightingState::M_animated_behaviour' has a wrong offset!");

// ScriptStruct keaton.CASecurityModulePostProcessing
// 0x0658 (0x0660 - 0x0008)
struct FCASecurityModulePostProcessing final : public FTableRowBase
{
public:
	struct FGameplayTag                           M_status_tag;                                      // 0x0008(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_blend_factor;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_blend_time;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   M_postprocess_setting;                             // 0x0020(0x0640)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASecurityModulePostProcessing) == 0x000010, "Wrong alignment on FCASecurityModulePostProcessing");
static_assert(sizeof(FCASecurityModulePostProcessing) == 0x000660, "Wrong size on FCASecurityModulePostProcessing");
static_assert(offsetof(FCASecurityModulePostProcessing, M_status_tag) == 0x000008, "Member 'FCASecurityModulePostProcessing::M_status_tag' has a wrong offset!");
static_assert(offsetof(FCASecurityModulePostProcessing, M_blend_factor) == 0x000014, "Member 'FCASecurityModulePostProcessing::M_blend_factor' has a wrong offset!");
static_assert(offsetof(FCASecurityModulePostProcessing, M_blend_time) == 0x000018, "Member 'FCASecurityModulePostProcessing::M_blend_time' has a wrong offset!");
static_assert(offsetof(FCASecurityModulePostProcessing, M_postprocess_setting) == 0x000020, "Member 'FCASecurityModulePostProcessing::M_postprocess_setting' has a wrong offset!");

// ScriptStruct keaton.CALightManagerSlot
// 0x0050 (0x0050 - 0x0000)
struct FCALightManagerSlot final
{
public:
	class UCALightBehaviourComponent*             Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAAnimatedLightBehaviour*              behaviour;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Instance_offset;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULightComponent*>                Light_components;                                  // 0x0018(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FCAMeshLightSlot>               Mesh_light_instances;                              // 0x0028(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FColor                                 Tint;                                              // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCALightManagerSlot) == 0x000008, "Wrong alignment on FCALightManagerSlot");
static_assert(sizeof(FCALightManagerSlot) == 0x000050, "Wrong size on FCALightManagerSlot");
static_assert(offsetof(FCALightManagerSlot, Component) == 0x000000, "Member 'FCALightManagerSlot::Component' has a wrong offset!");
static_assert(offsetof(FCALightManagerSlot, behaviour) == 0x000008, "Member 'FCALightManagerSlot::behaviour' has a wrong offset!");
static_assert(offsetof(FCALightManagerSlot, Instance_offset) == 0x000010, "Member 'FCALightManagerSlot::Instance_offset' has a wrong offset!");
static_assert(offsetof(FCALightManagerSlot, Light_components) == 0x000018, "Member 'FCALightManagerSlot::Light_components' has a wrong offset!");
static_assert(offsetof(FCALightManagerSlot, Mesh_light_instances) == 0x000028, "Member 'FCALightManagerSlot::Mesh_light_instances' has a wrong offset!");
static_assert(offsetof(FCALightManagerSlot, Tint) == 0x000038, "Member 'FCALightManagerSlot::Tint' has a wrong offset!");
static_assert(offsetof(FCALightManagerSlot, Intensity) == 0x00003C, "Member 'FCALightManagerSlot::Intensity' has a wrong offset!");

// ScriptStruct keaton.EquipmentToSlot
// 0x0018 (0x0018 - 0x0000)
struct FEquipmentToSlot final
{
public:
	struct FGameplayTag                           M_slot_tag;                                        // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACAEquipmentBase*                       M_equipment;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipmentToSlot) == 0x000008, "Wrong alignment on FEquipmentToSlot");
static_assert(sizeof(FEquipmentToSlot) == 0x000018, "Wrong size on FEquipmentToSlot");
static_assert(offsetof(FEquipmentToSlot, M_slot_tag) == 0x000000, "Member 'FEquipmentToSlot::M_slot_tag' has a wrong offset!");
static_assert(offsetof(FEquipmentToSlot, M_equipment) == 0x000010, "Member 'FEquipmentToSlot::M_equipment' has a wrong offset!");

// ScriptStruct keaton.CALoadoutConfigurationTableRow
// 0x0018 (0x0020 - 0x0008)
struct FCALoadoutConfigurationTableRow final : public FTableRowBase
{
public:
	struct FCAGameDatabaseRowHandle               M_debug_loadouts;                                  // 0x0008(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALoadoutConfigurationTableRow) == 0x000008, "Wrong alignment on FCALoadoutConfigurationTableRow");
static_assert(sizeof(FCALoadoutConfigurationTableRow) == 0x000020, "Wrong size on FCALoadoutConfigurationTableRow");
static_assert(offsetof(FCALoadoutConfigurationTableRow, M_debug_loadouts) == 0x000008, "Member 'FCALoadoutConfigurationTableRow::M_debug_loadouts' has a wrong offset!");

// ScriptStruct keaton.CALoadoutDataDTO
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x08) FCALoadoutDataDTO final
{
public:
	uint8                                         Pad_0[0xB0];                                       // 0x0000(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCALoadoutDataDTO) == 0x000008, "Wrong alignment on FCALoadoutDataDTO");
static_assert(sizeof(FCALoadoutDataDTO) == 0x0000B0, "Wrong size on FCALoadoutDataDTO");

// ScriptStruct keaton.CAFTUEState
// 0x0060 (0x0060 - 0x0000)
struct FCAFTUEState final
{
public:
	ECAFTUEState                                  M_current_state;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAFrontendContext                            M_last_map_loaded;                                 // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             M_specialists_video_watched;                       // 0x0008(0x0050)(NativeAccessSpecifierPublic)
	int32                                         M_tracking_flag;                                   // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAFTUEState) == 0x000008, "Wrong alignment on FCAFTUEState");
static_assert(sizeof(FCAFTUEState) == 0x000060, "Wrong size on FCAFTUEState");
static_assert(offsetof(FCAFTUEState, M_current_state) == 0x000000, "Member 'FCAFTUEState::M_current_state' has a wrong offset!");
static_assert(offsetof(FCAFTUEState, M_last_map_loaded) == 0x000001, "Member 'FCAFTUEState::M_last_map_loaded' has a wrong offset!");
static_assert(offsetof(FCAFTUEState, M_specialists_video_watched) == 0x000008, "Member 'FCAFTUEState::M_specialists_video_watched' has a wrong offset!");
static_assert(offsetof(FCAFTUEState, M_tracking_flag) == 0x000058, "Member 'FCAFTUEState::M_tracking_flag' has a wrong offset!");

// ScriptStruct keaton.CASpecialistCache
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FCASpecialistCache final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCASpecialistCache) == 0x000008, "Wrong alignment on FCASpecialistCache");
static_assert(sizeof(FCASpecialistCache) == 0x000058, "Wrong size on FCASpecialistCache");

// ScriptStruct keaton.CASpecialistCacheItem
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FCASpecialistCacheItem final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCASpecialistCacheItem) == 0x000008, "Wrong alignment on FCASpecialistCacheItem");
static_assert(sizeof(FCASpecialistCacheItem) == 0x000050, "Wrong size on FCASpecialistCacheItem");

// ScriptStruct keaton.CAVanGameModeConfigTableRow
// 0x0030 (0x0038 - 0x0008)
struct FCAVanGameModeConfigTableRow final : public FTableRowBase
{
public:
	int32                                         M_expected_player_timeout;                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_get_ready_count_down;                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_selection_count_down;                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_safety_zone_count_down;                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_line_up_count_down;                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_travel_imminent_count_down;                      // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_count_down_interval;                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_num_expected_players;                            // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_max_team_size;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_number_of_teams;                                 // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECATeamAllocation                             M_team_allocation;                                 // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_skip_loadout_selection;                          // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAVanGameModeConfigTableRow) == 0x000008, "Wrong alignment on FCAVanGameModeConfigTableRow");
static_assert(sizeof(FCAVanGameModeConfigTableRow) == 0x000038, "Wrong size on FCAVanGameModeConfigTableRow");
static_assert(offsetof(FCAVanGameModeConfigTableRow, M_expected_player_timeout) == 0x000008, "Member 'FCAVanGameModeConfigTableRow::M_expected_player_timeout' has a wrong offset!");
static_assert(offsetof(FCAVanGameModeConfigTableRow, M_get_ready_count_down) == 0x00000C, "Member 'FCAVanGameModeConfigTableRow::M_get_ready_count_down' has a wrong offset!");
static_assert(offsetof(FCAVanGameModeConfigTableRow, M_selection_count_down) == 0x000010, "Member 'FCAVanGameModeConfigTableRow::M_selection_count_down' has a wrong offset!");
static_assert(offsetof(FCAVanGameModeConfigTableRow, M_safety_zone_count_down) == 0x000014, "Member 'FCAVanGameModeConfigTableRow::M_safety_zone_count_down' has a wrong offset!");
static_assert(offsetof(FCAVanGameModeConfigTableRow, M_line_up_count_down) == 0x000018, "Member 'FCAVanGameModeConfigTableRow::M_line_up_count_down' has a wrong offset!");
static_assert(offsetof(FCAVanGameModeConfigTableRow, M_travel_imminent_count_down) == 0x00001C, "Member 'FCAVanGameModeConfigTableRow::M_travel_imminent_count_down' has a wrong offset!");
static_assert(offsetof(FCAVanGameModeConfigTableRow, M_count_down_interval) == 0x000020, "Member 'FCAVanGameModeConfigTableRow::M_count_down_interval' has a wrong offset!");
static_assert(offsetof(FCAVanGameModeConfigTableRow, M_num_expected_players) == 0x000024, "Member 'FCAVanGameModeConfigTableRow::M_num_expected_players' has a wrong offset!");
static_assert(offsetof(FCAVanGameModeConfigTableRow, M_max_team_size) == 0x000028, "Member 'FCAVanGameModeConfigTableRow::M_max_team_size' has a wrong offset!");
static_assert(offsetof(FCAVanGameModeConfigTableRow, M_number_of_teams) == 0x00002C, "Member 'FCAVanGameModeConfigTableRow::M_number_of_teams' has a wrong offset!");
static_assert(offsetof(FCAVanGameModeConfigTableRow, M_team_allocation) == 0x000030, "Member 'FCAVanGameModeConfigTableRow::M_team_allocation' has a wrong offset!");
static_assert(offsetof(FCAVanGameModeConfigTableRow, M_skip_loadout_selection) == 0x000031, "Member 'FCAVanGameModeConfigTableRow::M_skip_loadout_selection' has a wrong offset!");

// ScriptStruct keaton.CALobbyPurchaseQueueItem
// 0x0018 (0x0018 - 0x0000)
struct FCALobbyPurchaseQueueItem final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCALobbyPlayerInfo*                     M_player_info;                                     // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALobbyPurchaseQueueItem) == 0x000008, "Wrong alignment on FCALobbyPurchaseQueueItem");
static_assert(sizeof(FCALobbyPurchaseQueueItem) == 0x000018, "Wrong size on FCALobbyPurchaseQueueItem");
static_assert(offsetof(FCALobbyPurchaseQueueItem, M_player_info) == 0x000010, "Member 'FCALobbyPurchaseQueueItem::M_player_info' has a wrong offset!");

// ScriptStruct keaton.CAVerticalNavigationData
// 0x005C (0x005C - 0x0000)
struct FCAVerticalNavigationData final
{
public:
	struct FBoxSphereBounds                       bounds;                                            // 0x0000(0x001C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Start_left;                                        // 0x001C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start_right;                                       // 0x0028(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End_left;                                          // 0x0034(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End_right;                                         // 0x0040(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Jump_height;                                       // 0x004C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Drop_height;                                       // 0x0050(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAVerticalNavigationType                     Vertical_navigation_type;                          // 0x0054(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Origin_tile_index;                                 // 0x0058(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAVerticalNavigationData) == 0x000004, "Wrong alignment on FCAVerticalNavigationData");
static_assert(sizeof(FCAVerticalNavigationData) == 0x00005C, "Wrong size on FCAVerticalNavigationData");
static_assert(offsetof(FCAVerticalNavigationData, bounds) == 0x000000, "Member 'FCAVerticalNavigationData::bounds' has a wrong offset!");
static_assert(offsetof(FCAVerticalNavigationData, Start_left) == 0x00001C, "Member 'FCAVerticalNavigationData::Start_left' has a wrong offset!");
static_assert(offsetof(FCAVerticalNavigationData, Start_right) == 0x000028, "Member 'FCAVerticalNavigationData::Start_right' has a wrong offset!");
static_assert(offsetof(FCAVerticalNavigationData, End_left) == 0x000034, "Member 'FCAVerticalNavigationData::End_left' has a wrong offset!");
static_assert(offsetof(FCAVerticalNavigationData, End_right) == 0x000040, "Member 'FCAVerticalNavigationData::End_right' has a wrong offset!");
static_assert(offsetof(FCAVerticalNavigationData, Jump_height) == 0x00004C, "Member 'FCAVerticalNavigationData::Jump_height' has a wrong offset!");
static_assert(offsetof(FCAVerticalNavigationData, Drop_height) == 0x000050, "Member 'FCAVerticalNavigationData::Drop_height' has a wrong offset!");
static_assert(offsetof(FCAVerticalNavigationData, Vertical_navigation_type) == 0x000054, "Member 'FCAVerticalNavigationData::Vertical_navigation_type' has a wrong offset!");
static_assert(offsetof(FCAVerticalNavigationData, Origin_tile_index) == 0x000058, "Member 'FCAVerticalNavigationData::Origin_tile_index' has a wrong offset!");

// ScriptStruct keaton.CALocomotionSpeed
// 0x0018 (0x0018 - 0x0000)
struct FCALocomotionSpeed final
{
public:
	float                                         M_lateral;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_forward;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_lateral_raw;                                     // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_forward_raw;                                     // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_lateral_last_moving;                             // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_forward_last_moving;                             // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALocomotionSpeed) == 0x000004, "Wrong alignment on FCALocomotionSpeed");
static_assert(sizeof(FCALocomotionSpeed) == 0x000018, "Wrong size on FCALocomotionSpeed");
static_assert(offsetof(FCALocomotionSpeed, M_lateral) == 0x000000, "Member 'FCALocomotionSpeed::M_lateral' has a wrong offset!");
static_assert(offsetof(FCALocomotionSpeed, M_forward) == 0x000004, "Member 'FCALocomotionSpeed::M_forward' has a wrong offset!");
static_assert(offsetof(FCALocomotionSpeed, M_lateral_raw) == 0x000008, "Member 'FCALocomotionSpeed::M_lateral_raw' has a wrong offset!");
static_assert(offsetof(FCALocomotionSpeed, M_forward_raw) == 0x00000C, "Member 'FCALocomotionSpeed::M_forward_raw' has a wrong offset!");
static_assert(offsetof(FCALocomotionSpeed, M_lateral_last_moving) == 0x000010, "Member 'FCALocomotionSpeed::M_lateral_last_moving' has a wrong offset!");
static_assert(offsetof(FCALocomotionSpeed, M_forward_last_moving) == 0x000014, "Member 'FCALocomotionSpeed::M_forward_last_moving' has a wrong offset!");

// ScriptStruct keaton.CALootDropRequest
// 0x0060 (0x0060 - 0x0000)
struct FCALootDropRequest final
{
public:
	TArray<struct FCAPickupSpawnData>             M_loot_to_drop;                                    // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TDelegate<void(class ACAPickUp* Pickup)>      M_request_pickup_spawned_dynamic_delegate;         // 0x0010(0x0014)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24[0x14];                                      // 0x0024(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             M_request_completed_dynamic_delegate;              // 0x0038(0x0014)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x14];                                      // 0x004C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCALootDropRequest) == 0x000008, "Wrong alignment on FCALootDropRequest");
static_assert(sizeof(FCALootDropRequest) == 0x000060, "Wrong size on FCALootDropRequest");
static_assert(offsetof(FCALootDropRequest, M_loot_to_drop) == 0x000000, "Member 'FCALootDropRequest::M_loot_to_drop' has a wrong offset!");
static_assert(offsetof(FCALootDropRequest, M_request_pickup_spawned_dynamic_delegate) == 0x000010, "Member 'FCALootDropRequest::M_request_pickup_spawned_dynamic_delegate' has a wrong offset!");
static_assert(offsetof(FCALootDropRequest, M_request_completed_dynamic_delegate) == 0x000038, "Member 'FCALootDropRequest::M_request_completed_dynamic_delegate' has a wrong offset!");

// ScriptStruct keaton.CAShipThemesTable
// 0x0010 (0x0018 - 0x0008)
struct FCAShipThemesTable final : public FTableRowBase
{
public:
	TArray<struct FGameplayTag>                   ShipThemes;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAShipThemesTable) == 0x000008, "Wrong alignment on FCAShipThemesTable");
static_assert(sizeof(FCAShipThemesTable) == 0x000018, "Wrong size on FCAShipThemesTable");
static_assert(offsetof(FCAShipThemesTable, ShipThemes) == 0x000008, "Member 'FCAShipThemesTable::ShipThemes' has a wrong offset!");

// ScriptStruct keaton.CAOutsideOfCampsLootTable
// 0x0008 (0x0010 - 0x0008)
struct FCAOutsideOfCampsLootTable final : public FTableRowBase
{
public:
	struct FCADataTableHandle                     LootContainerDistribution;                         // 0x0008(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAOutsideOfCampsLootTable) == 0x000008, "Wrong alignment on FCAOutsideOfCampsLootTable");
static_assert(sizeof(FCAOutsideOfCampsLootTable) == 0x000010, "Wrong size on FCAOutsideOfCampsLootTable");
static_assert(offsetof(FCAOutsideOfCampsLootTable, LootContainerDistribution) == 0x000008, "Member 'FCAOutsideOfCampsLootTable::LootContainerDistribution' has a wrong offset!");

// ScriptStruct keaton.SysSecurityEventTypeData
// 0x0010 (0x0018 - 0x0008)
struct FSysSecurityEventTypeData final : public FTableRowBase
{
public:
	ESysSecurityEventType                         M_event_type;                                      // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_aggro_points;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_needs_to_be_witnessed;                           // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_updates_last_known_position;                     // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_stops_deescalation;                              // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSysSecurityEventTypeData) == 0x000008, "Wrong alignment on FSysSecurityEventTypeData");
static_assert(sizeof(FSysSecurityEventTypeData) == 0x000018, "Wrong size on FSysSecurityEventTypeData");
static_assert(offsetof(FSysSecurityEventTypeData, M_event_type) == 0x000008, "Member 'FSysSecurityEventTypeData::M_event_type' has a wrong offset!");
static_assert(offsetof(FSysSecurityEventTypeData, M_aggro_points) == 0x00000C, "Member 'FSysSecurityEventTypeData::M_aggro_points' has a wrong offset!");
static_assert(offsetof(FSysSecurityEventTypeData, M_needs_to_be_witnessed) == 0x000010, "Member 'FSysSecurityEventTypeData::M_needs_to_be_witnessed' has a wrong offset!");
static_assert(offsetof(FSysSecurityEventTypeData, M_updates_last_known_position) == 0x000011, "Member 'FSysSecurityEventTypeData::M_updates_last_known_position' has a wrong offset!");
static_assert(offsetof(FSysSecurityEventTypeData, M_stops_deescalation) == 0x000012, "Member 'FSysSecurityEventTypeData::M_stops_deescalation' has a wrong offset!");

// ScriptStruct keaton.CALootContainerMapping
// 0x0040 (0x0048 - 0x0008)
struct FCALootContainerMapping final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   ContainerClass;                                    // 0x0008(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RewardSourceType;                                  // 0x0038(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCALootContainerMapping) == 0x000008, "Wrong alignment on FCALootContainerMapping");
static_assert(sizeof(FCALootContainerMapping) == 0x000048, "Wrong size on FCALootContainerMapping");
static_assert(offsetof(FCALootContainerMapping, ContainerClass) == 0x000008, "Member 'FCALootContainerMapping::ContainerClass' has a wrong offset!");
static_assert(offsetof(FCALootContainerMapping, RewardSourceType) == 0x000038, "Member 'FCALootContainerMapping::RewardSourceType' has a wrong offset!");

// ScriptStruct keaton.CALootSpotContainerInfo
// 0x0020 (0x0020 - 0x0000)
struct FCALootSpotContainerInfo final
{
public:
	struct FGameplayTag                           LootSpotID;                                        // 0x0000(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCALootContainerCount>          ContainerCounts;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALootSpotContainerInfo) == 0x000008, "Wrong alignment on FCALootSpotContainerInfo");
static_assert(sizeof(FCALootSpotContainerInfo) == 0x000020, "Wrong size on FCALootSpotContainerInfo");
static_assert(offsetof(FCALootSpotContainerInfo, LootSpotID) == 0x000000, "Member 'FCALootSpotContainerInfo::LootSpotID' has a wrong offset!");
static_assert(offsetof(FCALootSpotContainerInfo, ContainerCounts) == 0x000010, "Member 'FCALootSpotContainerInfo::ContainerCounts' has a wrong offset!");

// ScriptStruct keaton.CALootContainerDistribution
// 0x0018 (0x0020 - 0x0008)
struct FCALootContainerDistribution final : public FTableRowBase
{
public:
	TArray<struct FCALootSpotContainerInfo>       LootSpotContainers;                                // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCALootContainerDistribution) == 0x000008, "Wrong alignment on FCALootContainerDistribution");
static_assert(sizeof(FCALootContainerDistribution) == 0x000020, "Wrong size on FCALootContainerDistribution");
static_assert(offsetof(FCALootContainerDistribution, LootSpotContainers) == 0x000008, "Member 'FCALootContainerDistribution::LootSpotContainers' has a wrong offset!");
static_assert(offsetof(FCALootContainerDistribution, Weight) == 0x000018, "Member 'FCALootContainerDistribution::Weight' has a wrong offset!");

// ScriptStruct keaton.ControllerRotationYawModifier
// 0x0003 (0x0003 - 0x0000)
struct FControllerRotationYawModifier final
{
public:
	bool                                          Is_enabled;                                        // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Should_use_controller_yaw;                         // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControllerRotationYawType                    Key_type;                                          // 0x0002(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControllerRotationYawModifier) == 0x000001, "Wrong alignment on FControllerRotationYawModifier");
static_assert(sizeof(FControllerRotationYawModifier) == 0x000003, "Wrong size on FControllerRotationYawModifier");
static_assert(offsetof(FControllerRotationYawModifier, Is_enabled) == 0x000000, "Member 'FControllerRotationYawModifier::Is_enabled' has a wrong offset!");
static_assert(offsetof(FControllerRotationYawModifier, Should_use_controller_yaw) == 0x000001, "Member 'FControllerRotationYawModifier::Should_use_controller_yaw' has a wrong offset!");
static_assert(offsetof(FControllerRotationYawModifier, Key_type) == 0x000002, "Member 'FControllerRotationYawModifier::Key_type' has a wrong offset!");

// ScriptStruct keaton.ControllerRotationYawHistoryRequests
// 0x0010 (0x0010 - 0x0000)
struct FControllerRotationYawHistoryRequests final
{
public:
	TArray<struct FControllerRotationYawModifier> Modifiers;                                         // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FControllerRotationYawHistoryRequests) == 0x000008, "Wrong alignment on FControllerRotationYawHistoryRequests");
static_assert(sizeof(FControllerRotationYawHistoryRequests) == 0x000010, "Wrong size on FControllerRotationYawHistoryRequests");
static_assert(offsetof(FControllerRotationYawHistoryRequests, Modifiers) == 0x000000, "Member 'FControllerRotationYawHistoryRequests::Modifiers' has a wrong offset!");

// ScriptStruct keaton.CAMapLegendData
// 0x0070 (0x0078 - 0x0008)
struct FCAMapLegendData final : public FTableRowBase
{
public:
	struct FCAText                                M_label;                                           // 0x0008(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_icon_texture;                                    // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           M_colour;                                          // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMapLegendData) == 0x000008, "Wrong alignment on FCAMapLegendData");
static_assert(sizeof(FCAMapLegendData) == 0x000078, "Wrong size on FCAMapLegendData");
static_assert(offsetof(FCAMapLegendData, M_label) == 0x000008, "Member 'FCAMapLegendData::M_label' has a wrong offset!");
static_assert(offsetof(FCAMapLegendData, M_icon_texture) == 0x000038, "Member 'FCAMapLegendData::M_icon_texture' has a wrong offset!");
static_assert(offsetof(FCAMapLegendData, M_colour) == 0x000068, "Member 'FCAMapLegendData::M_colour' has a wrong offset!");

// ScriptStruct keaton.CATargetParamHistoryData
// 0x001C (0x001C - 0x0000)
struct FCATargetParamHistoryData final
{
public:
	float                                         M_time;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_camera_location;                                 // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_camera_rotation;                                 // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATargetParamHistoryData) == 0x000004, "Wrong alignment on FCATargetParamHistoryData");
static_assert(sizeof(FCATargetParamHistoryData) == 0x00001C, "Wrong size on FCATargetParamHistoryData");
static_assert(offsetof(FCATargetParamHistoryData, M_time) == 0x000000, "Member 'FCATargetParamHistoryData::M_time' has a wrong offset!");
static_assert(offsetof(FCATargetParamHistoryData, M_camera_location) == 0x000004, "Member 'FCATargetParamHistoryData::M_camera_location' has a wrong offset!");
static_assert(offsetof(FCATargetParamHistoryData, M_camera_rotation) == 0x000010, "Member 'FCATargetParamHistoryData::M_camera_rotation' has a wrong offset!");

// ScriptStruct keaton.CAMatchEndScreenSpawnInfo
// 0x0028 (0x0028 - 0x0000)
struct FCAMatchEndScreenSpawnInfo final
{
public:
	class FString                                 M_map_name;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_spawn_position;                                  // 0x0010(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_spawn_rotation;                                  // 0x001C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMatchEndScreenSpawnInfo) == 0x000008, "Wrong alignment on FCAMatchEndScreenSpawnInfo");
static_assert(sizeof(FCAMatchEndScreenSpawnInfo) == 0x000028, "Wrong size on FCAMatchEndScreenSpawnInfo");
static_assert(offsetof(FCAMatchEndScreenSpawnInfo, M_map_name) == 0x000000, "Member 'FCAMatchEndScreenSpawnInfo::M_map_name' has a wrong offset!");
static_assert(offsetof(FCAMatchEndScreenSpawnInfo, M_spawn_position) == 0x000010, "Member 'FCAMatchEndScreenSpawnInfo::M_spawn_position' has a wrong offset!");
static_assert(offsetof(FCAMatchEndScreenSpawnInfo, M_spawn_rotation) == 0x00001C, "Member 'FCAMatchEndScreenSpawnInfo::M_spawn_rotation' has a wrong offset!");

// ScriptStruct keaton.CAMatchResultRewardStruct
// 0x0088 (0x0088 - 0x0000)
struct FCAMatchResultRewardStruct final
{
public:
	class FName                                   M_reward_type;                                     // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_sc_value;                                        // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_hc_value;                                        // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_xp_value;                                        // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_xp_average;                                      // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_battle_points;                                   // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAText                                M_label;                                           // 0x0020(0x0030)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_category_icon;                                   // 0x0050(0x0030)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMatchResultRewardStruct) == 0x000008, "Wrong alignment on FCAMatchResultRewardStruct");
static_assert(sizeof(FCAMatchResultRewardStruct) == 0x000088, "Wrong size on FCAMatchResultRewardStruct");
static_assert(offsetof(FCAMatchResultRewardStruct, M_reward_type) == 0x000000, "Member 'FCAMatchResultRewardStruct::M_reward_type' has a wrong offset!");
static_assert(offsetof(FCAMatchResultRewardStruct, M_sc_value) == 0x00000C, "Member 'FCAMatchResultRewardStruct::M_sc_value' has a wrong offset!");
static_assert(offsetof(FCAMatchResultRewardStruct, M_hc_value) == 0x000010, "Member 'FCAMatchResultRewardStruct::M_hc_value' has a wrong offset!");
static_assert(offsetof(FCAMatchResultRewardStruct, M_xp_value) == 0x000014, "Member 'FCAMatchResultRewardStruct::M_xp_value' has a wrong offset!");
static_assert(offsetof(FCAMatchResultRewardStruct, M_xp_average) == 0x000018, "Member 'FCAMatchResultRewardStruct::M_xp_average' has a wrong offset!");
static_assert(offsetof(FCAMatchResultRewardStruct, M_battle_points) == 0x00001C, "Member 'FCAMatchResultRewardStruct::M_battle_points' has a wrong offset!");
static_assert(offsetof(FCAMatchResultRewardStruct, M_label) == 0x000020, "Member 'FCAMatchResultRewardStruct::M_label' has a wrong offset!");
static_assert(offsetof(FCAMatchResultRewardStruct, M_category_icon) == 0x000050, "Member 'FCAMatchResultRewardStruct::M_category_icon' has a wrong offset!");

// ScriptStruct keaton.CAPlayerTotalMatchStats
// 0x0038 (0x0038 - 0x0000)
struct FCAPlayerTotalMatchStats final
{
public:
	int32                                         M_total_score;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_player_name;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_specialist_name;                                 // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAPlayerExtractionStatus                     M_extraction_state;                                // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAMatchResultRewardStruct>     M_match_stat_details;                              // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPlayerTotalMatchStats) == 0x000008, "Wrong alignment on FCAPlayerTotalMatchStats");
static_assert(sizeof(FCAPlayerTotalMatchStats) == 0x000038, "Wrong size on FCAPlayerTotalMatchStats");
static_assert(offsetof(FCAPlayerTotalMatchStats, M_total_score) == 0x000000, "Member 'FCAPlayerTotalMatchStats::M_total_score' has a wrong offset!");
static_assert(offsetof(FCAPlayerTotalMatchStats, M_player_name) == 0x000008, "Member 'FCAPlayerTotalMatchStats::M_player_name' has a wrong offset!");
static_assert(offsetof(FCAPlayerTotalMatchStats, M_specialist_name) == 0x000018, "Member 'FCAPlayerTotalMatchStats::M_specialist_name' has a wrong offset!");
static_assert(offsetof(FCAPlayerTotalMatchStats, M_extraction_state) == 0x000024, "Member 'FCAPlayerTotalMatchStats::M_extraction_state' has a wrong offset!");
static_assert(offsetof(FCAPlayerTotalMatchStats, M_match_stat_details) == 0x000028, "Member 'FCAPlayerTotalMatchStats::M_match_stat_details' has a wrong offset!");

// ScriptStruct keaton.CARewardCategoryWeights
// 0x0008 (0x0010 - 0x0008)
struct FCARewardCategoryWeights final : public FTableRowBase
{
public:
	int32                                         M_weight_value;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCARewardCategoryWeights) == 0x000008, "Wrong alignment on FCARewardCategoryWeights");
static_assert(sizeof(FCARewardCategoryWeights) == 0x000010, "Wrong size on FCARewardCategoryWeights");
static_assert(offsetof(FCARewardCategoryWeights, M_weight_value) == 0x000008, "Member 'FCARewardCategoryWeights::M_weight_value' has a wrong offset!");

// ScriptStruct keaton.CAStatCategoryDefinition
// 0x0040 (0x0048 - 0x0008)
struct FCAStatCategoryDefinition final : public FTableRowBase
{
public:
	struct FCAText                                M_stat_category_label;                             // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_stat_ids;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAStatCategoryDefinition) == 0x000008, "Wrong alignment on FCAStatCategoryDefinition");
static_assert(sizeof(FCAStatCategoryDefinition) == 0x000048, "Wrong size on FCAStatCategoryDefinition");
static_assert(offsetof(FCAStatCategoryDefinition, M_stat_category_label) == 0x000008, "Member 'FCAStatCategoryDefinition::M_stat_category_label' has a wrong offset!");
static_assert(offsetof(FCAStatCategoryDefinition, M_stat_ids) == 0x000038, "Member 'FCAStatCategoryDefinition::M_stat_ids' has a wrong offset!");

// ScriptStruct keaton.CAMaterialSwap
// 0x0018 (0x0018 - 0x0000)
struct FCAMaterialSwap final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     Material;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMaterialSwap) == 0x000008, "Wrong alignment on FCAMaterialSwap");
static_assert(sizeof(FCAMaterialSwap) == 0x000018, "Wrong size on FCAMaterialSwap");
static_assert(offsetof(FCAMaterialSwap, Name) == 0x000000, "Member 'FCAMaterialSwap::Name' has a wrong offset!");
static_assert(offsetof(FCAMaterialSwap, Material) == 0x000010, "Member 'FCAMaterialSwap::Material' has a wrong offset!");

// ScriptStruct keaton.CAStrikeInfo
// 0x0098 (0x0098 - 0x0000)
struct FCAStrikeInfo final
{
public:
	struct FHitResult                             M_original_hit_result;                             // 0x0000(0x0090)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         M_FX_index;                                        // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAStrikeInfo) == 0x000004, "Wrong alignment on FCAStrikeInfo");
static_assert(sizeof(FCAStrikeInfo) == 0x000098, "Wrong size on FCAStrikeInfo");
static_assert(offsetof(FCAStrikeInfo, M_original_hit_result) == 0x000000, "Member 'FCAStrikeInfo::M_original_hit_result' has a wrong offset!");
static_assert(offsetof(FCAStrikeInfo, M_FX_index) == 0x000090, "Member 'FCAStrikeInfo::M_FX_index' has a wrong offset!");

// ScriptStruct keaton.CAHubNavigationData
// 0x0038 (0x0038 - 0x0000)
struct FCAHubNavigationData final
{
public:
	struct FCAGameDatabaseRowHandle               M_menu_data_handle;                                // 0x0000(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UCAMenuGroup*                           M_menu_group;                                      // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAMenuGroup*                           M_parent_menu_group;                               // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAMenuNavigationItem>          M_dynamic_menu_items;                              // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAHubNavigationData) == 0x000008, "Wrong alignment on FCAHubNavigationData");
static_assert(sizeof(FCAHubNavigationData) == 0x000038, "Wrong size on FCAHubNavigationData");
static_assert(offsetof(FCAHubNavigationData, M_menu_data_handle) == 0x000000, "Member 'FCAHubNavigationData::M_menu_data_handle' has a wrong offset!");
static_assert(offsetof(FCAHubNavigationData, M_menu_group) == 0x000018, "Member 'FCAHubNavigationData::M_menu_group' has a wrong offset!");
static_assert(offsetof(FCAHubNavigationData, M_parent_menu_group) == 0x000020, "Member 'FCAHubNavigationData::M_parent_menu_group' has a wrong offset!");
static_assert(offsetof(FCAHubNavigationData, M_dynamic_menu_items) == 0x000028, "Member 'FCAHubNavigationData::M_dynamic_menu_items' has a wrong offset!");

// ScriptStruct keaton.CAMenuNavigationTableRow
// 0x0080 (0x0088 - 0x0008)
struct FCAMenuNavigationTableRow final : public FTableRowBase
{
public:
	struct FCAMenuNavigationGroup                 M_menu_group;                                      // 0x0008(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMenuNavigationTableRow) == 0x000008, "Wrong alignment on FCAMenuNavigationTableRow");
static_assert(sizeof(FCAMenuNavigationTableRow) == 0x000088, "Wrong size on FCAMenuNavigationTableRow");
static_assert(offsetof(FCAMenuNavigationTableRow, M_menu_group) == 0x000008, "Member 'FCAMenuNavigationTableRow::M_menu_group' has a wrong offset!");

// ScriptStruct keaton.CANPCMissionTriggerRecord
// 0x0020 (0x0020 - 0x0000)
struct FCANPCMissionTriggerRecord final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_security_area;                                   // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCMissionTriggerRecord) == 0x000008, "Wrong alignment on FCANPCMissionTriggerRecord");
static_assert(sizeof(FCANPCMissionTriggerRecord) == 0x000020, "Wrong size on FCANPCMissionTriggerRecord");
static_assert(offsetof(FCANPCMissionTriggerRecord, M_security_area) == 0x000010, "Member 'FCANPCMissionTriggerRecord::M_security_area' has a wrong offset!");

// ScriptStruct keaton.CAShotPatternData
// 0x0028 (0x0030 - 0x0008)
struct FCAShotPatternData final : public FTableRowBase
{
public:
	float                                         M_shot_recoil_x;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_shot_recoil_y;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_spread_x;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_spread_y;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_spread_x;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_spread_y;                                    // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAPelletPatternData>           M_pellets;                                         // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAShotPatternData) == 0x000008, "Wrong alignment on FCAShotPatternData");
static_assert(sizeof(FCAShotPatternData) == 0x000030, "Wrong size on FCAShotPatternData");
static_assert(offsetof(FCAShotPatternData, M_shot_recoil_x) == 0x000008, "Member 'FCAShotPatternData::M_shot_recoil_x' has a wrong offset!");
static_assert(offsetof(FCAShotPatternData, M_shot_recoil_y) == 0x00000C, "Member 'FCAShotPatternData::M_shot_recoil_y' has a wrong offset!");
static_assert(offsetof(FCAShotPatternData, M_min_spread_x) == 0x000010, "Member 'FCAShotPatternData::M_min_spread_x' has a wrong offset!");
static_assert(offsetof(FCAShotPatternData, M_min_spread_y) == 0x000014, "Member 'FCAShotPatternData::M_min_spread_y' has a wrong offset!");
static_assert(offsetof(FCAShotPatternData, M_max_spread_x) == 0x000018, "Member 'FCAShotPatternData::M_max_spread_x' has a wrong offset!");
static_assert(offsetof(FCAShotPatternData, M_max_spread_y) == 0x00001C, "Member 'FCAShotPatternData::M_max_spread_y' has a wrong offset!");
static_assert(offsetof(FCAShotPatternData, M_pellets) == 0x000020, "Member 'FCAShotPatternData::M_pellets' has a wrong offset!");

// ScriptStruct keaton.CANPCCountChangeRecord
// 0x0020 (0x0020 - 0x0000)
struct FCANPCCountChangeRecord final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_security_area;                                   // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANPCCountChangeRecord) == 0x000008, "Wrong alignment on FCANPCCountChangeRecord");
static_assert(sizeof(FCANPCCountChangeRecord) == 0x000020, "Wrong size on FCANPCCountChangeRecord");
static_assert(offsetof(FCANPCCountChangeRecord, M_security_area) == 0x000018, "Member 'FCANPCCountChangeRecord::M_security_area' has a wrong offset!");

// ScriptStruct keaton.CAPlayerResult
// 0x0058 (0x0058 - 0x0000)
struct FCAPlayerResult final
{
public:
	class FString                                 Platform_user_id;                                  // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Display_name;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCATeamID                              Team_id;                                           // 0x0020(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Specialist;                                        // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Extraction_area_id;                                // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Extraction_camp_id;                                // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Loot;                                              // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Loot_from_players;                                 // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Loot_from_vaults;                                  // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Winning_team;                                      // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Extracted;                                         // 0x0055(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Alive;                                             // 0x0056(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Wiped;                                             // 0x0057(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPlayerResult) == 0x000008, "Wrong alignment on FCAPlayerResult");
static_assert(sizeof(FCAPlayerResult) == 0x000058, "Wrong size on FCAPlayerResult");
static_assert(offsetof(FCAPlayerResult, Platform_user_id) == 0x000000, "Member 'FCAPlayerResult::Platform_user_id' has a wrong offset!");
static_assert(offsetof(FCAPlayerResult, Display_name) == 0x000010, "Member 'FCAPlayerResult::Display_name' has a wrong offset!");
static_assert(offsetof(FCAPlayerResult, Team_id) == 0x000020, "Member 'FCAPlayerResult::Team_id' has a wrong offset!");
static_assert(offsetof(FCAPlayerResult, Specialist) == 0x000024, "Member 'FCAPlayerResult::Specialist' has a wrong offset!");
static_assert(offsetof(FCAPlayerResult, Extraction_area_id) == 0x000030, "Member 'FCAPlayerResult::Extraction_area_id' has a wrong offset!");
static_assert(offsetof(FCAPlayerResult, Extraction_camp_id) == 0x00003C, "Member 'FCAPlayerResult::Extraction_camp_id' has a wrong offset!");
static_assert(offsetof(FCAPlayerResult, Loot) == 0x000048, "Member 'FCAPlayerResult::Loot' has a wrong offset!");
static_assert(offsetof(FCAPlayerResult, Loot_from_players) == 0x00004C, "Member 'FCAPlayerResult::Loot_from_players' has a wrong offset!");
static_assert(offsetof(FCAPlayerResult, Loot_from_vaults) == 0x000050, "Member 'FCAPlayerResult::Loot_from_vaults' has a wrong offset!");
static_assert(offsetof(FCAPlayerResult, Winning_team) == 0x000054, "Member 'FCAPlayerResult::Winning_team' has a wrong offset!");
static_assert(offsetof(FCAPlayerResult, Extracted) == 0x000055, "Member 'FCAPlayerResult::Extracted' has a wrong offset!");
static_assert(offsetof(FCAPlayerResult, Alive) == 0x000056, "Member 'FCAPlayerResult::Alive' has a wrong offset!");
static_assert(offsetof(FCAPlayerResult, Wiped) == 0x000057, "Member 'FCAPlayerResult::Wiped' has a wrong offset!");

// ScriptStruct keaton.TeleporterUseData
// 0x0010 (0x0010 - 0x0000)
struct FTeleporterUseData final
{
public:
	class ACACharacter*                           Player;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           Timer_handle;                                      // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeleporterUseData) == 0x000008, "Wrong alignment on FTeleporterUseData");
static_assert(sizeof(FTeleporterUseData) == 0x000010, "Wrong size on FTeleporterUseData");
static_assert(offsetof(FTeleporterUseData, Player) == 0x000000, "Member 'FTeleporterUseData::Player' has a wrong offset!");
static_assert(offsetof(FTeleporterUseData, Timer_handle) == 0x000008, "Member 'FTeleporterUseData::Timer_handle' has a wrong offset!");

// ScriptStruct keaton.CABattleEventBody
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FCABattleEventBody final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCABattleEventBody) == 0x000008, "Wrong alignment on FCABattleEventBody");
static_assert(sizeof(FCABattleEventBody) == 0x000010, "Wrong size on FCABattleEventBody");

// ScriptStruct keaton.CAMountablePartWithMeshComponent
// 0x0048 (0x0048 - 0x0000)
struct FCAMountablePartWithMeshComponent final
{
public:
	struct FCAMountablePart                       M_mountable_part;                                  // 0x0000(0x0040)(NativeAccessSpecifierPublic)
	class UMeshComponent*                         M_mesh_component;                                  // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMountablePartWithMeshComponent) == 0x000008, "Wrong alignment on FCAMountablePartWithMeshComponent");
static_assert(sizeof(FCAMountablePartWithMeshComponent) == 0x000048, "Wrong size on FCAMountablePartWithMeshComponent");
static_assert(offsetof(FCAMountablePartWithMeshComponent, M_mountable_part) == 0x000000, "Member 'FCAMountablePartWithMeshComponent::M_mountable_part' has a wrong offset!");
static_assert(offsetof(FCAMountablePartWithMeshComponent, M_mesh_component) == 0x000040, "Member 'FCAMountablePartWithMeshComponent::M_mesh_component' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_Crouch
// 0x0010 (0x0018 - 0x0008)
struct FCAExceptionData_Crouch final : public FCAMovementModeExceptionData
{
public:
	struct FCAExceptionData_bool                  M_is_blocked;                                      // 0x0008(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAExceptionData_float                 M_max_speed;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAExceptionData_Crouch) == 0x000008, "Wrong alignment on FCAExceptionData_Crouch");
static_assert(sizeof(FCAExceptionData_Crouch) == 0x000018, "Wrong size on FCAExceptionData_Crouch");
static_assert(offsetof(FCAExceptionData_Crouch, M_is_blocked) == 0x000008, "Member 'FCAExceptionData_Crouch::M_is_blocked' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Crouch, M_max_speed) == 0x00000C, "Member 'FCAExceptionData_Crouch::M_max_speed' has a wrong offset!");

// ScriptStruct keaton.CAUIAutomationInstructions
// 0x0018 (0x0020 - 0x0008)
struct FCAUIAutomationInstructions final : public FTableRowBase
{
public:
	TArray<TSoftClassPtr<class UClass>>           M_instructions;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          M_restart_on_reentry_to_frontend;                  // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAUIAutomationInstructions) == 0x000008, "Wrong alignment on FCAUIAutomationInstructions");
static_assert(sizeof(FCAUIAutomationInstructions) == 0x000020, "Wrong size on FCAUIAutomationInstructions");
static_assert(offsetof(FCAUIAutomationInstructions, M_instructions) == 0x000008, "Member 'FCAUIAutomationInstructions::M_instructions' has a wrong offset!");
static_assert(offsetof(FCAUIAutomationInstructions, M_restart_on_reentry_to_frontend) == 0x000018, "Member 'FCAUIAutomationInstructions::M_restart_on_reentry_to_frontend' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_Downed
// 0x0008 (0x0010 - 0x0008)
struct FCAExceptionData_Downed final : public FCAMovementModeExceptionData
{
public:
	struct FCAExceptionData_float                 M_max_speed_crawling;                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAExceptionData_Downed) == 0x000008, "Wrong alignment on FCAExceptionData_Downed");
static_assert(sizeof(FCAExceptionData_Downed) == 0x000010, "Wrong size on FCAExceptionData_Downed");
static_assert(offsetof(FCAExceptionData_Downed, M_max_speed_crawling) == 0x000008, "Member 'FCAExceptionData_Downed::M_max_speed_crawling' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_Fall
// 0x0030 (0x0040 - 0x0010)
struct FCAMovementData_Fall final : public FCAMovementModeData
{
public:
	float                                         M_jump_allowed_time;                               // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_long_fall_height;                                // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_short_fall_air_control;                          // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_long_fall_air_control;                           // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_landing_restitution;                             // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_restitution_speed;                           // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_speed;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_speed_post_slide;                            // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_over_speed_deceleration;                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_post_ZG_reduced_gravity_height;                  // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_post_ZG_fall_gravity_factor;                     // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementData_Fall) == 0x000008, "Wrong alignment on FCAMovementData_Fall");
static_assert(sizeof(FCAMovementData_Fall) == 0x000040, "Wrong size on FCAMovementData_Fall");
static_assert(offsetof(FCAMovementData_Fall, M_jump_allowed_time) == 0x000010, "Member 'FCAMovementData_Fall::M_jump_allowed_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Fall, M_long_fall_height) == 0x000014, "Member 'FCAMovementData_Fall::M_long_fall_height' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Fall, M_short_fall_air_control) == 0x000018, "Member 'FCAMovementData_Fall::M_short_fall_air_control' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Fall, M_long_fall_air_control) == 0x00001C, "Member 'FCAMovementData_Fall::M_long_fall_air_control' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Fall, M_landing_restitution) == 0x000020, "Member 'FCAMovementData_Fall::M_landing_restitution' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Fall, M_min_restitution_speed) == 0x000024, "Member 'FCAMovementData_Fall::M_min_restitution_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Fall, M_max_speed) == 0x000028, "Member 'FCAMovementData_Fall::M_max_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Fall, M_max_speed_post_slide) == 0x00002C, "Member 'FCAMovementData_Fall::M_max_speed_post_slide' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Fall, M_over_speed_deceleration) == 0x000030, "Member 'FCAMovementData_Fall::M_over_speed_deceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Fall, M_post_ZG_reduced_gravity_height) == 0x000034, "Member 'FCAMovementData_Fall::M_post_ZG_reduced_gravity_height' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Fall, M_post_ZG_fall_gravity_factor) == 0x000038, "Member 'FCAMovementData_Fall::M_post_ZG_fall_gravity_factor' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_JumpProfile_Elt
// 0x0014 (0x0014 - 0x0000)
struct FCAMovementData_JumpProfile_Elt final
{
public:
	float                                         M_jump_height;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_running_jump_distance;                           // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sprinting_jump_distance;                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sliding_jump_distance;                           // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_can_accelerate;                                  // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementData_JumpProfile_Elt) == 0x000004, "Wrong alignment on FCAMovementData_JumpProfile_Elt");
static_assert(sizeof(FCAMovementData_JumpProfile_Elt) == 0x000014, "Wrong size on FCAMovementData_JumpProfile_Elt");
static_assert(offsetof(FCAMovementData_JumpProfile_Elt, M_jump_height) == 0x000000, "Member 'FCAMovementData_JumpProfile_Elt::M_jump_height' has a wrong offset!");
static_assert(offsetof(FCAMovementData_JumpProfile_Elt, M_running_jump_distance) == 0x000004, "Member 'FCAMovementData_JumpProfile_Elt::M_running_jump_distance' has a wrong offset!");
static_assert(offsetof(FCAMovementData_JumpProfile_Elt, M_sprinting_jump_distance) == 0x000008, "Member 'FCAMovementData_JumpProfile_Elt::M_sprinting_jump_distance' has a wrong offset!");
static_assert(offsetof(FCAMovementData_JumpProfile_Elt, M_sliding_jump_distance) == 0x00000C, "Member 'FCAMovementData_JumpProfile_Elt::M_sliding_jump_distance' has a wrong offset!");
static_assert(offsetof(FCAMovementData_JumpProfile_Elt, M_can_accelerate) == 0x000010, "Member 'FCAMovementData_JumpProfile_Elt::M_can_accelerate' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_Jump
// 0x0038 (0x0048 - 0x0010)
struct FCAMovementData_Jump final : public FCAMovementModeData
{
public:
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAMovementData_JumpProfile_Elt> M_jump_profiles;                                   // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_acceleration;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_deceleration;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_air_control;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_bunny_hop_time_out;                              // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_forwards_check;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sliding_jump_allowable_angle;                    // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_gap_edge_detection;                              // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_takeoff_down_into_zg_holes;                      // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_angle_of_declination_down_into_zg_holes;         // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMovementData_Jump) == 0x000008, "Wrong alignment on FCAMovementData_Jump");
static_assert(sizeof(FCAMovementData_Jump) == 0x000048, "Wrong size on FCAMovementData_Jump");
static_assert(offsetof(FCAMovementData_Jump, M_jump_profiles) == 0x000018, "Member 'FCAMovementData_Jump::M_jump_profiles' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Jump, M_acceleration) == 0x000028, "Member 'FCAMovementData_Jump::M_acceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Jump, M_deceleration) == 0x00002C, "Member 'FCAMovementData_Jump::M_deceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Jump, M_air_control) == 0x000030, "Member 'FCAMovementData_Jump::M_air_control' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Jump, M_bunny_hop_time_out) == 0x000034, "Member 'FCAMovementData_Jump::M_bunny_hop_time_out' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Jump, M_forwards_check) == 0x000038, "Member 'FCAMovementData_Jump::M_forwards_check' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Jump, M_sliding_jump_allowable_angle) == 0x00003C, "Member 'FCAMovementData_Jump::M_sliding_jump_allowable_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Jump, M_gap_edge_detection) == 0x000040, "Member 'FCAMovementData_Jump::M_gap_edge_detection' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Jump, M_takeoff_down_into_zg_holes) == 0x000041, "Member 'FCAMovementData_Jump::M_takeoff_down_into_zg_holes' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Jump, M_angle_of_declination_down_into_zg_holes) == 0x000044, "Member 'FCAMovementData_Jump::M_angle_of_declination_down_into_zg_holes' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_Loco
// 0x0058 (0x0068 - 0x0010)
struct FCAMovementData_Loco final : public FCAMovementModeData
{
public:
	uint8                                         Pad_10[0x4];                                       // 0x0010(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_ground_friction;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_deceleration;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_acceleration;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_full_speed_turn_rate;                        // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_low_speed_turn_rate;                         // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_speed_when_max_turning;                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_walkable_floor_angle;                            // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x4];                                       // 0x0030(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_walkable_floor_angle_foam;                       // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x4];                                       // 0x0038(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_max_step_height;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_perch_radius;                                // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_just_landed_acceleration;                        // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_just_landed_timeout;                             // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_speed_forwards;                              // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_diagonal_angle;                              // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_speed_backwards;                             // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_speed_cap;                                       // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_client_authoritative_allowable_error;        // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_client_authoritative_timeout;                    // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementData_Loco) == 0x000008, "Wrong alignment on FCAMovementData_Loco");
static_assert(sizeof(FCAMovementData_Loco) == 0x000068, "Wrong size on FCAMovementData_Loco");
static_assert(offsetof(FCAMovementData_Loco, M_ground_friction) == 0x000014, "Member 'FCAMovementData_Loco::M_ground_friction' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Loco, M_deceleration) == 0x000018, "Member 'FCAMovementData_Loco::M_deceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Loco, M_acceleration) == 0x00001C, "Member 'FCAMovementData_Loco::M_acceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Loco, M_max_full_speed_turn_rate) == 0x000020, "Member 'FCAMovementData_Loco::M_max_full_speed_turn_rate' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Loco, M_max_low_speed_turn_rate) == 0x000024, "Member 'FCAMovementData_Loco::M_max_low_speed_turn_rate' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Loco, M_speed_when_max_turning) == 0x000028, "Member 'FCAMovementData_Loco::M_speed_when_max_turning' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Loco, M_walkable_floor_angle) == 0x00002C, "Member 'FCAMovementData_Loco::M_walkable_floor_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Loco, M_walkable_floor_angle_foam) == 0x000034, "Member 'FCAMovementData_Loco::M_walkable_floor_angle_foam' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Loco, M_max_step_height) == 0x00003C, "Member 'FCAMovementData_Loco::M_max_step_height' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Loco, M_min_perch_radius) == 0x000040, "Member 'FCAMovementData_Loco::M_min_perch_radius' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Loco, M_just_landed_acceleration) == 0x000044, "Member 'FCAMovementData_Loco::M_just_landed_acceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Loco, M_just_landed_timeout) == 0x000048, "Member 'FCAMovementData_Loco::M_just_landed_timeout' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Loco, M_max_speed_forwards) == 0x00004C, "Member 'FCAMovementData_Loco::M_max_speed_forwards' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Loco, M_max_diagonal_angle) == 0x000050, "Member 'FCAMovementData_Loco::M_max_diagonal_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Loco, M_max_speed_backwards) == 0x000054, "Member 'FCAMovementData_Loco::M_max_speed_backwards' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Loco, M_speed_cap) == 0x000058, "Member 'FCAMovementData_Loco::M_speed_cap' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Loco, M_max_client_authoritative_allowable_error) == 0x00005C, "Member 'FCAMovementData_Loco::M_max_client_authoritative_allowable_error' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Loco, M_client_authoritative_timeout) == 0x000060, "Member 'FCAMovementData_Loco::M_client_authoritative_timeout' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_Loco
// 0x0058 (0x0060 - 0x0008)
struct FCAExceptionData_Loco final : public FCAMovementModeExceptionData
{
public:
	struct FCAExceptionData_bool                  M_is_immobilised;                                  // 0x0008(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAExceptionData_float                 M_ground_friction;                                 // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_deceleration;                                    // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_acceleration;                                    // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_max_full_speed_turn_rate;                        // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_max_low_speed_turn_rate;                         // 0x002C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_speed_when_max_turning;                          // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_just_landed_acceleration;                        // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_just_landed_timeout;                             // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_max_speed_forwards;                              // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_max_speed_backwards;                             // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAExceptionData_Loco) == 0x000008, "Wrong alignment on FCAExceptionData_Loco");
static_assert(sizeof(FCAExceptionData_Loco) == 0x000060, "Wrong size on FCAExceptionData_Loco");
static_assert(offsetof(FCAExceptionData_Loco, M_is_immobilised) == 0x000008, "Member 'FCAExceptionData_Loco::M_is_immobilised' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Loco, M_ground_friction) == 0x00000C, "Member 'FCAExceptionData_Loco::M_ground_friction' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Loco, M_deceleration) == 0x000014, "Member 'FCAExceptionData_Loco::M_deceleration' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Loco, M_acceleration) == 0x00001C, "Member 'FCAExceptionData_Loco::M_acceleration' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Loco, M_max_full_speed_turn_rate) == 0x000024, "Member 'FCAExceptionData_Loco::M_max_full_speed_turn_rate' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Loco, M_max_low_speed_turn_rate) == 0x00002C, "Member 'FCAExceptionData_Loco::M_max_low_speed_turn_rate' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Loco, M_speed_when_max_turning) == 0x000034, "Member 'FCAExceptionData_Loco::M_speed_when_max_turning' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Loco, M_just_landed_acceleration) == 0x00003C, "Member 'FCAExceptionData_Loco::M_just_landed_acceleration' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Loco, M_just_landed_timeout) == 0x000044, "Member 'FCAExceptionData_Loco::M_just_landed_timeout' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Loco, M_max_speed_forwards) == 0x00004C, "Member 'FCAExceptionData_Loco::M_max_speed_forwards' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Loco, M_max_speed_backwards) == 0x000054, "Member 'FCAExceptionData_Loco::M_max_speed_backwards' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_MagBoots
// 0x0030 (0x0040 - 0x0010)
struct FCAMovementData_MagBoots final : public FCAMovementModeData
{
public:
	float                                         M_ground_friction;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_deceleration;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_acceleration;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_wall_angle_magboots_to_wall_crawl;               // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x4];                                       // 0x0020(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_camera_angle_magboots_to_wall_crawl;             // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_camera_yaw_magboots_to_wall_crawl;               // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_wall_push_time;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_speed;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_diagonal_angle;                              // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementData_MagBoots) == 0x000008, "Wrong alignment on FCAMovementData_MagBoots");
static_assert(sizeof(FCAMovementData_MagBoots) == 0x000040, "Wrong size on FCAMovementData_MagBoots");
static_assert(offsetof(FCAMovementData_MagBoots, M_ground_friction) == 0x000010, "Member 'FCAMovementData_MagBoots::M_ground_friction' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBoots, M_deceleration) == 0x000014, "Member 'FCAMovementData_MagBoots::M_deceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBoots, M_acceleration) == 0x000018, "Member 'FCAMovementData_MagBoots::M_acceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBoots, M_wall_angle_magboots_to_wall_crawl) == 0x00001C, "Member 'FCAMovementData_MagBoots::M_wall_angle_magboots_to_wall_crawl' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBoots, M_camera_angle_magboots_to_wall_crawl) == 0x000024, "Member 'FCAMovementData_MagBoots::M_camera_angle_magboots_to_wall_crawl' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBoots, M_camera_yaw_magboots_to_wall_crawl) == 0x000028, "Member 'FCAMovementData_MagBoots::M_camera_yaw_magboots_to_wall_crawl' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBoots, M_wall_push_time) == 0x000030, "Member 'FCAMovementData_MagBoots::M_wall_push_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBoots, M_max_speed) == 0x000034, "Member 'FCAMovementData_MagBoots::M_max_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBoots, M_max_diagonal_angle) == 0x000038, "Member 'FCAMovementData_MagBoots::M_max_diagonal_angle' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_MagBootsCrouch
// 0x0008 (0x0018 - 0x0010)
struct FCAMovementData_MagBootsCrouch final : public FCAMovementModeData
{
public:
	float                                         M_half_height;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_speed;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMovementData_MagBootsCrouch) == 0x000008, "Wrong alignment on FCAMovementData_MagBootsCrouch");
static_assert(sizeof(FCAMovementData_MagBootsCrouch) == 0x000018, "Wrong size on FCAMovementData_MagBootsCrouch");
static_assert(offsetof(FCAMovementData_MagBootsCrouch, M_half_height) == 0x000010, "Member 'FCAMovementData_MagBootsCrouch::M_half_height' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBootsCrouch, M_max_speed) == 0x000014, "Member 'FCAMovementData_MagBootsCrouch::M_max_speed' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_MagBootsCrouch
// 0x0008 (0x0010 - 0x0008)
struct FCAExceptionData_MagBootsCrouch final : public FCAMovementModeExceptionData
{
public:
	struct FCAExceptionData_float                 M_max_speed;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAExceptionData_MagBootsCrouch) == 0x000008, "Wrong alignment on FCAExceptionData_MagBootsCrouch");
static_assert(sizeof(FCAExceptionData_MagBootsCrouch) == 0x000010, "Wrong size on FCAExceptionData_MagBootsCrouch");
static_assert(offsetof(FCAExceptionData_MagBootsCrouch, M_max_speed) == 0x000008, "Member 'FCAExceptionData_MagBootsCrouch::M_max_speed' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_MagBootsSprint
// 0x0010 (0x0020 - 0x0010)
struct FCAMovementData_MagBootsSprint final : public FCAMovementModeData
{
public:
	uint8                                         Pad_10[0x4];                                       // 0x0010(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_max_speed;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_diagonal_angle;                              // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementData_MagBootsSprint) == 0x000008, "Wrong alignment on FCAMovementData_MagBootsSprint");
static_assert(sizeof(FCAMovementData_MagBootsSprint) == 0x000020, "Wrong size on FCAMovementData_MagBootsSprint");
static_assert(offsetof(FCAMovementData_MagBootsSprint, M_max_speed) == 0x000014, "Member 'FCAMovementData_MagBootsSprint::M_max_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_MagBootsSprint, M_max_diagonal_angle) == 0x000018, "Member 'FCAMovementData_MagBootsSprint::M_max_diagonal_angle' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_MagBootsSprint
// 0x0010 (0x0018 - 0x0008)
struct FCAExceptionData_MagBootsSprint final : public FCAMovementModeExceptionData
{
public:
	struct FCAExceptionData_bool                  M_is_blocked;                                      // 0x0008(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAExceptionData_float                 M_max_speed;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAExceptionData_MagBootsSprint) == 0x000008, "Wrong alignment on FCAExceptionData_MagBootsSprint");
static_assert(sizeof(FCAExceptionData_MagBootsSprint) == 0x000018, "Wrong size on FCAExceptionData_MagBootsSprint");
static_assert(offsetof(FCAExceptionData_MagBootsSprint, M_is_blocked) == 0x000008, "Member 'FCAExceptionData_MagBootsSprint::M_is_blocked' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_MagBootsSprint, M_max_speed) == 0x00000C, "Member 'FCAExceptionData_MagBootsSprint::M_max_speed' has a wrong offset!");

// ScriptStruct keaton.ServicesUserProfileEntry
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FServicesUserProfileEntry final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FServicesUserProfileEntry) == 0x000008, "Wrong alignment on FServicesUserProfileEntry");
static_assert(sizeof(FServicesUserProfileEntry) == 0x000020, "Wrong size on FServicesUserProfileEntry");

// ScriptStruct keaton.CAGameplayAbilityTargetData_TeleportLocation
// 0x0010 (0x0018 - 0x0008)
struct FCAGameplayAbilityTargetData_TeleportLocation final : public FGameplayAbilityTargetData
{
public:
	struct FGameplayTag                           M_gameplay_tag;                                    // 0x0008(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_location_enter;                                  // 0x0014(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_location_leave;                                  // 0x0015(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_location_confirm;                                // 0x0016(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAGameplayAbilityTargetData_TeleportLocation) == 0x000008, "Wrong alignment on FCAGameplayAbilityTargetData_TeleportLocation");
static_assert(sizeof(FCAGameplayAbilityTargetData_TeleportLocation) == 0x000018, "Wrong size on FCAGameplayAbilityTargetData_TeleportLocation");
static_assert(offsetof(FCAGameplayAbilityTargetData_TeleportLocation, M_gameplay_tag) == 0x000008, "Member 'FCAGameplayAbilityTargetData_TeleportLocation::M_gameplay_tag' has a wrong offset!");
static_assert(offsetof(FCAGameplayAbilityTargetData_TeleportLocation, M_location_enter) == 0x000014, "Member 'FCAGameplayAbilityTargetData_TeleportLocation::M_location_enter' has a wrong offset!");
static_assert(offsetof(FCAGameplayAbilityTargetData_TeleportLocation, M_location_leave) == 0x000015, "Member 'FCAGameplayAbilityTargetData_TeleportLocation::M_location_leave' has a wrong offset!");
static_assert(offsetof(FCAGameplayAbilityTargetData_TeleportLocation, M_location_confirm) == 0x000016, "Member 'FCAGameplayAbilityTargetData_TeleportLocation::M_location_confirm' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_Npc
// 0x0050 (0x0060 - 0x0010)
struct FCAMovementData_Npc final : public FCAMovementModeData
{
public:
	float                                         M_walk_speed;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_jog_speed;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_run_speed;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fast_travel_speed;                               // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_walk_max_deceleration;                           // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_jog_max_deceleration;                            // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_run_max_deceleration;                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fast_travel_max_deceleration;                    // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_walk_max_acceleration;                           // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_jog_max_acceleration;                            // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_run_max_acceleration;                            // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fast_travel_max_acceleration;                    // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_possessed_jump_height;                           // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_possessed_speed_horizontal;                      // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_possessed_acceleration_horizontal;               // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_possessed_deceleration_horizontal;               // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_possessed_flying_friction;                       // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_possessed_speed_vertical;                        // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_possessed_acceleration_vertical;                 // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_possessed_deceleration_vertical;                 // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMovementData_Npc) == 0x000008, "Wrong alignment on FCAMovementData_Npc");
static_assert(sizeof(FCAMovementData_Npc) == 0x000060, "Wrong size on FCAMovementData_Npc");
static_assert(offsetof(FCAMovementData_Npc, M_walk_speed) == 0x000010, "Member 'FCAMovementData_Npc::M_walk_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_jog_speed) == 0x000014, "Member 'FCAMovementData_Npc::M_jog_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_run_speed) == 0x000018, "Member 'FCAMovementData_Npc::M_run_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_fast_travel_speed) == 0x00001C, "Member 'FCAMovementData_Npc::M_fast_travel_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_walk_max_deceleration) == 0x000020, "Member 'FCAMovementData_Npc::M_walk_max_deceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_jog_max_deceleration) == 0x000024, "Member 'FCAMovementData_Npc::M_jog_max_deceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_run_max_deceleration) == 0x000028, "Member 'FCAMovementData_Npc::M_run_max_deceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_fast_travel_max_deceleration) == 0x00002C, "Member 'FCAMovementData_Npc::M_fast_travel_max_deceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_walk_max_acceleration) == 0x000030, "Member 'FCAMovementData_Npc::M_walk_max_acceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_jog_max_acceleration) == 0x000034, "Member 'FCAMovementData_Npc::M_jog_max_acceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_run_max_acceleration) == 0x000038, "Member 'FCAMovementData_Npc::M_run_max_acceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_fast_travel_max_acceleration) == 0x00003C, "Member 'FCAMovementData_Npc::M_fast_travel_max_acceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_possessed_jump_height) == 0x000040, "Member 'FCAMovementData_Npc::M_possessed_jump_height' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_possessed_speed_horizontal) == 0x000044, "Member 'FCAMovementData_Npc::M_possessed_speed_horizontal' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_possessed_acceleration_horizontal) == 0x000048, "Member 'FCAMovementData_Npc::M_possessed_acceleration_horizontal' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_possessed_deceleration_horizontal) == 0x00004C, "Member 'FCAMovementData_Npc::M_possessed_deceleration_horizontal' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_possessed_flying_friction) == 0x000050, "Member 'FCAMovementData_Npc::M_possessed_flying_friction' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_possessed_speed_vertical) == 0x000054, "Member 'FCAMovementData_Npc::M_possessed_speed_vertical' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_possessed_acceleration_vertical) == 0x000058, "Member 'FCAMovementData_Npc::M_possessed_acceleration_vertical' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Npc, M_possessed_deceleration_vertical) == 0x00005C, "Member 'FCAMovementData_Npc::M_possessed_deceleration_vertical' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_Slide_ProfileSet
// 0x0018 (0x0018 - 0x0000)
struct FCAMovementData_Slide_ProfileSet final
{
public:
	TArray<struct FCAMovementData_Slide_ProfileSetElt> M_phases;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_slide_braking_friction;                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementData_Slide_ProfileSet) == 0x000008, "Wrong alignment on FCAMovementData_Slide_ProfileSet");
static_assert(sizeof(FCAMovementData_Slide_ProfileSet) == 0x000018, "Wrong size on FCAMovementData_Slide_ProfileSet");
static_assert(offsetof(FCAMovementData_Slide_ProfileSet, M_phases) == 0x000000, "Member 'FCAMovementData_Slide_ProfileSet::M_phases' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide_ProfileSet, M_slide_braking_friction) == 0x000010, "Member 'FCAMovementData_Slide_ProfileSet::M_slide_braking_friction' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_Slide
// 0x00C8 (0x00D8 - 0x0010)
struct FCAMovementData_Slide final : public FCAMovementModeData
{
public:
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAMovementData_Slide_ProfileSet       M_default_profile;                                 // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x4];                                       // 0x0030(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_turn_offset;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x4];                                       // 0x0038(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_max_deceleration;                                // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_downhill_speed_boost;                            // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAMovementData_Slide_ProfileSet       M_uphill_profile;                                  // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_steep_slope_angle;                               // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAMovementData_Slide_ProfileSet       M_wall_slide_profile;                              // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_wall_slide_grace_period;                         // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_wall_impact_abort_angle;                         // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_wall_slide_profile_angle;                        // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAMovementData_Slide_ProfileSet> M_slide_spamming_profiles;                         // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_spam_timeout;                                    // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_loco_speed_to_start_slide;                   // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_crouch_tap_time;                                 // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_time_between_slides;                         // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_steering_boost_max_forward_look;                 // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_steering_boost_lateral_look_size;                // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_vent_assistance_width;                           // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_steepest_angle_to_allow_starting_slide;          // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_max_step_height;                                 // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_abort_when_crouch_released_time;                 // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_capsule_half_height;                             // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementData_Slide) == 0x000008, "Wrong alignment on FCAMovementData_Slide");
static_assert(sizeof(FCAMovementData_Slide) == 0x0000D8, "Wrong size on FCAMovementData_Slide");
static_assert(offsetof(FCAMovementData_Slide, M_default_profile) == 0x000018, "Member 'FCAMovementData_Slide::M_default_profile' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_turn_offset) == 0x000034, "Member 'FCAMovementData_Slide::M_turn_offset' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_max_deceleration) == 0x00003C, "Member 'FCAMovementData_Slide::M_max_deceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_downhill_speed_boost) == 0x000040, "Member 'FCAMovementData_Slide::M_downhill_speed_boost' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_uphill_profile) == 0x000048, "Member 'FCAMovementData_Slide::M_uphill_profile' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_steep_slope_angle) == 0x000060, "Member 'FCAMovementData_Slide::M_steep_slope_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_wall_slide_profile) == 0x000068, "Member 'FCAMovementData_Slide::M_wall_slide_profile' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_wall_slide_grace_period) == 0x000080, "Member 'FCAMovementData_Slide::M_wall_slide_grace_period' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_wall_impact_abort_angle) == 0x000084, "Member 'FCAMovementData_Slide::M_wall_impact_abort_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_wall_slide_profile_angle) == 0x000088, "Member 'FCAMovementData_Slide::M_wall_slide_profile_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_slide_spamming_profiles) == 0x000090, "Member 'FCAMovementData_Slide::M_slide_spamming_profiles' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_spam_timeout) == 0x0000A0, "Member 'FCAMovementData_Slide::M_spam_timeout' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_min_loco_speed_to_start_slide) == 0x0000A4, "Member 'FCAMovementData_Slide::M_min_loco_speed_to_start_slide' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_crouch_tap_time) == 0x0000A8, "Member 'FCAMovementData_Slide::M_crouch_tap_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_min_time_between_slides) == 0x0000AC, "Member 'FCAMovementData_Slide::M_min_time_between_slides' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_steering_boost_max_forward_look) == 0x0000B0, "Member 'FCAMovementData_Slide::M_steering_boost_max_forward_look' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_steering_boost_lateral_look_size) == 0x0000B8, "Member 'FCAMovementData_Slide::M_steering_boost_lateral_look_size' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_vent_assistance_width) == 0x0000BC, "Member 'FCAMovementData_Slide::M_vent_assistance_width' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_steepest_angle_to_allow_starting_slide) == 0x0000C0, "Member 'FCAMovementData_Slide::M_steepest_angle_to_allow_starting_slide' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_max_step_height) == 0x0000C8, "Member 'FCAMovementData_Slide::M_max_step_height' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_abort_when_crouch_released_time) == 0x0000CC, "Member 'FCAMovementData_Slide::M_abort_when_crouch_released_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Slide, M_capsule_half_height) == 0x0000D0, "Member 'FCAMovementData_Slide::M_capsule_half_height' has a wrong offset!");

// ScriptStruct keaton.WeaponData
// 0x0008 (0x0008 - 0x0000)
struct FWeaponData final
{
public:
	float                                         No_anim_reload_duration;                           // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_full_clip_reload;                                // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_should_show_firing_mode_switcher_indicator;      // 0x0005(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponData) == 0x000004, "Wrong alignment on FWeaponData");
static_assert(sizeof(FWeaponData) == 0x000008, "Wrong size on FWeaponData");
static_assert(offsetof(FWeaponData, No_anim_reload_duration) == 0x000000, "Member 'FWeaponData::No_anim_reload_duration' has a wrong offset!");
static_assert(offsetof(FWeaponData, M_full_clip_reload) == 0x000004, "Member 'FWeaponData::M_full_clip_reload' has a wrong offset!");
static_assert(offsetof(FWeaponData, M_should_show_firing_mode_switcher_indicator) == 0x000005, "Member 'FWeaponData::M_should_show_firing_mode_switcher_indicator' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_Slide_ProfileSetElt
// 0x0010 (0x0010 - 0x0000)
struct FCAExceptionData_Slide_ProfileSetElt final
{
public:
	struct FCAExceptionData_float                 M_time;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_speed;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAExceptionData_Slide_ProfileSetElt) == 0x000004, "Wrong alignment on FCAExceptionData_Slide_ProfileSetElt");
static_assert(sizeof(FCAExceptionData_Slide_ProfileSetElt) == 0x000010, "Wrong size on FCAExceptionData_Slide_ProfileSetElt");
static_assert(offsetof(FCAExceptionData_Slide_ProfileSetElt, M_time) == 0x000000, "Member 'FCAExceptionData_Slide_ProfileSetElt::M_time' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Slide_ProfileSetElt, M_speed) == 0x000008, "Member 'FCAExceptionData_Slide_ProfileSetElt::M_speed' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_Slide_ProfileSet
// 0x0018 (0x0018 - 0x0000)
struct FCAExceptionData_Slide_ProfileSet final
{
public:
	TArray<struct FCAExceptionData_Slide_ProfileSetElt> M_phases;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_slide_braking_friction;                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAExceptionData_Slide_ProfileSet) == 0x000008, "Wrong alignment on FCAExceptionData_Slide_ProfileSet");
static_assert(sizeof(FCAExceptionData_Slide_ProfileSet) == 0x000018, "Wrong size on FCAExceptionData_Slide_ProfileSet");
static_assert(offsetof(FCAExceptionData_Slide_ProfileSet, M_phases) == 0x000000, "Member 'FCAExceptionData_Slide_ProfileSet::M_phases' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Slide_ProfileSet, M_slide_braking_friction) == 0x000010, "Member 'FCAExceptionData_Slide_ProfileSet::M_slide_braking_friction' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_Slide
// 0x0070 (0x0078 - 0x0008)
struct FCAExceptionData_Slide final : public FCAMovementModeExceptionData
{
public:
	struct FCAExceptionData_bool                  M_is_blocked;                                      // 0x0008(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_bool                  M_abort_if_active;                                 // 0x000A(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAExceptionData_Slide_ProfileSet      M_default_profile;                                 // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_max_deceleration;                                // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_downhill_speed_boost;                            // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_Slide_ProfileSet      M_uphill_profile;                                  // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAExceptionData_Slide_ProfileSet      M_wall_slide_profile;                              // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAExceptionData_Slide_ProfileSet> M_slide_spamming_profiles;                         // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAExceptionData_Slide) == 0x000008, "Wrong alignment on FCAExceptionData_Slide");
static_assert(sizeof(FCAExceptionData_Slide) == 0x000078, "Wrong size on FCAExceptionData_Slide");
static_assert(offsetof(FCAExceptionData_Slide, M_is_blocked) == 0x000008, "Member 'FCAExceptionData_Slide::M_is_blocked' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Slide, M_abort_if_active) == 0x00000A, "Member 'FCAExceptionData_Slide::M_abort_if_active' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Slide, M_default_profile) == 0x000010, "Member 'FCAExceptionData_Slide::M_default_profile' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Slide, M_max_deceleration) == 0x000028, "Member 'FCAExceptionData_Slide::M_max_deceleration' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Slide, M_downhill_speed_boost) == 0x000030, "Member 'FCAExceptionData_Slide::M_downhill_speed_boost' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Slide, M_uphill_profile) == 0x000038, "Member 'FCAExceptionData_Slide::M_uphill_profile' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Slide, M_wall_slide_profile) == 0x000050, "Member 'FCAExceptionData_Slide::M_wall_slide_profile' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Slide, M_slide_spamming_profiles) == 0x000068, "Member 'FCAExceptionData_Slide::M_slide_spamming_profiles' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_Sprint
// 0x0018 (0x0028 - 0x0010)
struct FCAMovementData_Sprint final : public FCAMovementModeData
{
public:
	uint8                                         Pad_10[0x4];                                       // 0x0010(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_max_allowed_cam_pitch;                           // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_acceleration;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_speed_forwards;                              // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_diagonal_angle;                              // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementData_Sprint) == 0x000008, "Wrong alignment on FCAMovementData_Sprint");
static_assert(sizeof(FCAMovementData_Sprint) == 0x000028, "Wrong size on FCAMovementData_Sprint");
static_assert(offsetof(FCAMovementData_Sprint, M_max_allowed_cam_pitch) == 0x000014, "Member 'FCAMovementData_Sprint::M_max_allowed_cam_pitch' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Sprint, M_acceleration) == 0x000018, "Member 'FCAMovementData_Sprint::M_acceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Sprint, M_max_speed_forwards) == 0x00001C, "Member 'FCAMovementData_Sprint::M_max_speed_forwards' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Sprint, M_max_diagonal_angle) == 0x000020, "Member 'FCAMovementData_Sprint::M_max_diagonal_angle' has a wrong offset!");

// ScriptStruct keaton.CAServicesLootTableRow
// 0x00D8 (0x00E0 - 0x0008)
struct FCAServicesLootTableRow final : public FTableRowBase
{
public:
	bool                                          M_is_disabled;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_collect_me;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_collect_value;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_collect_currency_handle;                         // 0x0024(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         M_collected_total;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_fence_me;                                        // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_fence_value;                                     // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_fence_currency_handle;                           // 0x0054(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         M_fenced_total;                                    // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_pending_total;                                   // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_loot_reference;                                  // 0x0074(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_category;                                        // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_reward_category;                                 // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCALocalisationEntry                   M_category_loc;                                    // 0x00B0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAThemePackMultiplierData>     M_theme_pack_multipliers;                          // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_default_theme_pack_multiplier;                   // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_enabled_RDS;                                  // 0x00DC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAServicesLootTableRow) == 0x000008, "Wrong alignment on FCAServicesLootTableRow");
static_assert(sizeof(FCAServicesLootTableRow) == 0x0000E0, "Wrong size on FCAServicesLootTableRow");
static_assert(offsetof(FCAServicesLootTableRow, M_is_disabled) == 0x000008, "Member 'FCAServicesLootTableRow::M_is_disabled' has a wrong offset!");
static_assert(offsetof(FCAServicesLootTableRow, M_collect_me) == 0x000010, "Member 'FCAServicesLootTableRow::M_collect_me' has a wrong offset!");
static_assert(offsetof(FCAServicesLootTableRow, M_collect_value) == 0x000020, "Member 'FCAServicesLootTableRow::M_collect_value' has a wrong offset!");
static_assert(offsetof(FCAServicesLootTableRow, M_collect_currency_handle) == 0x000024, "Member 'FCAServicesLootTableRow::M_collect_currency_handle' has a wrong offset!");
static_assert(offsetof(FCAServicesLootTableRow, M_collected_total) == 0x00003C, "Member 'FCAServicesLootTableRow::M_collected_total' has a wrong offset!");
static_assert(offsetof(FCAServicesLootTableRow, M_fence_me) == 0x000040, "Member 'FCAServicesLootTableRow::M_fence_me' has a wrong offset!");
static_assert(offsetof(FCAServicesLootTableRow, M_fence_value) == 0x000050, "Member 'FCAServicesLootTableRow::M_fence_value' has a wrong offset!");
static_assert(offsetof(FCAServicesLootTableRow, M_fence_currency_handle) == 0x000054, "Member 'FCAServicesLootTableRow::M_fence_currency_handle' has a wrong offset!");
static_assert(offsetof(FCAServicesLootTableRow, M_fenced_total) == 0x00006C, "Member 'FCAServicesLootTableRow::M_fenced_total' has a wrong offset!");
static_assert(offsetof(FCAServicesLootTableRow, M_pending_total) == 0x000070, "Member 'FCAServicesLootTableRow::M_pending_total' has a wrong offset!");
static_assert(offsetof(FCAServicesLootTableRow, M_loot_reference) == 0x000074, "Member 'FCAServicesLootTableRow::M_loot_reference' has a wrong offset!");
static_assert(offsetof(FCAServicesLootTableRow, M_category) == 0x000090, "Member 'FCAServicesLootTableRow::M_category' has a wrong offset!");
static_assert(offsetof(FCAServicesLootTableRow, M_reward_category) == 0x0000A0, "Member 'FCAServicesLootTableRow::M_reward_category' has a wrong offset!");
static_assert(offsetof(FCAServicesLootTableRow, M_category_loc) == 0x0000B0, "Member 'FCAServicesLootTableRow::M_category_loc' has a wrong offset!");
static_assert(offsetof(FCAServicesLootTableRow, M_theme_pack_multipliers) == 0x0000C8, "Member 'FCAServicesLootTableRow::M_theme_pack_multipliers' has a wrong offset!");
static_assert(offsetof(FCAServicesLootTableRow, M_default_theme_pack_multiplier) == 0x0000D8, "Member 'FCAServicesLootTableRow::M_default_theme_pack_multiplier' has a wrong offset!");
static_assert(offsetof(FCAServicesLootTableRow, M_is_enabled_RDS) == 0x0000DC, "Member 'FCAServicesLootTableRow::M_is_enabled_RDS' has a wrong offset!");

// ScriptStruct keaton.CATaggedWeaponClassTableValueRow
// 0x0010 (0x0018 - 0x0008)
struct FCATaggedWeaponClassTableValueRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           M_tag;                                             // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAWeaponClass                                M_weapon_class;                                    // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCATaggedWeaponClassTableValueRow) == 0x000008, "Wrong alignment on FCATaggedWeaponClassTableValueRow");
static_assert(sizeof(FCATaggedWeaponClassTableValueRow) == 0x000018, "Wrong size on FCATaggedWeaponClassTableValueRow");
static_assert(offsetof(FCATaggedWeaponClassTableValueRow, M_tag) == 0x000008, "Member 'FCATaggedWeaponClassTableValueRow::M_tag' has a wrong offset!");
static_assert(offsetof(FCATaggedWeaponClassTableValueRow, M_weapon_class) == 0x000014, "Member 'FCATaggedWeaponClassTableValueRow::M_weapon_class' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_Sprint
// 0x0018 (0x0020 - 0x0008)
struct FCAExceptionData_Sprint final : public FCAMovementModeExceptionData
{
public:
	struct FCAExceptionData_bool                  M_is_blocked;                                      // 0x0008(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAExceptionData_float                 M_acceleration;                                    // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_max_speed_forwards;                              // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAExceptionData_Sprint) == 0x000008, "Wrong alignment on FCAExceptionData_Sprint");
static_assert(sizeof(FCAExceptionData_Sprint) == 0x000020, "Wrong size on FCAExceptionData_Sprint");
static_assert(offsetof(FCAExceptionData_Sprint, M_is_blocked) == 0x000008, "Member 'FCAExceptionData_Sprint::M_is_blocked' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Sprint, M_acceleration) == 0x00000C, "Member 'FCAExceptionData_Sprint::M_acceleration' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Sprint, M_max_speed_forwards) == 0x000014, "Member 'FCAExceptionData_Sprint::M_max_speed_forwards' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_Traverse
// 0x0080 (0x0090 - 0x0010)
struct FCAMovementData_Traverse final : public FCAMovementModeData
{
public:
	uint8                                         Pad_10[0x2];                                       // 0x0010(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_can_cancel_horizontal_vault;                     // 0x0012(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_allow_traverse_from_falling;                     // 0x0013(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_zero_g_up_height;                            // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_high_traversal;                              // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_low_traversal;                               // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_impact_extra_height;                         // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_short_ascent;                                // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_angle_to_wall;                               // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_max_overhang;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_forward_step;                                // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_foam_overhang;                               // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_landed_leniency_time;                            // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_test_up_step;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_mantle_forwards_distance;                        // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_vault_forwards_distance;                         // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_window_vault_forwards_distance;                  // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_exit_zerog_vault_forwards_distance;              // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_vault_min_drop;                                  // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_horizontal_penguin_jump_distance;            // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_vertical_acceleration;                           // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_rise_time;                                   // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_short_ascent_speed_sprint;                       // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_short_ascent_speed_crouch;                       // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_short_ascent_speed_normal;                       // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_long_ascent_speed;                               // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_converge_time;                               // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_previously_in_air_lerp_time;                     // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_horizontal_acceleration;                         // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_converge_speed_after_high_traversal;             // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_camera_clamp_soft_angle;                         // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_camera_clamp_hard_angle;                         // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_camera_blend_speed;                              // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMovementData_Traverse) == 0x000008, "Wrong alignment on FCAMovementData_Traverse");
static_assert(sizeof(FCAMovementData_Traverse) == 0x000090, "Wrong size on FCAMovementData_Traverse");
static_assert(offsetof(FCAMovementData_Traverse, M_can_cancel_horizontal_vault) == 0x000012, "Member 'FCAMovementData_Traverse::M_can_cancel_horizontal_vault' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_allow_traverse_from_falling) == 0x000013, "Member 'FCAMovementData_Traverse::M_allow_traverse_from_falling' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_max_zero_g_up_height) == 0x000014, "Member 'FCAMovementData_Traverse::M_max_zero_g_up_height' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_max_high_traversal) == 0x000018, "Member 'FCAMovementData_Traverse::M_max_high_traversal' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_max_low_traversal) == 0x00001C, "Member 'FCAMovementData_Traverse::M_max_low_traversal' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_min_impact_extra_height) == 0x000020, "Member 'FCAMovementData_Traverse::M_min_impact_extra_height' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_max_short_ascent) == 0x000024, "Member 'FCAMovementData_Traverse::M_max_short_ascent' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_max_angle_to_wall) == 0x000028, "Member 'FCAMovementData_Traverse::M_max_angle_to_wall' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_max_overhang) == 0x000030, "Member 'FCAMovementData_Traverse::M_max_overhang' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_max_forward_step) == 0x000034, "Member 'FCAMovementData_Traverse::M_max_forward_step' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_max_foam_overhang) == 0x000038, "Member 'FCAMovementData_Traverse::M_max_foam_overhang' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_landed_leniency_time) == 0x00003C, "Member 'FCAMovementData_Traverse::M_landed_leniency_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_test_up_step) == 0x000040, "Member 'FCAMovementData_Traverse::M_test_up_step' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_mantle_forwards_distance) == 0x000044, "Member 'FCAMovementData_Traverse::M_mantle_forwards_distance' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_vault_forwards_distance) == 0x000048, "Member 'FCAMovementData_Traverse::M_vault_forwards_distance' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_window_vault_forwards_distance) == 0x00004C, "Member 'FCAMovementData_Traverse::M_window_vault_forwards_distance' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_exit_zerog_vault_forwards_distance) == 0x000050, "Member 'FCAMovementData_Traverse::M_exit_zerog_vault_forwards_distance' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_vault_min_drop) == 0x000054, "Member 'FCAMovementData_Traverse::M_vault_min_drop' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_max_horizontal_penguin_jump_distance) == 0x000058, "Member 'FCAMovementData_Traverse::M_max_horizontal_penguin_jump_distance' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_vertical_acceleration) == 0x00005C, "Member 'FCAMovementData_Traverse::M_vertical_acceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_max_rise_time) == 0x000060, "Member 'FCAMovementData_Traverse::M_max_rise_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_short_ascent_speed_sprint) == 0x000064, "Member 'FCAMovementData_Traverse::M_short_ascent_speed_sprint' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_short_ascent_speed_crouch) == 0x000068, "Member 'FCAMovementData_Traverse::M_short_ascent_speed_crouch' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_short_ascent_speed_normal) == 0x00006C, "Member 'FCAMovementData_Traverse::M_short_ascent_speed_normal' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_long_ascent_speed) == 0x000070, "Member 'FCAMovementData_Traverse::M_long_ascent_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_max_converge_time) == 0x000074, "Member 'FCAMovementData_Traverse::M_max_converge_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_previously_in_air_lerp_time) == 0x000078, "Member 'FCAMovementData_Traverse::M_previously_in_air_lerp_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_horizontal_acceleration) == 0x00007C, "Member 'FCAMovementData_Traverse::M_horizontal_acceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_converge_speed_after_high_traversal) == 0x000080, "Member 'FCAMovementData_Traverse::M_converge_speed_after_high_traversal' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_camera_clamp_soft_angle) == 0x000084, "Member 'FCAMovementData_Traverse::M_camera_clamp_soft_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_camera_clamp_hard_angle) == 0x000088, "Member 'FCAMovementData_Traverse::M_camera_clamp_hard_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_Traverse, M_camera_blend_speed) == 0x00008C, "Member 'FCAMovementData_Traverse::M_camera_blend_speed' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_Traverse
// 0x0058 (0x0060 - 0x0008)
struct FCAExceptionData_Traverse final : public FCAMovementModeExceptionData
{
public:
	struct FCAExceptionData_bool                  M_is_blocked;                                      // 0x0008(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_bool                  M_abort_if_active;                                 // 0x000A(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_max_high_traversal;                              // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_max_low_traversal;                               // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_max_short_ascent;                                // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_vertical_acceleration;                           // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_short_ascent_speed_sprint;                       // 0x002C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_short_ascent_speed_crouch;                       // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_short_ascent_speed_normal;                       // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_long_ascent_speed;                               // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_horizontal_acceleration;                         // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_converge_speed_after_high_traversal;             // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAExceptionData_Traverse) == 0x000008, "Wrong alignment on FCAExceptionData_Traverse");
static_assert(sizeof(FCAExceptionData_Traverse) == 0x000060, "Wrong size on FCAExceptionData_Traverse");
static_assert(offsetof(FCAExceptionData_Traverse, M_is_blocked) == 0x000008, "Member 'FCAExceptionData_Traverse::M_is_blocked' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Traverse, M_abort_if_active) == 0x00000A, "Member 'FCAExceptionData_Traverse::M_abort_if_active' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Traverse, M_max_high_traversal) == 0x00000C, "Member 'FCAExceptionData_Traverse::M_max_high_traversal' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Traverse, M_max_low_traversal) == 0x000014, "Member 'FCAExceptionData_Traverse::M_max_low_traversal' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Traverse, M_max_short_ascent) == 0x00001C, "Member 'FCAExceptionData_Traverse::M_max_short_ascent' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Traverse, M_vertical_acceleration) == 0x000024, "Member 'FCAExceptionData_Traverse::M_vertical_acceleration' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Traverse, M_short_ascent_speed_sprint) == 0x00002C, "Member 'FCAExceptionData_Traverse::M_short_ascent_speed_sprint' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Traverse, M_short_ascent_speed_crouch) == 0x000034, "Member 'FCAExceptionData_Traverse::M_short_ascent_speed_crouch' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Traverse, M_short_ascent_speed_normal) == 0x00003C, "Member 'FCAExceptionData_Traverse::M_short_ascent_speed_normal' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Traverse, M_long_ascent_speed) == 0x000044, "Member 'FCAExceptionData_Traverse::M_long_ascent_speed' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Traverse, M_horizontal_acceleration) == 0x00004C, "Member 'FCAExceptionData_Traverse::M_horizontal_acceleration' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_Traverse, M_converge_speed_after_high_traversal) == 0x000054, "Member 'FCAExceptionData_Traverse::M_converge_speed_after_high_traversal' has a wrong offset!");

// ScriptStruct keaton.CALerpPair
// 0x0008 (0x0008 - 0x0000)
struct FCALerpPair final
{
public:
	float                                         M_value_at_min;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_value_at_max;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALerpPair) == 0x000004, "Wrong alignment on FCALerpPair");
static_assert(sizeof(FCALerpPair) == 0x000008, "Wrong size on FCALerpPair");
static_assert(offsetof(FCALerpPair, M_value_at_min) == 0x000000, "Member 'FCALerpPair::M_value_at_min' has a wrong offset!");
static_assert(offsetof(FCALerpPair, M_value_at_max) == 0x000004, "Member 'FCALerpPair::M_value_at_max' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_ZeroGGravHook_BoostItem
// 0x000C (0x000C - 0x0000)
struct FCAMovementData_ZeroGGravHook_BoostItem final
{
public:
	float                                         M_acceleration;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_speed;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_range;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMovementData_ZeroGGravHook_BoostItem) == 0x000004, "Wrong alignment on FCAMovementData_ZeroGGravHook_BoostItem");
static_assert(sizeof(FCAMovementData_ZeroGGravHook_BoostItem) == 0x00000C, "Wrong size on FCAMovementData_ZeroGGravHook_BoostItem");
static_assert(offsetof(FCAMovementData_ZeroGGravHook_BoostItem, M_acceleration) == 0x000000, "Member 'FCAMovementData_ZeroGGravHook_BoostItem::M_acceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook_BoostItem, M_speed) == 0x000004, "Member 'FCAMovementData_ZeroGGravHook_BoostItem::M_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook_BoostItem, M_min_range) == 0x000008, "Member 'FCAMovementData_ZeroGGravHook_BoostItem::M_min_range' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_ZeroGGravHook_BoostSet
// 0x0018 (0x0018 - 0x0000)
struct FCAMovementData_ZeroGGravHook_BoostSet final
{
public:
	bool                                          M_speeds_are_absolute;                             // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAMovementData_ZeroGGravHook_BoostItem> M_profile;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMovementData_ZeroGGravHook_BoostSet) == 0x000008, "Wrong alignment on FCAMovementData_ZeroGGravHook_BoostSet");
static_assert(sizeof(FCAMovementData_ZeroGGravHook_BoostSet) == 0x000018, "Wrong size on FCAMovementData_ZeroGGravHook_BoostSet");
static_assert(offsetof(FCAMovementData_ZeroGGravHook_BoostSet, M_speeds_are_absolute) == 0x000000, "Member 'FCAMovementData_ZeroGGravHook_BoostSet::M_speeds_are_absolute' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook_BoostSet, M_profile) == 0x000008, "Member 'FCAMovementData_ZeroGGravHook_BoostSet::M_profile' has a wrong offset!");

// ScriptStruct keaton.CAMinMaxPair
// 0x0008 (0x0008 - 0x0000)
struct FCAMinMaxPair final
{
public:
	float                                         M_min;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMinMaxPair) == 0x000004, "Wrong alignment on FCAMinMaxPair");
static_assert(sizeof(FCAMinMaxPair) == 0x000008, "Wrong size on FCAMinMaxPair");
static_assert(offsetof(FCAMinMaxPair, M_min) == 0x000000, "Member 'FCAMinMaxPair::M_min' has a wrong offset!");
static_assert(offsetof(FCAMinMaxPair, M_max) == 0x000004, "Member 'FCAMinMaxPair::M_max' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_ZeroGGravHook
// 0x0158 (0x0168 - 0x0010)
struct FCAMovementData_ZeroGGravHook final : public FCAMovementModeData
{
public:
	bool                                          M_grav_hook_allowed;                               // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_always_aim_to_cross_hair;                        // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_lateral_aim_uses_aim_pitch;                      // 0x0012(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_allow_aiming_backwards;                          // 0x0013(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_allow_hook_to_attach_to_players;                 // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_allow_out_of_range_course_changes;               // 0x0015(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_max_range;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_reactivate_cooldown;                             // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_anti_spam_timeout;                               // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_reactivate_cooldown_cancels_on_landing;          // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_pressing_magboots_forces_reactivate_cooldown;    // 0x0025(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_reactivate_cooldown_cancels_on_completion;       // 0x0026(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ELocomotionClass, struct FGravHookAnimList> M_anim_data;                                       // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_anim_montage_completes_before_turning;           // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_can_cancel_during_montage;                       // 0x0079(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x2];                                       // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_lost_LOS_time;                                   // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_steering_cooldown;                               // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_jump_cancels;                                    // 0x0084(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_jump_restarts;                                   // 0x0085(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_behind_attachment_face_cancels;                  // 0x0086(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_87[0x1];                                       // 0x0087(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_min_proximity_to_target_player;                  // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_proximity_to_target_marker;                  // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCALerpPair                            M_aim_release_forgiveness;                         // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAMovementData_ZeroGGravHook_BoostSet M_boost;                                           // 0x0098(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_avoidance_lookahead_distance;                    // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_avoidance_steer_distance;                        // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_avoidance_capsule_fattening;                     // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_blend_time;                                      // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_blend_angle;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_blending_to_a_halt_deceleration;                 // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_maintain_LOS_to_anchorpoint_during_blend_in;     // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESteeringStyle                                M_steering_style;                                  // 0x00C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_start_swinging;                                  // 0x00CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB[0x1];                                       // 0x00CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_auto_debounce_timeout;                           // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAMinMaxPair                          M_steering_turn_ranges;                            // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCALerpPair                            M_steering_turn_rate;                              // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAMinMaxPair                          M_turn_distance_range;                             // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCALerpPair                            M_max_turn_angle_allowed;                          // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCALerpPair                            M_max_non_steering_turn_angle_allowed;             // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_initial_steering_ease_time;                      // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_steering_ease_time;                              // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAMinMaxPair                          M_turn_limit_range;                                // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCALerpPair                            M_total_turn_limits;                               // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_allow_steering_speed_boost;                      // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_directional_force_per_second;                    // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_directional_force_min_speed;                     // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_directional_force_max_speed;                     // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_directional_boost_acceleration;                  // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_directional_force_deceleration;                  // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_defer_steering_boost_until_after_release;        // 0x0128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAMinMaxPair                          M_steering_speedboost_range;                       // 0x012C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCALerpPair                            M_steering_speed_boost;                            // 0x0134(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_steering_boost_acceleration;                     // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_steering_boost_deceleration;                     // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_clamp_camera;                                    // 0x0144(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_145[0x3];                                      // 0x0145(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_max_camera_movement_arc_soft;                    // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_camera_movement_arc_hard;                    // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_camera_roll_proportion;                          // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_external_force_turn_amount;                      // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_external_force_min_speed;                        // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_stick_flick_gravhook_lateral_max;                // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_allow_any_flick;                                 // 0x0160(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHUDZeroGAbilityMode                         M_hud_zero_g_ability_mode;                         // 0x0161(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_162[0x6];                                      // 0x0162(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementData_ZeroGGravHook) == 0x000008, "Wrong alignment on FCAMovementData_ZeroGGravHook");
static_assert(sizeof(FCAMovementData_ZeroGGravHook) == 0x000168, "Wrong size on FCAMovementData_ZeroGGravHook");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_grav_hook_allowed) == 0x000010, "Member 'FCAMovementData_ZeroGGravHook::M_grav_hook_allowed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_always_aim_to_cross_hair) == 0x000011, "Member 'FCAMovementData_ZeroGGravHook::M_always_aim_to_cross_hair' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_lateral_aim_uses_aim_pitch) == 0x000012, "Member 'FCAMovementData_ZeroGGravHook::M_lateral_aim_uses_aim_pitch' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_allow_aiming_backwards) == 0x000013, "Member 'FCAMovementData_ZeroGGravHook::M_allow_aiming_backwards' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_allow_hook_to_attach_to_players) == 0x000014, "Member 'FCAMovementData_ZeroGGravHook::M_allow_hook_to_attach_to_players' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_allow_out_of_range_course_changes) == 0x000015, "Member 'FCAMovementData_ZeroGGravHook::M_allow_out_of_range_course_changes' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_max_range) == 0x000018, "Member 'FCAMovementData_ZeroGGravHook::M_max_range' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_reactivate_cooldown) == 0x00001C, "Member 'FCAMovementData_ZeroGGravHook::M_reactivate_cooldown' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_anti_spam_timeout) == 0x000020, "Member 'FCAMovementData_ZeroGGravHook::M_anti_spam_timeout' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_reactivate_cooldown_cancels_on_landing) == 0x000024, "Member 'FCAMovementData_ZeroGGravHook::M_reactivate_cooldown_cancels_on_landing' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_pressing_magboots_forces_reactivate_cooldown) == 0x000025, "Member 'FCAMovementData_ZeroGGravHook::M_pressing_magboots_forces_reactivate_cooldown' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_reactivate_cooldown_cancels_on_completion) == 0x000026, "Member 'FCAMovementData_ZeroGGravHook::M_reactivate_cooldown_cancels_on_completion' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_anim_data) == 0x000028, "Member 'FCAMovementData_ZeroGGravHook::M_anim_data' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_anim_montage_completes_before_turning) == 0x000078, "Member 'FCAMovementData_ZeroGGravHook::M_anim_montage_completes_before_turning' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_can_cancel_during_montage) == 0x000079, "Member 'FCAMovementData_ZeroGGravHook::M_can_cancel_during_montage' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_lost_LOS_time) == 0x00007C, "Member 'FCAMovementData_ZeroGGravHook::M_lost_LOS_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_steering_cooldown) == 0x000080, "Member 'FCAMovementData_ZeroGGravHook::M_steering_cooldown' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_jump_cancels) == 0x000084, "Member 'FCAMovementData_ZeroGGravHook::M_jump_cancels' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_jump_restarts) == 0x000085, "Member 'FCAMovementData_ZeroGGravHook::M_jump_restarts' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_behind_attachment_face_cancels) == 0x000086, "Member 'FCAMovementData_ZeroGGravHook::M_behind_attachment_face_cancels' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_min_proximity_to_target_player) == 0x000088, "Member 'FCAMovementData_ZeroGGravHook::M_min_proximity_to_target_player' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_min_proximity_to_target_marker) == 0x00008C, "Member 'FCAMovementData_ZeroGGravHook::M_min_proximity_to_target_marker' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_aim_release_forgiveness) == 0x000090, "Member 'FCAMovementData_ZeroGGravHook::M_aim_release_forgiveness' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_boost) == 0x000098, "Member 'FCAMovementData_ZeroGGravHook::M_boost' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_avoidance_lookahead_distance) == 0x0000B0, "Member 'FCAMovementData_ZeroGGravHook::M_avoidance_lookahead_distance' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_avoidance_steer_distance) == 0x0000B4, "Member 'FCAMovementData_ZeroGGravHook::M_avoidance_steer_distance' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_avoidance_capsule_fattening) == 0x0000B8, "Member 'FCAMovementData_ZeroGGravHook::M_avoidance_capsule_fattening' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_blend_time) == 0x0000BC, "Member 'FCAMovementData_ZeroGGravHook::M_blend_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_blend_angle) == 0x0000C0, "Member 'FCAMovementData_ZeroGGravHook::M_blend_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_blending_to_a_halt_deceleration) == 0x0000C4, "Member 'FCAMovementData_ZeroGGravHook::M_blending_to_a_halt_deceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_maintain_LOS_to_anchorpoint_during_blend_in) == 0x0000C8, "Member 'FCAMovementData_ZeroGGravHook::M_maintain_LOS_to_anchorpoint_during_blend_in' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_steering_style) == 0x0000C9, "Member 'FCAMovementData_ZeroGGravHook::M_steering_style' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_start_swinging) == 0x0000CA, "Member 'FCAMovementData_ZeroGGravHook::M_start_swinging' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_auto_debounce_timeout) == 0x0000CC, "Member 'FCAMovementData_ZeroGGravHook::M_auto_debounce_timeout' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_steering_turn_ranges) == 0x0000D0, "Member 'FCAMovementData_ZeroGGravHook::M_steering_turn_ranges' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_steering_turn_rate) == 0x0000D8, "Member 'FCAMovementData_ZeroGGravHook::M_steering_turn_rate' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_turn_distance_range) == 0x0000E0, "Member 'FCAMovementData_ZeroGGravHook::M_turn_distance_range' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_max_turn_angle_allowed) == 0x0000E8, "Member 'FCAMovementData_ZeroGGravHook::M_max_turn_angle_allowed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_max_non_steering_turn_angle_allowed) == 0x0000F0, "Member 'FCAMovementData_ZeroGGravHook::M_max_non_steering_turn_angle_allowed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_initial_steering_ease_time) == 0x0000F8, "Member 'FCAMovementData_ZeroGGravHook::M_initial_steering_ease_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_steering_ease_time) == 0x0000FC, "Member 'FCAMovementData_ZeroGGravHook::M_steering_ease_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_turn_limit_range) == 0x000100, "Member 'FCAMovementData_ZeroGGravHook::M_turn_limit_range' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_total_turn_limits) == 0x000108, "Member 'FCAMovementData_ZeroGGravHook::M_total_turn_limits' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_allow_steering_speed_boost) == 0x000110, "Member 'FCAMovementData_ZeroGGravHook::M_allow_steering_speed_boost' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_directional_force_per_second) == 0x000114, "Member 'FCAMovementData_ZeroGGravHook::M_directional_force_per_second' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_directional_force_min_speed) == 0x000118, "Member 'FCAMovementData_ZeroGGravHook::M_directional_force_min_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_directional_force_max_speed) == 0x00011C, "Member 'FCAMovementData_ZeroGGravHook::M_directional_force_max_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_directional_boost_acceleration) == 0x000120, "Member 'FCAMovementData_ZeroGGravHook::M_directional_boost_acceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_directional_force_deceleration) == 0x000124, "Member 'FCAMovementData_ZeroGGravHook::M_directional_force_deceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_defer_steering_boost_until_after_release) == 0x000128, "Member 'FCAMovementData_ZeroGGravHook::M_defer_steering_boost_until_after_release' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_steering_speedboost_range) == 0x00012C, "Member 'FCAMovementData_ZeroGGravHook::M_steering_speedboost_range' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_steering_speed_boost) == 0x000134, "Member 'FCAMovementData_ZeroGGravHook::M_steering_speed_boost' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_steering_boost_acceleration) == 0x00013C, "Member 'FCAMovementData_ZeroGGravHook::M_steering_boost_acceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_steering_boost_deceleration) == 0x000140, "Member 'FCAMovementData_ZeroGGravHook::M_steering_boost_deceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_clamp_camera) == 0x000144, "Member 'FCAMovementData_ZeroGGravHook::M_clamp_camera' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_max_camera_movement_arc_soft) == 0x000148, "Member 'FCAMovementData_ZeroGGravHook::M_max_camera_movement_arc_soft' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_max_camera_movement_arc_hard) == 0x00014C, "Member 'FCAMovementData_ZeroGGravHook::M_max_camera_movement_arc_hard' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_camera_roll_proportion) == 0x000150, "Member 'FCAMovementData_ZeroGGravHook::M_camera_roll_proportion' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_external_force_turn_amount) == 0x000154, "Member 'FCAMovementData_ZeroGGravHook::M_external_force_turn_amount' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_external_force_min_speed) == 0x000158, "Member 'FCAMovementData_ZeroGGravHook::M_external_force_min_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_stick_flick_gravhook_lateral_max) == 0x00015C, "Member 'FCAMovementData_ZeroGGravHook::M_stick_flick_gravhook_lateral_max' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_allow_any_flick) == 0x000160, "Member 'FCAMovementData_ZeroGGravHook::M_allow_any_flick' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGGravHook, M_hud_zero_g_ability_mode) == 0x000161, "Member 'FCAMovementData_ZeroGGravHook::M_hud_zero_g_ability_mode' has a wrong offset!");

// ScriptStruct keaton.CAWeaponFireModeAnimationData
// 0x04C0 (0x04C8 - 0x0008)
struct FCAWeaponFireModeAnimationData final : public FTableRowBase
{
public:
	struct FFeatureKeyItem                        M_feature;                                         // 0x0008(0x0004)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEquipmentAnims                        M_fire_anim;                                       // 0x0010(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         M_looped_fire_anim : 1;                            // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_stop_firing_section_name;                        // 0x0074(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEquipmentAnims                        M_reload_anim;                                     // 0x0080(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FEquipmentAnims                        M_soft_cancel_reload_anim;                         // 0x00E0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FEquipmentAnims                        M_charge_anim;                                     // 0x0140(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FEquipmentAnims                        M_equip_anim;                                      // 0x01A0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FEquipmentAnims                        M_unequip_anim;                                    // 0x0200(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FEquipmentAnims                        M_next_weapon_mode_anim;                           // 0x0260(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FEquipmentAnims                        M_prev_weapon_mode_anim;                           // 0x02C0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ELocomotionClass                              M_locomotion_class;                                // 0x0320(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_ads_as_locomotion_base;                      // 0x0321(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_fire_one_handed_ZG;                              // 0x0322(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_sprint_left_hand_on_weapon;                      // 0x0323(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             M_anim_override_list;                              // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_held_rotation_offset;                            // 0x0330(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_held_offset;                                     // 0x033C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_rumble_hipfire;                                  // 0x0348(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_rumble_ads;                                      // 0x0354(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_kickback_enabled;                                // 0x0360(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_361[0x3];                                      // 0x0361(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_kickback_time;                                   // 0x0364(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            M_kickback_curve;                                  // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_kickback_vector;                                 // 0x0370(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_kickback_cone;                                   // 0x037C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_kickback_length_variation;                       // 0x0380(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_kickback_rotation_range;                         // 0x0384(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               M_kickback_rotation_add;                           // 0x0390(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_kickback_return_speed_limit;                     // 0x039C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_pushback_enabled;                                // 0x03A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A1[0x3];                                      // 0x03A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_pushback_time;                                   // 0x03A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            M_pushback_curve;                                  // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_pushback_vector;                                 // 0x03B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_pushback_cone;                                   // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_pushback_length_variation;                       // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_shake_enabled;                                   // 0x03C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C5[0x3];                                      // 0x03C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_shake_time;                                      // 0x03C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_shake_perlin_A;                                  // 0x03CC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_shake_perlin_B;                                  // 0x03D8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_shake_perlin_C;                                  // 0x03E4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_shake_perlin_D;                                  // 0x03F0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_shake_perlin_E;                                  // 0x03FC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ADS_scale_kickback;                              // 0x0408(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ADS_scale_pushback;                              // 0x040C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ADS_scale_shake;                                 // 0x0410(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_rotation_offset;                                 // 0x0414(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_rotation_offset_ADS;                             // 0x0420(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sway_time_period;                                // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sway_scale;                                      // 0x0430(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sway_clamp;                                      // 0x0434(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sway_time_period_ZG;                             // 0x0438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sway_scale_ZG;                                   // 0x043C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sway_clamp_ZG;                                   // 0x0440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sway_interp;                                     // 0x0444(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sway_offset_scale;                               // 0x0448(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_sway_rotation_scale;                             // 0x044C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_sway_rotation_offset;                            // 0x0458(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sway_sprint_scale;                               // 0x0464(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sway_interp_ADS;                                 // 0x0468(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sway_offset_scale_ADS;                           // 0x046C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_sway_rotation_scale_ADS;                         // 0x0470(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_sway_rotation_offset_ADS;                        // 0x047C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sway_interp_ZG;                                  // 0x0488(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sway_offset_scale_ZG;                            // 0x048C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_sway_rotation_scale_ZG;                          // 0x0490(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_sway_rotation_offset_ZG;                         // 0x049C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sway_interp_ZG_ADS;                              // 0x04A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sway_offset_scale_ZG_ADS;                        // 0x04AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_sway_rotation_scale_ZG_ADS;                      // 0x04B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_sway_rotation_offset_ZG_ADS;                     // 0x04BC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAWeaponFireModeAnimationData) == 0x000008, "Wrong alignment on FCAWeaponFireModeAnimationData");
static_assert(sizeof(FCAWeaponFireModeAnimationData) == 0x0004C8, "Wrong size on FCAWeaponFireModeAnimationData");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_feature) == 0x000008, "Member 'FCAWeaponFireModeAnimationData::M_feature' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_fire_anim) == 0x000010, "Member 'FCAWeaponFireModeAnimationData::M_fire_anim' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_stop_firing_section_name) == 0x000074, "Member 'FCAWeaponFireModeAnimationData::M_stop_firing_section_name' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_reload_anim) == 0x000080, "Member 'FCAWeaponFireModeAnimationData::M_reload_anim' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_soft_cancel_reload_anim) == 0x0000E0, "Member 'FCAWeaponFireModeAnimationData::M_soft_cancel_reload_anim' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_charge_anim) == 0x000140, "Member 'FCAWeaponFireModeAnimationData::M_charge_anim' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_equip_anim) == 0x0001A0, "Member 'FCAWeaponFireModeAnimationData::M_equip_anim' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_unequip_anim) == 0x000200, "Member 'FCAWeaponFireModeAnimationData::M_unequip_anim' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_next_weapon_mode_anim) == 0x000260, "Member 'FCAWeaponFireModeAnimationData::M_next_weapon_mode_anim' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_prev_weapon_mode_anim) == 0x0002C0, "Member 'FCAWeaponFireModeAnimationData::M_prev_weapon_mode_anim' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_locomotion_class) == 0x000320, "Member 'FCAWeaponFireModeAnimationData::M_locomotion_class' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_use_ads_as_locomotion_base) == 0x000321, "Member 'FCAWeaponFireModeAnimationData::M_use_ads_as_locomotion_base' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_fire_one_handed_ZG) == 0x000322, "Member 'FCAWeaponFireModeAnimationData::M_fire_one_handed_ZG' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sprint_left_hand_on_weapon) == 0x000323, "Member 'FCAWeaponFireModeAnimationData::M_sprint_left_hand_on_weapon' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_anim_override_list) == 0x000328, "Member 'FCAWeaponFireModeAnimationData::M_anim_override_list' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_held_rotation_offset) == 0x000330, "Member 'FCAWeaponFireModeAnimationData::M_held_rotation_offset' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_held_offset) == 0x00033C, "Member 'FCAWeaponFireModeAnimationData::M_held_offset' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_rumble_hipfire) == 0x000348, "Member 'FCAWeaponFireModeAnimationData::M_rumble_hipfire' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_rumble_ads) == 0x000354, "Member 'FCAWeaponFireModeAnimationData::M_rumble_ads' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_kickback_enabled) == 0x000360, "Member 'FCAWeaponFireModeAnimationData::M_kickback_enabled' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_kickback_time) == 0x000364, "Member 'FCAWeaponFireModeAnimationData::M_kickback_time' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_kickback_curve) == 0x000368, "Member 'FCAWeaponFireModeAnimationData::M_kickback_curve' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_kickback_vector) == 0x000370, "Member 'FCAWeaponFireModeAnimationData::M_kickback_vector' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_kickback_cone) == 0x00037C, "Member 'FCAWeaponFireModeAnimationData::M_kickback_cone' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_kickback_length_variation) == 0x000380, "Member 'FCAWeaponFireModeAnimationData::M_kickback_length_variation' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_kickback_rotation_range) == 0x000384, "Member 'FCAWeaponFireModeAnimationData::M_kickback_rotation_range' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_kickback_rotation_add) == 0x000390, "Member 'FCAWeaponFireModeAnimationData::M_kickback_rotation_add' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_kickback_return_speed_limit) == 0x00039C, "Member 'FCAWeaponFireModeAnimationData::M_kickback_return_speed_limit' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_pushback_enabled) == 0x0003A0, "Member 'FCAWeaponFireModeAnimationData::M_pushback_enabled' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_pushback_time) == 0x0003A4, "Member 'FCAWeaponFireModeAnimationData::M_pushback_time' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_pushback_curve) == 0x0003A8, "Member 'FCAWeaponFireModeAnimationData::M_pushback_curve' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_pushback_vector) == 0x0003B0, "Member 'FCAWeaponFireModeAnimationData::M_pushback_vector' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_pushback_cone) == 0x0003BC, "Member 'FCAWeaponFireModeAnimationData::M_pushback_cone' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_pushback_length_variation) == 0x0003C0, "Member 'FCAWeaponFireModeAnimationData::M_pushback_length_variation' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_shake_enabled) == 0x0003C4, "Member 'FCAWeaponFireModeAnimationData::M_shake_enabled' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_shake_time) == 0x0003C8, "Member 'FCAWeaponFireModeAnimationData::M_shake_time' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_shake_perlin_A) == 0x0003CC, "Member 'FCAWeaponFireModeAnimationData::M_shake_perlin_A' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_shake_perlin_B) == 0x0003D8, "Member 'FCAWeaponFireModeAnimationData::M_shake_perlin_B' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_shake_perlin_C) == 0x0003E4, "Member 'FCAWeaponFireModeAnimationData::M_shake_perlin_C' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_shake_perlin_D) == 0x0003F0, "Member 'FCAWeaponFireModeAnimationData::M_shake_perlin_D' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_shake_perlin_E) == 0x0003FC, "Member 'FCAWeaponFireModeAnimationData::M_shake_perlin_E' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_ADS_scale_kickback) == 0x000408, "Member 'FCAWeaponFireModeAnimationData::M_ADS_scale_kickback' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_ADS_scale_pushback) == 0x00040C, "Member 'FCAWeaponFireModeAnimationData::M_ADS_scale_pushback' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_ADS_scale_shake) == 0x000410, "Member 'FCAWeaponFireModeAnimationData::M_ADS_scale_shake' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_rotation_offset) == 0x000414, "Member 'FCAWeaponFireModeAnimationData::M_rotation_offset' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_rotation_offset_ADS) == 0x000420, "Member 'FCAWeaponFireModeAnimationData::M_rotation_offset_ADS' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_time_period) == 0x00042C, "Member 'FCAWeaponFireModeAnimationData::M_sway_time_period' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_scale) == 0x000430, "Member 'FCAWeaponFireModeAnimationData::M_sway_scale' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_clamp) == 0x000434, "Member 'FCAWeaponFireModeAnimationData::M_sway_clamp' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_time_period_ZG) == 0x000438, "Member 'FCAWeaponFireModeAnimationData::M_sway_time_period_ZG' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_scale_ZG) == 0x00043C, "Member 'FCAWeaponFireModeAnimationData::M_sway_scale_ZG' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_clamp_ZG) == 0x000440, "Member 'FCAWeaponFireModeAnimationData::M_sway_clamp_ZG' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_interp) == 0x000444, "Member 'FCAWeaponFireModeAnimationData::M_sway_interp' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_offset_scale) == 0x000448, "Member 'FCAWeaponFireModeAnimationData::M_sway_offset_scale' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_rotation_scale) == 0x00044C, "Member 'FCAWeaponFireModeAnimationData::M_sway_rotation_scale' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_rotation_offset) == 0x000458, "Member 'FCAWeaponFireModeAnimationData::M_sway_rotation_offset' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_sprint_scale) == 0x000464, "Member 'FCAWeaponFireModeAnimationData::M_sway_sprint_scale' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_interp_ADS) == 0x000468, "Member 'FCAWeaponFireModeAnimationData::M_sway_interp_ADS' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_offset_scale_ADS) == 0x00046C, "Member 'FCAWeaponFireModeAnimationData::M_sway_offset_scale_ADS' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_rotation_scale_ADS) == 0x000470, "Member 'FCAWeaponFireModeAnimationData::M_sway_rotation_scale_ADS' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_rotation_offset_ADS) == 0x00047C, "Member 'FCAWeaponFireModeAnimationData::M_sway_rotation_offset_ADS' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_interp_ZG) == 0x000488, "Member 'FCAWeaponFireModeAnimationData::M_sway_interp_ZG' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_offset_scale_ZG) == 0x00048C, "Member 'FCAWeaponFireModeAnimationData::M_sway_offset_scale_ZG' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_rotation_scale_ZG) == 0x000490, "Member 'FCAWeaponFireModeAnimationData::M_sway_rotation_scale_ZG' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_rotation_offset_ZG) == 0x00049C, "Member 'FCAWeaponFireModeAnimationData::M_sway_rotation_offset_ZG' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_interp_ZG_ADS) == 0x0004A8, "Member 'FCAWeaponFireModeAnimationData::M_sway_interp_ZG_ADS' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_offset_scale_ZG_ADS) == 0x0004AC, "Member 'FCAWeaponFireModeAnimationData::M_sway_offset_scale_ZG_ADS' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_rotation_scale_ZG_ADS) == 0x0004B0, "Member 'FCAWeaponFireModeAnimationData::M_sway_rotation_scale_ZG_ADS' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAnimationData, M_sway_rotation_offset_ZG_ADS) == 0x0004BC, "Member 'FCAWeaponFireModeAnimationData::M_sway_rotation_offset_ZG_ADS' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_ZeroGGravHook
// 0x0008 (0x0010 - 0x0008)
struct FCAExceptionData_ZeroGGravHook final : public FCAMovementModeExceptionData
{
public:
	struct FCAExceptionData_bool                  M_grav_hook_allowed;                               // 0x0008(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAExceptionData_ZeroGGravHook) == 0x000008, "Wrong alignment on FCAExceptionData_ZeroGGravHook");
static_assert(sizeof(FCAExceptionData_ZeroGGravHook) == 0x000010, "Wrong size on FCAExceptionData_ZeroGGravHook");
static_assert(offsetof(FCAExceptionData_ZeroGGravHook, M_grav_hook_allowed) == 0x000008, "Member 'FCAExceptionData_ZeroGGravHook::M_grav_hook_allowed' has a wrong offset!");

// ScriptStruct keaton.CAScoredTarget
// 0x0020 (0x0020 - 0x0000)
struct FCAScoredTarget final
{
public:
	struct FCATargetInfo                          M_target_info;                                     // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_score;                                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAScoredTarget) == 0x000008, "Wrong alignment on FCAScoredTarget");
static_assert(sizeof(FCAScoredTarget) == 0x000020, "Wrong size on FCAScoredTarget");
static_assert(offsetof(FCAScoredTarget, M_target_info) == 0x000000, "Member 'FCAScoredTarget::M_target_info' has a wrong offset!");
static_assert(offsetof(FCAScoredTarget, M_score) == 0x000018, "Member 'FCAScoredTarget::M_score' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_ZeroGTakeOff
// 0x0018 (0x0020 - 0x0008)
struct FCAExceptionData_ZeroGTakeOff final : public FCAMovementModeExceptionData
{
public:
	struct FCAExceptionData_bool                  M_is_blocked;                                      // 0x0008(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAExceptionData_float                 M_maximum_takeoff_speed;                           // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_takeoff_speed_cap;                               // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAExceptionData_ZeroGTakeOff) == 0x000008, "Wrong alignment on FCAExceptionData_ZeroGTakeOff");
static_assert(sizeof(FCAExceptionData_ZeroGTakeOff) == 0x000020, "Wrong size on FCAExceptionData_ZeroGTakeOff");
static_assert(offsetof(FCAExceptionData_ZeroGTakeOff, M_is_blocked) == 0x000008, "Member 'FCAExceptionData_ZeroGTakeOff::M_is_blocked' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroGTakeOff, M_maximum_takeoff_speed) == 0x00000C, "Member 'FCAExceptionData_ZeroGTakeOff::M_maximum_takeoff_speed' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroGTakeOff, M_takeoff_speed_cap) == 0x000014, "Member 'FCAExceptionData_ZeroGTakeOff::M_takeoff_speed_cap' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_ZeroG
// 0x00C8 (0x00D8 - 0x0010)
struct FCAMovementData_ZeroG final : public FCAMovementModeData
{
public:
	uint8                                         Pad_10[0x4];                                       // 0x0010(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_distance_to_near_wall_to_push;                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_takeoff_acceleration;                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_top_speed_sustain_time;                          // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_target_speed;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_allowed_speed;                               // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_turnrate;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_turnrate;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAMovementData_ZeroGDirectionalForce  M_directional_force;                               // 0x0030(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_flying_acceleration;                             // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_flying_deceleration;                             // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_flying_friction;                                 // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_temporary_braking_flying_speed;                  // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_allow_braking;                                   // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_ignore_pulling_back;                             // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_any_counter_steering_direction_brakes;           // 0x009A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B[0x1];                                       // 0x009B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_flying_braking_deceleration;                     // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_indicator_range_for_instant_attach;          // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_immediate_attach_impact_angle;                   // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_marker_max_distance_check;                       // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_marker_flying_distance_check;                    // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_marker_avoidance_check_size;                     // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_capsule_half_height_flying;                      // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCASubCapsuleData                      M_sub_capsule;                                     // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_speed_cap;                                       // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementData_ZeroG) == 0x000008, "Wrong alignment on FCAMovementData_ZeroG");
static_assert(sizeof(FCAMovementData_ZeroG) == 0x0000D8, "Wrong size on FCAMovementData_ZeroG");
static_assert(offsetof(FCAMovementData_ZeroG, M_distance_to_near_wall_to_push) == 0x000014, "Member 'FCAMovementData_ZeroG::M_distance_to_near_wall_to_push' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_takeoff_acceleration) == 0x000018, "Member 'FCAMovementData_ZeroG::M_takeoff_acceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_top_speed_sustain_time) == 0x00001C, "Member 'FCAMovementData_ZeroG::M_top_speed_sustain_time' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_target_speed) == 0x000020, "Member 'FCAMovementData_ZeroG::M_target_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_max_allowed_speed) == 0x000024, "Member 'FCAMovementData_ZeroG::M_max_allowed_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_max_turnrate) == 0x000028, "Member 'FCAMovementData_ZeroG::M_max_turnrate' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_min_turnrate) == 0x00002C, "Member 'FCAMovementData_ZeroG::M_min_turnrate' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_directional_force) == 0x000030, "Member 'FCAMovementData_ZeroG::M_directional_force' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_flying_acceleration) == 0x000088, "Member 'FCAMovementData_ZeroG::M_flying_acceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_flying_deceleration) == 0x00008C, "Member 'FCAMovementData_ZeroG::M_flying_deceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_flying_friction) == 0x000090, "Member 'FCAMovementData_ZeroG::M_flying_friction' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_temporary_braking_flying_speed) == 0x000094, "Member 'FCAMovementData_ZeroG::M_temporary_braking_flying_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_allow_braking) == 0x000098, "Member 'FCAMovementData_ZeroG::M_allow_braking' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_ignore_pulling_back) == 0x000099, "Member 'FCAMovementData_ZeroG::M_ignore_pulling_back' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_any_counter_steering_direction_brakes) == 0x00009A, "Member 'FCAMovementData_ZeroG::M_any_counter_steering_direction_brakes' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_flying_braking_deceleration) == 0x00009C, "Member 'FCAMovementData_ZeroG::M_flying_braking_deceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_max_indicator_range_for_instant_attach) == 0x0000A0, "Member 'FCAMovementData_ZeroG::M_max_indicator_range_for_instant_attach' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_immediate_attach_impact_angle) == 0x0000A4, "Member 'FCAMovementData_ZeroG::M_immediate_attach_impact_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_marker_max_distance_check) == 0x0000A8, "Member 'FCAMovementData_ZeroG::M_marker_max_distance_check' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_marker_flying_distance_check) == 0x0000AC, "Member 'FCAMovementData_ZeroG::M_marker_flying_distance_check' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_marker_avoidance_check_size) == 0x0000B0, "Member 'FCAMovementData_ZeroG::M_marker_avoidance_check_size' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_capsule_half_height_flying) == 0x0000B4, "Member 'FCAMovementData_ZeroG::M_capsule_half_height_flying' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_sub_capsule) == 0x0000B8, "Member 'FCAMovementData_ZeroG::M_sub_capsule' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroG, M_speed_cap) == 0x0000D0, "Member 'FCAMovementData_ZeroG::M_speed_cap' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_float_MPY_Only
// 0x0008 (0x0008 - 0x0000)
struct FCAExceptionData_float_MPY_Only final
{
public:
	ECAExceptionData_Operator_MPY_Only            M_operator;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_value;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAExceptionData_float_MPY_Only) == 0x000004, "Wrong alignment on FCAExceptionData_float_MPY_Only");
static_assert(sizeof(FCAExceptionData_float_MPY_Only) == 0x000008, "Wrong size on FCAExceptionData_float_MPY_Only");
static_assert(offsetof(FCAExceptionData_float_MPY_Only, M_operator) == 0x000000, "Member 'FCAExceptionData_float_MPY_Only::M_operator' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_float_MPY_Only, M_value) == 0x000004, "Member 'FCAExceptionData_float_MPY_Only::M_value' has a wrong offset!");

// ScriptStruct keaton.CAMovementException_ZGDF_CurveEntry
// 0x000C (0x000C - 0x0000)
struct FCAMovementException_ZGDF_CurveEntry final
{
public:
	float                                         M_angle;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float_MPY_Only        M_modifier;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMovementException_ZGDF_CurveEntry) == 0x000004, "Wrong alignment on FCAMovementException_ZGDF_CurveEntry");
static_assert(sizeof(FCAMovementException_ZGDF_CurveEntry) == 0x00000C, "Wrong size on FCAMovementException_ZGDF_CurveEntry");
static_assert(offsetof(FCAMovementException_ZGDF_CurveEntry, M_angle) == 0x000000, "Member 'FCAMovementException_ZGDF_CurveEntry::M_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementException_ZGDF_CurveEntry, M_modifier) == 0x000004, "Member 'FCAMovementException_ZGDF_CurveEntry::M_modifier' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_ZeroGDirectionalForce
// 0x0068 (0x0068 - 0x0000)
struct FCAExceptionData_ZeroGDirectionalForce final
{
public:
	struct FCAExceptionData_bool                  M_is_blocked;                                      // 0x0000(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAMovementException_ZGDF_CurveEntry> M_speed_mapping;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAMovementException_ZGDF_CurveEntry> M_duration_mapping;                                // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAMovementException_ZGDF_CurveEntry> M_target_turn_mapping;                             // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float_MPY_Only        M_duration_modifier;                               // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_sustain_time;                                    // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_double_press_excluded;                           // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_total_boosts;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_boost_recharge_time;                             // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_boost_recharge_delay;                            // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAExceptionData_ZeroGDirectionalForce) == 0x000008, "Wrong alignment on FCAExceptionData_ZeroGDirectionalForce");
static_assert(sizeof(FCAExceptionData_ZeroGDirectionalForce) == 0x000068, "Wrong size on FCAExceptionData_ZeroGDirectionalForce");
static_assert(offsetof(FCAExceptionData_ZeroGDirectionalForce, M_is_blocked) == 0x000000, "Member 'FCAExceptionData_ZeroGDirectionalForce::M_is_blocked' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroGDirectionalForce, M_speed_mapping) == 0x000008, "Member 'FCAExceptionData_ZeroGDirectionalForce::M_speed_mapping' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroGDirectionalForce, M_duration_mapping) == 0x000018, "Member 'FCAExceptionData_ZeroGDirectionalForce::M_duration_mapping' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroGDirectionalForce, M_target_turn_mapping) == 0x000028, "Member 'FCAExceptionData_ZeroGDirectionalForce::M_target_turn_mapping' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroGDirectionalForce, M_duration_modifier) == 0x000038, "Member 'FCAExceptionData_ZeroGDirectionalForce::M_duration_modifier' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroGDirectionalForce, M_sustain_time) == 0x000040, "Member 'FCAExceptionData_ZeroGDirectionalForce::M_sustain_time' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroGDirectionalForce, M_double_press_excluded) == 0x000048, "Member 'FCAExceptionData_ZeroGDirectionalForce::M_double_press_excluded' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroGDirectionalForce, M_total_boosts) == 0x000050, "Member 'FCAExceptionData_ZeroGDirectionalForce::M_total_boosts' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroGDirectionalForce, M_boost_recharge_time) == 0x000058, "Member 'FCAExceptionData_ZeroGDirectionalForce::M_boost_recharge_time' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroGDirectionalForce, M_boost_recharge_delay) == 0x000060, "Member 'FCAExceptionData_ZeroGDirectionalForce::M_boost_recharge_delay' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_ZeroG
// 0x00B8 (0x00C0 - 0x0008)
struct FCAExceptionData_ZeroG final : public FCAMovementModeExceptionData
{
public:
	struct FCAExceptionData_bool                  M_is_blocked;                                      // 0x0008(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_bool                  M_is_a_braking_exception;                          // 0x000A(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_takeoff_acceleration;                            // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_top_speed_sustain_time;                          // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_target_speed;                                    // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_max_allowed_speed;                               // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_temporary_braking_flying_speed;                  // 0x002C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_max_turnrate;                                    // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_min_turnrate;                                    // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAExceptionData_ZeroGDirectionalForce M_directional_force;                               // 0x0048(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_flying_friction;                                 // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_flying_deceleration;                             // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAExceptionData_ZeroG) == 0x000008, "Wrong alignment on FCAExceptionData_ZeroG");
static_assert(sizeof(FCAExceptionData_ZeroG) == 0x0000C0, "Wrong size on FCAExceptionData_ZeroG");
static_assert(offsetof(FCAExceptionData_ZeroG, M_is_blocked) == 0x000008, "Member 'FCAExceptionData_ZeroG::M_is_blocked' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroG, M_is_a_braking_exception) == 0x00000A, "Member 'FCAExceptionData_ZeroG::M_is_a_braking_exception' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroG, M_takeoff_acceleration) == 0x00000C, "Member 'FCAExceptionData_ZeroG::M_takeoff_acceleration' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroG, M_top_speed_sustain_time) == 0x000014, "Member 'FCAExceptionData_ZeroG::M_top_speed_sustain_time' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroG, M_target_speed) == 0x00001C, "Member 'FCAExceptionData_ZeroG::M_target_speed' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroG, M_max_allowed_speed) == 0x000024, "Member 'FCAExceptionData_ZeroG::M_max_allowed_speed' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroG, M_temporary_braking_flying_speed) == 0x00002C, "Member 'FCAExceptionData_ZeroG::M_temporary_braking_flying_speed' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroG, M_max_turnrate) == 0x000034, "Member 'FCAExceptionData_ZeroG::M_max_turnrate' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroG, M_min_turnrate) == 0x00003C, "Member 'FCAExceptionData_ZeroG::M_min_turnrate' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroG, M_directional_force) == 0x000048, "Member 'FCAExceptionData_ZeroG::M_directional_force' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroG, M_flying_friction) == 0x0000B0, "Member 'FCAExceptionData_ZeroG::M_flying_friction' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroG, M_flying_deceleration) == 0x0000B8, "Member 'FCAExceptionData_ZeroG::M_flying_deceleration' has a wrong offset!");

// ScriptStruct keaton.TeamStateData
// 0x0028 (0x0028 - 0x0000)
struct FTeamStateData final
{
public:
	int32                                         M_num_teams_present;                               // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_teams_in_game;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_teams_exited;                                    // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_teams_extracted;                                 // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_teams_wiped;                                     // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTeamData>                      M_teams;                                           // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FTeamStateData) == 0x000008, "Wrong alignment on FTeamStateData");
static_assert(sizeof(FTeamStateData) == 0x000028, "Wrong size on FTeamStateData");
static_assert(offsetof(FTeamStateData, M_num_teams_present) == 0x000000, "Member 'FTeamStateData::M_num_teams_present' has a wrong offset!");
static_assert(offsetof(FTeamStateData, M_teams_in_game) == 0x000004, "Member 'FTeamStateData::M_teams_in_game' has a wrong offset!");
static_assert(offsetof(FTeamStateData, M_teams_exited) == 0x000008, "Member 'FTeamStateData::M_teams_exited' has a wrong offset!");
static_assert(offsetof(FTeamStateData, M_teams_extracted) == 0x00000C, "Member 'FTeamStateData::M_teams_extracted' has a wrong offset!");
static_assert(offsetof(FTeamStateData, M_teams_wiped) == 0x000010, "Member 'FTeamStateData::M_teams_wiped' has a wrong offset!");
static_assert(offsetof(FTeamStateData, M_teams) == 0x000018, "Member 'FTeamStateData::M_teams' has a wrong offset!");

// ScriptStruct keaton.CAMovementData_ZeroGWallClimbing
// 0x0070 (0x0080 - 0x0010)
struct FCAMovementData_ZeroGWallClimbing final : public FCAMovementModeData
{
public:
	uint8                                         Pad_10[0x4];                                       // 0x0010(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_wall_crawling_no_move_angle;                     // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_wall_crawling_vault_speed;                       // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_speed_wall_crawling;                         // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_breaking_deceleration_wall_crawling;             // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_wall_crawling_right_change_mode_zone;            // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_attached_acceleration;                           // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_stop_movement_friction;                          // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_detach_speed;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_detach_move;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_fall_height;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_hop_distance;                                    // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_auto_fall_down_distance;                         // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_auto_fall_up_distance;                           // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_auto_fall_sideways_distance;                     // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_capsule_half_height_attached;                    // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCASubCapsuleData                      M_sub_capsule_wall;                                // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCASubCapsuleData                      M_sub_capsule_roof;                                // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMovementData_ZeroGWallClimbing) == 0x000008, "Wrong alignment on FCAMovementData_ZeroGWallClimbing");
static_assert(sizeof(FCAMovementData_ZeroGWallClimbing) == 0x000080, "Wrong size on FCAMovementData_ZeroGWallClimbing");
static_assert(offsetof(FCAMovementData_ZeroGWallClimbing, M_wall_crawling_no_move_angle) == 0x000014, "Member 'FCAMovementData_ZeroGWallClimbing::M_wall_crawling_no_move_angle' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGWallClimbing, M_wall_crawling_vault_speed) == 0x000018, "Member 'FCAMovementData_ZeroGWallClimbing::M_wall_crawling_vault_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGWallClimbing, M_max_speed_wall_crawling) == 0x00001C, "Member 'FCAMovementData_ZeroGWallClimbing::M_max_speed_wall_crawling' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGWallClimbing, M_breaking_deceleration_wall_crawling) == 0x000020, "Member 'FCAMovementData_ZeroGWallClimbing::M_breaking_deceleration_wall_crawling' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGWallClimbing, M_wall_crawling_right_change_mode_zone) == 0x000024, "Member 'FCAMovementData_ZeroGWallClimbing::M_wall_crawling_right_change_mode_zone' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGWallClimbing, M_attached_acceleration) == 0x000028, "Member 'FCAMovementData_ZeroGWallClimbing::M_attached_acceleration' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGWallClimbing, M_stop_movement_friction) == 0x00002C, "Member 'FCAMovementData_ZeroGWallClimbing::M_stop_movement_friction' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGWallClimbing, M_detach_speed) == 0x000030, "Member 'FCAMovementData_ZeroGWallClimbing::M_detach_speed' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGWallClimbing, M_detach_move) == 0x000034, "Member 'FCAMovementData_ZeroGWallClimbing::M_detach_move' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGWallClimbing, M_max_fall_height) == 0x000038, "Member 'FCAMovementData_ZeroGWallClimbing::M_max_fall_height' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGWallClimbing, M_hop_distance) == 0x00003C, "Member 'FCAMovementData_ZeroGWallClimbing::M_hop_distance' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGWallClimbing, M_auto_fall_down_distance) == 0x000040, "Member 'FCAMovementData_ZeroGWallClimbing::M_auto_fall_down_distance' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGWallClimbing, M_auto_fall_up_distance) == 0x000044, "Member 'FCAMovementData_ZeroGWallClimbing::M_auto_fall_up_distance' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGWallClimbing, M_auto_fall_sideways_distance) == 0x000048, "Member 'FCAMovementData_ZeroGWallClimbing::M_auto_fall_sideways_distance' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGWallClimbing, M_capsule_half_height_attached) == 0x00004C, "Member 'FCAMovementData_ZeroGWallClimbing::M_capsule_half_height_attached' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGWallClimbing, M_sub_capsule_wall) == 0x000050, "Member 'FCAMovementData_ZeroGWallClimbing::M_sub_capsule_wall' has a wrong offset!");
static_assert(offsetof(FCAMovementData_ZeroGWallClimbing, M_sub_capsule_roof) == 0x000068, "Member 'FCAMovementData_ZeroGWallClimbing::M_sub_capsule_roof' has a wrong offset!");

// ScriptStruct keaton.CATeamGenderData
// 0x0058 (0x0060 - 0x0008)
struct FCATeamGenderData final : public FTableRowBase
{
public:
	TSet<ECAGender>                               GenderSet;                                         // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
	ECAGender                                     Result;                                            // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCATeamGenderData) == 0x000008, "Wrong alignment on FCATeamGenderData");
static_assert(sizeof(FCATeamGenderData) == 0x000060, "Wrong size on FCATeamGenderData");
static_assert(offsetof(FCATeamGenderData, GenderSet) == 0x000008, "Member 'FCATeamGenderData::GenderSet' has a wrong offset!");
static_assert(offsetof(FCATeamGenderData, Result) == 0x000058, "Member 'FCATeamGenderData::Result' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_ZeroGWallClimbing
// 0x0010 (0x0018 - 0x0008)
struct FCAExceptionData_ZeroGWallClimbing final : public FCAMovementModeExceptionData
{
public:
	struct FCAExceptionData_bool                  M_is_blocked;                                      // 0x0008(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAExceptionData_float                 M_max_speed_wall_crawling;                         // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAExceptionData_ZeroGWallClimbing) == 0x000008, "Wrong alignment on FCAExceptionData_ZeroGWallClimbing");
static_assert(sizeof(FCAExceptionData_ZeroGWallClimbing) == 0x000018, "Wrong size on FCAExceptionData_ZeroGWallClimbing");
static_assert(offsetof(FCAExceptionData_ZeroGWallClimbing, M_is_blocked) == 0x000008, "Member 'FCAExceptionData_ZeroGWallClimbing::M_is_blocked' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_ZeroGWallClimbing, M_max_speed_wall_crawling) == 0x00000C, "Member 'FCAExceptionData_ZeroGWallClimbing::M_max_speed_wall_crawling' has a wrong offset!");

// ScriptStruct keaton.CAMovementErrorCorrectionRequests
// 0x0010 (0x0010 - 0x0000)
struct FCAMovementErrorCorrectionRequests final
{
public:
	TArray<struct FCAMovementErrorCorrectionModifier> Modifiers;                                         // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCAMovementErrorCorrectionRequests) == 0x000008, "Wrong alignment on FCAMovementErrorCorrectionRequests");
static_assert(sizeof(FCAMovementErrorCorrectionRequests) == 0x000010, "Wrong size on FCAMovementErrorCorrectionRequests");
static_assert(offsetof(FCAMovementErrorCorrectionRequests, Modifiers) == 0x000000, "Member 'FCAMovementErrorCorrectionRequests::Modifiers' has a wrong offset!");

// ScriptStruct keaton.CAFollowupCharacterOverride
// 0x0008 (0x0008 - 0x0000)
struct FCAFollowupCharacterOverride final
{
public:
	struct FCAAudioSwitchValueType                Speaker;                                           // 0x0000(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioSwitchValueType                Responder;                                         // 0x0004(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFollowupCharacterOverride) == 0x000004, "Wrong alignment on FCAFollowupCharacterOverride");
static_assert(sizeof(FCAFollowupCharacterOverride) == 0x000008, "Wrong size on FCAFollowupCharacterOverride");
static_assert(offsetof(FCAFollowupCharacterOverride, Speaker) == 0x000000, "Member 'FCAFollowupCharacterOverride::Speaker' has a wrong offset!");
static_assert(offsetof(FCAFollowupCharacterOverride, Responder) == 0x000004, "Member 'FCAFollowupCharacterOverride::Responder' has a wrong offset!");

// ScriptStruct keaton.CAFollowup
// 0x0030 (0x0030 - 0x0000)
struct FCAFollowup final
{
public:
	struct FCAGameDatabaseRowHandle               Trigger;                                           // 0x0000(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ECADialogueFollowUpType                       Scope;                                             // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Delay;                                             // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAFollowupCharacterOverride>   ExcludedCharacters;                                // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFollowup) == 0x000008, "Wrong alignment on FCAFollowup");
static_assert(sizeof(FCAFollowup) == 0x000030, "Wrong size on FCAFollowup");
static_assert(offsetof(FCAFollowup, Trigger) == 0x000000, "Member 'FCAFollowup::Trigger' has a wrong offset!");
static_assert(offsetof(FCAFollowup, Scope) == 0x000018, "Member 'FCAFollowup::Scope' has a wrong offset!");
static_assert(offsetof(FCAFollowup, Delay) == 0x00001C, "Member 'FCAFollowup::Delay' has a wrong offset!");
static_assert(offsetof(FCAFollowup, ExcludedCharacters) == 0x000020, "Member 'FCAFollowup::ExcludedCharacters' has a wrong offset!");

// ScriptStruct keaton.CAMovementExceptionsTable
// 0x0020 (0x0028 - 0x0008)
struct FCAMovementExceptionsTable final : public FTableRowBase
{
public:
	struct FGameplayTag                           M_ActivationTag;                                   // 0x0008(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAExceptionData_Priority                     M_priority;                                        // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAGameDatabaseRowHandle>       M_exceptions;                                      // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMovementExceptionsTable) == 0x000008, "Wrong alignment on FCAMovementExceptionsTable");
static_assert(sizeof(FCAMovementExceptionsTable) == 0x000028, "Wrong size on FCAMovementExceptionsTable");
static_assert(offsetof(FCAMovementExceptionsTable, M_ActivationTag) == 0x000008, "Member 'FCAMovementExceptionsTable::M_ActivationTag' has a wrong offset!");
static_assert(offsetof(FCAMovementExceptionsTable, M_priority) == 0x000014, "Member 'FCAMovementExceptionsTable::M_priority' has a wrong offset!");
static_assert(offsetof(FCAMovementExceptionsTable, M_exceptions) == 0x000018, "Member 'FCAMovementExceptionsTable::M_exceptions' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_LerpPair
// 0x0010 (0x0010 - 0x0000)
struct FCAExceptionData_LerpPair final
{
public:
	struct FCAExceptionData_float                 M_value_at_min;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_value_at_max;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAExceptionData_LerpPair) == 0x000004, "Wrong alignment on FCAExceptionData_LerpPair");
static_assert(sizeof(FCAExceptionData_LerpPair) == 0x000010, "Wrong size on FCAExceptionData_LerpPair");
static_assert(offsetof(FCAExceptionData_LerpPair, M_value_at_min) == 0x000000, "Member 'FCAExceptionData_LerpPair::M_value_at_min' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_LerpPair, M_value_at_max) == 0x000008, "Member 'FCAExceptionData_LerpPair::M_value_at_max' has a wrong offset!");

// ScriptStruct keaton.CAExceptionData_MinMaxPair
// 0x0010 (0x0010 - 0x0000)
struct FCAExceptionData_MinMaxPair final
{
public:
	struct FCAExceptionData_float                 M_min;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAExceptionData_float                 M_max;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAExceptionData_MinMaxPair) == 0x000004, "Wrong alignment on FCAExceptionData_MinMaxPair");
static_assert(sizeof(FCAExceptionData_MinMaxPair) == 0x000010, "Wrong size on FCAExceptionData_MinMaxPair");
static_assert(offsetof(FCAExceptionData_MinMaxPair, M_min) == 0x000000, "Member 'FCAExceptionData_MinMaxPair::M_min' has a wrong offset!");
static_assert(offsetof(FCAExceptionData_MinMaxPair, M_max) == 0x000008, "Member 'FCAExceptionData_MinMaxPair::M_max' has a wrong offset!");

// ScriptStruct keaton.CACharacterMovementModeDataSet
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FCACharacterMovementModeDataSet final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCACharacterMovementModeDataSet) == 0x000008, "Wrong alignment on FCACharacterMovementModeDataSet");
static_assert(sizeof(FCACharacterMovementModeDataSet) == 0x000018, "Wrong size on FCACharacterMovementModeDataSet");

// ScriptStruct keaton.CADialogueVariableDT
// 0x0010 (0x0018 - 0x0008)
struct FCADialogueVariableDT final : public FTableRowBase
{
public:
	class FName                                   VariableName;                                      // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECADialogueVariableType                       Type;                                              // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECADialogueVariableScope                      Scope;                                             // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADialogueVariableDT) == 0x000008, "Wrong alignment on FCADialogueVariableDT");
static_assert(sizeof(FCADialogueVariableDT) == 0x000018, "Wrong size on FCADialogueVariableDT");
static_assert(offsetof(FCADialogueVariableDT, VariableName) == 0x000008, "Member 'FCADialogueVariableDT::VariableName' has a wrong offset!");
static_assert(offsetof(FCADialogueVariableDT, Type) == 0x000014, "Member 'FCADialogueVariableDT::Type' has a wrong offset!");
static_assert(offsetof(FCADialogueVariableDT, Scope) == 0x000015, "Member 'FCADialogueVariableDT::Scope' has a wrong offset!");

// ScriptStruct keaton.CACharacterMovementModeExceptionData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FCACharacterMovementModeExceptionData final
{
public:
	int8                                          M_exception_table_index;                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCACharacterMovementModeExceptionData) == 0x000008, "Wrong alignment on FCACharacterMovementModeExceptionData");
static_assert(sizeof(FCACharacterMovementModeExceptionData) == 0x000010, "Wrong size on FCACharacterMovementModeExceptionData");
static_assert(offsetof(FCACharacterMovementModeExceptionData, M_exception_table_index) == 0x000000, "Member 'FCACharacterMovementModeExceptionData::M_exception_table_index' has a wrong offset!");

// ScriptStruct keaton.CAMovementStateMachineReplicatedData
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FCAMovementStateMachineReplicatedData final
{
public:
	uint16                                        M_index;                                           // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6E];                                       // 0x0002(0x006E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovementStateMachineReplicatedData) == 0x000008, "Wrong alignment on FCAMovementStateMachineReplicatedData");
static_assert(sizeof(FCAMovementStateMachineReplicatedData) == 0x000070, "Wrong size on FCAMovementStateMachineReplicatedData");
static_assert(offsetof(FCAMovementStateMachineReplicatedData, M_index) == 0x000000, "Member 'FCAMovementStateMachineReplicatedData::M_index' has a wrong offset!");

// ScriptStruct keaton.CAMovingActor
// 0x0020 (0x0020 - 0x0000)
struct FCAMovingActor final
{
public:
	class AActor*                                 M_moving_actor;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMovingActor) == 0x000008, "Wrong alignment on FCAMovingActor");
static_assert(sizeof(FCAMovingActor) == 0x000020, "Wrong size on FCAMovingActor");
static_assert(offsetof(FCAMovingActor, M_moving_actor) == 0x000000, "Member 'FCAMovingActor::M_moving_actor' has a wrong offset!");

// ScriptStruct keaton.CANavLinkUserData
// 0x0010 (0x0010 - 0x0000)
struct FCANavLinkUserData final
{
public:
	class AActor*                                 User_actor;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANavLinkUserData) == 0x000008, "Wrong alignment on FCANavLinkUserData");
static_assert(sizeof(FCANavLinkUserData) == 0x000010, "Wrong size on FCANavLinkUserData");
static_assert(offsetof(FCANavLinkUserData, User_actor) == 0x000000, "Member 'FCANavLinkUserData::User_actor' has a wrong offset!");

// ScriptStruct keaton.CASliderOptionMapping
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FCASliderOptionMapping final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCASliderOptionMapping) == 0x000008, "Wrong alignment on FCASliderOptionMapping");
static_assert(sizeof(FCASliderOptionMapping) == 0x000018, "Wrong size on FCASliderOptionMapping");

// ScriptStruct keaton.CANetworkedFXArray
// 0x0010 (0x0118 - 0x0108)
struct FCANetworkedFXArray final : public FFastArraySerializer
{
public:
	TArray<struct FCACharacterInstantHitInfo>     Items;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANetworkedFXArray) == 0x000008, "Wrong alignment on FCANetworkedFXArray");
static_assert(sizeof(FCANetworkedFXArray) == 0x000118, "Wrong size on FCANetworkedFXArray");
static_assert(offsetof(FCANetworkedFXArray, Items) == 0x000108, "Member 'FCANetworkedFXArray::Items' has a wrong offset!");

// ScriptStruct keaton.NetworkedDownedHit
// 0x0050 (0x0050 - 0x0000)
struct FNetworkedDownedHit final
{
public:
	struct FVector_NetQuantize                    M_victim_location;                                 // 0x0000(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    M_victim_velocity;                                 // 0x000C(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_victim_is_in_zero_g;                             // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_victim_is_using_magboots;                        // 0x0019(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_victim_yaw;                                      // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    M_hit_location;                                    // 0x0020(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_hit_direction;                                   // 0x002C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_is_valid;                                        // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBodyPart                                     M_body_part;                                       // 0x0039(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ACAEquipmentBase*                       M_source_equipment;                                // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAWeaponClass                                M_weapon_class;                                    // 0x0048(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetworkedDownedHit) == 0x000008, "Wrong alignment on FNetworkedDownedHit");
static_assert(sizeof(FNetworkedDownedHit) == 0x000050, "Wrong size on FNetworkedDownedHit");
static_assert(offsetof(FNetworkedDownedHit, M_victim_location) == 0x000000, "Member 'FNetworkedDownedHit::M_victim_location' has a wrong offset!");
static_assert(offsetof(FNetworkedDownedHit, M_victim_velocity) == 0x00000C, "Member 'FNetworkedDownedHit::M_victim_velocity' has a wrong offset!");
static_assert(offsetof(FNetworkedDownedHit, M_victim_is_in_zero_g) == 0x000018, "Member 'FNetworkedDownedHit::M_victim_is_in_zero_g' has a wrong offset!");
static_assert(offsetof(FNetworkedDownedHit, M_victim_is_using_magboots) == 0x000019, "Member 'FNetworkedDownedHit::M_victim_is_using_magboots' has a wrong offset!");
static_assert(offsetof(FNetworkedDownedHit, M_victim_yaw) == 0x00001C, "Member 'FNetworkedDownedHit::M_victim_yaw' has a wrong offset!");
static_assert(offsetof(FNetworkedDownedHit, M_hit_location) == 0x000020, "Member 'FNetworkedDownedHit::M_hit_location' has a wrong offset!");
static_assert(offsetof(FNetworkedDownedHit, M_hit_direction) == 0x00002C, "Member 'FNetworkedDownedHit::M_hit_direction' has a wrong offset!");
static_assert(offsetof(FNetworkedDownedHit, M_is_valid) == 0x000038, "Member 'FNetworkedDownedHit::M_is_valid' has a wrong offset!");
static_assert(offsetof(FNetworkedDownedHit, M_body_part) == 0x000039, "Member 'FNetworkedDownedHit::M_body_part' has a wrong offset!");
static_assert(offsetof(FNetworkedDownedHit, M_source_equipment) == 0x000040, "Member 'FNetworkedDownedHit::M_source_equipment' has a wrong offset!");
static_assert(offsetof(FNetworkedDownedHit, M_weapon_class) == 0x000048, "Member 'FNetworkedDownedHit::M_weapon_class' has a wrong offset!");

// ScriptStruct keaton.CACurrencyRewardData
// 0x0040 (0x0040 - 0x0000)
struct FCACurrencyRewardData final
{
public:
	struct FCAText                                M_currency_reward_name;                            // 0x0000(0x0030)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         M_currency_reward_amount;                          // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_currency_service_key;                            // 0x0034(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACurrencyRewardData) == 0x000008, "Wrong alignment on FCACurrencyRewardData");
static_assert(sizeof(FCACurrencyRewardData) == 0x000040, "Wrong size on FCACurrencyRewardData");
static_assert(offsetof(FCACurrencyRewardData, M_currency_reward_name) == 0x000000, "Member 'FCACurrencyRewardData::M_currency_reward_name' has a wrong offset!");
static_assert(offsetof(FCACurrencyRewardData, M_currency_reward_amount) == 0x000030, "Member 'FCACurrencyRewardData::M_currency_reward_amount' has a wrong offset!");
static_assert(offsetof(FCACurrencyRewardData, M_currency_service_key) == 0x000034, "Member 'FCACurrencyRewardData::M_currency_service_key' has a wrong offset!");

// ScriptStruct keaton.CANotificationQueueItem
// 0x0248 (0x0248 - 0x0000)
struct FCANotificationQueueItem final
{
public:
	uint8                                         Pad_0[0x238];                                      // 0x0000(0x0238)(Fixing Size After Last Property [ Dumper-7 ])
	class UCARequestNotificationAsyncAction*      M_current_async_action;                            // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCANotificationQueue*                   M_client;                                          // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCANotificationQueueItem) == 0x000008, "Wrong alignment on FCANotificationQueueItem");
static_assert(sizeof(FCANotificationQueueItem) == 0x000248, "Wrong size on FCANotificationQueueItem");
static_assert(offsetof(FCANotificationQueueItem, M_current_async_action) == 0x000238, "Member 'FCANotificationQueueItem::M_current_async_action' has a wrong offset!");
static_assert(offsetof(FCANotificationQueueItem, M_client) == 0x000240, "Member 'FCANotificationQueueItem::M_client' has a wrong offset!");

// ScriptStruct keaton.CANPCAttackRangeData
// 0x0008 (0x0010 - 0x0008)
struct FCANPCAttackRangeData final : public FTableRowBase
{
public:
	float                                         MaxRange;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCAttackRangeData) == 0x000008, "Wrong alignment on FCANPCAttackRangeData");
static_assert(sizeof(FCANPCAttackRangeData) == 0x000010, "Wrong size on FCANPCAttackRangeData");
static_assert(offsetof(FCANPCAttackRangeData, MaxRange) == 0x000008, "Member 'FCANPCAttackRangeData::MaxRange' has a wrong offset!");

// ScriptStruct keaton.CANPCAwarenessUIData
// 0x0008 (0x0008 - 0x0000)
struct FCANPCAwarenessUIData final
{
public:
	ECANPCAwarenessUIState                        M_state;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_progress;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANPCAwarenessUIData) == 0x000004, "Wrong alignment on FCANPCAwarenessUIData");
static_assert(sizeof(FCANPCAwarenessUIData) == 0x000008, "Wrong size on FCANPCAwarenessUIData");
static_assert(offsetof(FCANPCAwarenessUIData, M_state) == 0x000000, "Member 'FCANPCAwarenessUIData::M_state' has a wrong offset!");
static_assert(offsetof(FCANPCAwarenessUIData, M_progress) == 0x000004, "Member 'FCANPCAwarenessUIData::M_progress' has a wrong offset!");

// ScriptStruct keaton.CANPCMotivationData
// 0x0010 (0x0010 - 0x0000)
struct FCANPCMotivationData final
{
public:
	struct FGameplayTag                           M_motivation_tag;                                  // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_motivation_value;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANPCMotivationData) == 0x000004, "Wrong alignment on FCANPCMotivationData");
static_assert(sizeof(FCANPCMotivationData) == 0x000010, "Wrong size on FCANPCMotivationData");
static_assert(offsetof(FCANPCMotivationData, M_motivation_tag) == 0x000000, "Member 'FCANPCMotivationData::M_motivation_tag' has a wrong offset!");
static_assert(offsetof(FCANPCMotivationData, M_motivation_value) == 0x00000C, "Member 'FCANPCMotivationData::M_motivation_value' has a wrong offset!");

// ScriptStruct keaton.CARotationManagerSetup
// 0x0008 (0x0008 - 0x0000)
struct FCARotationManagerSetup final
{
public:
	float                                         M_rotation_speed;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_angle_before_initiating_capsule_turn;        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARotationManagerSetup) == 0x000004, "Wrong alignment on FCARotationManagerSetup");
static_assert(sizeof(FCARotationManagerSetup) == 0x000008, "Wrong size on FCARotationManagerSetup");
static_assert(offsetof(FCARotationManagerSetup, M_rotation_speed) == 0x000000, "Member 'FCARotationManagerSetup::M_rotation_speed' has a wrong offset!");
static_assert(offsetof(FCARotationManagerSetup, M_max_angle_before_initiating_capsule_turn) == 0x000004, "Member 'FCARotationManagerSetup::M_max_angle_before_initiating_capsule_turn' has a wrong offset!");

// ScriptStruct keaton.CANPCDroneMovementData
// 0x0048 (0x0048 - 0x0000)
struct FCANPCDroneMovementData final
{
public:
	struct FVector                                M_input_noise_ampl;                                // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_input_noise_freq;                                // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_input_noise_freq_variance;                       // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_input_scale;                                     // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_input_smoothing;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_cannot_stop_immediately;                         // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_input_to_target;                                 // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_input_to_target_extrapolation;                   // 0x003C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANPCDroneMovementData) == 0x000004, "Wrong alignment on FCANPCDroneMovementData");
static_assert(sizeof(FCANPCDroneMovementData) == 0x000048, "Wrong size on FCANPCDroneMovementData");
static_assert(offsetof(FCANPCDroneMovementData, M_input_noise_ampl) == 0x000000, "Member 'FCANPCDroneMovementData::M_input_noise_ampl' has a wrong offset!");
static_assert(offsetof(FCANPCDroneMovementData, M_input_noise_freq) == 0x00000C, "Member 'FCANPCDroneMovementData::M_input_noise_freq' has a wrong offset!");
static_assert(offsetof(FCANPCDroneMovementData, M_input_noise_freq_variance) == 0x000018, "Member 'FCANPCDroneMovementData::M_input_noise_freq_variance' has a wrong offset!");
static_assert(offsetof(FCANPCDroneMovementData, M_input_scale) == 0x00001C, "Member 'FCANPCDroneMovementData::M_input_scale' has a wrong offset!");
static_assert(offsetof(FCANPCDroneMovementData, M_input_smoothing) == 0x000028, "Member 'FCANPCDroneMovementData::M_input_smoothing' has a wrong offset!");
static_assert(offsetof(FCANPCDroneMovementData, M_cannot_stop_immediately) == 0x00002C, "Member 'FCANPCDroneMovementData::M_cannot_stop_immediately' has a wrong offset!");
static_assert(offsetof(FCANPCDroneMovementData, M_input_to_target) == 0x000030, "Member 'FCANPCDroneMovementData::M_input_to_target' has a wrong offset!");
static_assert(offsetof(FCANPCDroneMovementData, M_input_to_target_extrapolation) == 0x00003C, "Member 'FCANPCDroneMovementData::M_input_to_target_extrapolation' has a wrong offset!");

// ScriptStruct keaton.CAFastTravelParameters
// 0x0018 (0x0018 - 0x0000)
struct FCAFastTravelParameters final
{
public:
	ECAFastTravelMode                             M_fast_travel_mode;                                // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_start_distance;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_stop_distance;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_stop_outside_entrance_to_destinations_security_area; // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_stop_when_players_encountered;                   // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_min_travel_distance;                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_teleportation_duration;                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFastTravelParameters) == 0x000004, "Wrong alignment on FCAFastTravelParameters");
static_assert(sizeof(FCAFastTravelParameters) == 0x000018, "Wrong size on FCAFastTravelParameters");
static_assert(offsetof(FCAFastTravelParameters, M_fast_travel_mode) == 0x000000, "Member 'FCAFastTravelParameters::M_fast_travel_mode' has a wrong offset!");
static_assert(offsetof(FCAFastTravelParameters, M_start_distance) == 0x000004, "Member 'FCAFastTravelParameters::M_start_distance' has a wrong offset!");
static_assert(offsetof(FCAFastTravelParameters, M_stop_distance) == 0x000008, "Member 'FCAFastTravelParameters::M_stop_distance' has a wrong offset!");
static_assert(offsetof(FCAFastTravelParameters, M_stop_outside_entrance_to_destinations_security_area) == 0x00000C, "Member 'FCAFastTravelParameters::M_stop_outside_entrance_to_destinations_security_area' has a wrong offset!");
static_assert(offsetof(FCAFastTravelParameters, M_stop_when_players_encountered) == 0x00000D, "Member 'FCAFastTravelParameters::M_stop_when_players_encountered' has a wrong offset!");
static_assert(offsetof(FCAFastTravelParameters, M_min_travel_distance) == 0x000010, "Member 'FCAFastTravelParameters::M_min_travel_distance' has a wrong offset!");
static_assert(offsetof(FCAFastTravelParameters, M_teleportation_duration) == 0x000014, "Member 'FCAFastTravelParameters::M_teleportation_duration' has a wrong offset!");

// ScriptStruct keaton.CANPCOnDamagedData
// 0x0008 (0x0008 - 0x0000)
struct FCANPCOnDamagedData final
{
public:
	float                                         M_burst_damage_interval;                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_burst_damage_threshold;                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANPCOnDamagedData) == 0x000004, "Wrong alignment on FCANPCOnDamagedData");
static_assert(sizeof(FCANPCOnDamagedData) == 0x000008, "Wrong size on FCANPCOnDamagedData");
static_assert(offsetof(FCANPCOnDamagedData, M_burst_damage_interval) == 0x000000, "Member 'FCANPCOnDamagedData::M_burst_damage_interval' has a wrong offset!");
static_assert(offsetof(FCANPCOnDamagedData, M_burst_damage_threshold) == 0x000004, "Member 'FCANPCOnDamagedData::M_burst_damage_threshold' has a wrong offset!");

// ScriptStruct keaton.CANPCCriticalHitHealthPool
// 0x0038 (0x0038 - 0x0000)
struct FCANPCCriticalHitHealthPool final
{
public:
	struct FGameplayTag                           M_pool_name;                                       // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_health;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    M_on_zero_health_gameplay_effects;                 // 0x0010(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_on_zero_health_gameplay_event;                   // 0x0020(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECriticalHitDamageTransfer                    M_damage_transfer;                                 // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_blinking_effect_duration;                        // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCCriticalHitHealthPool) == 0x000008, "Wrong alignment on FCANPCCriticalHitHealthPool");
static_assert(sizeof(FCANPCCriticalHitHealthPool) == 0x000038, "Wrong size on FCANPCCriticalHitHealthPool");
static_assert(offsetof(FCANPCCriticalHitHealthPool, M_pool_name) == 0x000000, "Member 'FCANPCCriticalHitHealthPool::M_pool_name' has a wrong offset!");
static_assert(offsetof(FCANPCCriticalHitHealthPool, M_health) == 0x00000C, "Member 'FCANPCCriticalHitHealthPool::M_health' has a wrong offset!");
static_assert(offsetof(FCANPCCriticalHitHealthPool, M_on_zero_health_gameplay_effects) == 0x000010, "Member 'FCANPCCriticalHitHealthPool::M_on_zero_health_gameplay_effects' has a wrong offset!");
static_assert(offsetof(FCANPCCriticalHitHealthPool, M_on_zero_health_gameplay_event) == 0x000020, "Member 'FCANPCCriticalHitHealthPool::M_on_zero_health_gameplay_event' has a wrong offset!");
static_assert(offsetof(FCANPCCriticalHitHealthPool, M_damage_transfer) == 0x00002C, "Member 'FCANPCCriticalHitHealthPool::M_damage_transfer' has a wrong offset!");
static_assert(offsetof(FCANPCCriticalHitHealthPool, M_blinking_effect_duration) == 0x000030, "Member 'FCANPCCriticalHitHealthPool::M_blinking_effect_duration' has a wrong offset!");

// ScriptStruct keaton.CANPCZeroGData
// 0x0050 (0x0050 - 0x0000)
struct FCANPCZeroGData final
{
public:
	ECAZeroGReaction                              M_zero_g_reaction;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_zero_g_float_time;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_float_time_random_deviation;              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_magboots_attract_to_ground_gravity_scale;        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_on_hit_direction_impact_multiplier;       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_initial_upward_velocity_min;              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_initial_upward_velocity_max;              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_initial_forward_velocity_min;             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_initial_forward_velocity_max;             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_initial_sideward_velocity_min;            // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_initial_sideward_velocity_max;            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_collision_slow_percentage;                // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_angular_velocity_max;                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_linear_velocity_max;                      // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_bullet_angular_impact;                    // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_initial_angular_velocity_fwd;             // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_initial_angular_velocity_random;          // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_angular_slowdown_floating;                // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_angular_slowdown_falling;                 // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_time_between_zero_g_floating;                // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANPCZeroGData) == 0x000004, "Wrong alignment on FCANPCZeroGData");
static_assert(sizeof(FCANPCZeroGData) == 0x000050, "Wrong size on FCANPCZeroGData");
static_assert(offsetof(FCANPCZeroGData, M_zero_g_reaction) == 0x000000, "Member 'FCANPCZeroGData::M_zero_g_reaction' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_zero_g_float_time) == 0x000004, "Member 'FCANPCZeroGData::M_zero_g_float_time' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_zero_g_float_time_random_deviation) == 0x000008, "Member 'FCANPCZeroGData::M_zero_g_float_time_random_deviation' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_magboots_attract_to_ground_gravity_scale) == 0x00000C, "Member 'FCANPCZeroGData::M_magboots_attract_to_ground_gravity_scale' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_zero_g_on_hit_direction_impact_multiplier) == 0x000010, "Member 'FCANPCZeroGData::M_zero_g_on_hit_direction_impact_multiplier' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_zero_g_initial_upward_velocity_min) == 0x000014, "Member 'FCANPCZeroGData::M_zero_g_initial_upward_velocity_min' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_zero_g_initial_upward_velocity_max) == 0x000018, "Member 'FCANPCZeroGData::M_zero_g_initial_upward_velocity_max' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_zero_g_initial_forward_velocity_min) == 0x00001C, "Member 'FCANPCZeroGData::M_zero_g_initial_forward_velocity_min' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_zero_g_initial_forward_velocity_max) == 0x000020, "Member 'FCANPCZeroGData::M_zero_g_initial_forward_velocity_max' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_zero_g_initial_sideward_velocity_min) == 0x000024, "Member 'FCANPCZeroGData::M_zero_g_initial_sideward_velocity_min' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_zero_g_initial_sideward_velocity_max) == 0x000028, "Member 'FCANPCZeroGData::M_zero_g_initial_sideward_velocity_max' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_zero_g_collision_slow_percentage) == 0x00002C, "Member 'FCANPCZeroGData::M_zero_g_collision_slow_percentage' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_zero_g_angular_velocity_max) == 0x000030, "Member 'FCANPCZeroGData::M_zero_g_angular_velocity_max' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_zero_g_linear_velocity_max) == 0x000034, "Member 'FCANPCZeroGData::M_zero_g_linear_velocity_max' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_zero_g_bullet_angular_impact) == 0x000038, "Member 'FCANPCZeroGData::M_zero_g_bullet_angular_impact' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_zero_g_initial_angular_velocity_fwd) == 0x00003C, "Member 'FCANPCZeroGData::M_zero_g_initial_angular_velocity_fwd' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_zero_g_initial_angular_velocity_random) == 0x000040, "Member 'FCANPCZeroGData::M_zero_g_initial_angular_velocity_random' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_zero_g_angular_slowdown_floating) == 0x000044, "Member 'FCANPCZeroGData::M_zero_g_angular_slowdown_floating' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_zero_g_angular_slowdown_falling) == 0x000048, "Member 'FCANPCZeroGData::M_zero_g_angular_slowdown_falling' has a wrong offset!");
static_assert(offsetof(FCANPCZeroGData, M_min_time_between_zero_g_floating) == 0x00004C, "Member 'FCANPCZeroGData::M_min_time_between_zero_g_floating' has a wrong offset!");

// ScriptStruct keaton.CANPCCharacterData
// 0x0678 (0x08A0 - 0x0228)
struct FCANPCCharacterData final : public FCACharacterData
{
public:
	TSoftObjectPtr<class UBlackboardData>         M_blackboard_data;                                 // 0x0228(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBehaviorTree>           M_behavior_tree_asset;                             // 0x0258(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_pursue_outside_mission_area;                     // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCANPCMotivationData>           M_npc_motivations;                                 // 0x0290(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              M_sense_set_data_table_DNT;                        // 0x02A0(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              M_view_cone_data_table_DNT;                        // 0x02D0(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_enemy_sighted_alert_radius;                      // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_virtual_vision_duration;                         // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_start_combat_delay_base;                         // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_start_combat_delay_random_deviation;             // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_time_to_forget_target;                           // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECARangedAttackWeaponType                     M_best_weapon_vs_target_objects;                   // 0x0314(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_315[0x3];                                      // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_current_target_sticky_duration;                  // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_current_target_sticky_if_charging_weapon;        // 0x031C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_current_target_sticky_if_firing_weapon;          // 0x031D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_current_target_sticky_if_firing_secondary_weapon; // 0x031E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_current_target_sticky_if_charging_secondary_weapon; // 0x031F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCATargetScoreRuleData>  M_target_rules_table_DNT;                          // 0x0320(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCANPCTacticalMovementParams> M_tactical_movement_params;                        // 0x0350(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_max_idle_behaviour_radius;                       // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_minimum_target_distance_range;                   // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_maximum_target_distance_range;                   // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_melee_attack_range;                              // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_melee_attack_angle_range;                        // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_aoe_special_attack_trigger_range;                // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_follow_radius_inner;                             // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_follow_radius_outer;                             // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_follow_at_max_behave_radius_if_attacking;        // 0x03A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A1[0x3];                                      // 0x03A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_relocate_attack_range;                           // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_relocate_attack_cooldown;                        // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_relocate_attack_duration;                        // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_relocate_attack_damage_taken_clears_cooldown;    // 0x03B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B1[0x3];                                      // 0x03B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAAimManagerSetup                     M_aim_manager_setup;                               // 0x03B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCARotationManagerSetup                M_rotation_manager_setup;                          // 0x03BC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAAttackManagerSetup                  M_attack_manager_setup;                            // 0x03C8(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAAttackManagerSetup                  M_secondary_attack_manager_setup;                  // 0x0478(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_can_get_staggered;                               // 0x0528(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_529[0x3];                                      // 0x0529(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_stagger_threshold;                               // 0x052C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_stagger_pain_decrease_per_second;                // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_stagger_cooldown;                                // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCANPCGrenadeAbilityData               M_grenade_ability_data;                            // 0x0538(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_emp_ability_cooldown;                            // 0x0580(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_laser_ability_cooldown;                          // 0x0584(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_combat_jump_ability_cooldown;                    // 0x0588(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_evade_ability_cooldown;                          // 0x058C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_special_abilities_initial_cooldown;              // 0x0590(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_special_abilities_initial_cooldown_variance;     // 0x0594(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_idle_behaviour_cooldown;                         // 0x0598(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_rvo_avoidance;                               // 0x059C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59D[0x3];                                      // 0x059D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_avoidance_consideration_radius;                  // 0x05A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_rvo_avoidance_weight;                            // 0x05A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_crowd_following_avoidance;                   // 0x05A8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_exit_magboots_interrupts_abilities;              // 0x05A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5AA[0x2];                                      // 0x05AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCANPCDroneMovementData                M_drone_movement_data;                             // 0x05AC(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_use_fast_travel;                                 // 0x05F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F5[0x3];                                      // 0x05F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAFastTravelParameters                M_fast_travel_parameters;                          // 0x05F8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_stop_movement_on_abort_move;                     // 0x0610(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAAllyTargetRule                             M_ally_target_rule;                                // 0x0611(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_612[0x2];                                      // 0x0612(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_ally_target_identifier_tag;                      // 0x0614(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_target_lock_duration;                            // 0x0620(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_suspicious_warning_duration;                     // 0x0624(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCANPCCriticalHitData>          M_critical_hit_data;                               // 0x0628(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCANPCCriticalHitHealthPool>    M_critical_hit_health_pools;                       // 0x0638(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCALayerEffectDataAsset> M_blink_layer_effect;                              // 0x0648(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCANPCOnDamagedData                    M_on_damaged_data;                                 // 0x0678(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAInclusionSetting                    M_patrol_path_inclusion_settings;                  // 0x0680(0x0028)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCAEquippableInventoryItem> M_weapon_asset;                                    // 0x06A8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UCAEquippableInventoryItem>> M_additional_weapon_assets;                        // 0x06D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E8[0x8];                                      // 0x06E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMountingInfo                          M_weapon_mounting_info;                            // 0x06F0(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FMountingInfo>                  M_additional_weapon_mounting_info;                 // 0x0760(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_arc_lens_inspectable_class;                      // 0x0770(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           M_gameplay_state_component_classes;                // 0x07A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_zero_g_navigation_filter_class;                  // 0x07B0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_default_navigation_filter_class;                 // 0x07E0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_client_weapon_aim_loc_offset;                    // 0x0810(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_can_be_dialogue_spokesperson;                    // 0x081C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECANPCSquadHierarchyRoleType                  M_squad_hierarchy_role_type;                       // 0x081D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81E[0x2];                                      // 0x081E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    M_audio_data_table;                                // 0x0820(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UCAAudioBank>>    M_sound_banks;                                     // 0x0838(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FCANPCZeroGData                        M_zero_g_data;                                     // 0x0848(0x0050)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_898[0x8];                                      // 0x0898(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCCharacterData) == 0x000010, "Wrong alignment on FCANPCCharacterData");
static_assert(sizeof(FCANPCCharacterData) == 0x0008A0, "Wrong size on FCANPCCharacterData");
static_assert(offsetof(FCANPCCharacterData, M_blackboard_data) == 0x000228, "Member 'FCANPCCharacterData::M_blackboard_data' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_behavior_tree_asset) == 0x000258, "Member 'FCANPCCharacterData::M_behavior_tree_asset' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_pursue_outside_mission_area) == 0x000288, "Member 'FCANPCCharacterData::M_pursue_outside_mission_area' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_npc_motivations) == 0x000290, "Member 'FCANPCCharacterData::M_npc_motivations' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_sense_set_data_table_DNT) == 0x0002A0, "Member 'FCANPCCharacterData::M_sense_set_data_table_DNT' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_view_cone_data_table_DNT) == 0x0002D0, "Member 'FCANPCCharacterData::M_view_cone_data_table_DNT' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_enemy_sighted_alert_radius) == 0x000300, "Member 'FCANPCCharacterData::M_enemy_sighted_alert_radius' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_virtual_vision_duration) == 0x000304, "Member 'FCANPCCharacterData::M_virtual_vision_duration' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_start_combat_delay_base) == 0x000308, "Member 'FCANPCCharacterData::M_start_combat_delay_base' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_start_combat_delay_random_deviation) == 0x00030C, "Member 'FCANPCCharacterData::M_start_combat_delay_random_deviation' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_time_to_forget_target) == 0x000310, "Member 'FCANPCCharacterData::M_time_to_forget_target' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_best_weapon_vs_target_objects) == 0x000314, "Member 'FCANPCCharacterData::M_best_weapon_vs_target_objects' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_current_target_sticky_duration) == 0x000318, "Member 'FCANPCCharacterData::M_current_target_sticky_duration' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_current_target_sticky_if_charging_weapon) == 0x00031C, "Member 'FCANPCCharacterData::M_current_target_sticky_if_charging_weapon' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_current_target_sticky_if_firing_weapon) == 0x00031D, "Member 'FCANPCCharacterData::M_current_target_sticky_if_firing_weapon' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_current_target_sticky_if_firing_secondary_weapon) == 0x00031E, "Member 'FCANPCCharacterData::M_current_target_sticky_if_firing_secondary_weapon' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_current_target_sticky_if_charging_secondary_weapon) == 0x00031F, "Member 'FCANPCCharacterData::M_current_target_sticky_if_charging_secondary_weapon' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_target_rules_table_DNT) == 0x000320, "Member 'FCANPCCharacterData::M_target_rules_table_DNT' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_tactical_movement_params) == 0x000350, "Member 'FCANPCCharacterData::M_tactical_movement_params' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_max_idle_behaviour_radius) == 0x000380, "Member 'FCANPCCharacterData::M_max_idle_behaviour_radius' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_minimum_target_distance_range) == 0x000384, "Member 'FCANPCCharacterData::M_minimum_target_distance_range' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_maximum_target_distance_range) == 0x000388, "Member 'FCANPCCharacterData::M_maximum_target_distance_range' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_melee_attack_range) == 0x00038C, "Member 'FCANPCCharacterData::M_melee_attack_range' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_melee_attack_angle_range) == 0x000390, "Member 'FCANPCCharacterData::M_melee_attack_angle_range' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_aoe_special_attack_trigger_range) == 0x000394, "Member 'FCANPCCharacterData::M_aoe_special_attack_trigger_range' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_follow_radius_inner) == 0x000398, "Member 'FCANPCCharacterData::M_follow_radius_inner' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_follow_radius_outer) == 0x00039C, "Member 'FCANPCCharacterData::M_follow_radius_outer' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_follow_at_max_behave_radius_if_attacking) == 0x0003A0, "Member 'FCANPCCharacterData::M_follow_at_max_behave_radius_if_attacking' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_relocate_attack_range) == 0x0003A4, "Member 'FCANPCCharacterData::M_relocate_attack_range' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_relocate_attack_cooldown) == 0x0003A8, "Member 'FCANPCCharacterData::M_relocate_attack_cooldown' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_relocate_attack_duration) == 0x0003AC, "Member 'FCANPCCharacterData::M_relocate_attack_duration' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_relocate_attack_damage_taken_clears_cooldown) == 0x0003B0, "Member 'FCANPCCharacterData::M_relocate_attack_damage_taken_clears_cooldown' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_aim_manager_setup) == 0x0003B4, "Member 'FCANPCCharacterData::M_aim_manager_setup' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_rotation_manager_setup) == 0x0003BC, "Member 'FCANPCCharacterData::M_rotation_manager_setup' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_attack_manager_setup) == 0x0003C8, "Member 'FCANPCCharacterData::M_attack_manager_setup' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_secondary_attack_manager_setup) == 0x000478, "Member 'FCANPCCharacterData::M_secondary_attack_manager_setup' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_can_get_staggered) == 0x000528, "Member 'FCANPCCharacterData::M_can_get_staggered' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_stagger_threshold) == 0x00052C, "Member 'FCANPCCharacterData::M_stagger_threshold' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_stagger_pain_decrease_per_second) == 0x000530, "Member 'FCANPCCharacterData::M_stagger_pain_decrease_per_second' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_stagger_cooldown) == 0x000534, "Member 'FCANPCCharacterData::M_stagger_cooldown' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_grenade_ability_data) == 0x000538, "Member 'FCANPCCharacterData::M_grenade_ability_data' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_emp_ability_cooldown) == 0x000580, "Member 'FCANPCCharacterData::M_emp_ability_cooldown' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_laser_ability_cooldown) == 0x000584, "Member 'FCANPCCharacterData::M_laser_ability_cooldown' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_combat_jump_ability_cooldown) == 0x000588, "Member 'FCANPCCharacterData::M_combat_jump_ability_cooldown' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_evade_ability_cooldown) == 0x00058C, "Member 'FCANPCCharacterData::M_evade_ability_cooldown' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_special_abilities_initial_cooldown) == 0x000590, "Member 'FCANPCCharacterData::M_special_abilities_initial_cooldown' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_special_abilities_initial_cooldown_variance) == 0x000594, "Member 'FCANPCCharacterData::M_special_abilities_initial_cooldown_variance' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_idle_behaviour_cooldown) == 0x000598, "Member 'FCANPCCharacterData::M_idle_behaviour_cooldown' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_use_rvo_avoidance) == 0x00059C, "Member 'FCANPCCharacterData::M_use_rvo_avoidance' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_avoidance_consideration_radius) == 0x0005A0, "Member 'FCANPCCharacterData::M_avoidance_consideration_radius' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_rvo_avoidance_weight) == 0x0005A4, "Member 'FCANPCCharacterData::M_rvo_avoidance_weight' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_use_crowd_following_avoidance) == 0x0005A8, "Member 'FCANPCCharacterData::M_use_crowd_following_avoidance' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_exit_magboots_interrupts_abilities) == 0x0005A9, "Member 'FCANPCCharacterData::M_exit_magboots_interrupts_abilities' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_drone_movement_data) == 0x0005AC, "Member 'FCANPCCharacterData::M_drone_movement_data' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_use_fast_travel) == 0x0005F4, "Member 'FCANPCCharacterData::M_use_fast_travel' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_fast_travel_parameters) == 0x0005F8, "Member 'FCANPCCharacterData::M_fast_travel_parameters' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_stop_movement_on_abort_move) == 0x000610, "Member 'FCANPCCharacterData::M_stop_movement_on_abort_move' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_ally_target_rule) == 0x000611, "Member 'FCANPCCharacterData::M_ally_target_rule' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_ally_target_identifier_tag) == 0x000614, "Member 'FCANPCCharacterData::M_ally_target_identifier_tag' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_target_lock_duration) == 0x000620, "Member 'FCANPCCharacterData::M_target_lock_duration' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_suspicious_warning_duration) == 0x000624, "Member 'FCANPCCharacterData::M_suspicious_warning_duration' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_critical_hit_data) == 0x000628, "Member 'FCANPCCharacterData::M_critical_hit_data' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_critical_hit_health_pools) == 0x000638, "Member 'FCANPCCharacterData::M_critical_hit_health_pools' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_blink_layer_effect) == 0x000648, "Member 'FCANPCCharacterData::M_blink_layer_effect' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_on_damaged_data) == 0x000678, "Member 'FCANPCCharacterData::M_on_damaged_data' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_patrol_path_inclusion_settings) == 0x000680, "Member 'FCANPCCharacterData::M_patrol_path_inclusion_settings' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_weapon_asset) == 0x0006A8, "Member 'FCANPCCharacterData::M_weapon_asset' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_additional_weapon_assets) == 0x0006D8, "Member 'FCANPCCharacterData::M_additional_weapon_assets' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_weapon_mounting_info) == 0x0006F0, "Member 'FCANPCCharacterData::M_weapon_mounting_info' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_additional_weapon_mounting_info) == 0x000760, "Member 'FCANPCCharacterData::M_additional_weapon_mounting_info' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_arc_lens_inspectable_class) == 0x000770, "Member 'FCANPCCharacterData::M_arc_lens_inspectable_class' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_gameplay_state_component_classes) == 0x0007A0, "Member 'FCANPCCharacterData::M_gameplay_state_component_classes' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_zero_g_navigation_filter_class) == 0x0007B0, "Member 'FCANPCCharacterData::M_zero_g_navigation_filter_class' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_default_navigation_filter_class) == 0x0007E0, "Member 'FCANPCCharacterData::M_default_navigation_filter_class' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_client_weapon_aim_loc_offset) == 0x000810, "Member 'FCANPCCharacterData::M_client_weapon_aim_loc_offset' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_can_be_dialogue_spokesperson) == 0x00081C, "Member 'FCANPCCharacterData::M_can_be_dialogue_spokesperson' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_squad_hierarchy_role_type) == 0x00081D, "Member 'FCANPCCharacterData::M_squad_hierarchy_role_type' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_audio_data_table) == 0x000820, "Member 'FCANPCCharacterData::M_audio_data_table' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_sound_banks) == 0x000838, "Member 'FCANPCCharacterData::M_sound_banks' has a wrong offset!");
static_assert(offsetof(FCANPCCharacterData, M_zero_g_data) == 0x000848, "Member 'FCANPCCharacterData::M_zero_g_data' has a wrong offset!");

// ScriptStruct keaton.CALayoutItem
// 0x0030 (0x0038 - 0x0008)
struct FCALayoutItem final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   M_layout_class;                                    // 0x0008(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALayoutItem) == 0x000008, "Wrong alignment on FCALayoutItem");
static_assert(sizeof(FCALayoutItem) == 0x000038, "Wrong size on FCALayoutItem");
static_assert(offsetof(FCALayoutItem, M_layout_class) == 0x000008, "Member 'FCALayoutItem::M_layout_class' has a wrong offset!");

// ScriptStruct keaton.SecurityScreenViewDesc
// 0x0018 (0x0018 - 0x0000)
struct FSecurityScreenViewDesc final
{
public:
	class FName                                   Widget_view_row_name;                              // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Widget_view_id;                                    // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSecurityScreenViewDesc) == 0x000004, "Wrong alignment on FSecurityScreenViewDesc");
static_assert(sizeof(FSecurityScreenViewDesc) == 0x000018, "Wrong size on FSecurityScreenViewDesc");
static_assert(offsetof(FSecurityScreenViewDesc, Widget_view_row_name) == 0x000000, "Member 'FSecurityScreenViewDesc::Widget_view_row_name' has a wrong offset!");
static_assert(offsetof(FSecurityScreenViewDesc, Widget_view_id) == 0x00000C, "Member 'FSecurityScreenViewDesc::Widget_view_id' has a wrong offset!");

// ScriptStruct keaton.CAPurchaseItem
// 0x00E0 (0x00E0 - 0x0000)
struct alignas(0x08) FCAPurchaseItem final
{
public:
	uint8                                         Pad_0[0xE0];                                       // 0x0000(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPurchaseItem) == 0x000008, "Wrong alignment on FCAPurchaseItem");
static_assert(sizeof(FCAPurchaseItem) == 0x0000E0, "Wrong size on FCAPurchaseItem");

// ScriptStruct keaton.NPCGameplayHint
// 0x0024 (0x0024 - 0x0000)
struct FNPCGameplayHint final
{
public:
	struct FVector                                M_location;                                        // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCGameplayHintType                          M_type;                                            // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  M_instigator;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  M_actor;                                           // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_radius;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCGameplayHint) == 0x000004, "Wrong alignment on FNPCGameplayHint");
static_assert(sizeof(FNPCGameplayHint) == 0x000024, "Wrong size on FNPCGameplayHint");
static_assert(offsetof(FNPCGameplayHint, M_location) == 0x000000, "Member 'FNPCGameplayHint::M_location' has a wrong offset!");
static_assert(offsetof(FNPCGameplayHint, M_type) == 0x00000C, "Member 'FNPCGameplayHint::M_type' has a wrong offset!");
static_assert(offsetof(FNPCGameplayHint, M_instigator) == 0x000010, "Member 'FNPCGameplayHint::M_instigator' has a wrong offset!");
static_assert(offsetof(FNPCGameplayHint, M_actor) == 0x000018, "Member 'FNPCGameplayHint::M_actor' has a wrong offset!");
static_assert(offsetof(FNPCGameplayHint, M_radius) == 0x000020, "Member 'FNPCGameplayHint::M_radius' has a wrong offset!");

// ScriptStruct keaton.CANPCMoveData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FCANPCMoveData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCMoveData) == 0x000004, "Wrong alignment on FCANPCMoveData");
static_assert(sizeof(FCANPCMoveData) == 0x000018, "Wrong size on FCANPCMoveData");

// ScriptStruct keaton.CANPCHitChanceData
// 0x0018 (0x0020 - 0x0008)
struct FCANPCHitChanceData final : public FTableRowBase
{
public:
	float                                         MeleePenalty;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShortRangePenalty;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MediumRangePenalty;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LongRangePenalty;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SniperRangePenalty;                                // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANPCHitChanceData) == 0x000008, "Wrong alignment on FCANPCHitChanceData");
static_assert(sizeof(FCANPCHitChanceData) == 0x000020, "Wrong size on FCANPCHitChanceData");
static_assert(offsetof(FCANPCHitChanceData, MeleePenalty) == 0x000008, "Member 'FCANPCHitChanceData::MeleePenalty' has a wrong offset!");
static_assert(offsetof(FCANPCHitChanceData, ShortRangePenalty) == 0x00000C, "Member 'FCANPCHitChanceData::ShortRangePenalty' has a wrong offset!");
static_assert(offsetof(FCANPCHitChanceData, MediumRangePenalty) == 0x000010, "Member 'FCANPCHitChanceData::MediumRangePenalty' has a wrong offset!");
static_assert(offsetof(FCANPCHitChanceData, LongRangePenalty) == 0x000014, "Member 'FCANPCHitChanceData::LongRangePenalty' has a wrong offset!");
static_assert(offsetof(FCANPCHitChanceData, SniperRangePenalty) == 0x000018, "Member 'FCANPCHitChanceData::SniperRangePenalty' has a wrong offset!");

// ScriptStruct keaton.CAMapInfo
// 0x01B0 (0x01B0 - 0x0000)
struct FCAMapInfo final
{
public:
	class FName                                   M_key;                                             // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0xC];                                        // 0x000C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_display_name;                                    // 0x0018(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCAText                                M_display_description;                             // 0x0048(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCAText                                M_display_type;                                    // 0x0078(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCAText                                M_game_mode_hint;                                  // 0x00A8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ECAGameModeType                               M_game_mode_type;                                  // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_map_uri;                                         // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_queue;                                           // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_selected;                                     // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_recommended_player_level;                        // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_icon;                                            // 0x0108(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_map_featured_image;                              // 0x0138(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCAGameModeConfiguration> M_gamemode_configuration;                          // 0x0168(0x0030)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_debug;                                        // 0x0198(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_featured;                                     // 0x0199(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A[0x2];                                      // 0x019A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_max_party_size;                                  // 0x019C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_min_party_size;                                  // 0x01A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_crews_number_in_game;                            // 0x01A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8[0x8];                                      // 0x01A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMapInfo) == 0x000008, "Wrong alignment on FCAMapInfo");
static_assert(sizeof(FCAMapInfo) == 0x0001B0, "Wrong size on FCAMapInfo");
static_assert(offsetof(FCAMapInfo, M_key) == 0x000000, "Member 'FCAMapInfo::M_key' has a wrong offset!");
static_assert(offsetof(FCAMapInfo, M_display_name) == 0x000018, "Member 'FCAMapInfo::M_display_name' has a wrong offset!");
static_assert(offsetof(FCAMapInfo, M_display_description) == 0x000048, "Member 'FCAMapInfo::M_display_description' has a wrong offset!");
static_assert(offsetof(FCAMapInfo, M_display_type) == 0x000078, "Member 'FCAMapInfo::M_display_type' has a wrong offset!");
static_assert(offsetof(FCAMapInfo, M_game_mode_hint) == 0x0000A8, "Member 'FCAMapInfo::M_game_mode_hint' has a wrong offset!");
static_assert(offsetof(FCAMapInfo, M_game_mode_type) == 0x0000D8, "Member 'FCAMapInfo::M_game_mode_type' has a wrong offset!");
static_assert(offsetof(FCAMapInfo, M_map_uri) == 0x0000E0, "Member 'FCAMapInfo::M_map_uri' has a wrong offset!");
static_assert(offsetof(FCAMapInfo, M_queue) == 0x0000F0, "Member 'FCAMapInfo::M_queue' has a wrong offset!");
static_assert(offsetof(FCAMapInfo, M_is_selected) == 0x000100, "Member 'FCAMapInfo::M_is_selected' has a wrong offset!");
static_assert(offsetof(FCAMapInfo, M_recommended_player_level) == 0x000104, "Member 'FCAMapInfo::M_recommended_player_level' has a wrong offset!");
static_assert(offsetof(FCAMapInfo, M_icon) == 0x000108, "Member 'FCAMapInfo::M_icon' has a wrong offset!");
static_assert(offsetof(FCAMapInfo, M_map_featured_image) == 0x000138, "Member 'FCAMapInfo::M_map_featured_image' has a wrong offset!");
static_assert(offsetof(FCAMapInfo, M_gamemode_configuration) == 0x000168, "Member 'FCAMapInfo::M_gamemode_configuration' has a wrong offset!");
static_assert(offsetof(FCAMapInfo, M_is_debug) == 0x000198, "Member 'FCAMapInfo::M_is_debug' has a wrong offset!");
static_assert(offsetof(FCAMapInfo, M_is_featured) == 0x000199, "Member 'FCAMapInfo::M_is_featured' has a wrong offset!");
static_assert(offsetof(FCAMapInfo, M_max_party_size) == 0x00019C, "Member 'FCAMapInfo::M_max_party_size' has a wrong offset!");
static_assert(offsetof(FCAMapInfo, M_min_party_size) == 0x0001A0, "Member 'FCAMapInfo::M_min_party_size' has a wrong offset!");
static_assert(offsetof(FCAMapInfo, M_crews_number_in_game) == 0x0001A4, "Member 'FCAMapInfo::M_crews_number_in_game' has a wrong offset!");

// ScriptStruct keaton.CAPolitenessChannel
// 0x001C (0x001C - 0x0000)
struct FCAPolitenessChannel final
{
public:
	struct FGameplayTag                           M_tag;                                             // 0x0000(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECANPCPolitenessCategory                      M_category;                                        // 0x000C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ACACharacter>            M_target;                                          // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_autoregistration_enabled;                     // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_performing_behaviour;                         // 0x0019(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPolitenessChannel) == 0x000004, "Wrong alignment on FCAPolitenessChannel");
static_assert(sizeof(FCAPolitenessChannel) == 0x00001C, "Wrong size on FCAPolitenessChannel");
static_assert(offsetof(FCAPolitenessChannel, M_tag) == 0x000000, "Member 'FCAPolitenessChannel::M_tag' has a wrong offset!");
static_assert(offsetof(FCAPolitenessChannel, M_category) == 0x00000C, "Member 'FCAPolitenessChannel::M_category' has a wrong offset!");
static_assert(offsetof(FCAPolitenessChannel, M_target) == 0x000010, "Member 'FCAPolitenessChannel::M_target' has a wrong offset!");
static_assert(offsetof(FCAPolitenessChannel, M_is_autoregistration_enabled) == 0x000018, "Member 'FCAPolitenessChannel::M_is_autoregistration_enabled' has a wrong offset!");
static_assert(offsetof(FCAPolitenessChannel, M_is_performing_behaviour) == 0x000019, "Member 'FCAPolitenessChannel::M_is_performing_behaviour' has a wrong offset!");

// ScriptStruct keaton.CAPolitenessToken
// 0x0018 (0x0018 - 0x0000)
struct FCAPolitenessToken final
{
public:
	TWeakObjectPtr<class AActor>                  M_assigned_npc;                                    // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UObject>                 M_npc_politeness_user_object;                      // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_token_release_timestamp;                         // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_token_cooldown_time;                             // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FCAPolitenessToken) == 0x000004, "Wrong alignment on FCAPolitenessToken");
static_assert(sizeof(FCAPolitenessToken) == 0x000018, "Wrong size on FCAPolitenessToken");
static_assert(offsetof(FCAPolitenessToken, M_assigned_npc) == 0x000000, "Member 'FCAPolitenessToken::M_assigned_npc' has a wrong offset!");
static_assert(offsetof(FCAPolitenessToken, M_npc_politeness_user_object) == 0x000008, "Member 'FCAPolitenessToken::M_npc_politeness_user_object' has a wrong offset!");
static_assert(offsetof(FCAPolitenessToken, M_token_release_timestamp) == 0x000010, "Member 'FCAPolitenessToken::M_token_release_timestamp' has a wrong offset!");
static_assert(offsetof(FCAPolitenessToken, M_token_cooldown_time) == 0x000014, "Member 'FCAPolitenessToken::M_token_cooldown_time' has a wrong offset!");

// ScriptStruct keaton.CAPolitenessTokenArray
// 0x0010 (0x0010 - 0x0000)
struct FCAPolitenessTokenArray final
{
public:
	TArray<struct FCAPolitenessToken>             M_tokens;                                          // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPolitenessTokenArray) == 0x000008, "Wrong alignment on FCAPolitenessTokenArray");
static_assert(sizeof(FCAPolitenessTokenArray) == 0x000010, "Wrong size on FCAPolitenessTokenArray");
static_assert(offsetof(FCAPolitenessTokenArray, M_tokens) == 0x000000, "Member 'FCAPolitenessTokenArray::M_tokens' has a wrong offset!");

// ScriptStruct keaton.CAPolitenessCandidate
// 0x001C (0x001C - 0x0000)
struct FCAPolitenessCandidate final
{
public:
	TWeakObjectPtr<class AActor>                  M_npc;                                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 M_npc_politeness_user_object;                      // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_permission_score;                                // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPolitenessCandidate) == 0x000004, "Wrong alignment on FCAPolitenessCandidate");
static_assert(sizeof(FCAPolitenessCandidate) == 0x00001C, "Wrong size on FCAPolitenessCandidate");
static_assert(offsetof(FCAPolitenessCandidate, M_npc) == 0x000000, "Member 'FCAPolitenessCandidate::M_npc' has a wrong offset!");
static_assert(offsetof(FCAPolitenessCandidate, M_npc_politeness_user_object) == 0x000008, "Member 'FCAPolitenessCandidate::M_npc_politeness_user_object' has a wrong offset!");
static_assert(offsetof(FCAPolitenessCandidate, M_permission_score) == 0x000018, "Member 'FCAPolitenessCandidate::M_permission_score' has a wrong offset!");

// ScriptStruct keaton.CAPolitenessCandidateArray
// 0x0010 (0x0010 - 0x0000)
struct FCAPolitenessCandidateArray final
{
public:
	TArray<struct FCAPolitenessCandidate>         M_politeness_candidate_array;                      // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPolitenessCandidateArray) == 0x000008, "Wrong alignment on FCAPolitenessCandidateArray");
static_assert(sizeof(FCAPolitenessCandidateArray) == 0x000010, "Wrong size on FCAPolitenessCandidateArray");
static_assert(offsetof(FCAPolitenessCandidateArray, M_politeness_candidate_array) == 0x000000, "Member 'FCAPolitenessCandidateArray::M_politeness_candidate_array' has a wrong offset!");

// ScriptStruct keaton.CAPolitenessTokenDefinition
// 0x000C (0x000C - 0x0000)
struct FCAPolitenessTokenDefinition final
{
public:
	ECANPCPolitenessCategory                      M_category;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_count;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_cooldown;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPolitenessTokenDefinition) == 0x000004, "Wrong alignment on FCAPolitenessTokenDefinition");
static_assert(sizeof(FCAPolitenessTokenDefinition) == 0x00000C, "Wrong size on FCAPolitenessTokenDefinition");
static_assert(offsetof(FCAPolitenessTokenDefinition, M_category) == 0x000000, "Member 'FCAPolitenessTokenDefinition::M_category' has a wrong offset!");
static_assert(offsetof(FCAPolitenessTokenDefinition, M_count) == 0x000004, "Member 'FCAPolitenessTokenDefinition::M_count' has a wrong offset!");
static_assert(offsetof(FCAPolitenessTokenDefinition, M_cooldown) == 0x000008, "Member 'FCAPolitenessTokenDefinition::M_cooldown' has a wrong offset!");

// ScriptStruct keaton.CASpawnInclusionSetting
// 0x0028 (0x0028 - 0x0000)
struct FCASpawnInclusionSetting final
{
public:
	ECASpawnInclusionSetting                      M_inclusion_setting;                               // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECANPCType>                            M_exceptions;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACACharacter_NPC>>   M_exceptions_resolved;                             // 0x0018(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASpawnInclusionSetting) == 0x000008, "Wrong alignment on FCASpawnInclusionSetting");
static_assert(sizeof(FCASpawnInclusionSetting) == 0x000028, "Wrong size on FCASpawnInclusionSetting");
static_assert(offsetof(FCASpawnInclusionSetting, M_inclusion_setting) == 0x000000, "Member 'FCASpawnInclusionSetting::M_inclusion_setting' has a wrong offset!");
static_assert(offsetof(FCASpawnInclusionSetting, M_exceptions) == 0x000008, "Member 'FCASpawnInclusionSetting::M_exceptions' has a wrong offset!");
static_assert(offsetof(FCASpawnInclusionSetting, M_exceptions_resolved) == 0x000018, "Member 'FCASpawnInclusionSetting::M_exceptions_resolved' has a wrong offset!");

// ScriptStruct keaton.CAPartyMemberUIData
// 0x0068 (0x0068 - 0x0000)
struct FCAPartyMemberUIData final
{
public:
	class FString                                 M_player_name;                                     // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_leader;                                       // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_ready;                                        // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_me;                                           // 0x0012(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_friend;                                       // 0x0013(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_user_guid;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_player_level;                                    // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_prestige_level;                                  // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_current_platform;                                // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_specialist_id;                                   // 0x0040(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_disconnected;                                 // 0x004C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x1B];                                      // 0x004D(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPartyMemberUIData) == 0x000008, "Wrong alignment on FCAPartyMemberUIData");
static_assert(sizeof(FCAPartyMemberUIData) == 0x000068, "Wrong size on FCAPartyMemberUIData");
static_assert(offsetof(FCAPartyMemberUIData, M_player_name) == 0x000000, "Member 'FCAPartyMemberUIData::M_player_name' has a wrong offset!");
static_assert(offsetof(FCAPartyMemberUIData, M_is_leader) == 0x000010, "Member 'FCAPartyMemberUIData::M_is_leader' has a wrong offset!");
static_assert(offsetof(FCAPartyMemberUIData, M_is_ready) == 0x000011, "Member 'FCAPartyMemberUIData::M_is_ready' has a wrong offset!");
static_assert(offsetof(FCAPartyMemberUIData, M_is_me) == 0x000012, "Member 'FCAPartyMemberUIData::M_is_me' has a wrong offset!");
static_assert(offsetof(FCAPartyMemberUIData, M_is_friend) == 0x000013, "Member 'FCAPartyMemberUIData::M_is_friend' has a wrong offset!");
static_assert(offsetof(FCAPartyMemberUIData, M_user_guid) == 0x000018, "Member 'FCAPartyMemberUIData::M_user_guid' has a wrong offset!");
static_assert(offsetof(FCAPartyMemberUIData, M_player_level) == 0x000028, "Member 'FCAPartyMemberUIData::M_player_level' has a wrong offset!");
static_assert(offsetof(FCAPartyMemberUIData, M_prestige_level) == 0x00002C, "Member 'FCAPartyMemberUIData::M_prestige_level' has a wrong offset!");
static_assert(offsetof(FCAPartyMemberUIData, M_current_platform) == 0x000030, "Member 'FCAPartyMemberUIData::M_current_platform' has a wrong offset!");
static_assert(offsetof(FCAPartyMemberUIData, M_specialist_id) == 0x000040, "Member 'FCAPartyMemberUIData::M_specialist_id' has a wrong offset!");
static_assert(offsetof(FCAPartyMemberUIData, M_is_disconnected) == 0x00004C, "Member 'FCAPartyMemberUIData::M_is_disconnected' has a wrong offset!");

// ScriptStruct keaton.NPCVertexData
// 0x0030 (0x0030 - 0x0000)
struct FNPCVertexData final
{
public:
	class FString                                 M_npc_name;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_npc_asset;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_lod;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_vertex_count_total;                              // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_vertex_count_skinned;                            // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_vertex_count_static;                             // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCVertexData) == 0x000008, "Wrong alignment on FNPCVertexData");
static_assert(sizeof(FNPCVertexData) == 0x000030, "Wrong size on FNPCVertexData");
static_assert(offsetof(FNPCVertexData, M_npc_name) == 0x000000, "Member 'FNPCVertexData::M_npc_name' has a wrong offset!");
static_assert(offsetof(FNPCVertexData, M_npc_asset) == 0x000010, "Member 'FNPCVertexData::M_npc_asset' has a wrong offset!");
static_assert(offsetof(FNPCVertexData, M_lod) == 0x000020, "Member 'FNPCVertexData::M_lod' has a wrong offset!");
static_assert(offsetof(FNPCVertexData, M_vertex_count_total) == 0x000024, "Member 'FNPCVertexData::M_vertex_count_total' has a wrong offset!");
static_assert(offsetof(FNPCVertexData, M_vertex_count_skinned) == 0x000028, "Member 'FNPCVertexData::M_vertex_count_skinned' has a wrong offset!");
static_assert(offsetof(FNPCVertexData, M_vertex_count_static) == 0x00002C, "Member 'FNPCVertexData::M_vertex_count_static' has a wrong offset!");

// ScriptStruct keaton.NPCData
// 0x0038 (0x0038 - 0x0000)
struct FNPCData final
{
public:
	class FString                                 M_npc_name;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_npc_asset;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_did_spawn;                                       // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_memory_mb;                                       // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_tick_time_ms;                                    // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_unique_materials;                                // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_unique_textures;                                 // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCData) == 0x000008, "Wrong alignment on FNPCData");
static_assert(sizeof(FNPCData) == 0x000038, "Wrong size on FNPCData");
static_assert(offsetof(FNPCData, M_npc_name) == 0x000000, "Member 'FNPCData::M_npc_name' has a wrong offset!");
static_assert(offsetof(FNPCData, M_npc_asset) == 0x000010, "Member 'FNPCData::M_npc_asset' has a wrong offset!");
static_assert(offsetof(FNPCData, M_did_spawn) == 0x000020, "Member 'FNPCData::M_did_spawn' has a wrong offset!");
static_assert(offsetof(FNPCData, M_memory_mb) == 0x000024, "Member 'FNPCData::M_memory_mb' has a wrong offset!");
static_assert(offsetof(FNPCData, M_tick_time_ms) == 0x000028, "Member 'FNPCData::M_tick_time_ms' has a wrong offset!");
static_assert(offsetof(FNPCData, M_unique_materials) == 0x00002C, "Member 'FNPCData::M_unique_materials' has a wrong offset!");
static_assert(offsetof(FNPCData, M_unique_textures) == 0x000030, "Member 'FNPCData::M_unique_textures' has a wrong offset!");

// ScriptStruct keaton.CASecurityAreaLoops
// 0x0010 (0x0010 - 0x0000)
struct FCASecurityAreaLoops final
{
public:
	TArray<class ACAObjectiveLoop*>               M_loops;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASecurityAreaLoops) == 0x000008, "Wrong alignment on FCASecurityAreaLoops");
static_assert(sizeof(FCASecurityAreaLoops) == 0x000010, "Wrong size on FCASecurityAreaLoops");
static_assert(offsetof(FCASecurityAreaLoops, M_loops) == 0x000000, "Member 'FCASecurityAreaLoops::M_loops' has a wrong offset!");

// ScriptStruct keaton.ObjectiveLoopPermutationDefinition
// 0x0050 (0x0058 - 0x0008)
struct FObjectiveLoopPermutationDefinition final : public FTableRowBase
{
public:
	TMap<struct FGameplayTag, int32>              M_objective_loops_per_camp;                        // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectiveLoopPermutationDefinition) == 0x000008, "Wrong alignment on FObjectiveLoopPermutationDefinition");
static_assert(sizeof(FObjectiveLoopPermutationDefinition) == 0x000058, "Wrong size on FObjectiveLoopPermutationDefinition");
static_assert(offsetof(FObjectiveLoopPermutationDefinition, M_objective_loops_per_camp) == 0x000008, "Member 'FObjectiveLoopPermutationDefinition::M_objective_loops_per_camp' has a wrong offset!");

// ScriptStruct keaton.CALinkData
// 0x0008 (0x0008 - 0x0000)
struct FCALinkData final
{
public:
	float                                         M_volume;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_flow;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALinkData) == 0x000004, "Wrong alignment on FCALinkData");
static_assert(sizeof(FCALinkData) == 0x000008, "Wrong size on FCALinkData");
static_assert(offsetof(FCALinkData, M_volume) == 0x000000, "Member 'FCALinkData::M_volume' has a wrong offset!");
static_assert(offsetof(FCALinkData, M_flow) == 0x000004, "Member 'FCALinkData::M_flow' has a wrong offset!");

// ScriptStruct keaton.CAInputActionUITableRow
// 0x0080 (0x0088 - 0x0008)
struct FCAInputActionUITableRow final : public FTableRowBase
{
public:
	struct FCAText                                M_action_display_name;                             // 0x0008(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ECAActionType                                 M_action_type;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           M_children;                                        // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_must_be_bound;                                   // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_action_description;                              // 0x0058(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAInputActionUITableRow) == 0x000008, "Wrong alignment on FCAInputActionUITableRow");
static_assert(sizeof(FCAInputActionUITableRow) == 0x000088, "Wrong size on FCAInputActionUITableRow");
static_assert(offsetof(FCAInputActionUITableRow, M_action_display_name) == 0x000008, "Member 'FCAInputActionUITableRow::M_action_display_name' has a wrong offset!");
static_assert(offsetof(FCAInputActionUITableRow, M_action_type) == 0x000038, "Member 'FCAInputActionUITableRow::M_action_type' has a wrong offset!");
static_assert(offsetof(FCAInputActionUITableRow, M_children) == 0x000040, "Member 'FCAInputActionUITableRow::M_children' has a wrong offset!");
static_assert(offsetof(FCAInputActionUITableRow, M_must_be_bound) == 0x000050, "Member 'FCAInputActionUITableRow::M_must_be_bound' has a wrong offset!");
static_assert(offsetof(FCAInputActionUITableRow, M_action_description) == 0x000058, "Member 'FCAInputActionUITableRow::M_action_description' has a wrong offset!");

// ScriptStruct keaton.CAGameModePermutationContainer
// 0x0038 (0x0038 - 0x0000)
struct FCAGameModePermutationContainer final
{
public:
	TSoftObjectPtr<class UCAGameModeConfiguration> GameModeConfig;                                    // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAPermutationRuleSetDataAsset*         M_game_mode_permutations_rule_set;                 // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAGameModePermutationContainer) == 0x000008, "Wrong alignment on FCAGameModePermutationContainer");
static_assert(sizeof(FCAGameModePermutationContainer) == 0x000038, "Wrong size on FCAGameModePermutationContainer");
static_assert(offsetof(FCAGameModePermutationContainer, GameModeConfig) == 0x000000, "Member 'FCAGameModePermutationContainer::GameModeConfig' has a wrong offset!");
static_assert(offsetof(FCAGameModePermutationContainer, M_game_mode_permutations_rule_set) == 0x000030, "Member 'FCAGameModePermutationContainer::M_game_mode_permutations_rule_set' has a wrong offset!");

// ScriptStruct keaton.CampTypeProbabilityEntry
// 0x0010 (0x0010 - 0x0000)
struct FCampTypeProbabilityEntry final
{
public:
	struct FGameplayTag                           M_camp_type;                                       // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_weighting;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCampTypeProbabilityEntry) == 0x000004, "Wrong alignment on FCampTypeProbabilityEntry");
static_assert(sizeof(FCampTypeProbabilityEntry) == 0x000010, "Wrong size on FCampTypeProbabilityEntry");
static_assert(offsetof(FCampTypeProbabilityEntry, M_camp_type) == 0x000000, "Member 'FCampTypeProbabilityEntry::M_camp_type' has a wrong offset!");
static_assert(offsetof(FCampTypeProbabilityEntry, M_weighting) == 0x00000C, "Member 'FCampTypeProbabilityEntry::M_weighting' has a wrong offset!");

// ScriptStruct keaton.RuleCampProbabilityOverride
// 0x0020 (0x0020 - 0x0000)
struct FRuleCampProbabilityOverride final
{
public:
	struct FGameplayTag                           M_camp;                                            // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCampTypeProbabilityEntry>      M_weightings;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuleCampProbabilityOverride) == 0x000008, "Wrong alignment on FRuleCampProbabilityOverride");
static_assert(sizeof(FRuleCampProbabilityOverride) == 0x000020, "Wrong size on FRuleCampProbabilityOverride");
static_assert(offsetof(FRuleCampProbabilityOverride, M_camp) == 0x000000, "Member 'FRuleCampProbabilityOverride::M_camp' has a wrong offset!");
static_assert(offsetof(FRuleCampProbabilityOverride, M_weightings) == 0x000010, "Member 'FRuleCampProbabilityOverride::M_weightings' has a wrong offset!");

// ScriptStruct keaton.RuleGroupCampTypeLimit
// 0x001C (0x001C - 0x0000)
struct FRuleGroupCampTypeLimit final
{
public:
	struct FGameplayTag                           M_group_id;                                        // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_camp_type;                                       // 0x000C(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_camp_limit;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuleGroupCampTypeLimit) == 0x000004, "Wrong alignment on FRuleGroupCampTypeLimit");
static_assert(sizeof(FRuleGroupCampTypeLimit) == 0x00001C, "Wrong size on FRuleGroupCampTypeLimit");
static_assert(offsetof(FRuleGroupCampTypeLimit, M_group_id) == 0x000000, "Member 'FRuleGroupCampTypeLimit::M_group_id' has a wrong offset!");
static_assert(offsetof(FRuleGroupCampTypeLimit, M_camp_type) == 0x00000C, "Member 'FRuleGroupCampTypeLimit::M_camp_type' has a wrong offset!");
static_assert(offsetof(FRuleGroupCampTypeLimit, M_camp_limit) == 0x000018, "Member 'FRuleGroupCampTypeLimit::M_camp_limit' has a wrong offset!");

// ScriptStruct keaton.RuleGroupTotalCampLimit
// 0x0010 (0x0010 - 0x0000)
struct FRuleGroupTotalCampLimit final
{
public:
	struct FGameplayTag                           M_group_id;                                        // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_total_camp_limit;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuleGroupTotalCampLimit) == 0x000004, "Wrong alignment on FRuleGroupTotalCampLimit");
static_assert(sizeof(FRuleGroupTotalCampLimit) == 0x000010, "Wrong size on FRuleGroupTotalCampLimit");
static_assert(offsetof(FRuleGroupTotalCampLimit, M_group_id) == 0x000000, "Member 'FRuleGroupTotalCampLimit::M_group_id' has a wrong offset!");
static_assert(offsetof(FRuleGroupTotalCampLimit, M_total_camp_limit) == 0x00000C, "Member 'FRuleGroupTotalCampLimit::M_total_camp_limit' has a wrong offset!");

// ScriptStruct keaton.RuleForcedCamp
// 0x0018 (0x0018 - 0x0000)
struct FRuleForcedCamp final
{
public:
	struct FGameplayTag                           M_camp;                                            // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_camp_type;                                       // 0x000C(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuleForcedCamp) == 0x000004, "Wrong alignment on FRuleForcedCamp");
static_assert(sizeof(FRuleForcedCamp) == 0x000018, "Wrong size on FRuleForcedCamp");
static_assert(offsetof(FRuleForcedCamp, M_camp) == 0x000000, "Member 'FRuleForcedCamp::M_camp' has a wrong offset!");
static_assert(offsetof(FRuleForcedCamp, M_camp_type) == 0x00000C, "Member 'FRuleForcedCamp::M_camp_type' has a wrong offset!");

// ScriptStruct keaton.CAMatchResultRewards
// 0x0010 (0x0018 - 0x0008)
struct FCAMatchResultRewards final : public FTableRowBase
{
public:
	TArray<struct FCAMatchResultSubRewards>       M_rewards;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMatchResultRewards) == 0x000008, "Wrong alignment on FCAMatchResultRewards");
static_assert(sizeof(FCAMatchResultRewards) == 0x000018, "Wrong size on FCAMatchResultRewards");
static_assert(offsetof(FCAMatchResultRewards, M_rewards) == 0x000008, "Member 'FCAMatchResultRewards::M_rewards' has a wrong offset!");

// ScriptStruct keaton.CADamageEffectSpecification
// 0x0040 (0x0040 - 0x0000)
struct FCADamageEffectSpecification final
{
public:
	bool                                          Is_attached;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Attachment_socket_name;                            // 0x0004(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Attached_particle_system;                          // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         Fallback_niagara_system;                           // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        One_shot_particle_system;                          // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         One_shot_niagara_system;                           // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Explosion_radius;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACAExplosionEffect>         Explosion_effect;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADamageEffectSpecification) == 0x000008, "Wrong alignment on FCADamageEffectSpecification");
static_assert(sizeof(FCADamageEffectSpecification) == 0x000040, "Wrong size on FCADamageEffectSpecification");
static_assert(offsetof(FCADamageEffectSpecification, Is_attached) == 0x000000, "Member 'FCADamageEffectSpecification::Is_attached' has a wrong offset!");
static_assert(offsetof(FCADamageEffectSpecification, Attachment_socket_name) == 0x000004, "Member 'FCADamageEffectSpecification::Attachment_socket_name' has a wrong offset!");
static_assert(offsetof(FCADamageEffectSpecification, Attached_particle_system) == 0x000010, "Member 'FCADamageEffectSpecification::Attached_particle_system' has a wrong offset!");
static_assert(offsetof(FCADamageEffectSpecification, Fallback_niagara_system) == 0x000018, "Member 'FCADamageEffectSpecification::Fallback_niagara_system' has a wrong offset!");
static_assert(offsetof(FCADamageEffectSpecification, One_shot_particle_system) == 0x000020, "Member 'FCADamageEffectSpecification::One_shot_particle_system' has a wrong offset!");
static_assert(offsetof(FCADamageEffectSpecification, One_shot_niagara_system) == 0x000028, "Member 'FCADamageEffectSpecification::One_shot_niagara_system' has a wrong offset!");
static_assert(offsetof(FCADamageEffectSpecification, Explosion_radius) == 0x000030, "Member 'FCADamageEffectSpecification::Explosion_radius' has a wrong offset!");
static_assert(offsetof(FCADamageEffectSpecification, Explosion_effect) == 0x000038, "Member 'FCADamageEffectSpecification::Explosion_effect' has a wrong offset!");

// ScriptStruct keaton.CAPhysicsPropConfiguration
// 0x02C0 (0x02C8 - 0x0008)
struct FCAPhysicsPropConfiguration final : public FTableRowBase
{
public:
	struct FFeatureObjectPtr                      Prop_asset;                                        // 0x0008(0x0068)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Simulates_physics;                                 // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Linear_damping;                                    // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angular_damping;                                   // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass_scaling;                                      // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Zero_gravity_uplift_impulse;                       // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Zero_gravity_uplift_variance;                      // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Can_be_impacted;                                   // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Impact_threshold;                                  // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Impact_duration;                                   // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCADamageEffectSpecification           Normal_gravity_impact_effect;                      // 0x0098(0x0040)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCADamageEffectSpecification           Zero_gravity_impact_effect;                        // 0x00D8(0x0040)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      Impact_sound;                                      // 0x0118(0x0004)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Can_be_damaged;                                    // 0x011C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Simulates_when_damaged;                            // 0x011D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11E[0x2];                                      // 0x011E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFeatureObjectPtr                      Damaged_asset;                                     // 0x0120(0x0068)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage_threshold;                                  // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCADamageEffectSpecification           Normal_gravity_damage_effect;                      // 0x0190(0x0040)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCADamageEffectSpecification           Zero_gravity_damage_effect;                        // 0x01D0(0x0040)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      Damaged_sound;                                     // 0x0210(0x0004)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Can_be_destroyed;                                  // 0x0214(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_215[0x3];                                      // 0x0215(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Destruction_threshold;                             // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Destroyed_removal_time;                            // 0x021C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCADamageEffectSpecification           Normal_gravity_destruction_effect;                 // 0x0220(0x0040)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCADamageEffectSpecification           Zero_gravity_destruction_effect;                   // 0x0260(0x0040)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      Destroyed_sound;                                   // 0x02A0(0x0004)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Apply_collision_impulses;                          // 0x02A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Collision_offset;                                  // 0x02A8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECACollisionPrimitiveType                     Collision_primitive;                               // 0x02B4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B5[0x3];                                      // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Collision_dimensions;                              // 0x02B8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Collision_impulse_magnitude;                       // 0x02C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPhysicsPropConfiguration) == 0x000008, "Wrong alignment on FCAPhysicsPropConfiguration");
static_assert(sizeof(FCAPhysicsPropConfiguration) == 0x0002C8, "Wrong size on FCAPhysicsPropConfiguration");
static_assert(offsetof(FCAPhysicsPropConfiguration, Prop_asset) == 0x000008, "Member 'FCAPhysicsPropConfiguration::Prop_asset' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Simulates_physics) == 0x000070, "Member 'FCAPhysicsPropConfiguration::Simulates_physics' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Linear_damping) == 0x000074, "Member 'FCAPhysicsPropConfiguration::Linear_damping' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Angular_damping) == 0x000078, "Member 'FCAPhysicsPropConfiguration::Angular_damping' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Mass_scaling) == 0x00007C, "Member 'FCAPhysicsPropConfiguration::Mass_scaling' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Zero_gravity_uplift_impulse) == 0x000080, "Member 'FCAPhysicsPropConfiguration::Zero_gravity_uplift_impulse' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Zero_gravity_uplift_variance) == 0x000084, "Member 'FCAPhysicsPropConfiguration::Zero_gravity_uplift_variance' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Can_be_impacted) == 0x000088, "Member 'FCAPhysicsPropConfiguration::Can_be_impacted' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Impact_threshold) == 0x00008C, "Member 'FCAPhysicsPropConfiguration::Impact_threshold' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Impact_duration) == 0x000090, "Member 'FCAPhysicsPropConfiguration::Impact_duration' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Normal_gravity_impact_effect) == 0x000098, "Member 'FCAPhysicsPropConfiguration::Normal_gravity_impact_effect' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Zero_gravity_impact_effect) == 0x0000D8, "Member 'FCAPhysicsPropConfiguration::Zero_gravity_impact_effect' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Impact_sound) == 0x000118, "Member 'FCAPhysicsPropConfiguration::Impact_sound' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Can_be_damaged) == 0x00011C, "Member 'FCAPhysicsPropConfiguration::Can_be_damaged' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Simulates_when_damaged) == 0x00011D, "Member 'FCAPhysicsPropConfiguration::Simulates_when_damaged' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Damaged_asset) == 0x000120, "Member 'FCAPhysicsPropConfiguration::Damaged_asset' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Damage_threshold) == 0x000188, "Member 'FCAPhysicsPropConfiguration::Damage_threshold' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Normal_gravity_damage_effect) == 0x000190, "Member 'FCAPhysicsPropConfiguration::Normal_gravity_damage_effect' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Zero_gravity_damage_effect) == 0x0001D0, "Member 'FCAPhysicsPropConfiguration::Zero_gravity_damage_effect' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Damaged_sound) == 0x000210, "Member 'FCAPhysicsPropConfiguration::Damaged_sound' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Can_be_destroyed) == 0x000214, "Member 'FCAPhysicsPropConfiguration::Can_be_destroyed' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Destruction_threshold) == 0x000218, "Member 'FCAPhysicsPropConfiguration::Destruction_threshold' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Destroyed_removal_time) == 0x00021C, "Member 'FCAPhysicsPropConfiguration::Destroyed_removal_time' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Normal_gravity_destruction_effect) == 0x000220, "Member 'FCAPhysicsPropConfiguration::Normal_gravity_destruction_effect' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Zero_gravity_destruction_effect) == 0x000260, "Member 'FCAPhysicsPropConfiguration::Zero_gravity_destruction_effect' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Destroyed_sound) == 0x0002A0, "Member 'FCAPhysicsPropConfiguration::Destroyed_sound' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Apply_collision_impulses) == 0x0002A4, "Member 'FCAPhysicsPropConfiguration::Apply_collision_impulses' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Collision_offset) == 0x0002A8, "Member 'FCAPhysicsPropConfiguration::Collision_offset' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Collision_primitive) == 0x0002B4, "Member 'FCAPhysicsPropConfiguration::Collision_primitive' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Collision_dimensions) == 0x0002B8, "Member 'FCAPhysicsPropConfiguration::Collision_dimensions' has a wrong offset!");
static_assert(offsetof(FCAPhysicsPropConfiguration, Collision_impulse_magnitude) == 0x0002C4, "Member 'FCAPhysicsPropConfiguration::Collision_impulse_magnitude' has a wrong offset!");

// ScriptStruct keaton.CAPingResponseContextDefinition
// 0x0010 (0x0018 - 0x0008)
struct FCAPingResponseContextDefinition final : public FTableRowBase
{
public:
	ECAPingResponseContext                        M_context;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             M_radial_menu_config_table;                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPingResponseContextDefinition) == 0x000008, "Wrong alignment on FCAPingResponseContextDefinition");
static_assert(sizeof(FCAPingResponseContextDefinition) == 0x000018, "Wrong size on FCAPingResponseContextDefinition");
static_assert(offsetof(FCAPingResponseContextDefinition, M_context) == 0x000008, "Member 'FCAPingResponseContextDefinition::M_context' has a wrong offset!");
static_assert(offsetof(FCAPingResponseContextDefinition, M_radial_menu_config_table) == 0x000010, "Member 'FCAPingResponseContextDefinition::M_radial_menu_config_table' has a wrong offset!");

// ScriptStruct keaton.CABattleStat
// 0x0018 (0x0018 - 0x0000)
struct FCABattleStat final
{
public:
	class FString                                 M_stat_name;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_stat_value;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_stat_average;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCABattleStat) == 0x000008, "Wrong alignment on FCABattleStat");
static_assert(sizeof(FCABattleStat) == 0x000018, "Wrong size on FCABattleStat");
static_assert(offsetof(FCABattleStat, M_stat_name) == 0x000000, "Member 'FCABattleStat::M_stat_name' has a wrong offset!");
static_assert(offsetof(FCABattleStat, M_stat_value) == 0x000010, "Member 'FCABattleStat::M_stat_value' has a wrong offset!");
static_assert(offsetof(FCABattleStat, M_stat_average) == 0x000014, "Member 'FCABattleStat::M_stat_average' has a wrong offset!");

// ScriptStruct keaton.CAWeaponVariableFireRateEntry
// 0x0008 (0x0008 - 0x0000)
struct FCAWeaponVariableFireRateEntry final
{
public:
	float                                         M_fire_rate;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_weight;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAWeaponVariableFireRateEntry) == 0x000004, "Wrong alignment on FCAWeaponVariableFireRateEntry");
static_assert(sizeof(FCAWeaponVariableFireRateEntry) == 0x000008, "Wrong size on FCAWeaponVariableFireRateEntry");
static_assert(offsetof(FCAWeaponVariableFireRateEntry, M_fire_rate) == 0x000000, "Member 'FCAWeaponVariableFireRateEntry::M_fire_rate' has a wrong offset!");
static_assert(offsetof(FCAWeaponVariableFireRateEntry, M_weight) == 0x000004, "Member 'FCAWeaponVariableFireRateEntry::M_weight' has a wrong offset!");

// ScriptStruct keaton.CAAttributePostProcess
// 0x0048 (0x0048 - 0x0000)
struct FCAAttributePostProcess final
{
public:
	struct FGameplayAttribute                     M_attribute;                                       // 0x0000(0x0038)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACAPostProcessEffect>       M_effect;                                          // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPostProcessType                              M_post_process_type;                               // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAAttributePostProcess) == 0x000008, "Wrong alignment on FCAAttributePostProcess");
static_assert(sizeof(FCAAttributePostProcess) == 0x000048, "Wrong size on FCAAttributePostProcess");
static_assert(offsetof(FCAAttributePostProcess, M_attribute) == 0x000000, "Member 'FCAAttributePostProcess::M_attribute' has a wrong offset!");
static_assert(offsetof(FCAAttributePostProcess, M_effect) == 0x000038, "Member 'FCAAttributePostProcess::M_effect' has a wrong offset!");
static_assert(offsetof(FCAAttributePostProcess, M_post_process_type) == 0x000040, "Member 'FCAAttributePostProcess::M_post_process_type' has a wrong offset!");

// ScriptStruct keaton.CATagPostProcess
// 0x0020 (0x0020 - 0x0000)
struct FCATagPostProcess final
{
public:
	struct FGameplayTag                           M_tag;                                             // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACAPostProcessEffect>       M_effect;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPostProcessType                              M_post_process_type;                               // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCATagPostProcess) == 0x000008, "Wrong alignment on FCATagPostProcess");
static_assert(sizeof(FCATagPostProcess) == 0x000020, "Wrong size on FCATagPostProcess");
static_assert(offsetof(FCATagPostProcess, M_tag) == 0x000000, "Member 'FCATagPostProcess::M_tag' has a wrong offset!");
static_assert(offsetof(FCATagPostProcess, M_effect) == 0x000010, "Member 'FCATagPostProcess::M_effect' has a wrong offset!");
static_assert(offsetof(FCATagPostProcess, M_post_process_type) == 0x000018, "Member 'FCATagPostProcess::M_post_process_type' has a wrong offset!");

// ScriptStruct keaton.CAGamepad_Identifiers
// 0x0028 (0x0028 - 0x0000)
struct FCAGamepad_Identifiers final
{
public:
	class FString                                 M_vendor_id;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_product_id;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x4];                                       // 0x0020(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EGamepad_Type                                 M_gamepad_type;                                    // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_gamepad_subtype;                                 // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAGamepad_Identifiers) == 0x000008, "Wrong alignment on FCAGamepad_Identifiers");
static_assert(sizeof(FCAGamepad_Identifiers) == 0x000028, "Wrong size on FCAGamepad_Identifiers");
static_assert(offsetof(FCAGamepad_Identifiers, M_vendor_id) == 0x000000, "Member 'FCAGamepad_Identifiers::M_vendor_id' has a wrong offset!");
static_assert(offsetof(FCAGamepad_Identifiers, M_product_id) == 0x000010, "Member 'FCAGamepad_Identifiers::M_product_id' has a wrong offset!");
static_assert(offsetof(FCAGamepad_Identifiers, M_gamepad_type) == 0x000024, "Member 'FCAGamepad_Identifiers::M_gamepad_type' has a wrong offset!");
static_assert(offsetof(FCAGamepad_Identifiers, M_gamepad_subtype) == 0x000025, "Member 'FCAGamepad_Identifiers::M_gamepad_subtype' has a wrong offset!");

// ScriptStruct keaton.CARumbleRescale_Data
// 0x0018 (0x0018 - 0x0000)
struct FCARumbleRescale_Data final
{
public:
	EGamepad_Type                                 M_gamepad_type;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_gamepad_subtype;                                 // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FForceFeedbackChannelDetails>   M_rescale_curves;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARumbleRescale_Data) == 0x000008, "Wrong alignment on FCARumbleRescale_Data");
static_assert(sizeof(FCARumbleRescale_Data) == 0x000018, "Wrong size on FCARumbleRescale_Data");
static_assert(offsetof(FCARumbleRescale_Data, M_gamepad_type) == 0x000000, "Member 'FCARumbleRescale_Data::M_gamepad_type' has a wrong offset!");
static_assert(offsetof(FCARumbleRescale_Data, M_gamepad_subtype) == 0x000001, "Member 'FCARumbleRescale_Data::M_gamepad_subtype' has a wrong offset!");
static_assert(offsetof(FCARumbleRescale_Data, M_rescale_curves) == 0x000008, "Member 'FCARumbleRescale_Data::M_rescale_curves' has a wrong offset!");

// ScriptStruct keaton.CAForceFeedbackItem_MapEntry
// 0x0020 (0x0020 - 0x0000)
struct FCAForceFeedbackItem_MapEntry final
{
public:
	EForceFeedbackCategory                        M_category;                                        // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackEffect*                   M_2_motor;                                         // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   M_4_motor;                                         // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundWave*                             M_PS5_soundwave;                                   // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAForceFeedbackItem_MapEntry) == 0x000008, "Wrong alignment on FCAForceFeedbackItem_MapEntry");
static_assert(sizeof(FCAForceFeedbackItem_MapEntry) == 0x000020, "Wrong size on FCAForceFeedbackItem_MapEntry");
static_assert(offsetof(FCAForceFeedbackItem_MapEntry, M_category) == 0x000000, "Member 'FCAForceFeedbackItem_MapEntry::M_category' has a wrong offset!");
static_assert(offsetof(FCAForceFeedbackItem_MapEntry, M_2_motor) == 0x000008, "Member 'FCAForceFeedbackItem_MapEntry::M_2_motor' has a wrong offset!");
static_assert(offsetof(FCAForceFeedbackItem_MapEntry, M_4_motor) == 0x000010, "Member 'FCAForceFeedbackItem_MapEntry::M_4_motor' has a wrong offset!");
static_assert(offsetof(FCAForceFeedbackItem_MapEntry, M_PS5_soundwave) == 0x000018, "Member 'FCAForceFeedbackItem_MapEntry::M_PS5_soundwave' has a wrong offset!");

// ScriptStruct keaton.CAServicesRewardCategoryTableRow
// 0x0010 (0x0018 - 0x0008)
struct FCAServicesRewardCategoryTableRow final : public FTableRowBase
{
public:
	TArray<struct FCARewardCategory>              M_category_rewards;                                // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAServicesRewardCategoryTableRow) == 0x000008, "Wrong alignment on FCAServicesRewardCategoryTableRow");
static_assert(sizeof(FCAServicesRewardCategoryTableRow) == 0x000018, "Wrong size on FCAServicesRewardCategoryTableRow");
static_assert(offsetof(FCAServicesRewardCategoryTableRow, M_category_rewards) == 0x000008, "Member 'FCAServicesRewardCategoryTableRow::M_category_rewards' has a wrong offset!");

// ScriptStruct keaton.CACharacterInfo
// 0x0068 (0x0070 - 0x0008)
struct FCACharacterInfo final : public FTableRowBase
{
public:
	struct FFeatureKeyItem                        M_feature;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	ECAReleaseState                               M_release_state;                                   // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCASpecialistPrimaryDataAsset> SpecialistPrimaryDataAsset;                        // 0x0010(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               UIElementsDatabaseHandle;                          // 0x0040(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               LoadoutDatabaseHandle;                             // 0x0058(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACharacterInfo) == 0x000008, "Wrong alignment on FCACharacterInfo");
static_assert(sizeof(FCACharacterInfo) == 0x000070, "Wrong size on FCACharacterInfo");
static_assert(offsetof(FCACharacterInfo, M_feature) == 0x000008, "Member 'FCACharacterInfo::M_feature' has a wrong offset!");
static_assert(offsetof(FCACharacterInfo, M_release_state) == 0x00000C, "Member 'FCACharacterInfo::M_release_state' has a wrong offset!");
static_assert(offsetof(FCACharacterInfo, SpecialistPrimaryDataAsset) == 0x000010, "Member 'FCACharacterInfo::SpecialistPrimaryDataAsset' has a wrong offset!");
static_assert(offsetof(FCACharacterInfo, UIElementsDatabaseHandle) == 0x000040, "Member 'FCACharacterInfo::UIElementsDatabaseHandle' has a wrong offset!");
static_assert(offsetof(FCACharacterInfo, LoadoutDatabaseHandle) == 0x000058, "Member 'FCACharacterInfo::LoadoutDatabaseHandle' has a wrong offset!");

// ScriptStruct keaton.NetworkedSpecialistAssetPayload
// 0x00B8 (0x00B8 - 0x0000)
struct FNetworkedSpecialistAssetPayload final
{
public:
	class FName                                   M_specialist_name;                                 // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_customisation_name;                              // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_online_username;                                 // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_player_name;                                     // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCALoadoutSlots                        M_loadout_slots;                                   // 0x0038(0x0040)(NativeAccessSpecifierPublic)
	TArray<class FName>                           M_emotes;                                          // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_sprays;                                          // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_player_id;                                       // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpecialistAssetContext                       M_asset_context;                                   // 0x009C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_asset_details_id;                                // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCATeamID                              M_teamID;                                          // 0x00A4(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_perks;                                           // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetworkedSpecialistAssetPayload) == 0x000008, "Wrong alignment on FNetworkedSpecialistAssetPayload");
static_assert(sizeof(FNetworkedSpecialistAssetPayload) == 0x0000B8, "Wrong size on FNetworkedSpecialistAssetPayload");
static_assert(offsetof(FNetworkedSpecialistAssetPayload, M_specialist_name) == 0x000000, "Member 'FNetworkedSpecialistAssetPayload::M_specialist_name' has a wrong offset!");
static_assert(offsetof(FNetworkedSpecialistAssetPayload, M_customisation_name) == 0x00000C, "Member 'FNetworkedSpecialistAssetPayload::M_customisation_name' has a wrong offset!");
static_assert(offsetof(FNetworkedSpecialistAssetPayload, M_online_username) == 0x000018, "Member 'FNetworkedSpecialistAssetPayload::M_online_username' has a wrong offset!");
static_assert(offsetof(FNetworkedSpecialistAssetPayload, M_player_name) == 0x000028, "Member 'FNetworkedSpecialistAssetPayload::M_player_name' has a wrong offset!");
static_assert(offsetof(FNetworkedSpecialistAssetPayload, M_loadout_slots) == 0x000038, "Member 'FNetworkedSpecialistAssetPayload::M_loadout_slots' has a wrong offset!");
static_assert(offsetof(FNetworkedSpecialistAssetPayload, M_emotes) == 0x000078, "Member 'FNetworkedSpecialistAssetPayload::M_emotes' has a wrong offset!");
static_assert(offsetof(FNetworkedSpecialistAssetPayload, M_sprays) == 0x000088, "Member 'FNetworkedSpecialistAssetPayload::M_sprays' has a wrong offset!");
static_assert(offsetof(FNetworkedSpecialistAssetPayload, M_player_id) == 0x000098, "Member 'FNetworkedSpecialistAssetPayload::M_player_id' has a wrong offset!");
static_assert(offsetof(FNetworkedSpecialistAssetPayload, M_asset_context) == 0x00009C, "Member 'FNetworkedSpecialistAssetPayload::M_asset_context' has a wrong offset!");
static_assert(offsetof(FNetworkedSpecialistAssetPayload, M_asset_details_id) == 0x0000A0, "Member 'FNetworkedSpecialistAssetPayload::M_asset_details_id' has a wrong offset!");
static_assert(offsetof(FNetworkedSpecialistAssetPayload, M_teamID) == 0x0000A4, "Member 'FNetworkedSpecialistAssetPayload::M_teamID' has a wrong offset!");
static_assert(offsetof(FNetworkedSpecialistAssetPayload, M_perks) == 0x0000A8, "Member 'FNetworkedSpecialistAssetPayload::M_perks' has a wrong offset!");

// ScriptStruct keaton.NetworkedSpecialistAssetDetails
// 0x00BC (0x00C8 - 0x000C)
struct FNetworkedSpecialistAssetDetails final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNetworkedSpecialistAssetPayload       M_payload;                                         // 0x0010(0x00B8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetworkedSpecialistAssetDetails) == 0x000008, "Wrong alignment on FNetworkedSpecialistAssetDetails");
static_assert(sizeof(FNetworkedSpecialistAssetDetails) == 0x0000C8, "Wrong size on FNetworkedSpecialistAssetDetails");
static_assert(offsetof(FNetworkedSpecialistAssetDetails, M_payload) == 0x000010, "Member 'FNetworkedSpecialistAssetDetails::M_payload' has a wrong offset!");

// ScriptStruct keaton.NetworkedSpecialistAssetDetailsArray
// 0x0018 (0x0120 - 0x0108)
struct FNetworkedSpecialistAssetDetailsArray final : public FFastArraySerializer
{
public:
	TArray<struct FNetworkedSpecialistAssetDetails> Items;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UCAPlayerAssetsComponent*               M_owning_player_assets_component;                  // 0x0118(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetworkedSpecialistAssetDetailsArray) == 0x000008, "Wrong alignment on FNetworkedSpecialistAssetDetailsArray");
static_assert(sizeof(FNetworkedSpecialistAssetDetailsArray) == 0x000120, "Wrong size on FNetworkedSpecialistAssetDetailsArray");
static_assert(offsetof(FNetworkedSpecialistAssetDetailsArray, Items) == 0x000108, "Member 'FNetworkedSpecialistAssetDetailsArray::Items' has a wrong offset!");
static_assert(offsetof(FNetworkedSpecialistAssetDetailsArray, M_owning_player_assets_component) == 0x000118, "Member 'FNetworkedSpecialistAssetDetailsArray::M_owning_player_assets_component' has a wrong offset!");

// ScriptStruct keaton.SpecialistAssetDetails
// 0x00B0 (0x00B0 - 0x0000)
struct FSpecialistAssetDetails final
{
public:
	class FName                                   M_specialist_name;                                 // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_customisation_name;                              // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_online_username;                                 // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_player_name;                                     // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCALoadoutSlots                        M_loadout_slots;                                   // 0x0038(0x0040)(NativeAccessSpecifierPublic)
	int32                                         M_player_id;                                       // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCATeamID                              M_teamID;                                          // 0x007C(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_emotes;                                          // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_sprays;                                          // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_perks;                                           // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialistAssetDetails) == 0x000008, "Wrong alignment on FSpecialistAssetDetails");
static_assert(sizeof(FSpecialistAssetDetails) == 0x0000B0, "Wrong size on FSpecialistAssetDetails");
static_assert(offsetof(FSpecialistAssetDetails, M_specialist_name) == 0x000000, "Member 'FSpecialistAssetDetails::M_specialist_name' has a wrong offset!");
static_assert(offsetof(FSpecialistAssetDetails, M_customisation_name) == 0x00000C, "Member 'FSpecialistAssetDetails::M_customisation_name' has a wrong offset!");
static_assert(offsetof(FSpecialistAssetDetails, M_online_username) == 0x000018, "Member 'FSpecialistAssetDetails::M_online_username' has a wrong offset!");
static_assert(offsetof(FSpecialistAssetDetails, M_player_name) == 0x000028, "Member 'FSpecialistAssetDetails::M_player_name' has a wrong offset!");
static_assert(offsetof(FSpecialistAssetDetails, M_loadout_slots) == 0x000038, "Member 'FSpecialistAssetDetails::M_loadout_slots' has a wrong offset!");
static_assert(offsetof(FSpecialistAssetDetails, M_player_id) == 0x000078, "Member 'FSpecialistAssetDetails::M_player_id' has a wrong offset!");
static_assert(offsetof(FSpecialistAssetDetails, M_teamID) == 0x00007C, "Member 'FSpecialistAssetDetails::M_teamID' has a wrong offset!");
static_assert(offsetof(FSpecialistAssetDetails, M_emotes) == 0x000080, "Member 'FSpecialistAssetDetails::M_emotes' has a wrong offset!");
static_assert(offsetof(FSpecialistAssetDetails, M_sprays) == 0x000090, "Member 'FSpecialistAssetDetails::M_sprays' has a wrong offset!");
static_assert(offsetof(FSpecialistAssetDetails, M_perks) == 0x0000A0, "Member 'FSpecialistAssetDetails::M_perks' has a wrong offset!");

// ScriptStruct keaton.CAPlayerProfileLevelData
// 0x0018 (0x0018 - 0x0000)
struct FCAPlayerProfileLevelData final
{
public:
	TArray<struct FCARewardAssets>                M_reward_data;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_level_up_xp;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPlayerProfileLevelData) == 0x000008, "Wrong alignment on FCAPlayerProfileLevelData");
static_assert(sizeof(FCAPlayerProfileLevelData) == 0x000018, "Wrong size on FCAPlayerProfileLevelData");
static_assert(offsetof(FCAPlayerProfileLevelData, M_reward_data) == 0x000000, "Member 'FCAPlayerProfileLevelData::M_reward_data' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileLevelData, M_level_up_xp) == 0x000010, "Member 'FCAPlayerProfileLevelData::M_level_up_xp' has a wrong offset!");

// ScriptStruct keaton.CAPlayerLevelAssetData
// 0x0060 (0x0060 - 0x0000)
struct FCAPlayerLevelAssetData final
{
public:
	struct FCAText                                M_rank_name;                                       // 0x0000(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_rank_icon;                                       // 0x0030(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPlayerLevelAssetData) == 0x000008, "Wrong alignment on FCAPlayerLevelAssetData");
static_assert(sizeof(FCAPlayerLevelAssetData) == 0x000060, "Wrong size on FCAPlayerLevelAssetData");
static_assert(offsetof(FCAPlayerLevelAssetData, M_rank_name) == 0x000000, "Member 'FCAPlayerLevelAssetData::M_rank_name' has a wrong offset!");
static_assert(offsetof(FCAPlayerLevelAssetData, M_rank_icon) == 0x000030, "Member 'FCAPlayerLevelAssetData::M_rank_icon' has a wrong offset!");

// ScriptStruct keaton.CAPlayerProfileData
// 0x0080 (0x0080 - 0x0000)
struct FCAPlayerProfileData final
{
public:
	TArray<struct FCAPlayerLevelAssetData>        M_level_asset_data;                                // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCAPlayerLevelAssetData>        M_prestige_asset_data;                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_player_level;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_current_xp_amount;                               // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_level_up_xp_threshold;                           // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_xp_progress;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_max_player_level;                                // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              M_prestige_emblem;                                 // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_player_prestige_level;                           // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_current_prestige_amount;                         // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_prestige_level_up_threshold;                     // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_prestige_progress;                               // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_max_prestige_level;                              // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPlayerProfileData) == 0x000008, "Wrong alignment on FCAPlayerProfileData");
static_assert(sizeof(FCAPlayerProfileData) == 0x000080, "Wrong size on FCAPlayerProfileData");
static_assert(offsetof(FCAPlayerProfileData, M_level_asset_data) == 0x000000, "Member 'FCAPlayerProfileData::M_level_asset_data' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileData, M_prestige_asset_data) == 0x000010, "Member 'FCAPlayerProfileData::M_prestige_asset_data' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileData, M_player_level) == 0x000020, "Member 'FCAPlayerProfileData::M_player_level' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileData, M_current_xp_amount) == 0x000024, "Member 'FCAPlayerProfileData::M_current_xp_amount' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileData, M_level_up_xp_threshold) == 0x000028, "Member 'FCAPlayerProfileData::M_level_up_xp_threshold' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileData, M_xp_progress) == 0x00002C, "Member 'FCAPlayerProfileData::M_xp_progress' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileData, M_max_player_level) == 0x000030, "Member 'FCAPlayerProfileData::M_max_player_level' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileData, M_prestige_emblem) == 0x000038, "Member 'FCAPlayerProfileData::M_prestige_emblem' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileData, M_player_prestige_level) == 0x000068, "Member 'FCAPlayerProfileData::M_player_prestige_level' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileData, M_current_prestige_amount) == 0x00006C, "Member 'FCAPlayerProfileData::M_current_prestige_amount' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileData, M_prestige_level_up_threshold) == 0x000070, "Member 'FCAPlayerProfileData::M_prestige_level_up_threshold' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileData, M_prestige_progress) == 0x000074, "Member 'FCAPlayerProfileData::M_prestige_progress' has a wrong offset!");
static_assert(offsetof(FCAPlayerProfileData, M_max_prestige_level) == 0x000078, "Member 'FCAPlayerProfileData::M_max_prestige_level' has a wrong offset!");

// ScriptStruct keaton.CAPlayerCardUIData
// 0x0100 (0x0100 - 0x0000)
struct FCAPlayerCardUIData final
{
public:
	class FText                                   M_player_name;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_rank_name;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_rank_icon;                                       // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         M_rank;                                            // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_xp_progress;                                     // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x1C];                                      // 0x006C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FCACurrencyAssetData> M_currencys;                                       // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x28];                                      // 0x00D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPlayerCardUIData) == 0x000008, "Wrong alignment on FCAPlayerCardUIData");
static_assert(sizeof(FCAPlayerCardUIData) == 0x000100, "Wrong size on FCAPlayerCardUIData");
static_assert(offsetof(FCAPlayerCardUIData, M_player_name) == 0x000000, "Member 'FCAPlayerCardUIData::M_player_name' has a wrong offset!");
static_assert(offsetof(FCAPlayerCardUIData, M_rank_name) == 0x000018, "Member 'FCAPlayerCardUIData::M_rank_name' has a wrong offset!");
static_assert(offsetof(FCAPlayerCardUIData, M_rank_icon) == 0x000030, "Member 'FCAPlayerCardUIData::M_rank_icon' has a wrong offset!");
static_assert(offsetof(FCAPlayerCardUIData, M_rank) == 0x000060, "Member 'FCAPlayerCardUIData::M_rank' has a wrong offset!");
static_assert(offsetof(FCAPlayerCardUIData, M_xp_progress) == 0x000068, "Member 'FCAPlayerCardUIData::M_xp_progress' has a wrong offset!");
static_assert(offsetof(FCAPlayerCardUIData, M_currencys) == 0x000088, "Member 'FCAPlayerCardUIData::M_currencys' has a wrong offset!");

// ScriptStruct keaton.RunningQosQuery
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FRunningQosQuery final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRunningQosQuery) == 0x000008, "Wrong alignment on FRunningQosQuery");
static_assert(sizeof(FRunningQosQuery) == 0x000048, "Wrong size on FRunningQosQuery");

// ScriptStruct keaton.CAChallengesUIData
// 0x00F8 (0x00F8 - 0x0000)
struct FCAChallengesUIData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_current_progress;                                // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_progress_delta;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_progress_target;                                 // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_challenge_title;                                 // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   M_challenge_description;                           // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   M_challenge_owner;                                 // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_challenge_icon;                                  // 0x0068(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_visibility_type;                                 // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_challenge_type_display_name;                     // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ECAChallengesType                             M_challenge_type;                                  // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_locked;                                       // 0x00C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_claimed;                                      // 0x00C2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C3[0x5];                                       // 0x00C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCARewardAssets>                M_rewards;                                         // 0x00C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x18];                                      // 0x00D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         M_expiry_time_ms;                                  // 0x00F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAChallengesUIData) == 0x000008, "Wrong alignment on FCAChallengesUIData");
static_assert(sizeof(FCAChallengesUIData) == 0x0000F8, "Wrong size on FCAChallengesUIData");
static_assert(offsetof(FCAChallengesUIData, M_current_progress) == 0x000010, "Member 'FCAChallengesUIData::M_current_progress' has a wrong offset!");
static_assert(offsetof(FCAChallengesUIData, M_progress_delta) == 0x000014, "Member 'FCAChallengesUIData::M_progress_delta' has a wrong offset!");
static_assert(offsetof(FCAChallengesUIData, M_progress_target) == 0x000018, "Member 'FCAChallengesUIData::M_progress_target' has a wrong offset!");
static_assert(offsetof(FCAChallengesUIData, M_challenge_title) == 0x000020, "Member 'FCAChallengesUIData::M_challenge_title' has a wrong offset!");
static_assert(offsetof(FCAChallengesUIData, M_challenge_description) == 0x000038, "Member 'FCAChallengesUIData::M_challenge_description' has a wrong offset!");
static_assert(offsetof(FCAChallengesUIData, M_challenge_owner) == 0x000050, "Member 'FCAChallengesUIData::M_challenge_owner' has a wrong offset!");
static_assert(offsetof(FCAChallengesUIData, M_challenge_icon) == 0x000068, "Member 'FCAChallengesUIData::M_challenge_icon' has a wrong offset!");
static_assert(offsetof(FCAChallengesUIData, M_visibility_type) == 0x000098, "Member 'FCAChallengesUIData::M_visibility_type' has a wrong offset!");
static_assert(offsetof(FCAChallengesUIData, M_challenge_type_display_name) == 0x0000A8, "Member 'FCAChallengesUIData::M_challenge_type_display_name' has a wrong offset!");
static_assert(offsetof(FCAChallengesUIData, M_challenge_type) == 0x0000C0, "Member 'FCAChallengesUIData::M_challenge_type' has a wrong offset!");
static_assert(offsetof(FCAChallengesUIData, M_is_locked) == 0x0000C1, "Member 'FCAChallengesUIData::M_is_locked' has a wrong offset!");
static_assert(offsetof(FCAChallengesUIData, M_is_claimed) == 0x0000C2, "Member 'FCAChallengesUIData::M_is_claimed' has a wrong offset!");
static_assert(offsetof(FCAChallengesUIData, M_rewards) == 0x0000C8, "Member 'FCAChallengesUIData::M_rewards' has a wrong offset!");
static_assert(offsetof(FCAChallengesUIData, M_expiry_time_ms) == 0x0000F0, "Member 'FCAChallengesUIData::M_expiry_time_ms' has a wrong offset!");

// ScriptStruct keaton.CAChallengesTextData
// 0x0060 (0x0068 - 0x0008)
struct FCAChallengesTextData final : public FTableRowBase
{
public:
	struct FCAText                                M_challenge_title;                                 // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_challenge_icon;                                  // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAChallengesTextData) == 0x000008, "Wrong alignment on FCAChallengesTextData");
static_assert(sizeof(FCAChallengesTextData) == 0x000068, "Wrong size on FCAChallengesTextData");
static_assert(offsetof(FCAChallengesTextData, M_challenge_title) == 0x000008, "Member 'FCAChallengesTextData::M_challenge_title' has a wrong offset!");
static_assert(offsetof(FCAChallengesTextData, M_challenge_icon) == 0x000038, "Member 'FCAChallengesTextData::M_challenge_icon' has a wrong offset!");

// ScriptStruct keaton.CAPlayerCharacterData
// 0x0000 (0x0228 - 0x0228)
struct FCAPlayerCharacterData final : public FCACharacterData
{
};
static_assert(alignof(FCAPlayerCharacterData) == 0x000008, "Wrong alignment on FCAPlayerCharacterData");
static_assert(sizeof(FCAPlayerCharacterData) == 0x000228, "Wrong size on FCAPlayerCharacterData");

// ScriptStruct keaton.CARivalryStats
// 0x0028 (0x0028 - 0x0000)
struct FCARivalryStats final
{
public:
	class FString                                 M_rival_username;                                  // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_damage_dealt;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_damage_taken;                                    // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_downs_dealt;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_downs_received;                                  // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_kills_dealt;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_kills_received;                                  // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARivalryStats) == 0x000008, "Wrong alignment on FCARivalryStats");
static_assert(sizeof(FCARivalryStats) == 0x000028, "Wrong size on FCARivalryStats");
static_assert(offsetof(FCARivalryStats, M_rival_username) == 0x000000, "Member 'FCARivalryStats::M_rival_username' has a wrong offset!");
static_assert(offsetof(FCARivalryStats, M_damage_dealt) == 0x000010, "Member 'FCARivalryStats::M_damage_dealt' has a wrong offset!");
static_assert(offsetof(FCARivalryStats, M_damage_taken) == 0x000014, "Member 'FCARivalryStats::M_damage_taken' has a wrong offset!");
static_assert(offsetof(FCARivalryStats, M_downs_dealt) == 0x000018, "Member 'FCARivalryStats::M_downs_dealt' has a wrong offset!");
static_assert(offsetof(FCARivalryStats, M_downs_received) == 0x00001C, "Member 'FCARivalryStats::M_downs_received' has a wrong offset!");
static_assert(offsetof(FCARivalryStats, M_kills_dealt) == 0x000020, "Member 'FCARivalryStats::M_kills_dealt' has a wrong offset!");
static_assert(offsetof(FCARivalryStats, M_kills_received) == 0x000024, "Member 'FCARivalryStats::M_kills_received' has a wrong offset!");

// ScriptStruct keaton.MatchEndScreenCustomisations
// 0x0068 (0x0068 - 0x0000)
struct FMatchEndScreenCustomisations final
{
public:
	class USkeletalMesh*                          M_TP_mesh;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAOverrideMaterial>            M_override_materials;                              // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x50];                                      // 0x0018(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchEndScreenCustomisations) == 0x000008, "Wrong alignment on FMatchEndScreenCustomisations");
static_assert(sizeof(FMatchEndScreenCustomisations) == 0x000068, "Wrong size on FMatchEndScreenCustomisations");
static_assert(offsetof(FMatchEndScreenCustomisations, M_TP_mesh) == 0x000000, "Member 'FMatchEndScreenCustomisations::M_TP_mesh' has a wrong offset!");
static_assert(offsetof(FMatchEndScreenCustomisations, M_override_materials) == 0x000008, "Member 'FMatchEndScreenCustomisations::M_override_materials' has a wrong offset!");

// ScriptStruct keaton.CANetworkedPlayerHitUIData
// 0x0050 (0x0050 - 0x0000)
struct FCANetworkedPlayerHitUIData final
{
public:
	class AActor*                                 M_hit_actor;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           M_player_state;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    M_hit_location;                                    // 0x0010(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              M_hit_direction;                                   // 0x001C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_damage;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_armour_damage;                                   // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_armour_broken;                                   // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_armour_hit;                                      // 0x0031(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_weak_point_broken;                               // 0x0032(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_downed_target;                                   // 0x0033(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_killed_target;                                   // 0x0034(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_headshot;                                        // 0x0035(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_critical;                                     // 0x0036(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37[0x1];                                       // 0x0037(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_source_actor;                                    // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_instigator_actor;                                // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_player;                                       // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCATeamID                              M_target_team_id;                                  // 0x004C(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCANetworkedPlayerHitUIData) == 0x000008, "Wrong alignment on FCANetworkedPlayerHitUIData");
static_assert(sizeof(FCANetworkedPlayerHitUIData) == 0x000050, "Wrong size on FCANetworkedPlayerHitUIData");
static_assert(offsetof(FCANetworkedPlayerHitUIData, M_hit_actor) == 0x000000, "Member 'FCANetworkedPlayerHitUIData::M_hit_actor' has a wrong offset!");
static_assert(offsetof(FCANetworkedPlayerHitUIData, M_player_state) == 0x000008, "Member 'FCANetworkedPlayerHitUIData::M_player_state' has a wrong offset!");
static_assert(offsetof(FCANetworkedPlayerHitUIData, M_hit_location) == 0x000010, "Member 'FCANetworkedPlayerHitUIData::M_hit_location' has a wrong offset!");
static_assert(offsetof(FCANetworkedPlayerHitUIData, M_hit_direction) == 0x00001C, "Member 'FCANetworkedPlayerHitUIData::M_hit_direction' has a wrong offset!");
static_assert(offsetof(FCANetworkedPlayerHitUIData, M_damage) == 0x000028, "Member 'FCANetworkedPlayerHitUIData::M_damage' has a wrong offset!");
static_assert(offsetof(FCANetworkedPlayerHitUIData, M_armour_damage) == 0x00002C, "Member 'FCANetworkedPlayerHitUIData::M_armour_damage' has a wrong offset!");
static_assert(offsetof(FCANetworkedPlayerHitUIData, M_armour_broken) == 0x000030, "Member 'FCANetworkedPlayerHitUIData::M_armour_broken' has a wrong offset!");
static_assert(offsetof(FCANetworkedPlayerHitUIData, M_armour_hit) == 0x000031, "Member 'FCANetworkedPlayerHitUIData::M_armour_hit' has a wrong offset!");
static_assert(offsetof(FCANetworkedPlayerHitUIData, M_weak_point_broken) == 0x000032, "Member 'FCANetworkedPlayerHitUIData::M_weak_point_broken' has a wrong offset!");
static_assert(offsetof(FCANetworkedPlayerHitUIData, M_downed_target) == 0x000033, "Member 'FCANetworkedPlayerHitUIData::M_downed_target' has a wrong offset!");
static_assert(offsetof(FCANetworkedPlayerHitUIData, M_killed_target) == 0x000034, "Member 'FCANetworkedPlayerHitUIData::M_killed_target' has a wrong offset!");
static_assert(offsetof(FCANetworkedPlayerHitUIData, M_headshot) == 0x000035, "Member 'FCANetworkedPlayerHitUIData::M_headshot' has a wrong offset!");
static_assert(offsetof(FCANetworkedPlayerHitUIData, M_is_critical) == 0x000036, "Member 'FCANetworkedPlayerHitUIData::M_is_critical' has a wrong offset!");
static_assert(offsetof(FCANetworkedPlayerHitUIData, M_source_actor) == 0x000038, "Member 'FCANetworkedPlayerHitUIData::M_source_actor' has a wrong offset!");
static_assert(offsetof(FCANetworkedPlayerHitUIData, M_instigator_actor) == 0x000040, "Member 'FCANetworkedPlayerHitUIData::M_instigator_actor' has a wrong offset!");
static_assert(offsetof(FCANetworkedPlayerHitUIData, M_is_player) == 0x000048, "Member 'FCANetworkedPlayerHitUIData::M_is_player' has a wrong offset!");
static_assert(offsetof(FCANetworkedPlayerHitUIData, M_target_team_id) == 0x00004C, "Member 'FCANetworkedPlayerHitUIData::M_target_team_id' has a wrong offset!");

// ScriptStruct keaton.CARebindingStatus
// 0x0040 (0x0040 - 0x0000)
struct FCARebindingStatus final
{
public:
	struct FKey                                   M_current_key;                                     // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   M_previously_assigned_key;                         // 0x0020(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARebindingStatus) == 0x000008, "Wrong alignment on FCARebindingStatus");
static_assert(sizeof(FCARebindingStatus) == 0x000040, "Wrong size on FCARebindingStatus");
static_assert(offsetof(FCARebindingStatus, M_current_key) == 0x000000, "Member 'FCARebindingStatus::M_current_key' has a wrong offset!");
static_assert(offsetof(FCARebindingStatus, M_previously_assigned_key) == 0x000020, "Member 'FCARebindingStatus::M_previously_assigned_key' has a wrong offset!");

// ScriptStruct keaton.PrioritisedInputConfig
// 0x0010 (0x0010 - 0x0000)
struct FPrioritisedInputConfig final
{
public:
	class UCAPlayerInputConfig*                   M_input_config;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPrioritisedInputConfig) == 0x000008, "Wrong alignment on FPrioritisedInputConfig");
static_assert(sizeof(FPrioritisedInputConfig) == 0x000010, "Wrong size on FPrioritisedInputConfig");
static_assert(offsetof(FPrioritisedInputConfig, M_input_config) == 0x000000, "Member 'FPrioritisedInputConfig::M_input_config' has a wrong offset!");

// ScriptStruct keaton.CAKeyRebindData
// 0x0030 (0x0030 - 0x0000)
struct FCAKeyRebindData final
{
public:
	class FName                                   M_remap_id;                                        // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_primary_slot;                                 // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   M_key;                                             // 0x0010(0x0020)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAKeyRebindData) == 0x000008, "Wrong alignment on FCAKeyRebindData");
static_assert(sizeof(FCAKeyRebindData) == 0x000030, "Wrong size on FCAKeyRebindData");
static_assert(offsetof(FCAKeyRebindData, M_remap_id) == 0x000000, "Member 'FCAKeyRebindData::M_remap_id' has a wrong offset!");
static_assert(offsetof(FCAKeyRebindData, M_is_primary_slot) == 0x00000C, "Member 'FCAKeyRebindData::M_is_primary_slot' has a wrong offset!");
static_assert(offsetof(FCAKeyRebindData, M_key) == 0x000010, "Member 'FCAKeyRebindData::M_key' has a wrong offset!");

// ScriptStruct keaton.CAShipsVoiceRequestReplicated
// 0x0014 (0x0014 - 0x0000)
struct FCAShipsVoiceRequestReplicated final
{
public:
	float                                         Max_queue_time;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max_distance;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAAudioHashBase                       Group_name;                                        // 0x0008(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioHashBase                       Emitter_name;                                      // 0x000C(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCAHashableString                      Trigger;                                           // 0x0010(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAShipsVoiceRequestReplicated) == 0x000004, "Wrong alignment on FCAShipsVoiceRequestReplicated");
static_assert(sizeof(FCAShipsVoiceRequestReplicated) == 0x000014, "Wrong size on FCAShipsVoiceRequestReplicated");
static_assert(offsetof(FCAShipsVoiceRequestReplicated, Max_queue_time) == 0x000000, "Member 'FCAShipsVoiceRequestReplicated::Max_queue_time' has a wrong offset!");
static_assert(offsetof(FCAShipsVoiceRequestReplicated, Max_distance) == 0x000004, "Member 'FCAShipsVoiceRequestReplicated::Max_distance' has a wrong offset!");
static_assert(offsetof(FCAShipsVoiceRequestReplicated, Group_name) == 0x000008, "Member 'FCAShipsVoiceRequestReplicated::Group_name' has a wrong offset!");
static_assert(offsetof(FCAShipsVoiceRequestReplicated, Emitter_name) == 0x00000C, "Member 'FCAShipsVoiceRequestReplicated::Emitter_name' has a wrong offset!");
static_assert(offsetof(FCAShipsVoiceRequestReplicated, Trigger) == 0x000010, "Member 'FCAShipsVoiceRequestReplicated::Trigger' has a wrong offset!");

// ScriptStruct keaton.CAPlayerSetupData
// 0x00E8 (0x00E8 - 0x0000)
struct FCAPlayerSetupData final
{
public:
	bool                                          M_is_valid;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_ready;                                        // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_loaded;                                       // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_acknowledged;                                 // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_has_failed;                                      // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCATeamID                              M_team_id;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_player_name;                                     // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCASpecialistPrimaryDataAsset> M_specialisation;                                  // 0x0018(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_customisation_name;                              // 0x0048(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_specialist_name;                                 // 0x0054(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_ping_colour;                                     // 0x0060(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           M_emotes;                                          // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_sprays;                                          // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class FName                                   M_spawn_group_id;                                  // 0x0090(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_online_username;                                 // 0x009C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_online_username_hash;                            // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_input_method_is_controller;                      // 0x00AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_player_level;                                    // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_prestige_level;                                  // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_current_platform;                                // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_avatar_services_id;                              // 0x00C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           M_player_perks;                                    // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPlayerSetupData) == 0x000008, "Wrong alignment on FCAPlayerSetupData");
static_assert(sizeof(FCAPlayerSetupData) == 0x0000E8, "Wrong size on FCAPlayerSetupData");
static_assert(offsetof(FCAPlayerSetupData, M_is_valid) == 0x000000, "Member 'FCAPlayerSetupData::M_is_valid' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_is_ready) == 0x000001, "Member 'FCAPlayerSetupData::M_is_ready' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_is_loaded) == 0x000002, "Member 'FCAPlayerSetupData::M_is_loaded' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_is_acknowledged) == 0x000003, "Member 'FCAPlayerSetupData::M_is_acknowledged' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_has_failed) == 0x000004, "Member 'FCAPlayerSetupData::M_has_failed' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_team_id) == 0x000008, "Member 'FCAPlayerSetupData::M_team_id' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_player_name) == 0x00000C, "Member 'FCAPlayerSetupData::M_player_name' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_specialisation) == 0x000018, "Member 'FCAPlayerSetupData::M_specialisation' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_customisation_name) == 0x000048, "Member 'FCAPlayerSetupData::M_customisation_name' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_specialist_name) == 0x000054, "Member 'FCAPlayerSetupData::M_specialist_name' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_ping_colour) == 0x000060, "Member 'FCAPlayerSetupData::M_ping_colour' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_emotes) == 0x000070, "Member 'FCAPlayerSetupData::M_emotes' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_sprays) == 0x000080, "Member 'FCAPlayerSetupData::M_sprays' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_spawn_group_id) == 0x000090, "Member 'FCAPlayerSetupData::M_spawn_group_id' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_online_username) == 0x00009C, "Member 'FCAPlayerSetupData::M_online_username' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_online_username_hash) == 0x0000A8, "Member 'FCAPlayerSetupData::M_online_username_hash' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_input_method_is_controller) == 0x0000AC, "Member 'FCAPlayerSetupData::M_input_method_is_controller' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_player_level) == 0x0000B0, "Member 'FCAPlayerSetupData::M_player_level' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_prestige_level) == 0x0000B4, "Member 'FCAPlayerSetupData::M_prestige_level' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_current_platform) == 0x0000B8, "Member 'FCAPlayerSetupData::M_current_platform' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_avatar_services_id) == 0x0000C8, "Member 'FCAPlayerSetupData::M_avatar_services_id' has a wrong offset!");
static_assert(offsetof(FCAPlayerSetupData, M_player_perks) == 0x0000D8, "Member 'FCAPlayerSetupData::M_player_perks' has a wrong offset!");

// ScriptStruct keaton.CASpawner
// 0x0088 (0x0088 - 0x0000)
struct FCASpawner final
{
public:
	class AActor*                                 SpawnerActor;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpawnerType                                  Type;                                              // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpawnerTag;                                        // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECARespawnStationState                        SpawnerState;                                      // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StateEndTime;                                      // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StateDuration;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class ACAPlayerState*>                   PlayersToRespawn;                                  // 0x0028(0x0050)(NativeAccessSpecifierPublic)
	TArray<class AActor*>                         SpawnPoints;                                       // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASpawner) == 0x000008, "Wrong alignment on FCASpawner");
static_assert(sizeof(FCASpawner) == 0x000088, "Wrong size on FCASpawner");
static_assert(offsetof(FCASpawner, SpawnerActor) == 0x000000, "Member 'FCASpawner::SpawnerActor' has a wrong offset!");
static_assert(offsetof(FCASpawner, Type) == 0x000008, "Member 'FCASpawner::Type' has a wrong offset!");
static_assert(offsetof(FCASpawner, SpawnerTag) == 0x00000C, "Member 'FCASpawner::SpawnerTag' has a wrong offset!");
static_assert(offsetof(FCASpawner, SpawnerState) == 0x000018, "Member 'FCASpawner::SpawnerState' has a wrong offset!");
static_assert(offsetof(FCASpawner, StateEndTime) == 0x00001C, "Member 'FCASpawner::StateEndTime' has a wrong offset!");
static_assert(offsetof(FCASpawner, StateDuration) == 0x000020, "Member 'FCASpawner::StateDuration' has a wrong offset!");
static_assert(offsetof(FCASpawner, PlayersToRespawn) == 0x000028, "Member 'FCASpawner::PlayersToRespawn' has a wrong offset!");
static_assert(offsetof(FCASpawner, SpawnPoints) == 0x000078, "Member 'FCASpawner::SpawnPoints' has a wrong offset!");

// ScriptStruct keaton.CAPooledDecal
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FCAPooledDecal final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPooledDecal) == 0x000004, "Wrong alignment on FCAPooledDecal");
static_assert(sizeof(FCAPooledDecal) == 0x00000C, "Wrong size on FCAPooledDecal");

// ScriptStruct keaton.CAWinnerTeamInfo
// 0x0038 (0x0038 - 0x0000)
struct FCAWinnerTeamInfo final
{
public:
	struct FCATeamStats                           M_team_stats;                                      // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	struct FCATeamID                              M_winning_team;                                    // 0x0020(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAClientConnection>            M_disconnected_teammates_history;                  // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAWinnerTeamInfo) == 0x000008, "Wrong alignment on FCAWinnerTeamInfo");
static_assert(sizeof(FCAWinnerTeamInfo) == 0x000038, "Wrong size on FCAWinnerTeamInfo");
static_assert(offsetof(FCAWinnerTeamInfo, M_team_stats) == 0x000000, "Member 'FCAWinnerTeamInfo::M_team_stats' has a wrong offset!");
static_assert(offsetof(FCAWinnerTeamInfo, M_winning_team) == 0x000020, "Member 'FCAWinnerTeamInfo::M_winning_team' has a wrong offset!");
static_assert(offsetof(FCAWinnerTeamInfo, M_disconnected_teammates_history) == 0x000028, "Member 'FCAWinnerTeamInfo::M_disconnected_teammates_history' has a wrong offset!");

// ScriptStruct keaton.CAPowerUpMappingInfo
// 0x0028 (0x0028 - 0x0000)
struct FCAPowerUpMappingInfo final
{
public:
	struct FGameplayTag                           M_buff_tag;                                        // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            M_gameplay_effect_to_apply_to_target;              // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_gameplay_event_to_apply_to_target;               // 0x0018(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPowerUpMappingInfo) == 0x000008, "Wrong alignment on FCAPowerUpMappingInfo");
static_assert(sizeof(FCAPowerUpMappingInfo) == 0x000028, "Wrong size on FCAPowerUpMappingInfo");
static_assert(offsetof(FCAPowerUpMappingInfo, M_buff_tag) == 0x000000, "Member 'FCAPowerUpMappingInfo::M_buff_tag' has a wrong offset!");
static_assert(offsetof(FCAPowerUpMappingInfo, M_gameplay_effect_to_apply_to_target) == 0x000010, "Member 'FCAPowerUpMappingInfo::M_gameplay_effect_to_apply_to_target' has a wrong offset!");
static_assert(offsetof(FCAPowerUpMappingInfo, M_gameplay_event_to_apply_to_target) == 0x000018, "Member 'FCAPowerUpMappingInfo::M_gameplay_event_to_apply_to_target' has a wrong offset!");

// ScriptStruct keaton.CAPrimaryProgressionData
// 0x0038 (0x0038 - 0x0000)
struct FCAPrimaryProgressionData final
{
public:
	struct FCAText                                M_progression_label;                               // 0x0000(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          M_disable_progress_button;                         // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPrimaryProgressionData) == 0x000008, "Wrong alignment on FCAPrimaryProgressionData");
static_assert(sizeof(FCAPrimaryProgressionData) == 0x000038, "Wrong size on FCAPrimaryProgressionData");
static_assert(offsetof(FCAPrimaryProgressionData, M_progression_label) == 0x000000, "Member 'FCAPrimaryProgressionData::M_progression_label' has a wrong offset!");
static_assert(offsetof(FCAPrimaryProgressionData, M_disable_progress_button) == 0x000030, "Member 'FCAPrimaryProgressionData::M_disable_progress_button' has a wrong offset!");

// ScriptStruct keaton.CATimedMovementState
// 0x0038 (0x0038 - 0x0000)
struct FCATimedMovementState final
{
public:
	struct FCASynchronisedState                   M_Active;                                          // 0x0000(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCASynchronisedState                   M_Paused;                                          // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCASynchronisedState                   M_Hidden;                                          // 0x0010(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCASynchronisedState                   M_Authorised;                                      // 0x0018(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCASynchronisedState                   M_Disarmed;                                        // 0x0020(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCASynchronisedState                   M_Triggered;                                       // 0x0028(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCASynchronisedState                   M_Alerted;                                         // 0x0030(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATimedMovementState) == 0x000004, "Wrong alignment on FCATimedMovementState");
static_assert(sizeof(FCATimedMovementState) == 0x000038, "Wrong size on FCATimedMovementState");
static_assert(offsetof(FCATimedMovementState, M_Active) == 0x000000, "Member 'FCATimedMovementState::M_Active' has a wrong offset!");
static_assert(offsetof(FCATimedMovementState, M_Paused) == 0x000008, "Member 'FCATimedMovementState::M_Paused' has a wrong offset!");
static_assert(offsetof(FCATimedMovementState, M_Hidden) == 0x000010, "Member 'FCATimedMovementState::M_Hidden' has a wrong offset!");
static_assert(offsetof(FCATimedMovementState, M_Authorised) == 0x000018, "Member 'FCATimedMovementState::M_Authorised' has a wrong offset!");
static_assert(offsetof(FCATimedMovementState, M_Disarmed) == 0x000020, "Member 'FCATimedMovementState::M_Disarmed' has a wrong offset!");
static_assert(offsetof(FCATimedMovementState, M_Triggered) == 0x000028, "Member 'FCATimedMovementState::M_Triggered' has a wrong offset!");
static_assert(offsetof(FCATimedMovementState, M_Alerted) == 0x000030, "Member 'FCATimedMovementState::M_Alerted' has a wrong offset!");

// ScriptStruct keaton.ProcGenSocketData
// 0x0040 (0x0040 - 0x0000)
struct FProcGenSocketData final
{
public:
	struct FTransform                             M_socket_transform;                                // 0x0000(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   M_socket_tag;                                      // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProcGenSocketData) == 0x000010, "Wrong alignment on FProcGenSocketData");
static_assert(sizeof(FProcGenSocketData) == 0x000040, "Wrong size on FProcGenSocketData");
static_assert(offsetof(FProcGenSocketData, M_socket_transform) == 0x000000, "Member 'FProcGenSocketData::M_socket_transform' has a wrong offset!");
static_assert(offsetof(FProcGenSocketData, M_socket_tag) == 0x000030, "Member 'FProcGenSocketData::M_socket_tag' has a wrong offset!");

// ScriptStruct keaton.ObjectDataEntry
// 0x0020 (0x0020 - 0x0000)
struct FObjectDataEntry final
{
public:
	TSubclassOf<class AActor>                     M_device_class;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_place_probability;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_object_spread;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_max_objects;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_socket_name;                                     // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectDataEntry) == 0x000008, "Wrong alignment on FObjectDataEntry");
static_assert(sizeof(FObjectDataEntry) == 0x000020, "Wrong size on FObjectDataEntry");
static_assert(offsetof(FObjectDataEntry, M_device_class) == 0x000000, "Member 'FObjectDataEntry::M_device_class' has a wrong offset!");
static_assert(offsetof(FObjectDataEntry, M_place_probability) == 0x000008, "Member 'FObjectDataEntry::M_place_probability' has a wrong offset!");
static_assert(offsetof(FObjectDataEntry, M_object_spread) == 0x00000C, "Member 'FObjectDataEntry::M_object_spread' has a wrong offset!");
static_assert(offsetof(FObjectDataEntry, M_max_objects) == 0x000010, "Member 'FObjectDataEntry::M_max_objects' has a wrong offset!");
static_assert(offsetof(FObjectDataEntry, M_socket_name) == 0x000014, "Member 'FObjectDataEntry::M_socket_name' has a wrong offset!");

// ScriptStruct keaton.ProcGenObjectData
// 0x0010 (0x0018 - 0x0008)
struct FProcGenObjectData final : public FTableRowBase
{
public:
	TArray<struct FObjectDataEntry>               M_data_entry;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProcGenObjectData) == 0x000008, "Wrong alignment on FProcGenObjectData");
static_assert(sizeof(FProcGenObjectData) == 0x000018, "Wrong size on FProcGenObjectData");
static_assert(offsetof(FProcGenObjectData, M_data_entry) == 0x000008, "Member 'FProcGenObjectData::M_data_entry' has a wrong offset!");

// ScriptStruct keaton.CATransitionProgress
// 0x0008 (0x0008 - 0x0000)
struct FCATransitionProgress final
{
public:
	float                                         M_progress;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_desired_active;                                  // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_force_state;                                     // 0x0005(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_paused;                                          // 0x0006(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_disabled;                                        // 0x0007(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATransitionProgress) == 0x000004, "Wrong alignment on FCATransitionProgress");
static_assert(sizeof(FCATransitionProgress) == 0x000008, "Wrong size on FCATransitionProgress");
static_assert(offsetof(FCATransitionProgress, M_progress) == 0x000000, "Member 'FCATransitionProgress::M_progress' has a wrong offset!");
static_assert(offsetof(FCATransitionProgress, M_desired_active) == 0x000004, "Member 'FCATransitionProgress::M_desired_active' has a wrong offset!");
static_assert(offsetof(FCATransitionProgress, M_force_state) == 0x000005, "Member 'FCATransitionProgress::M_force_state' has a wrong offset!");
static_assert(offsetof(FCATransitionProgress, M_paused) == 0x000006, "Member 'FCATransitionProgress::M_paused' has a wrong offset!");
static_assert(offsetof(FCATransitionProgress, M_disabled) == 0x000007, "Member 'FCATransitionProgress::M_disabled' has a wrong offset!");

// ScriptStruct keaton.CABattleStatContext
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FCABattleStatContext final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCABattleStatContext) == 0x000004, "Wrong alignment on FCABattleStatContext");
static_assert(sizeof(FCABattleStatContext) == 0x000004, "Wrong size on FCABattleStatContext");

// ScriptStruct keaton.CAReplicateProjectileData
// 0x00B0 (0x00B0 - 0x0000)
struct FCAReplicateProjectileData final
{
public:
	struct FHitResult                             M_detonation_request_hit;                          // 0x0000(0x0090)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ECAAOEProjectileEventType                     M_projectile_state;                                // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECAAOEProjectileEventType>             M_projectile_state_history;                        // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAReplicateProjectileData) == 0x000008, "Wrong alignment on FCAReplicateProjectileData");
static_assert(sizeof(FCAReplicateProjectileData) == 0x0000B0, "Wrong size on FCAReplicateProjectileData");
static_assert(offsetof(FCAReplicateProjectileData, M_detonation_request_hit) == 0x000000, "Member 'FCAReplicateProjectileData::M_detonation_request_hit' has a wrong offset!");
static_assert(offsetof(FCAReplicateProjectileData, M_projectile_state) == 0x000090, "Member 'FCAReplicateProjectileData::M_projectile_state' has a wrong offset!");
static_assert(offsetof(FCAReplicateProjectileData, M_projectile_state_history) == 0x000098, "Member 'FCAReplicateProjectileData::M_projectile_state_history' has a wrong offset!");

// ScriptStruct keaton.CAPathPredictionData
// 0x0070 (0x0070 - 0x0000)
struct FCAPathPredictionData final
{
public:
	TSubclassOf<class ACAProjectileBase>          M_projectile_class;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_start_location;                                  // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_start_velocity;                                  // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_distance;                                    // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_gravity_multiplier;                              // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_gravity_search_iterations;                       // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_ignore_actor;                                    // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_add_prediction_arc_launch_offset;                // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_prediction_arc_launch_offset;                    // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_sweep_radius_scale;                              // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_time_step;                                       // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_debug;                                           // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_max_bounces;                                     // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_stop_after_first_zero_g_collision;               // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_stop_after_target_normal_collision;              // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_tactical_level;                                  // 0x005A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x1];                                       // 0x005B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_target_normal;                                   // 0x005C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_target_normal_dot_product_minimum_tolerance;     // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_bounce_friction_coefficient;                     // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPathPredictionData) == 0x000008, "Wrong alignment on FCAPathPredictionData");
static_assert(sizeof(FCAPathPredictionData) == 0x000070, "Wrong size on FCAPathPredictionData");
static_assert(offsetof(FCAPathPredictionData, M_projectile_class) == 0x000000, "Member 'FCAPathPredictionData::M_projectile_class' has a wrong offset!");
static_assert(offsetof(FCAPathPredictionData, M_start_location) == 0x000008, "Member 'FCAPathPredictionData::M_start_location' has a wrong offset!");
static_assert(offsetof(FCAPathPredictionData, M_start_velocity) == 0x000014, "Member 'FCAPathPredictionData::M_start_velocity' has a wrong offset!");
static_assert(offsetof(FCAPathPredictionData, M_max_distance) == 0x000020, "Member 'FCAPathPredictionData::M_max_distance' has a wrong offset!");
static_assert(offsetof(FCAPathPredictionData, M_gravity_multiplier) == 0x000024, "Member 'FCAPathPredictionData::M_gravity_multiplier' has a wrong offset!");
static_assert(offsetof(FCAPathPredictionData, M_gravity_search_iterations) == 0x000028, "Member 'FCAPathPredictionData::M_gravity_search_iterations' has a wrong offset!");
static_assert(offsetof(FCAPathPredictionData, M_ignore_actor) == 0x000030, "Member 'FCAPathPredictionData::M_ignore_actor' has a wrong offset!");
static_assert(offsetof(FCAPathPredictionData, M_add_prediction_arc_launch_offset) == 0x000038, "Member 'FCAPathPredictionData::M_add_prediction_arc_launch_offset' has a wrong offset!");
static_assert(offsetof(FCAPathPredictionData, M_prediction_arc_launch_offset) == 0x00003C, "Member 'FCAPathPredictionData::M_prediction_arc_launch_offset' has a wrong offset!");
static_assert(offsetof(FCAPathPredictionData, M_sweep_radius_scale) == 0x000048, "Member 'FCAPathPredictionData::M_sweep_radius_scale' has a wrong offset!");
static_assert(offsetof(FCAPathPredictionData, M_time_step) == 0x00004C, "Member 'FCAPathPredictionData::M_time_step' has a wrong offset!");
static_assert(offsetof(FCAPathPredictionData, M_debug) == 0x000050, "Member 'FCAPathPredictionData::M_debug' has a wrong offset!");
static_assert(offsetof(FCAPathPredictionData, M_max_bounces) == 0x000054, "Member 'FCAPathPredictionData::M_max_bounces' has a wrong offset!");
static_assert(offsetof(FCAPathPredictionData, M_stop_after_first_zero_g_collision) == 0x000058, "Member 'FCAPathPredictionData::M_stop_after_first_zero_g_collision' has a wrong offset!");
static_assert(offsetof(FCAPathPredictionData, M_stop_after_target_normal_collision) == 0x000059, "Member 'FCAPathPredictionData::M_stop_after_target_normal_collision' has a wrong offset!");
static_assert(offsetof(FCAPathPredictionData, M_tactical_level) == 0x00005A, "Member 'FCAPathPredictionData::M_tactical_level' has a wrong offset!");
static_assert(offsetof(FCAPathPredictionData, M_target_normal) == 0x00005C, "Member 'FCAPathPredictionData::M_target_normal' has a wrong offset!");
static_assert(offsetof(FCAPathPredictionData, M_target_normal_dot_product_minimum_tolerance) == 0x000068, "Member 'FCAPathPredictionData::M_target_normal_dot_product_minimum_tolerance' has a wrong offset!");
static_assert(offsetof(FCAPathPredictionData, M_bounce_friction_coefficient) == 0x00006C, "Member 'FCAPathPredictionData::M_bounce_friction_coefficient' has a wrong offset!");

// ScriptStruct keaton.ProjectilePathResult
// 0x0020 (0x0020 - 0x0000)
struct FProjectilePathResult final
{
public:
	TArray<struct FProjectilePathVertex>          M_path_vertex_array;                               // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_collided;                                        // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_collision_hit_normal;                            // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectilePathResult) == 0x000008, "Wrong alignment on FProjectilePathResult");
static_assert(sizeof(FProjectilePathResult) == 0x000020, "Wrong size on FProjectilePathResult");
static_assert(offsetof(FProjectilePathResult, M_path_vertex_array) == 0x000000, "Member 'FProjectilePathResult::M_path_vertex_array' has a wrong offset!");
static_assert(offsetof(FProjectilePathResult, M_collided) == 0x000010, "Member 'FProjectilePathResult::M_collided' has a wrong offset!");
static_assert(offsetof(FProjectilePathResult, M_collision_hit_normal) == 0x000014, "Member 'FProjectilePathResult::M_collision_hit_normal' has a wrong offset!");

// ScriptStruct keaton.CAServicesItemEventContainer
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FCAServicesItemEventContainer final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAServicesItemEventContainer) == 0x000008, "Wrong alignment on FCAServicesItemEventContainer");
static_assert(sizeof(FCAServicesItemEventContainer) == 0x000010, "Wrong size on FCAServicesItemEventContainer");

// ScriptStruct keaton.CAAnimatedDeath
// 0x0003 (0x0003 - 0x0000)
struct FCAAnimatedDeath final
{
public:
	ECADeathType                                  M_type;                                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAReactionDirection                          M_direction;                                       // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAReactionState                              M_state;                                           // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAnimatedDeath) == 0x000001, "Wrong alignment on FCAAnimatedDeath");
static_assert(sizeof(FCAAnimatedDeath) == 0x000003, "Wrong size on FCAAnimatedDeath");
static_assert(offsetof(FCAAnimatedDeath, M_type) == 0x000000, "Member 'FCAAnimatedDeath::M_type' has a wrong offset!");
static_assert(offsetof(FCAAnimatedDeath, M_direction) == 0x000001, "Member 'FCAAnimatedDeath::M_direction' has a wrong offset!");
static_assert(offsetof(FCAAnimatedDeath, M_state) == 0x000002, "Member 'FCAAnimatedDeath::M_state' has a wrong offset!");

// ScriptStruct keaton.CAAnimatedReaction
// 0x0010 (0x0010 - 0x0000)
struct FCAAnimatedReaction final
{
public:
	ECAReactionType                               M_type;                                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAReactionDirection                          M_direction;                                       // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAReactionState                              M_state;                                           // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_gameplay_tag;                                    // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAAnimatedReaction) == 0x000004, "Wrong alignment on FCAAnimatedReaction");
static_assert(sizeof(FCAAnimatedReaction) == 0x000010, "Wrong size on FCAAnimatedReaction");
static_assert(offsetof(FCAAnimatedReaction, M_type) == 0x000000, "Member 'FCAAnimatedReaction::M_type' has a wrong offset!");
static_assert(offsetof(FCAAnimatedReaction, M_direction) == 0x000001, "Member 'FCAAnimatedReaction::M_direction' has a wrong offset!");
static_assert(offsetof(FCAAnimatedReaction, M_state) == 0x000002, "Member 'FCAAnimatedReaction::M_state' has a wrong offset!");
static_assert(offsetof(FCAAnimatedReaction, M_gameplay_tag) == 0x000004, "Member 'FCAAnimatedReaction::M_gameplay_tag' has a wrong offset!");

// ScriptStruct keaton.ShipAIMissionSelectionStruct
// 0x001C (0x001C - 0x0000)
struct FShipAIMissionSelectionStruct final
{
public:
	uint32                                        M_mission_table_index;                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_mission_index;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_wave_group_index;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_wave_index;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_npc_task_group_index;                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_motivation_activation_phase_index;               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_randomness_iteration_id;                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShipAIMissionSelectionStruct) == 0x000004, "Wrong alignment on FShipAIMissionSelectionStruct");
static_assert(sizeof(FShipAIMissionSelectionStruct) == 0x00001C, "Wrong size on FShipAIMissionSelectionStruct");
static_assert(offsetof(FShipAIMissionSelectionStruct, M_mission_table_index) == 0x000000, "Member 'FShipAIMissionSelectionStruct::M_mission_table_index' has a wrong offset!");
static_assert(offsetof(FShipAIMissionSelectionStruct, M_mission_index) == 0x000004, "Member 'FShipAIMissionSelectionStruct::M_mission_index' has a wrong offset!");
static_assert(offsetof(FShipAIMissionSelectionStruct, M_wave_group_index) == 0x000008, "Member 'FShipAIMissionSelectionStruct::M_wave_group_index' has a wrong offset!");
static_assert(offsetof(FShipAIMissionSelectionStruct, M_wave_index) == 0x00000C, "Member 'FShipAIMissionSelectionStruct::M_wave_index' has a wrong offset!");
static_assert(offsetof(FShipAIMissionSelectionStruct, M_npc_task_group_index) == 0x000010, "Member 'FShipAIMissionSelectionStruct::M_npc_task_group_index' has a wrong offset!");
static_assert(offsetof(FShipAIMissionSelectionStruct, M_motivation_activation_phase_index) == 0x000014, "Member 'FShipAIMissionSelectionStruct::M_motivation_activation_phase_index' has a wrong offset!");
static_assert(offsetof(FShipAIMissionSelectionStruct, M_randomness_iteration_id) == 0x000018, "Member 'FShipAIMissionSelectionStruct::M_randomness_iteration_id' has a wrong offset!");

// ScriptStruct keaton.CAStateMachineDefinition
// 0x00B8 (0x00C0 - 0x0008)
struct FCAStateMachineDefinition final : public FTableRowBase
{
public:
	class FName                                   InitialDefaultState;                               // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  EntryTags;                                         // 0x0018(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          CanSelfPerform;                                    // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyNextBeforeRemovingPrevious;                   // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FCAFiniteStateDefinition> States;                                            // 0x0040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCAStateMachineDefinitionDataAsset> DefinitionAsset;                                   // 0x0090(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAStateMachineDefinition) == 0x000008, "Wrong alignment on FCAStateMachineDefinition");
static_assert(sizeof(FCAStateMachineDefinition) == 0x0000C0, "Wrong size on FCAStateMachineDefinition");
static_assert(offsetof(FCAStateMachineDefinition, InitialDefaultState) == 0x000008, "Member 'FCAStateMachineDefinition::InitialDefaultState' has a wrong offset!");
static_assert(offsetof(FCAStateMachineDefinition, EntryTags) == 0x000018, "Member 'FCAStateMachineDefinition::EntryTags' has a wrong offset!");
static_assert(offsetof(FCAStateMachineDefinition, CanSelfPerform) == 0x000038, "Member 'FCAStateMachineDefinition::CanSelfPerform' has a wrong offset!");
static_assert(offsetof(FCAStateMachineDefinition, ApplyNextBeforeRemovingPrevious) == 0x000039, "Member 'FCAStateMachineDefinition::ApplyNextBeforeRemovingPrevious' has a wrong offset!");
static_assert(offsetof(FCAStateMachineDefinition, States) == 0x000040, "Member 'FCAStateMachineDefinition::States' has a wrong offset!");
static_assert(offsetof(FCAStateMachineDefinition, DefinitionAsset) == 0x000090, "Member 'FCAStateMachineDefinition::DefinitionAsset' has a wrong offset!");

// ScriptStruct keaton.CARepGraphSettings
// 0x0018 (0x0018 - 0x0000)
struct FCARepGraphSettings final
{
public:
	ECARepGraphRoutingPolicy                      Routing_policy;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        Replication_period;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance_priority_scale;                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Starvation_priority_scale;                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Net_cull_distance;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priority_bias;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARepGraphSettings) == 0x000004, "Wrong alignment on FCARepGraphSettings");
static_assert(sizeof(FCARepGraphSettings) == 0x000018, "Wrong size on FCARepGraphSettings");
static_assert(offsetof(FCARepGraphSettings, Routing_policy) == 0x000000, "Member 'FCARepGraphSettings::Routing_policy' has a wrong offset!");
static_assert(offsetof(FCARepGraphSettings, Replication_period) == 0x000004, "Member 'FCARepGraphSettings::Replication_period' has a wrong offset!");
static_assert(offsetof(FCARepGraphSettings, Distance_priority_scale) == 0x000008, "Member 'FCARepGraphSettings::Distance_priority_scale' has a wrong offset!");
static_assert(offsetof(FCARepGraphSettings, Starvation_priority_scale) == 0x00000C, "Member 'FCARepGraphSettings::Starvation_priority_scale' has a wrong offset!");
static_assert(offsetof(FCARepGraphSettings, Net_cull_distance) == 0x000010, "Member 'FCARepGraphSettings::Net_cull_distance' has a wrong offset!");
static_assert(offsetof(FCARepGraphSettings, Priority_bias) == 0x000014, "Member 'FCARepGraphSettings::Priority_bias' has a wrong offset!");

// ScriptStruct keaton.ForcedRelevantConnections
// 0x0010 (0x0010 - 0x0000)
struct FForcedRelevantConnections final
{
public:
	TArray<class UNetConnection*>                 List;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FForcedRelevantConnections) == 0x000008, "Wrong alignment on FForcedRelevantConnections");
static_assert(sizeof(FForcedRelevantConnections) == 0x000010, "Wrong size on FForcedRelevantConnections");
static_assert(offsetof(FForcedRelevantConnections, List) == 0x000000, "Member 'FForcedRelevantConnections::List' has a wrong offset!");

// ScriptStruct keaton.CADebugWCLevelInfo
// 0x001C (0x001C - 0x0000)
struct FCADebugWCLevelInfo final
{
public:
	struct FVector                                Origin;                                            // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_visible;                                        // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADebugWCLevelInfo) == 0x000004, "Wrong alignment on FCADebugWCLevelInfo");
static_assert(sizeof(FCADebugWCLevelInfo) == 0x00001C, "Wrong size on FCADebugWCLevelInfo");
static_assert(offsetof(FCADebugWCLevelInfo, Origin) == 0x000000, "Member 'FCADebugWCLevelInfo::Origin' has a wrong offset!");
static_assert(offsetof(FCADebugWCLevelInfo, Extent) == 0x00000C, "Member 'FCADebugWCLevelInfo::Extent' has a wrong offset!");
static_assert(offsetof(FCADebugWCLevelInfo, Is_visible) == 0x000018, "Member 'FCADebugWCLevelInfo::Is_visible' has a wrong offset!");

// ScriptStruct keaton.CADebugSpatialWCActorInfo
// 0x0030 (0x0030 - 0x0000)
struct FCADebugSpatialWCActorInfo final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Frames_since_rep;                                  // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Channel_index;                                     // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Wants_to_be_dormant;                               // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_dormant;                                        // 0x002D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCADebugSpatialWCActorInfo) == 0x000004, "Wrong alignment on FCADebugSpatialWCActorInfo");
static_assert(sizeof(FCADebugSpatialWCActorInfo) == 0x000030, "Wrong size on FCADebugSpatialWCActorInfo");
static_assert(offsetof(FCADebugSpatialWCActorInfo, Location) == 0x000000, "Member 'FCADebugSpatialWCActorInfo::Location' has a wrong offset!");
static_assert(offsetof(FCADebugSpatialWCActorInfo, Origin) == 0x00000C, "Member 'FCADebugSpatialWCActorInfo::Origin' has a wrong offset!");
static_assert(offsetof(FCADebugSpatialWCActorInfo, Extent) == 0x000018, "Member 'FCADebugSpatialWCActorInfo::Extent' has a wrong offset!");
static_assert(offsetof(FCADebugSpatialWCActorInfo, Frames_since_rep) == 0x000024, "Member 'FCADebugSpatialWCActorInfo::Frames_since_rep' has a wrong offset!");
static_assert(offsetof(FCADebugSpatialWCActorInfo, Channel_index) == 0x000028, "Member 'FCADebugSpatialWCActorInfo::Channel_index' has a wrong offset!");
static_assert(offsetof(FCADebugSpatialWCActorInfo, Wants_to_be_dormant) == 0x00002C, "Member 'FCADebugSpatialWCActorInfo::Wants_to_be_dormant' has a wrong offset!");
static_assert(offsetof(FCADebugSpatialWCActorInfo, Is_dormant) == 0x00002D, "Member 'FCADebugSpatialWCActorInfo::Is_dormant' has a wrong offset!");

// ScriptStruct keaton.CADebugSpatialGridActorInfo
// 0x0028 (0x0028 - 0x0000)
struct FCADebugSpatialGridActorInfo final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Net_cull_distance;                                 // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADebugSpatialGridActorInfo) == 0x000004, "Wrong alignment on FCADebugSpatialGridActorInfo");
static_assert(sizeof(FCADebugSpatialGridActorInfo) == 0x000028, "Wrong size on FCADebugSpatialGridActorInfo");
static_assert(offsetof(FCADebugSpatialGridActorInfo, Location) == 0x000000, "Member 'FCADebugSpatialGridActorInfo::Location' has a wrong offset!");
static_assert(offsetof(FCADebugSpatialGridActorInfo, Origin) == 0x00000C, "Member 'FCADebugSpatialGridActorInfo::Origin' has a wrong offset!");
static_assert(offsetof(FCADebugSpatialGridActorInfo, Extent) == 0x000018, "Member 'FCADebugSpatialGridActorInfo::Extent' has a wrong offset!");
static_assert(offsetof(FCADebugSpatialGridActorInfo, Net_cull_distance) == 0x000024, "Member 'FCADebugSpatialGridActorInfo::Net_cull_distance' has a wrong offset!");

// ScriptStruct keaton.CACachedSpatialActorInfo
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FCACachedSpatialActorInfo final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCACachedSpatialActorInfo) == 0x000004, "Wrong alignment on FCACachedSpatialActorInfo");
static_assert(sizeof(FCACachedSpatialActorInfo) == 0x00001C, "Wrong size on FCACachedSpatialActorInfo");

// ScriptStruct keaton.LevelsForActor
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FLevelsForActor final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelsForActor) == 0x000008, "Wrong alignment on FLevelsForActor");
static_assert(sizeof(FLevelsForActor) == 0x000040, "Wrong size on FLevelsForActor");

// ScriptStruct keaton.CABPNPCsToSpawnOnRequest
// 0x0050 (0x0050 - 0x0000)
struct FCABPNPCsToSpawnOnRequest final
{
public:
	TMap<ECANPCType, int32>                       M_npcs_to_spawn;                                   // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCABPNPCsToSpawnOnRequest) == 0x000008, "Wrong alignment on FCABPNPCsToSpawnOnRequest");
static_assert(sizeof(FCABPNPCsToSpawnOnRequest) == 0x000050, "Wrong size on FCABPNPCsToSpawnOnRequest");
static_assert(offsetof(FCABPNPCsToSpawnOnRequest, M_npcs_to_spawn) == 0x000000, "Member 'FCABPNPCsToSpawnOnRequest::M_npcs_to_spawn' has a wrong offset!");

// ScriptStruct keaton.CABPNPCSpawnRequestData
// 0x0098 (0x0098 - 0x0000)
struct FCABPNPCSpawnRequestData final
{
public:
	class AActor*                                 M_owner;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_location;                                        // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECANPCType, int32>                       M_npcs_to_spawn;                                   // 0x0018(0x0050)(Edit, NativeAccessSpecifierPublic)
	class UEnvQuery*                              M_npc_teleport_in_spawn_location_query;            // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ACACharacter_NPC*>               M_preexisting_npcs;                                // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_max_npc_count;                                   // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_max_npc_token_value;                             // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_total_spawning_duration;                     // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_seconds_between_spawn_requests;                  // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x4];                                       // 0x0090(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_spawn_in_combat;                                 // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCABPNPCSpawnRequestData) == 0x000008, "Wrong alignment on FCABPNPCSpawnRequestData");
static_assert(sizeof(FCABPNPCSpawnRequestData) == 0x000098, "Wrong size on FCABPNPCSpawnRequestData");
static_assert(offsetof(FCABPNPCSpawnRequestData, M_owner) == 0x000000, "Member 'FCABPNPCSpawnRequestData::M_owner' has a wrong offset!");
static_assert(offsetof(FCABPNPCSpawnRequestData, M_location) == 0x000008, "Member 'FCABPNPCSpawnRequestData::M_location' has a wrong offset!");
static_assert(offsetof(FCABPNPCSpawnRequestData, M_npcs_to_spawn) == 0x000018, "Member 'FCABPNPCSpawnRequestData::M_npcs_to_spawn' has a wrong offset!");
static_assert(offsetof(FCABPNPCSpawnRequestData, M_npc_teleport_in_spawn_location_query) == 0x000068, "Member 'FCABPNPCSpawnRequestData::M_npc_teleport_in_spawn_location_query' has a wrong offset!");
static_assert(offsetof(FCABPNPCSpawnRequestData, M_preexisting_npcs) == 0x000070, "Member 'FCABPNPCSpawnRequestData::M_preexisting_npcs' has a wrong offset!");
static_assert(offsetof(FCABPNPCSpawnRequestData, M_max_npc_count) == 0x000080, "Member 'FCABPNPCSpawnRequestData::M_max_npc_count' has a wrong offset!");
static_assert(offsetof(FCABPNPCSpawnRequestData, M_max_npc_token_value) == 0x000084, "Member 'FCABPNPCSpawnRequestData::M_max_npc_token_value' has a wrong offset!");
static_assert(offsetof(FCABPNPCSpawnRequestData, M_max_total_spawning_duration) == 0x000088, "Member 'FCABPNPCSpawnRequestData::M_max_total_spawning_duration' has a wrong offset!");
static_assert(offsetof(FCABPNPCSpawnRequestData, M_seconds_between_spawn_requests) == 0x00008C, "Member 'FCABPNPCSpawnRequestData::M_seconds_between_spawn_requests' has a wrong offset!");
static_assert(offsetof(FCABPNPCSpawnRequestData, M_spawn_in_combat) == 0x000094, "Member 'FCABPNPCSpawnRequestData::M_spawn_in_combat' has a wrong offset!");

// ScriptStruct keaton.CARewardDistributionRuleData
// 0x0050 (0x0058 - 0x0008)
struct FCARewardDistributionRuleData final : public FTableRowBase
{
public:
	bool                                          M_enabled;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UCARewardDistributionRuleCriteria>> M_rule_criteria;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bool_match;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECARewardDistributionRuleOperationType        M_operation_type;                                  // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECARewardDistributionRuleOperationTargetType  M_operation_target_type;                           // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   M_given_operation_target_tags;                     // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UCARewardTagSelectionCriteria> M_tag_selection_criteria;                          // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_operation_parameter_given_value;                 // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCARewardDistributionRuleData) == 0x000008, "Wrong alignment on FCARewardDistributionRuleData");
static_assert(sizeof(FCARewardDistributionRuleData) == 0x000058, "Wrong size on FCARewardDistributionRuleData");
static_assert(offsetof(FCARewardDistributionRuleData, M_enabled) == 0x000008, "Member 'FCARewardDistributionRuleData::M_enabled' has a wrong offset!");
static_assert(offsetof(FCARewardDistributionRuleData, M_rule_criteria) == 0x000010, "Member 'FCARewardDistributionRuleData::M_rule_criteria' has a wrong offset!");
static_assert(offsetof(FCARewardDistributionRuleData, M_bool_match) == 0x000030, "Member 'FCARewardDistributionRuleData::M_bool_match' has a wrong offset!");
static_assert(offsetof(FCARewardDistributionRuleData, M_operation_type) == 0x000031, "Member 'FCARewardDistributionRuleData::M_operation_type' has a wrong offset!");
static_assert(offsetof(FCARewardDistributionRuleData, M_operation_target_type) == 0x000032, "Member 'FCARewardDistributionRuleData::M_operation_target_type' has a wrong offset!");
static_assert(offsetof(FCARewardDistributionRuleData, M_given_operation_target_tags) == 0x000038, "Member 'FCARewardDistributionRuleData::M_given_operation_target_tags' has a wrong offset!");
static_assert(offsetof(FCARewardDistributionRuleData, M_tag_selection_criteria) == 0x000048, "Member 'FCARewardDistributionRuleData::M_tag_selection_criteria' has a wrong offset!");
static_assert(offsetof(FCARewardDistributionRuleData, M_operation_parameter_given_value) == 0x000050, "Member 'FCARewardDistributionRuleData::M_operation_parameter_given_value' has a wrong offset!");

// ScriptStruct keaton.CARewardSetAndRulesData
// 0x0020 (0x0020 - 0x0000)
struct FCARewardSetAndRulesData final
{
public:
	TArray<struct FCARewardSetData>               M_reward_set;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCARewardDistributionRuleData>  M_rules;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARewardSetAndRulesData) == 0x000008, "Wrong alignment on FCARewardSetAndRulesData");
static_assert(sizeof(FCARewardSetAndRulesData) == 0x000020, "Wrong size on FCARewardSetAndRulesData");
static_assert(offsetof(FCARewardSetAndRulesData, M_reward_set) == 0x000000, "Member 'FCARewardSetAndRulesData::M_reward_set' has a wrong offset!");
static_assert(offsetof(FCARewardSetAndRulesData, M_rules) == 0x000010, "Member 'FCARewardSetAndRulesData::M_rules' has a wrong offset!");

// ScriptStruct keaton.CAGetRewardsRequest
// 0x00F0 (0x00F0 - 0x0000)
struct alignas(0x10) FCAGetRewardsRequest final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_reward_source;                                   // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCARewardSetAndRulesData               M_reward_set_and_rules;                            // 0x0068(0x0020)(NativeAccessSpecifierPublic)
	struct FCARewardSetData                       M_selected_reward_set_option;                      // 0x0088(0x0048)(NativeAccessSpecifierPublic)
	TArray<class UObject*>                        M_rewards;                                         // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAGetRewardsRequest) == 0x000010, "Wrong alignment on FCAGetRewardsRequest");
static_assert(sizeof(FCAGetRewardsRequest) == 0x0000F0, "Wrong size on FCAGetRewardsRequest");
static_assert(offsetof(FCAGetRewardsRequest, M_reward_source) == 0x000040, "Member 'FCAGetRewardsRequest::M_reward_source' has a wrong offset!");
static_assert(offsetof(FCAGetRewardsRequest, M_reward_set_and_rules) == 0x000068, "Member 'FCAGetRewardsRequest::M_reward_set_and_rules' has a wrong offset!");
static_assert(offsetof(FCAGetRewardsRequest, M_selected_reward_set_option) == 0x000088, "Member 'FCAGetRewardsRequest::M_selected_reward_set_option' has a wrong offset!");
static_assert(offsetof(FCAGetRewardsRequest, M_rewards) == 0x0000D0, "Member 'FCAGetRewardsRequest::M_rewards' has a wrong offset!");

// ScriptStruct keaton.CAServicesSlotTableRow
// 0x0048 (0x0050 - 0x0008)
struct FCAServicesSlotTableRow final : public FTableRowBase
{
public:
	struct FCAGameDatabaseRowHandle               M_equipped_option;                                 // 0x0008(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	ECAServicesSlot                               M_slot_type;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAServicesSlotOption>          M_options;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAServicesSlotTableRow) == 0x000008, "Wrong alignment on FCAServicesSlotTableRow");
static_assert(sizeof(FCAServicesSlotTableRow) == 0x000050, "Wrong size on FCAServicesSlotTableRow");
static_assert(offsetof(FCAServicesSlotTableRow, M_equipped_option) == 0x000008, "Member 'FCAServicesSlotTableRow::M_equipped_option' has a wrong offset!");
static_assert(offsetof(FCAServicesSlotTableRow, M_slot_type) == 0x000020, "Member 'FCAServicesSlotTableRow::M_slot_type' has a wrong offset!");
static_assert(offsetof(FCAServicesSlotTableRow, M_options) == 0x000028, "Member 'FCAServicesSlotTableRow::M_options' has a wrong offset!");

// ScriptStruct keaton.CARewardTypeDataCount
// 0x00A0 (0x00A0 - 0x0000)
struct FCARewardTypeDataCount final
{
public:
	struct FCARewardTypeData                      M_reward_type_data;                                // 0x0000(0x0098)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	int32                                         M_count;                                           // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCARewardTypeDataCount) == 0x000008, "Wrong alignment on FCARewardTypeDataCount");
static_assert(sizeof(FCARewardTypeDataCount) == 0x0000A0, "Wrong size on FCARewardTypeDataCount");
static_assert(offsetof(FCARewardTypeDataCount, M_reward_type_data) == 0x000000, "Member 'FCARewardTypeDataCount::M_reward_type_data' has a wrong offset!");
static_assert(offsetof(FCARewardTypeDataCount, M_count) == 0x000098, "Member 'FCARewardTypeDataCount::M_count' has a wrong offset!");

// ScriptStruct keaton.CAPickUpDropRewardsRegistryData
// 0x0020 (0x0020 - 0x0000)
struct FCAPickUpDropRewardsRegistryData final
{
public:
	class UCAInventoryItem*                       M_item;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_player;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_location;                                        // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPickUpDropRewardsRegistryData) == 0x000008, "Wrong alignment on FCAPickUpDropRewardsRegistryData");
static_assert(sizeof(FCAPickUpDropRewardsRegistryData) == 0x000020, "Wrong size on FCAPickUpDropRewardsRegistryData");
static_assert(offsetof(FCAPickUpDropRewardsRegistryData, M_item) == 0x000000, "Member 'FCAPickUpDropRewardsRegistryData::M_item' has a wrong offset!");
static_assert(offsetof(FCAPickUpDropRewardsRegistryData, M_player) == 0x000008, "Member 'FCAPickUpDropRewardsRegistryData::M_player' has a wrong offset!");
static_assert(offsetof(FCAPickUpDropRewardsRegistryData, M_location) == 0x000010, "Member 'FCAPickUpDropRewardsRegistryData::M_location' has a wrong offset!");

// ScriptStruct keaton.CAItemProgressionSetItemCountData
// 0x0010 (0x0010 - 0x0000)
struct FCAItemProgressionSetItemCountData final
{
public:
	class UCAInventoryItem*                       M_item_type;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_count;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAItemProgressionSetItemCountData) == 0x000008, "Wrong alignment on FCAItemProgressionSetItemCountData");
static_assert(sizeof(FCAItemProgressionSetItemCountData) == 0x000010, "Wrong size on FCAItemProgressionSetItemCountData");
static_assert(offsetof(FCAItemProgressionSetItemCountData, M_item_type) == 0x000000, "Member 'FCAItemProgressionSetItemCountData::M_item_type' has a wrong offset!");
static_assert(offsetof(FCAItemProgressionSetItemCountData, M_count) == 0x000008, "Member 'FCAItemProgressionSetItemCountData::M_count' has a wrong offset!");

// ScriptStruct keaton.CAItemProgressionSetData
// 0x0018 (0x0020 - 0x0008)
struct FCAItemProgressionSetData final : public FTableRowBase
{
public:
	bool                                          M_enabled;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAItemProgressionSetSubjectType              M_subject_type;                                    // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAItemProgressionSetItemCountData> M_item_progression;                                // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAItemProgressionSetData) == 0x000008, "Wrong alignment on FCAItemProgressionSetData");
static_assert(sizeof(FCAItemProgressionSetData) == 0x000020, "Wrong size on FCAItemProgressionSetData");
static_assert(offsetof(FCAItemProgressionSetData, M_enabled) == 0x000008, "Member 'FCAItemProgressionSetData::M_enabled' has a wrong offset!");
static_assert(offsetof(FCAItemProgressionSetData, M_subject_type) == 0x000009, "Member 'FCAItemProgressionSetData::M_subject_type' has a wrong offset!");
static_assert(offsetof(FCAItemProgressionSetData, M_item_progression) == 0x000010, "Member 'FCAItemProgressionSetData::M_item_progression' has a wrong offset!");

// ScriptStruct keaton.CAPlayerGuidanceLevelRuleData
// 0x0020 (0x0028 - 0x0008)
struct FCAPlayerGuidanceLevelRuleData final : public FTableRowBase
{
public:
	bool                                          M_enabled;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UCAPlayerGuidanceLevelRuleCriteria>> M_rule_criteria;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         M_weight_addition;                                 // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPlayerGuidanceLevelRuleData) == 0x000008, "Wrong alignment on FCAPlayerGuidanceLevelRuleData");
static_assert(sizeof(FCAPlayerGuidanceLevelRuleData) == 0x000028, "Wrong size on FCAPlayerGuidanceLevelRuleData");
static_assert(offsetof(FCAPlayerGuidanceLevelRuleData, M_enabled) == 0x000008, "Member 'FCAPlayerGuidanceLevelRuleData::M_enabled' has a wrong offset!");
static_assert(offsetof(FCAPlayerGuidanceLevelRuleData, M_rule_criteria) == 0x000010, "Member 'FCAPlayerGuidanceLevelRuleData::M_rule_criteria' has a wrong offset!");
static_assert(offsetof(FCAPlayerGuidanceLevelRuleData, M_weight_addition) == 0x000020, "Member 'FCAPlayerGuidanceLevelRuleData::M_weight_addition' has a wrong offset!");

// ScriptStruct keaton.CAApplicableSecurityModulesCacheIDStruct
// 0x0020 (0x0020 - 0x0000)
struct FCAApplicableSecurityModulesCacheIDStruct final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_reward_source;                                   // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAApplicableSecurityModulesCacheIDStruct) == 0x000008, "Wrong alignment on FCAApplicableSecurityModulesCacheIDStruct");
static_assert(sizeof(FCAApplicableSecurityModulesCacheIDStruct) == 0x000020, "Wrong size on FCAApplicableSecurityModulesCacheIDStruct");
static_assert(offsetof(FCAApplicableSecurityModulesCacheIDStruct, M_reward_source) == 0x000008, "Member 'FCAApplicableSecurityModulesCacheIDStruct::M_reward_source' has a wrong offset!");

// ScriptStruct keaton.ScreenshotFiles
// 0x0020 (0x0020 - 0x0000)
struct FScreenshotFiles final
{
public:
	TArray<class FString>                         M_template_paths;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FScreenshotData>                M_all_screenshots;                                 // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotFiles) == 0x000008, "Wrong alignment on FScreenshotFiles");
static_assert(sizeof(FScreenshotFiles) == 0x000020, "Wrong size on FScreenshotFiles");
static_assert(offsetof(FScreenshotFiles, M_template_paths) == 0x000000, "Member 'FScreenshotFiles::M_template_paths' has a wrong offset!");
static_assert(offsetof(FScreenshotFiles, M_all_screenshots) == 0x000010, "Member 'FScreenshotFiles::M_all_screenshots' has a wrong offset!");

// ScriptStruct keaton.CALayoutRequest
// 0x0004 (0x0004 - 0x0000)
struct FCALayoutRequest final
{
public:
	struct FCAGameDatabaseTypedRowHandle          M_handle;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCALayoutRequest) == 0x000004, "Wrong alignment on FCALayoutRequest");
static_assert(sizeof(FCALayoutRequest) == 0x000004, "Wrong size on FCALayoutRequest");
static_assert(offsetof(FCALayoutRequest, M_handle) == 0x000000, "Member 'FCALayoutRequest::M_handle' has a wrong offset!");

// ScriptStruct keaton.CampLevelConfigs
// 0x0030 (0x0030 - 0x0000)
struct FCampLevelConfigs final
{
public:
	struct FGameplayTag                           M_camp_config;                                     // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           M_levels_to_load;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_loot_config;                                     // 0x0020(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCampLevelConfigs) == 0x000008, "Wrong alignment on FCampLevelConfigs");
static_assert(sizeof(FCampLevelConfigs) == 0x000030, "Wrong size on FCampLevelConfigs");
static_assert(offsetof(FCampLevelConfigs, M_camp_config) == 0x000000, "Member 'FCampLevelConfigs::M_camp_config' has a wrong offset!");
static_assert(offsetof(FCampLevelConfigs, M_levels_to_load) == 0x000010, "Member 'FCampLevelConfigs::M_levels_to_load' has a wrong offset!");
static_assert(offsetof(FCampLevelConfigs, M_loot_config) == 0x000020, "Member 'FCampLevelConfigs::M_loot_config' has a wrong offset!");

// ScriptStruct keaton.CAPurchaseRecord
// 0x0030 (0x0030 - 0x0000)
struct FCAPurchaseRecord final
{
public:
	class FName                                   Services_key;                                      // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         M_total_currency;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         M_remaining_currency;                              // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         M_cost;                                            // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_success;                                         // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAPurchaseRecord) == 0x000008, "Wrong alignment on FCAPurchaseRecord");
static_assert(sizeof(FCAPurchaseRecord) == 0x000030, "Wrong size on FCAPurchaseRecord");
static_assert(offsetof(FCAPurchaseRecord, Services_key) == 0x000000, "Member 'FCAPurchaseRecord::Services_key' has a wrong offset!");
static_assert(offsetof(FCAPurchaseRecord, M_total_currency) == 0x000010, "Member 'FCAPurchaseRecord::M_total_currency' has a wrong offset!");
static_assert(offsetof(FCAPurchaseRecord, M_remaining_currency) == 0x000018, "Member 'FCAPurchaseRecord::M_remaining_currency' has a wrong offset!");
static_assert(offsetof(FCAPurchaseRecord, M_cost) == 0x000020, "Member 'FCAPurchaseRecord::M_cost' has a wrong offset!");
static_assert(offsetof(FCAPurchaseRecord, M_success) == 0x000028, "Member 'FCAPurchaseRecord::M_success' has a wrong offset!");

// ScriptStruct keaton.CARecentPlayer
// 0x0018 (0x0018 - 0x0000)
struct FCARecentPlayer final
{
public:
	class FString                                 M_user_id;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         M_last_seen_ts;                                    // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARecentPlayer) == 0x000008, "Wrong alignment on FCARecentPlayer");
static_assert(sizeof(FCARecentPlayer) == 0x000018, "Wrong size on FCARecentPlayer");
static_assert(offsetof(FCARecentPlayer, M_user_id) == 0x000000, "Member 'FCARecentPlayer::M_user_id' has a wrong offset!");
static_assert(offsetof(FCARecentPlayer, M_last_seen_ts) == 0x000010, "Member 'FCARecentPlayer::M_last_seen_ts' has a wrong offset!");

// ScriptStruct keaton.ServicesSpecialistLoadout
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FServicesSpecialistLoadout final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FServicesSpecialistLoadout) == 0x000008, "Wrong alignment on FServicesSpecialistLoadout");
static_assert(sizeof(FServicesSpecialistLoadout) == 0x000068, "Wrong size on FServicesSpecialistLoadout");

// ScriptStruct keaton.CAServicesAvatarTableRow
// 0x0048 (0x0050 - 0x0008)
struct FCAServicesAvatarTableRow final : public FTableRowBase
{
public:
	bool                                          M_is_disabled;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_owned;                                        // 0x0009(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_equip_me;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAObtainableOption>            M_obtain_options;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ECAAvailableVia                               M_available_via;                                   // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAGameDatabaseRowHandle               M_handle;                                          // 0x0034(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAServicesAvatarTableRow) == 0x000008, "Wrong alignment on FCAServicesAvatarTableRow");
static_assert(sizeof(FCAServicesAvatarTableRow) == 0x000050, "Wrong size on FCAServicesAvatarTableRow");
static_assert(offsetof(FCAServicesAvatarTableRow, M_is_disabled) == 0x000008, "Member 'FCAServicesAvatarTableRow::M_is_disabled' has a wrong offset!");
static_assert(offsetof(FCAServicesAvatarTableRow, M_is_owned) == 0x000009, "Member 'FCAServicesAvatarTableRow::M_is_owned' has a wrong offset!");
static_assert(offsetof(FCAServicesAvatarTableRow, M_equip_me) == 0x000010, "Member 'FCAServicesAvatarTableRow::M_equip_me' has a wrong offset!");
static_assert(offsetof(FCAServicesAvatarTableRow, M_obtain_options) == 0x000020, "Member 'FCAServicesAvatarTableRow::M_obtain_options' has a wrong offset!");
static_assert(offsetof(FCAServicesAvatarTableRow, M_available_via) == 0x000030, "Member 'FCAServicesAvatarTableRow::M_available_via' has a wrong offset!");
static_assert(offsetof(FCAServicesAvatarTableRow, M_handle) == 0x000034, "Member 'FCAServicesAvatarTableRow::M_handle' has a wrong offset!");

// ScriptStruct keaton.CAServicesPartyMemberTableRow
// 0x0090 (0x0098 - 0x0008)
struct FCAServicesPartyMemberTableRow final : public FTableRowBase
{
public:
	struct FCAGameDatabaseRowHandle               M_specialist_reference;                            // 0x0008(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_equipped_specialist_skin;                        // 0x0020(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_equipped_primary_weapon_skin;                    // 0x0038(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_equipped_primary_weapon_pendant;                 // 0x0050(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         M_player_level;                                    // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_prestige_level;                                  // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_equipped_avatar;                                 // 0x0070(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 M_active_platform;                                 // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAServicesPartyMemberTableRow) == 0x000008, "Wrong alignment on FCAServicesPartyMemberTableRow");
static_assert(sizeof(FCAServicesPartyMemberTableRow) == 0x000098, "Wrong size on FCAServicesPartyMemberTableRow");
static_assert(offsetof(FCAServicesPartyMemberTableRow, M_specialist_reference) == 0x000008, "Member 'FCAServicesPartyMemberTableRow::M_specialist_reference' has a wrong offset!");
static_assert(offsetof(FCAServicesPartyMemberTableRow, M_equipped_specialist_skin) == 0x000020, "Member 'FCAServicesPartyMemberTableRow::M_equipped_specialist_skin' has a wrong offset!");
static_assert(offsetof(FCAServicesPartyMemberTableRow, M_equipped_primary_weapon_skin) == 0x000038, "Member 'FCAServicesPartyMemberTableRow::M_equipped_primary_weapon_skin' has a wrong offset!");
static_assert(offsetof(FCAServicesPartyMemberTableRow, M_equipped_primary_weapon_pendant) == 0x000050, "Member 'FCAServicesPartyMemberTableRow::M_equipped_primary_weapon_pendant' has a wrong offset!");
static_assert(offsetof(FCAServicesPartyMemberTableRow, M_player_level) == 0x000068, "Member 'FCAServicesPartyMemberTableRow::M_player_level' has a wrong offset!");
static_assert(offsetof(FCAServicesPartyMemberTableRow, M_prestige_level) == 0x00006C, "Member 'FCAServicesPartyMemberTableRow::M_prestige_level' has a wrong offset!");
static_assert(offsetof(FCAServicesPartyMemberTableRow, M_equipped_avatar) == 0x000070, "Member 'FCAServicesPartyMemberTableRow::M_equipped_avatar' has a wrong offset!");
static_assert(offsetof(FCAServicesPartyMemberTableRow, M_active_platform) == 0x000088, "Member 'FCAServicesPartyMemberTableRow::M_active_platform' has a wrong offset!");

// ScriptStruct keaton.CAPlayerMetaProgression
// 0x0058 (0x0058 - 0x0000)
struct FCAPlayerMetaProgression final
{
public:
	class FText                                   M_rank_name;                                       // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         M_current_player_level;                            // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_current_xp_value;                                // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_next_level_xp_cost;                              // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              M_rank_icon;                                       // 0x0028(0x0030)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAPlayerMetaProgression) == 0x000008, "Wrong alignment on FCAPlayerMetaProgression");
static_assert(sizeof(FCAPlayerMetaProgression) == 0x000058, "Wrong size on FCAPlayerMetaProgression");
static_assert(offsetof(FCAPlayerMetaProgression, M_rank_name) == 0x000000, "Member 'FCAPlayerMetaProgression::M_rank_name' has a wrong offset!");
static_assert(offsetof(FCAPlayerMetaProgression, M_current_player_level) == 0x000018, "Member 'FCAPlayerMetaProgression::M_current_player_level' has a wrong offset!");
static_assert(offsetof(FCAPlayerMetaProgression, M_current_xp_value) == 0x00001C, "Member 'FCAPlayerMetaProgression::M_current_xp_value' has a wrong offset!");
static_assert(offsetof(FCAPlayerMetaProgression, M_next_level_xp_cost) == 0x000020, "Member 'FCAPlayerMetaProgression::M_next_level_xp_cost' has a wrong offset!");
static_assert(offsetof(FCAPlayerMetaProgression, M_rank_icon) == 0x000028, "Member 'FCAPlayerMetaProgression::M_rank_icon' has a wrong offset!");

// ScriptStruct keaton.CAServicesGameModeTableRow
// 0x0030 (0x0038 - 0x0008)
struct FCAServicesGameModeTableRow final : public FTableRowBase
{
public:
	bool                                          M_is_featured;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        M_display_order;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_default;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        M_max_party_size;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_min_party_size;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_recommended_player_level;                        // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        M_crews_number_in_game;                            // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         M_available_maps;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAServicesGameModeTableRow) == 0x000008, "Wrong alignment on FCAServicesGameModeTableRow");
static_assert(sizeof(FCAServicesGameModeTableRow) == 0x000038, "Wrong size on FCAServicesGameModeTableRow");
static_assert(offsetof(FCAServicesGameModeTableRow, M_is_featured) == 0x000008, "Member 'FCAServicesGameModeTableRow::M_is_featured' has a wrong offset!");
static_assert(offsetof(FCAServicesGameModeTableRow, M_display_order) == 0x00000C, "Member 'FCAServicesGameModeTableRow::M_display_order' has a wrong offset!");
static_assert(offsetof(FCAServicesGameModeTableRow, M_is_default) == 0x000010, "Member 'FCAServicesGameModeTableRow::M_is_default' has a wrong offset!");
static_assert(offsetof(FCAServicesGameModeTableRow, M_max_party_size) == 0x000014, "Member 'FCAServicesGameModeTableRow::M_max_party_size' has a wrong offset!");
static_assert(offsetof(FCAServicesGameModeTableRow, M_min_party_size) == 0x000018, "Member 'FCAServicesGameModeTableRow::M_min_party_size' has a wrong offset!");
static_assert(offsetof(FCAServicesGameModeTableRow, M_recommended_player_level) == 0x00001C, "Member 'FCAServicesGameModeTableRow::M_recommended_player_level' has a wrong offset!");
static_assert(offsetof(FCAServicesGameModeTableRow, M_crews_number_in_game) == 0x000020, "Member 'FCAServicesGameModeTableRow::M_crews_number_in_game' has a wrong offset!");
static_assert(offsetof(FCAServicesGameModeTableRow, M_available_maps) == 0x000028, "Member 'FCAServicesGameModeTableRow::M_available_maps' has a wrong offset!");

// ScriptStruct keaton.CAServicesPlayerLevel
// 0x0038 (0x0038 - 0x0000)
struct FCAServicesPlayerLevel final
{
public:
	struct FCAGameDatabaseRowHandle               M_handle;                                          // 0x0000(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int64                                         M_quantity;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         M_level_up_xp_threshold;                           // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_level_me;                                        // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAServicesPlayerLevel) == 0x000008, "Wrong alignment on FCAServicesPlayerLevel");
static_assert(sizeof(FCAServicesPlayerLevel) == 0x000038, "Wrong size on FCAServicesPlayerLevel");
static_assert(offsetof(FCAServicesPlayerLevel, M_handle) == 0x000000, "Member 'FCAServicesPlayerLevel::M_handle' has a wrong offset!");
static_assert(offsetof(FCAServicesPlayerLevel, M_quantity) == 0x000018, "Member 'FCAServicesPlayerLevel::M_quantity' has a wrong offset!");
static_assert(offsetof(FCAServicesPlayerLevel, M_level_up_xp_threshold) == 0x000020, "Member 'FCAServicesPlayerLevel::M_level_up_xp_threshold' has a wrong offset!");
static_assert(offsetof(FCAServicesPlayerLevel, M_level_me) == 0x000028, "Member 'FCAServicesPlayerLevel::M_level_me' has a wrong offset!");

// ScriptStruct keaton.CAServicesPlayerTableRow
// 0x00F8 (0x0100 - 0x0008)
struct FCAServicesPlayerTableRow final : public FTableRowBase
{
public:
	TArray<struct FCAServicesCheatCommand>        M_available_cheat_commands;                        // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_equipped_specialist;                             // 0x0018(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAGameDatabaseRowHandle               M_equipped_avatar;                                 // 0x0030(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FCAServicesPlayerCurrency>      M_player_currencies;                               // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAServicesPlayerLevel                 M_player_level;                                    // 0x0058(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAServicesPlayerLevel                 M_prestige_level;                                  // 0x0090(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 M_update_me;                                       // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_user_platform;                                   // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_voice_chat_enabled;                              // 0x00E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_target_leaderboard;                              // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAServicesPlayerTableRow) == 0x000008, "Wrong alignment on FCAServicesPlayerTableRow");
static_assert(sizeof(FCAServicesPlayerTableRow) == 0x000100, "Wrong size on FCAServicesPlayerTableRow");
static_assert(offsetof(FCAServicesPlayerTableRow, M_available_cheat_commands) == 0x000008, "Member 'FCAServicesPlayerTableRow::M_available_cheat_commands' has a wrong offset!");
static_assert(offsetof(FCAServicesPlayerTableRow, M_equipped_specialist) == 0x000018, "Member 'FCAServicesPlayerTableRow::M_equipped_specialist' has a wrong offset!");
static_assert(offsetof(FCAServicesPlayerTableRow, M_equipped_avatar) == 0x000030, "Member 'FCAServicesPlayerTableRow::M_equipped_avatar' has a wrong offset!");
static_assert(offsetof(FCAServicesPlayerTableRow, M_player_currencies) == 0x000048, "Member 'FCAServicesPlayerTableRow::M_player_currencies' has a wrong offset!");
static_assert(offsetof(FCAServicesPlayerTableRow, M_player_level) == 0x000058, "Member 'FCAServicesPlayerTableRow::M_player_level' has a wrong offset!");
static_assert(offsetof(FCAServicesPlayerTableRow, M_prestige_level) == 0x000090, "Member 'FCAServicesPlayerTableRow::M_prestige_level' has a wrong offset!");
static_assert(offsetof(FCAServicesPlayerTableRow, M_update_me) == 0x0000C8, "Member 'FCAServicesPlayerTableRow::M_update_me' has a wrong offset!");
static_assert(offsetof(FCAServicesPlayerTableRow, M_user_platform) == 0x0000D8, "Member 'FCAServicesPlayerTableRow::M_user_platform' has a wrong offset!");
static_assert(offsetof(FCAServicesPlayerTableRow, M_voice_chat_enabled) == 0x0000E8, "Member 'FCAServicesPlayerTableRow::M_voice_chat_enabled' has a wrong offset!");
static_assert(offsetof(FCAServicesPlayerTableRow, M_target_leaderboard) == 0x0000F0, "Member 'FCAServicesPlayerTableRow::M_target_leaderboard' has a wrong offset!");

// ScriptStruct keaton.CAServicesSpecialistTableRow
// 0x0088 (0x0090 - 0x0008)
struct FCAServicesSpecialistTableRow final : public FTableRowBase
{
public:
	struct FCAGameDatabaseRowHandle               M_specialist_reference;                            // 0x0008(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_slots;                                           // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 M_services_key;                                    // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_services_name;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_equip_me;                                        // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         M_services_item_id;                                // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_disabled;                                     // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_owned;                                        // 0x0069(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAEmoteOption>                 M_emotes;                                          // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCAObtainableOption>            M_obtain_options;                                  // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAServicesSpecialistTableRow) == 0x000008, "Wrong alignment on FCAServicesSpecialistTableRow");
static_assert(sizeof(FCAServicesSpecialistTableRow) == 0x000090, "Wrong size on FCAServicesSpecialistTableRow");
static_assert(offsetof(FCAServicesSpecialistTableRow, M_specialist_reference) == 0x000008, "Member 'FCAServicesSpecialistTableRow::M_specialist_reference' has a wrong offset!");
static_assert(offsetof(FCAServicesSpecialistTableRow, M_slots) == 0x000020, "Member 'FCAServicesSpecialistTableRow::M_slots' has a wrong offset!");
static_assert(offsetof(FCAServicesSpecialistTableRow, M_services_key) == 0x000030, "Member 'FCAServicesSpecialistTableRow::M_services_key' has a wrong offset!");
static_assert(offsetof(FCAServicesSpecialistTableRow, M_services_name) == 0x000040, "Member 'FCAServicesSpecialistTableRow::M_services_name' has a wrong offset!");
static_assert(offsetof(FCAServicesSpecialistTableRow, M_equip_me) == 0x000050, "Member 'FCAServicesSpecialistTableRow::M_equip_me' has a wrong offset!");
static_assert(offsetof(FCAServicesSpecialistTableRow, M_services_item_id) == 0x000060, "Member 'FCAServicesSpecialistTableRow::M_services_item_id' has a wrong offset!");
static_assert(offsetof(FCAServicesSpecialistTableRow, M_is_disabled) == 0x000068, "Member 'FCAServicesSpecialistTableRow::M_is_disabled' has a wrong offset!");
static_assert(offsetof(FCAServicesSpecialistTableRow, M_is_owned) == 0x000069, "Member 'FCAServicesSpecialistTableRow::M_is_owned' has a wrong offset!");
static_assert(offsetof(FCAServicesSpecialistTableRow, M_emotes) == 0x000070, "Member 'FCAServicesSpecialistTableRow::M_emotes' has a wrong offset!");
static_assert(offsetof(FCAServicesSpecialistTableRow, M_obtain_options) == 0x000080, "Member 'FCAServicesSpecialistTableRow::M_obtain_options' has a wrong offset!");

// ScriptStruct keaton.CASetBoolDelegate
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FCASetBoolDelegate final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(bool Value)>                   M_delegate_dynamic;                                // 0x0010(0x0014)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCASetBoolDelegate) == 0x000008, "Wrong alignment on FCASetBoolDelegate");
static_assert(sizeof(FCASetBoolDelegate) == 0x000028, "Wrong size on FCASetBoolDelegate");
static_assert(offsetof(FCASetBoolDelegate, M_delegate_dynamic) == 0x000010, "Member 'FCASetBoolDelegate::M_delegate_dynamic' has a wrong offset!");

// ScriptStruct keaton.CANumericLimitation
// 0x0008 (0x0008 - 0x0000)
struct FCANumericLimitation final
{
public:
	int32                                         M_max_mission_count;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECALimiter                                    M_limiter;                                         // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANumericLimitation) == 0x000004, "Wrong alignment on FCANumericLimitation");
static_assert(sizeof(FCANumericLimitation) == 0x000008, "Wrong size on FCANumericLimitation");
static_assert(offsetof(FCANumericLimitation, M_max_mission_count) == 0x000000, "Member 'FCANumericLimitation::M_max_mission_count' has a wrong offset!");
static_assert(offsetof(FCANumericLimitation, M_limiter) == 0x000004, "Member 'FCANumericLimitation::M_limiter' has a wrong offset!");

// ScriptStruct keaton.CAShipAIMissionData
// 0x01E8 (0x01F0 - 0x0008)
struct FCAShipAIMissionData final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x38];                                       // 0x0008(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_enabled;                                         // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   M_mission_activation_triggers;                     // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   M_mission_deactivation_non_despawn_triggers;       // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   M_mission_deactivation_triggers;                   // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ECAMissionAreaType                            M_mission_area_type;                               // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_npc_lod_enabled;                                 // 0x0079(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAInclusionSetting                    M_relevant_areas;                                  // 0x0080(0x0028)(NativeAccessSpecifierPublic)
	int32                                         M_time_between_trigger_activation_and_mission_initialization; // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_time_between_mission_end_and_npcs_despawning;    // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_mission_repeat_count;                            // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_time_between_mission_repeats;                    // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCANumericLimitation                   M_numeric_limitation;                              // 0x00B8(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         M_mission_count_increase_per_trigger_activation;   // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECANPCType, int32>                       M_max_npc_count;                                   // 0x00C8(0x0050)(NativeAccessSpecifierPublic)
	bool                                          M_can_take_extras;                                 // 0x0118(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_release_npcs_from_previous_wave_default_value;   // 0x0119(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A[0x6];                                      // 0x011A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAMissionWaveGroupData>        M_mission_wave_groups;                             // 0x0120(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCAMotivationActivationPhaseData> M_motivation_activation_phases;                    // 0x0130(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_spawn_in_combat_state;                           // 0x0140(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECANPCSpawnCoherencyType                      M_intra_mission_spawn_coherency_type;              // 0x0141(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_142[0x6];                                      // 0x0142(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              M_npc_squad_spawn_location_query;                  // 0x0148(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECANPCSpawnInterCoherencyType                 M_subsequent_npc_of_squad_coherency_type;          // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              M_subsequent_npc_spawn_location_query;             // 0x0158(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_spawn_facing_mission_objective_outer;            // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_contest_mission_objective_outer;                 // 0x0161(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_162[0x2];                                      // 0x0162(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_mission_wave_repeat_count;                       // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_time_between_mission_wave_repeats;               // 0x0168(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_time_between_this_wave_end_and_next_wave_start;  // 0x016C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_mission_wave_npc_replace_limit;                  // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_time_between_npc_replacements;                   // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   M_mission_wave_end_triggers;                       // 0x0178(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	int32                                         M_mission_wave_duration;                           // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_wait_for_entire_mission_wave_duration;           // 0x018C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_can_stream_spawn_npcs;                           // 0x018D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E[0x2];                                      // 0x018E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECANPCType, int32>                       M_mission_wave_replace_limit;                      // 0x0190(0x0050)(NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   M_additional_npc_squad_tags;                       // 0x01E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAShipAIMissionData) == 0x000008, "Wrong alignment on FCAShipAIMissionData");
static_assert(sizeof(FCAShipAIMissionData) == 0x0001F0, "Wrong size on FCAShipAIMissionData");
static_assert(offsetof(FCAShipAIMissionData, M_enabled) == 0x000040, "Member 'FCAShipAIMissionData::M_enabled' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_mission_activation_triggers) == 0x000048, "Member 'FCAShipAIMissionData::M_mission_activation_triggers' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_mission_deactivation_non_despawn_triggers) == 0x000058, "Member 'FCAShipAIMissionData::M_mission_deactivation_non_despawn_triggers' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_mission_deactivation_triggers) == 0x000068, "Member 'FCAShipAIMissionData::M_mission_deactivation_triggers' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_mission_area_type) == 0x000078, "Member 'FCAShipAIMissionData::M_mission_area_type' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_npc_lod_enabled) == 0x000079, "Member 'FCAShipAIMissionData::M_npc_lod_enabled' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_relevant_areas) == 0x000080, "Member 'FCAShipAIMissionData::M_relevant_areas' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_time_between_trigger_activation_and_mission_initialization) == 0x0000A8, "Member 'FCAShipAIMissionData::M_time_between_trigger_activation_and_mission_initialization' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_time_between_mission_end_and_npcs_despawning) == 0x0000AC, "Member 'FCAShipAIMissionData::M_time_between_mission_end_and_npcs_despawning' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_mission_repeat_count) == 0x0000B0, "Member 'FCAShipAIMissionData::M_mission_repeat_count' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_time_between_mission_repeats) == 0x0000B4, "Member 'FCAShipAIMissionData::M_time_between_mission_repeats' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_numeric_limitation) == 0x0000B8, "Member 'FCAShipAIMissionData::M_numeric_limitation' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_mission_count_increase_per_trigger_activation) == 0x0000C0, "Member 'FCAShipAIMissionData::M_mission_count_increase_per_trigger_activation' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_max_npc_count) == 0x0000C8, "Member 'FCAShipAIMissionData::M_max_npc_count' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_can_take_extras) == 0x000118, "Member 'FCAShipAIMissionData::M_can_take_extras' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_release_npcs_from_previous_wave_default_value) == 0x000119, "Member 'FCAShipAIMissionData::M_release_npcs_from_previous_wave_default_value' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_mission_wave_groups) == 0x000120, "Member 'FCAShipAIMissionData::M_mission_wave_groups' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_motivation_activation_phases) == 0x000130, "Member 'FCAShipAIMissionData::M_motivation_activation_phases' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_spawn_in_combat_state) == 0x000140, "Member 'FCAShipAIMissionData::M_spawn_in_combat_state' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_intra_mission_spawn_coherency_type) == 0x000141, "Member 'FCAShipAIMissionData::M_intra_mission_spawn_coherency_type' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_npc_squad_spawn_location_query) == 0x000148, "Member 'FCAShipAIMissionData::M_npc_squad_spawn_location_query' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_subsequent_npc_of_squad_coherency_type) == 0x000150, "Member 'FCAShipAIMissionData::M_subsequent_npc_of_squad_coherency_type' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_subsequent_npc_spawn_location_query) == 0x000158, "Member 'FCAShipAIMissionData::M_subsequent_npc_spawn_location_query' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_spawn_facing_mission_objective_outer) == 0x000160, "Member 'FCAShipAIMissionData::M_spawn_facing_mission_objective_outer' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_contest_mission_objective_outer) == 0x000161, "Member 'FCAShipAIMissionData::M_contest_mission_objective_outer' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_mission_wave_repeat_count) == 0x000164, "Member 'FCAShipAIMissionData::M_mission_wave_repeat_count' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_time_between_mission_wave_repeats) == 0x000168, "Member 'FCAShipAIMissionData::M_time_between_mission_wave_repeats' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_time_between_this_wave_end_and_next_wave_start) == 0x00016C, "Member 'FCAShipAIMissionData::M_time_between_this_wave_end_and_next_wave_start' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_mission_wave_npc_replace_limit) == 0x000170, "Member 'FCAShipAIMissionData::M_mission_wave_npc_replace_limit' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_time_between_npc_replacements) == 0x000174, "Member 'FCAShipAIMissionData::M_time_between_npc_replacements' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_mission_wave_end_triggers) == 0x000178, "Member 'FCAShipAIMissionData::M_mission_wave_end_triggers' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_mission_wave_duration) == 0x000188, "Member 'FCAShipAIMissionData::M_mission_wave_duration' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_wait_for_entire_mission_wave_duration) == 0x00018C, "Member 'FCAShipAIMissionData::M_wait_for_entire_mission_wave_duration' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_can_stream_spawn_npcs) == 0x00018D, "Member 'FCAShipAIMissionData::M_can_stream_spawn_npcs' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_mission_wave_replace_limit) == 0x000190, "Member 'FCAShipAIMissionData::M_mission_wave_replace_limit' has a wrong offset!");
static_assert(offsetof(FCAShipAIMissionData, M_additional_npc_squad_tags) == 0x0001E0, "Member 'FCAShipAIMissionData::M_additional_npc_squad_tags' has a wrong offset!");

// ScriptStruct keaton.AIPortalGraphAreaStateEntry
// 0x0030 (0x0030 - 0x0000)
struct FAIPortalGraphAreaStateEntry final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACACharacter_MainPlayer*>        M_current_players;                                 // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ACACharacter_MainPlayer*>        M_total_players;                                   // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIPortalGraphAreaStateEntry) == 0x000008, "Wrong alignment on FAIPortalGraphAreaStateEntry");
static_assert(sizeof(FAIPortalGraphAreaStateEntry) == 0x000030, "Wrong size on FAIPortalGraphAreaStateEntry");
static_assert(offsetof(FAIPortalGraphAreaStateEntry, M_current_players) == 0x000008, "Member 'FAIPortalGraphAreaStateEntry::M_current_players' has a wrong offset!");
static_assert(offsetof(FAIPortalGraphAreaStateEntry, M_total_players) == 0x000018, "Member 'FAIPortalGraphAreaStateEntry::M_total_players' has a wrong offset!");

// ScriptStruct keaton.CAShipWideEvent
// 0x0108 (0x0108 - 0x0000)
struct FCAShipWideEvent final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_event_name;                                      // 0x0004(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_enabled;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_only_runs_once_per_security_area;                // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_activation_delay;                                // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAShipWideEventTrigger                       M_trigger;                                         // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECASecurityAreaEnteredStateTriggerSubtype     M_security_area_enter_state_trigger_subtype;       // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_security_areas_enter_state_count;                // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCADataTableRowHandle                  M_state_machine_to_track_enter_state;              // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCAStateMachineDefinitionDataAsset> M_state_machine_to_track_enter_state_asset;        // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_state_to_track_name;                             // 0x0068(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_min_match_time_elapsed;                          // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_match_time_elapsed;                          // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAShipWideEventSecurityAreaQueryType         M_security_area_query_type;                        // 0x007C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCAShipWideEventSecurityAreaQuery> M_security_area_custom_query;                      // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCAShipWideEventCustomTriggerCondition> M_optional_trigger_condition;                      // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_security_area_types;                             // 0x0090(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_does_event_have_security_area_count_limit;       // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_limit_security_area_percentage;                  // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_can_event_override_other_events;                 // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_can_be_overriden_by_other_events;                // 0x00B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCAStateMachineDefinitionDataAsset> M_state_machine_to_run_asset;                      // 0x00C0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDataTable*>                     Npc_mission_tables;                                // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ECAMissionManagerInitializeMissionsMode       M_initialize_missions_mode;                        // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAShipWideEvent) == 0x000008, "Wrong alignment on FCAShipWideEvent");
static_assert(sizeof(FCAShipWideEvent) == 0x000108, "Wrong size on FCAShipWideEvent");
static_assert(offsetof(FCAShipWideEvent, M_event_name) == 0x000004, "Member 'FCAShipWideEvent::M_event_name' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_is_enabled) == 0x000010, "Member 'FCAShipWideEvent::M_is_enabled' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_only_runs_once_per_security_area) == 0x000011, "Member 'FCAShipWideEvent::M_only_runs_once_per_security_area' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_activation_delay) == 0x000014, "Member 'FCAShipWideEvent::M_activation_delay' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_trigger) == 0x000018, "Member 'FCAShipWideEvent::M_trigger' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_security_area_enter_state_trigger_subtype) == 0x000019, "Member 'FCAShipWideEvent::M_security_area_enter_state_trigger_subtype' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_security_areas_enter_state_count) == 0x00001C, "Member 'FCAShipWideEvent::M_security_areas_enter_state_count' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_state_machine_to_track_enter_state) == 0x000020, "Member 'FCAShipWideEvent::M_state_machine_to_track_enter_state' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_state_machine_to_track_enter_state_asset) == 0x000038, "Member 'FCAShipWideEvent::M_state_machine_to_track_enter_state_asset' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_state_to_track_name) == 0x000068, "Member 'FCAShipWideEvent::M_state_to_track_name' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_min_match_time_elapsed) == 0x000074, "Member 'FCAShipWideEvent::M_min_match_time_elapsed' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_max_match_time_elapsed) == 0x000078, "Member 'FCAShipWideEvent::M_max_match_time_elapsed' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_security_area_query_type) == 0x00007C, "Member 'FCAShipWideEvent::M_security_area_query_type' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_security_area_custom_query) == 0x000080, "Member 'FCAShipWideEvent::M_security_area_custom_query' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_optional_trigger_condition) == 0x000088, "Member 'FCAShipWideEvent::M_optional_trigger_condition' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_security_area_types) == 0x000090, "Member 'FCAShipWideEvent::M_security_area_types' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_does_event_have_security_area_count_limit) == 0x0000B0, "Member 'FCAShipWideEvent::M_does_event_have_security_area_count_limit' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_limit_security_area_percentage) == 0x0000B4, "Member 'FCAShipWideEvent::M_limit_security_area_percentage' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_can_event_override_other_events) == 0x0000B8, "Member 'FCAShipWideEvent::M_can_event_override_other_events' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_can_be_overriden_by_other_events) == 0x0000B9, "Member 'FCAShipWideEvent::M_can_be_overriden_by_other_events' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_state_machine_to_run_asset) == 0x0000C0, "Member 'FCAShipWideEvent::M_state_machine_to_run_asset' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, Npc_mission_tables) == 0x0000F0, "Member 'FCAShipWideEvent::Npc_mission_tables' has a wrong offset!");
static_assert(offsetof(FCAShipWideEvent, M_initialize_missions_mode) == 0x000100, "Member 'FCAShipWideEvent::M_initialize_missions_mode' has a wrong offset!");

// ScriptStruct keaton.CAItemLevelUpData
// 0x0040 (0x0040 - 0x0000)
struct FCAItemLevelUpData final
{
public:
	TSoftObjectPtr<class UCAInventoryItem>        M_inventory_item;                                  // 0x0000(0x0030)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAItemLevelUpDefinition>       M_item_levels;                                     // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAItemLevelUpData) == 0x000008, "Wrong alignment on FCAItemLevelUpData");
static_assert(sizeof(FCAItemLevelUpData) == 0x000040, "Wrong size on FCAItemLevelUpData");
static_assert(offsetof(FCAItemLevelUpData, M_inventory_item) == 0x000000, "Member 'FCAItemLevelUpData::M_inventory_item' has a wrong offset!");
static_assert(offsetof(FCAItemLevelUpData, M_item_levels) == 0x000030, "Member 'FCAItemLevelUpData::M_item_levels' has a wrong offset!");

// ScriptStruct keaton.CASocialNotificationQueueItem
// 0x0050 (0x0050 - 0x0000)
struct FCASocialNotificationQueueItem final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCANotificationRequest                 M_request;                                         // 0x0020(0x0018)(NativeAccessSpecifierPublic)
	TDelegate<void(ECADialogueResult Result, const class FString& Guid)> M_callback;                                        // 0x0038(0x0014)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCASocialNotificationQueueItem) == 0x000008, "Wrong alignment on FCASocialNotificationQueueItem");
static_assert(sizeof(FCASocialNotificationQueueItem) == 0x000050, "Wrong size on FCASocialNotificationQueueItem");
static_assert(offsetof(FCASocialNotificationQueueItem, M_request) == 0x000020, "Member 'FCASocialNotificationQueueItem::M_request' has a wrong offset!");
static_assert(offsetof(FCASocialNotificationQueueItem, M_callback) == 0x000038, "Member 'FCASocialNotificationQueueItem::M_callback' has a wrong offset!");

// ScriptStruct keaton.CASpatialActorData
// 0x0028 (0x0028 - 0x0000)
struct FCASpatialActorData final
{
public:
	int32                                         M_zone_id;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    M_primitive;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCACharacterMovementComponent*          M_movement_component;                              // 0x0010(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_force;                                           // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCASpatialActorData) == 0x000008, "Wrong alignment on FCASpatialActorData");
static_assert(sizeof(FCASpatialActorData) == 0x000028, "Wrong size on FCASpatialActorData");
static_assert(offsetof(FCASpatialActorData, M_zone_id) == 0x000000, "Member 'FCASpatialActorData::M_zone_id' has a wrong offset!");
static_assert(offsetof(FCASpatialActorData, M_primitive) == 0x000008, "Member 'FCASpatialActorData::M_primitive' has a wrong offset!");
static_assert(offsetof(FCASpatialActorData, M_movement_component) == 0x000010, "Member 'FCASpatialActorData::M_movement_component' has a wrong offset!");
static_assert(offsetof(FCASpatialActorData, M_force) == 0x000018, "Member 'FCASpatialActorData::M_force' has a wrong offset!");

// ScriptStruct keaton.PackingOffsetDefinition
// 0x0010 (0x0018 - 0x0008)
struct FPackingOffsetDefinition final : public FTableRowBase
{
public:
	struct FVector2D                              M_circle_offset;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              M_square_offset;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPackingOffsetDefinition) == 0x000008, "Wrong alignment on FPackingOffsetDefinition");
static_assert(sizeof(FPackingOffsetDefinition) == 0x000018, "Wrong size on FPackingOffsetDefinition");
static_assert(offsetof(FPackingOffsetDefinition, M_circle_offset) == 0x000008, "Member 'FPackingOffsetDefinition::M_circle_offset' has a wrong offset!");
static_assert(offsetof(FPackingOffsetDefinition, M_square_offset) == 0x000010, "Member 'FPackingOffsetDefinition::M_square_offset' has a wrong offset!");

// ScriptStruct keaton.CASpawnHelpers
// 0x0010 (0x0010 - 0x0000)
struct FCASpawnHelpers final
{
public:
	TArray<struct FCASpawnNPCTypeLookup>          Entries;                                           // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCASpawnHelpers) == 0x000008, "Wrong alignment on FCASpawnHelpers");
static_assert(sizeof(FCASpawnHelpers) == 0x000010, "Wrong size on FCASpawnHelpers");
static_assert(offsetof(FCASpawnHelpers, Entries) == 0x000000, "Member 'FCASpawnHelpers::Entries' has a wrong offset!");

// ScriptStruct keaton.CASpecialistUIItem
// 0x02F0 (0x02F8 - 0x0008)
struct FCASpecialistUIItem final : public FTableRowBase
{
public:
	int32                                         M_sort_priority;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_display_name;                                    // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_display_title;                                   // 0x0040(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_mini_bio;                                        // 0x0070(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_intro_bio;                                       // 0x00A0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_role;                                            // 0x00D0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_small_specialist_icon;                           // 0x0100(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_large_specialist_icon;                           // 0x0130(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_specialist_portrait;                             // 0x0160(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_specialist_ability_icon;                         // 0x0190(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCAFrontendCharacterAnimSlots> M_animations;                                      // 0x01C0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_anim_blueprint;                                  // 0x01F0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAUIInfoEntry>                 M_additional_info;                                 // 0x0220(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMediaSource>            M_specialist_video;                                // 0x0230(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_specialist_video_thumbnail;                      // 0x0260(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_specialist_video_disabled;                       // 0x0290(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAText                                M_specialist_disguised_as_enemy_name;              // 0x0298(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAText                                M_specialist_disguised_as_teammate_name;           // 0x02C8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASpecialistUIItem) == 0x000008, "Wrong alignment on FCASpecialistUIItem");
static_assert(sizeof(FCASpecialistUIItem) == 0x0002F8, "Wrong size on FCASpecialistUIItem");
static_assert(offsetof(FCASpecialistUIItem, M_sort_priority) == 0x000008, "Member 'FCASpecialistUIItem::M_sort_priority' has a wrong offset!");
static_assert(offsetof(FCASpecialistUIItem, M_display_name) == 0x000010, "Member 'FCASpecialistUIItem::M_display_name' has a wrong offset!");
static_assert(offsetof(FCASpecialistUIItem, M_display_title) == 0x000040, "Member 'FCASpecialistUIItem::M_display_title' has a wrong offset!");
static_assert(offsetof(FCASpecialistUIItem, M_mini_bio) == 0x000070, "Member 'FCASpecialistUIItem::M_mini_bio' has a wrong offset!");
static_assert(offsetof(FCASpecialistUIItem, M_intro_bio) == 0x0000A0, "Member 'FCASpecialistUIItem::M_intro_bio' has a wrong offset!");
static_assert(offsetof(FCASpecialistUIItem, M_role) == 0x0000D0, "Member 'FCASpecialistUIItem::M_role' has a wrong offset!");
static_assert(offsetof(FCASpecialistUIItem, M_small_specialist_icon) == 0x000100, "Member 'FCASpecialistUIItem::M_small_specialist_icon' has a wrong offset!");
static_assert(offsetof(FCASpecialistUIItem, M_large_specialist_icon) == 0x000130, "Member 'FCASpecialistUIItem::M_large_specialist_icon' has a wrong offset!");
static_assert(offsetof(FCASpecialistUIItem, M_specialist_portrait) == 0x000160, "Member 'FCASpecialistUIItem::M_specialist_portrait' has a wrong offset!");
static_assert(offsetof(FCASpecialistUIItem, M_specialist_ability_icon) == 0x000190, "Member 'FCASpecialistUIItem::M_specialist_ability_icon' has a wrong offset!");
static_assert(offsetof(FCASpecialistUIItem, M_animations) == 0x0001C0, "Member 'FCASpecialistUIItem::M_animations' has a wrong offset!");
static_assert(offsetof(FCASpecialistUIItem, M_anim_blueprint) == 0x0001F0, "Member 'FCASpecialistUIItem::M_anim_blueprint' has a wrong offset!");
static_assert(offsetof(FCASpecialistUIItem, M_additional_info) == 0x000220, "Member 'FCASpecialistUIItem::M_additional_info' has a wrong offset!");
static_assert(offsetof(FCASpecialistUIItem, M_specialist_video) == 0x000230, "Member 'FCASpecialistUIItem::M_specialist_video' has a wrong offset!");
static_assert(offsetof(FCASpecialistUIItem, M_specialist_video_thumbnail) == 0x000260, "Member 'FCASpecialistUIItem::M_specialist_video_thumbnail' has a wrong offset!");
static_assert(offsetof(FCASpecialistUIItem, M_specialist_video_disabled) == 0x000290, "Member 'FCASpecialistUIItem::M_specialist_video_disabled' has a wrong offset!");
static_assert(offsetof(FCASpecialistUIItem, M_specialist_disguised_as_enemy_name) == 0x000298, "Member 'FCASpecialistUIItem::M_specialist_disguised_as_enemy_name' has a wrong offset!");
static_assert(offsetof(FCASpecialistUIItem, M_specialist_disguised_as_teammate_name) == 0x0002C8, "Member 'FCASpecialistUIItem::M_specialist_disguised_as_teammate_name' has a wrong offset!");

// ScriptStruct keaton.CASquadMemberTypeRecord
// 0x0048 (0x0048 - 0x0000)
struct FCASquadMemberTypeRecord final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAMemberTaskMotivationActivationPhaseData> M_member_tasks;                                    // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x28];                                      // 0x0020(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCASquadMemberTypeRecord) == 0x000008, "Wrong alignment on FCASquadMemberTypeRecord");
static_assert(sizeof(FCASquadMemberTypeRecord) == 0x000048, "Wrong size on FCASquadMemberTypeRecord");
static_assert(offsetof(FCASquadMemberTypeRecord, M_member_tasks) == 0x000010, "Member 'FCASquadMemberTypeRecord::M_member_tasks' has a wrong offset!");

// ScriptStruct keaton.CASubtitlesTextSizeConfig
// 0x0008 (0x0008 - 0x0000)
struct FCASubtitlesTextSizeConfig final
{
public:
	ECASubtitlesTextSize                          M_size;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_font_size;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASubtitlesTextSizeConfig) == 0x000004, "Wrong alignment on FCASubtitlesTextSizeConfig");
static_assert(sizeof(FCASubtitlesTextSizeConfig) == 0x000008, "Wrong size on FCASubtitlesTextSizeConfig");
static_assert(offsetof(FCASubtitlesTextSizeConfig, M_size) == 0x000000, "Member 'FCASubtitlesTextSizeConfig::M_size' has a wrong offset!");
static_assert(offsetof(FCASubtitlesTextSizeConfig, M_font_size) == 0x000004, "Member 'FCASubtitlesTextSizeConfig::M_font_size' has a wrong offset!");

// ScriptStruct keaton.CASysAreaID
// 0x0004 (0x0004 - 0x0000)
struct FCASysAreaID final
{
public:
	int32                                         M_id;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASysAreaID) == 0x000004, "Wrong alignment on FCASysAreaID");
static_assert(sizeof(FCASysAreaID) == 0x000004, "Wrong size on FCASysAreaID");
static_assert(offsetof(FCASysAreaID, M_id) == 0x000000, "Member 'FCASysAreaID::M_id' has a wrong offset!");

// ScriptStruct keaton.CACachedAIActors
// 0x0078 (0x0078 - 0x0000)
struct FCACachedAIActors final
{
public:
	class AActor*                                 M_area;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         M_doors;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         M_vaults;                                          // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         M_extractions;                                     // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         M_mission_objectives;                              // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         M_loot;                                            // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         M_jobs;                                            // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         M_intel_terminals;                                 // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCACachedAIActors) == 0x000008, "Wrong alignment on FCACachedAIActors");
static_assert(sizeof(FCACachedAIActors) == 0x000078, "Wrong size on FCACachedAIActors");
static_assert(offsetof(FCACachedAIActors, M_area) == 0x000000, "Member 'FCACachedAIActors::M_area' has a wrong offset!");
static_assert(offsetof(FCACachedAIActors, M_doors) == 0x000008, "Member 'FCACachedAIActors::M_doors' has a wrong offset!");
static_assert(offsetof(FCACachedAIActors, M_vaults) == 0x000018, "Member 'FCACachedAIActors::M_vaults' has a wrong offset!");
static_assert(offsetof(FCACachedAIActors, M_extractions) == 0x000028, "Member 'FCACachedAIActors::M_extractions' has a wrong offset!");
static_assert(offsetof(FCACachedAIActors, M_mission_objectives) == 0x000038, "Member 'FCACachedAIActors::M_mission_objectives' has a wrong offset!");
static_assert(offsetof(FCACachedAIActors, M_loot) == 0x000048, "Member 'FCACachedAIActors::M_loot' has a wrong offset!");
static_assert(offsetof(FCACachedAIActors, M_jobs) == 0x000058, "Member 'FCACachedAIActors::M_jobs' has a wrong offset!");
static_assert(offsetof(FCACachedAIActors, M_intel_terminals) == 0x000068, "Member 'FCACachedAIActors::M_intel_terminals' has a wrong offset!");

// ScriptStruct keaton.SysSensorCallbackFunctionHandle
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FSysSensorCallbackFunctionHandle final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSysSensorCallbackFunctionHandle) == 0x000008, "Wrong alignment on FSysSensorCallbackFunctionHandle");
static_assert(sizeof(FSysSensorCallbackFunctionHandle) == 0x000008, "Wrong size on FSysSensorCallbackFunctionHandle");

// ScriptStruct keaton.SysSensorEventCallbackFunction
// 0x0014 (0x0014 - 0x0000)
struct FSysSensorEventCallbackFunction final
{
public:
	TDelegate<void(struct FSysSensorEventDataBase& Area_event_callback_data)> M_callback;                                        // 0x0000(0x0014)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSysSensorEventCallbackFunction) == 0x000004, "Wrong alignment on FSysSensorEventCallbackFunction");
static_assert(sizeof(FSysSensorEventCallbackFunction) == 0x000014, "Wrong size on FSysSensorEventCallbackFunction");
static_assert(offsetof(FSysSensorEventCallbackFunction, M_callback) == 0x000000, "Member 'FSysSensorEventCallbackFunction::M_callback' has a wrong offset!");

// ScriptStruct keaton.CASysTrackingState
// 0x0018 (0x0018 - 0x0000)
struct FCASysTrackingState final
{
public:
	ESysTrackingStateType                         M_tracking_state;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_progress;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           M_status_colour;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCASysTrackingState) == 0x000004, "Wrong alignment on FCASysTrackingState");
static_assert(sizeof(FCASysTrackingState) == 0x000018, "Wrong size on FCASysTrackingState");
static_assert(offsetof(FCASysTrackingState, M_tracking_state) == 0x000000, "Member 'FCASysTrackingState::M_tracking_state' has a wrong offset!");
static_assert(offsetof(FCASysTrackingState, M_progress) == 0x000004, "Member 'FCASysTrackingState::M_progress' has a wrong offset!");
static_assert(offsetof(FCASysTrackingState, M_status_colour) == 0x000008, "Member 'FCASysTrackingState::M_status_colour' has a wrong offset!");

// ScriptStruct keaton.TargetingParametersProjectile
// 0x0054 (0x0054 - 0x0000)
struct FTargetingParametersProjectile final
{
public:
	struct FVector                                M_initial_launch_direction;                        // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_launch_location;                                 // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_initial_launch_speed;                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_add_prediction_arc_launch_offset;                // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_prediction_arc_launch_offset;                    // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_player_movement_initial_launch_direction_miltipliers; // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_scale_added_actor_movement_by_similarity_to_forward_direction; // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_prediciton_sweep_scale;                          // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_prediction_bounces_to_show;                      // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_minimum_speed;                                   // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_target_location;                                 // 0x0048(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetingParametersProjectile) == 0x000004, "Wrong alignment on FTargetingParametersProjectile");
static_assert(sizeof(FTargetingParametersProjectile) == 0x000054, "Wrong size on FTargetingParametersProjectile");
static_assert(offsetof(FTargetingParametersProjectile, M_initial_launch_direction) == 0x000000, "Member 'FTargetingParametersProjectile::M_initial_launch_direction' has a wrong offset!");
static_assert(offsetof(FTargetingParametersProjectile, M_launch_location) == 0x00000C, "Member 'FTargetingParametersProjectile::M_launch_location' has a wrong offset!");
static_assert(offsetof(FTargetingParametersProjectile, M_initial_launch_speed) == 0x000018, "Member 'FTargetingParametersProjectile::M_initial_launch_speed' has a wrong offset!");
static_assert(offsetof(FTargetingParametersProjectile, M_add_prediction_arc_launch_offset) == 0x00001C, "Member 'FTargetingParametersProjectile::M_add_prediction_arc_launch_offset' has a wrong offset!");
static_assert(offsetof(FTargetingParametersProjectile, M_prediction_arc_launch_offset) == 0x000020, "Member 'FTargetingParametersProjectile::M_prediction_arc_launch_offset' has a wrong offset!");
static_assert(offsetof(FTargetingParametersProjectile, M_player_movement_initial_launch_direction_miltipliers) == 0x00002C, "Member 'FTargetingParametersProjectile::M_player_movement_initial_launch_direction_miltipliers' has a wrong offset!");
static_assert(offsetof(FTargetingParametersProjectile, M_scale_added_actor_movement_by_similarity_to_forward_direction) == 0x000038, "Member 'FTargetingParametersProjectile::M_scale_added_actor_movement_by_similarity_to_forward_direction' has a wrong offset!");
static_assert(offsetof(FTargetingParametersProjectile, M_prediciton_sweep_scale) == 0x00003C, "Member 'FTargetingParametersProjectile::M_prediciton_sweep_scale' has a wrong offset!");
static_assert(offsetof(FTargetingParametersProjectile, M_prediction_bounces_to_show) == 0x000040, "Member 'FTargetingParametersProjectile::M_prediction_bounces_to_show' has a wrong offset!");
static_assert(offsetof(FTargetingParametersProjectile, M_minimum_speed) == 0x000044, "Member 'FTargetingParametersProjectile::M_minimum_speed' has a wrong offset!");
static_assert(offsetof(FTargetingParametersProjectile, M_target_location) == 0x000048, "Member 'FTargetingParametersProjectile::M_target_location' has a wrong offset!");

// ScriptStruct keaton.CATargetingInputs
// 0x0018 (0x0018 - 0x0000)
struct FCATargetingInputs final
{
public:
	struct FVector                                M_source_location;                                 // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_direction;                                       // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATargetingInputs) == 0x000004, "Wrong alignment on FCATargetingInputs");
static_assert(sizeof(FCATargetingInputs) == 0x000018, "Wrong size on FCATargetingInputs");
static_assert(offsetof(FCATargetingInputs, M_source_location) == 0x000000, "Member 'FCATargetingInputs::M_source_location' has a wrong offset!");
static_assert(offsetof(FCATargetingInputs, M_direction) == 0x00000C, "Member 'FCATargetingInputs::M_direction' has a wrong offset!");

// ScriptStruct keaton.CATargetRecentlyDetectedScore
// 0x0008 (0x0008 - 0x0000)
struct FCATargetRecentlyDetectedScore final
{
public:
	int32                                         M_time_since_detected;                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_score;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATargetRecentlyDetectedScore) == 0x000004, "Wrong alignment on FCATargetRecentlyDetectedScore");
static_assert(sizeof(FCATargetRecentlyDetectedScore) == 0x000008, "Wrong size on FCATargetRecentlyDetectedScore");
static_assert(offsetof(FCATargetRecentlyDetectedScore, M_time_since_detected) == 0x000000, "Member 'FCATargetRecentlyDetectedScore::M_time_since_detected' has a wrong offset!");
static_assert(offsetof(FCATargetRecentlyDetectedScore, M_score) == 0x000004, "Member 'FCATargetRecentlyDetectedScore::M_score' has a wrong offset!");

// ScriptStruct keaton.CATargetProximityRangeScore
// 0x0008 (0x0008 - 0x0000)
struct FCATargetProximityRangeScore final
{
public:
	int32                                         M_within_range;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_score;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATargetProximityRangeScore) == 0x000004, "Wrong alignment on FCATargetProximityRangeScore");
static_assert(sizeof(FCATargetProximityRangeScore) == 0x000008, "Wrong size on FCATargetProximityRangeScore");
static_assert(offsetof(FCATargetProximityRangeScore, M_within_range) == 0x000000, "Member 'FCATargetProximityRangeScore::M_within_range' has a wrong offset!");
static_assert(offsetof(FCATargetProximityRangeScore, M_score) == 0x000004, "Member 'FCATargetProximityRangeScore::M_score' has a wrong offset!");

// ScriptStruct keaton.TeamMember
// 0x00C8 (0x00C8 - 0x0000)
struct FTeamMember final
{
public:
	struct FCATeamID                              M_team_id;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_username;                                        // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_specialist;                                      // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_player_name;                                     // 0x001C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerScore                           M_player_score;                                    // 0x0028(0x0090)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EPlayerMatchState                             M_match_state;                                     // 0x00B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_can_respawn;                                     // 0x00B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x2];                                       // 0x00BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_player_id;                                       // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACAPlayerState*                         M_player_state;                                    // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamMember) == 0x000008, "Wrong alignment on FTeamMember");
static_assert(sizeof(FTeamMember) == 0x0000C8, "Wrong size on FTeamMember");
static_assert(offsetof(FTeamMember, M_team_id) == 0x000000, "Member 'FTeamMember::M_team_id' has a wrong offset!");
static_assert(offsetof(FTeamMember, M_username) == 0x000004, "Member 'FTeamMember::M_username' has a wrong offset!");
static_assert(offsetof(FTeamMember, M_specialist) == 0x000010, "Member 'FTeamMember::M_specialist' has a wrong offset!");
static_assert(offsetof(FTeamMember, M_player_name) == 0x00001C, "Member 'FTeamMember::M_player_name' has a wrong offset!");
static_assert(offsetof(FTeamMember, M_player_score) == 0x000028, "Member 'FTeamMember::M_player_score' has a wrong offset!");
static_assert(offsetof(FTeamMember, M_match_state) == 0x0000B8, "Member 'FTeamMember::M_match_state' has a wrong offset!");
static_assert(offsetof(FTeamMember, M_can_respawn) == 0x0000B9, "Member 'FTeamMember::M_can_respawn' has a wrong offset!");
static_assert(offsetof(FTeamMember, M_player_id) == 0x0000BC, "Member 'FTeamMember::M_player_id' has a wrong offset!");
static_assert(offsetof(FTeamMember, M_player_state) == 0x0000C0, "Member 'FTeamMember::M_player_state' has a wrong offset!");

// ScriptStruct keaton.CATeleporter_Data
// 0x0020 (0x0028 - 0x0008)
struct FCATeleporter_Data final : public FTableRowBase
{
public:
	bool                                          M_is_default_row;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_tag;                                             // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_active;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_weight;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_disable_if_exclusion_zone_in_range;              // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCATeleporter_Data) == 0x000008, "Wrong alignment on FCATeleporter_Data");
static_assert(sizeof(FCATeleporter_Data) == 0x000028, "Wrong size on FCATeleporter_Data");
static_assert(offsetof(FCATeleporter_Data, M_is_default_row) == 0x000008, "Member 'FCATeleporter_Data::M_is_default_row' has a wrong offset!");
static_assert(offsetof(FCATeleporter_Data, M_tag) == 0x00000C, "Member 'FCATeleporter_Data::M_tag' has a wrong offset!");
static_assert(offsetof(FCATeleporter_Data, M_is_active) == 0x000018, "Member 'FCATeleporter_Data::M_is_active' has a wrong offset!");
static_assert(offsetof(FCATeleporter_Data, M_weight) == 0x00001C, "Member 'FCATeleporter_Data::M_weight' has a wrong offset!");
static_assert(offsetof(FCATeleporter_Data, M_disable_if_exclusion_zone_in_range) == 0x000020, "Member 'FCATeleporter_Data::M_disable_if_exclusion_zone_in_range' has a wrong offset!");

// ScriptStruct keaton.AggregatedTickFunction
// 0x0030 (0x0068 - 0x0038)
struct FAggregatedTickFunction final : public FActorComponentTickFunction
{
public:
	uint8                                         Pad_38[0x30];                                      // 0x0038(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAggregatedTickFunction) == 0x000008, "Wrong alignment on FAggregatedTickFunction");
static_assert(sizeof(FAggregatedTickFunction) == 0x000068, "Wrong size on FAggregatedTickFunction");

// ScriptStruct keaton.CATimedMovementConfig
// 0x0148 (0x0150 - 0x0008)
struct FCATimedMovementConfig final : public FTableRowBase
{
public:
	struct FGameplayTagContainer                  M_EnableTags;                                      // 0x0008(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_DisableTags;                                     // 0x0028(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_PauseTags;                                       // 0x0048(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_HideTags;                                        // 0x0068(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_AlertedTags;                                     // 0x0088(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_ResetTags;                                       // 0x00A8(0x0020)(Edit, NativeAccessSpecifierPublic)
	bool                                          M_ApplyStateToGroup;                               // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               M_RotationLimits;                                  // 0x00CC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                M_TranslationLimits;                               // 0x00D8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_CycleDuration;                                   // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_PauseFraction;                                   // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_FlashesPerCycle;                                 // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_BlinkFraction;                                   // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_HideWhenPaused;                                  // 0x00F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_HideWhenDisarmed;                                // 0x00F5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_UseScalingInsteadOfFlashing;                     // 0x00F6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F7[0x1];                                       // 0x00F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_MinimumScale;                                    // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         M_BeamDirection;                                   // 0x00FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_ManualBeamLength;                                // 0x00FD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FE[0x2];                                       // 0x00FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_BeamLength;                                      // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_BeamRadius;                                      // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_BeamIsDisc;                                      // 0x0108(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_BeamIsCone;                                      // 0x0109(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A[0x2];                                      // 0x010A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_ConeRatio;                                       // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_BeamIsPlane;                                     // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_PlaneWidth;                                      // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_BeamIsSphere;                                    // 0x0118(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAAudioEventType                      M_PassiveAudioEvent;                               // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_DetectingAudioEvent;                             // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_RearmingAudioEvent;                              // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_CollisionRadius;                                 // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_MinimumDetection;                                // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_DetectionCooldown;                               // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_RearmingTime;                                    // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_RearmingFlashesPerSecond;                        // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_OccupationRadiusRatio;                           // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_PauseWhileOccupied;                              // 0x0140(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAAudioEventType                      M_DisarmedAudioEvent;                              // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_ArmedAudioEvent;                                 // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_TriggeredAudioEvent;                             // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCATimedMovementConfig) == 0x000008, "Wrong alignment on FCATimedMovementConfig");
static_assert(sizeof(FCATimedMovementConfig) == 0x000150, "Wrong size on FCATimedMovementConfig");
static_assert(offsetof(FCATimedMovementConfig, M_EnableTags) == 0x000008, "Member 'FCATimedMovementConfig::M_EnableTags' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_DisableTags) == 0x000028, "Member 'FCATimedMovementConfig::M_DisableTags' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_PauseTags) == 0x000048, "Member 'FCATimedMovementConfig::M_PauseTags' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_HideTags) == 0x000068, "Member 'FCATimedMovementConfig::M_HideTags' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_AlertedTags) == 0x000088, "Member 'FCATimedMovementConfig::M_AlertedTags' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_ResetTags) == 0x0000A8, "Member 'FCATimedMovementConfig::M_ResetTags' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_ApplyStateToGroup) == 0x0000C8, "Member 'FCATimedMovementConfig::M_ApplyStateToGroup' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_RotationLimits) == 0x0000CC, "Member 'FCATimedMovementConfig::M_RotationLimits' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_TranslationLimits) == 0x0000D8, "Member 'FCATimedMovementConfig::M_TranslationLimits' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_CycleDuration) == 0x0000E4, "Member 'FCATimedMovementConfig::M_CycleDuration' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_PauseFraction) == 0x0000E8, "Member 'FCATimedMovementConfig::M_PauseFraction' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_FlashesPerCycle) == 0x0000EC, "Member 'FCATimedMovementConfig::M_FlashesPerCycle' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_BlinkFraction) == 0x0000F0, "Member 'FCATimedMovementConfig::M_BlinkFraction' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_HideWhenPaused) == 0x0000F4, "Member 'FCATimedMovementConfig::M_HideWhenPaused' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_HideWhenDisarmed) == 0x0000F5, "Member 'FCATimedMovementConfig::M_HideWhenDisarmed' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_UseScalingInsteadOfFlashing) == 0x0000F6, "Member 'FCATimedMovementConfig::M_UseScalingInsteadOfFlashing' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_MinimumScale) == 0x0000F8, "Member 'FCATimedMovementConfig::M_MinimumScale' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_BeamDirection) == 0x0000FC, "Member 'FCATimedMovementConfig::M_BeamDirection' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_ManualBeamLength) == 0x0000FD, "Member 'FCATimedMovementConfig::M_ManualBeamLength' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_BeamLength) == 0x000100, "Member 'FCATimedMovementConfig::M_BeamLength' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_BeamRadius) == 0x000104, "Member 'FCATimedMovementConfig::M_BeamRadius' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_BeamIsDisc) == 0x000108, "Member 'FCATimedMovementConfig::M_BeamIsDisc' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_BeamIsCone) == 0x000109, "Member 'FCATimedMovementConfig::M_BeamIsCone' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_ConeRatio) == 0x00010C, "Member 'FCATimedMovementConfig::M_ConeRatio' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_BeamIsPlane) == 0x000110, "Member 'FCATimedMovementConfig::M_BeamIsPlane' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_PlaneWidth) == 0x000114, "Member 'FCATimedMovementConfig::M_PlaneWidth' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_BeamIsSphere) == 0x000118, "Member 'FCATimedMovementConfig::M_BeamIsSphere' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_PassiveAudioEvent) == 0x00011C, "Member 'FCATimedMovementConfig::M_PassiveAudioEvent' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_DetectingAudioEvent) == 0x000120, "Member 'FCATimedMovementConfig::M_DetectingAudioEvent' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_RearmingAudioEvent) == 0x000124, "Member 'FCATimedMovementConfig::M_RearmingAudioEvent' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_CollisionRadius) == 0x000128, "Member 'FCATimedMovementConfig::M_CollisionRadius' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_MinimumDetection) == 0x00012C, "Member 'FCATimedMovementConfig::M_MinimumDetection' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_DetectionCooldown) == 0x000130, "Member 'FCATimedMovementConfig::M_DetectionCooldown' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_RearmingTime) == 0x000134, "Member 'FCATimedMovementConfig::M_RearmingTime' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_RearmingFlashesPerSecond) == 0x000138, "Member 'FCATimedMovementConfig::M_RearmingFlashesPerSecond' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_OccupationRadiusRatio) == 0x00013C, "Member 'FCATimedMovementConfig::M_OccupationRadiusRatio' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_PauseWhileOccupied) == 0x000140, "Member 'FCATimedMovementConfig::M_PauseWhileOccupied' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_DisarmedAudioEvent) == 0x000144, "Member 'FCATimedMovementConfig::M_DisarmedAudioEvent' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_ArmedAudioEvent) == 0x000148, "Member 'FCATimedMovementConfig::M_ArmedAudioEvent' has a wrong offset!");
static_assert(offsetof(FCATimedMovementConfig, M_TriggeredAudioEvent) == 0x00014C, "Member 'FCATimedMovementConfig::M_TriggeredAudioEvent' has a wrong offset!");

// ScriptStruct keaton.CATimedMovementPreset
// 0x0020 (0x0028 - 0x0008)
struct FCATimedMovementPreset final : public FTableRowBase
{
public:
	float                                         M_CycleDuration;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_MovementSpeed;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_UseFixedMovementSpeed;                           // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_PauseFraction;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_PauseTime;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_FlashesPerCycle;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_BlinkFraction;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCATimedMovementPreset) == 0x000008, "Wrong alignment on FCATimedMovementPreset");
static_assert(sizeof(FCATimedMovementPreset) == 0x000028, "Wrong size on FCATimedMovementPreset");
static_assert(offsetof(FCATimedMovementPreset, M_CycleDuration) == 0x000008, "Member 'FCATimedMovementPreset::M_CycleDuration' has a wrong offset!");
static_assert(offsetof(FCATimedMovementPreset, M_MovementSpeed) == 0x00000C, "Member 'FCATimedMovementPreset::M_MovementSpeed' has a wrong offset!");
static_assert(offsetof(FCATimedMovementPreset, M_UseFixedMovementSpeed) == 0x000010, "Member 'FCATimedMovementPreset::M_UseFixedMovementSpeed' has a wrong offset!");
static_assert(offsetof(FCATimedMovementPreset, M_PauseFraction) == 0x000014, "Member 'FCATimedMovementPreset::M_PauseFraction' has a wrong offset!");
static_assert(offsetof(FCATimedMovementPreset, M_PauseTime) == 0x000018, "Member 'FCATimedMovementPreset::M_PauseTime' has a wrong offset!");
static_assert(offsetof(FCATimedMovementPreset, M_FlashesPerCycle) == 0x00001C, "Member 'FCATimedMovementPreset::M_FlashesPerCycle' has a wrong offset!");
static_assert(offsetof(FCATimedMovementPreset, M_BlinkFraction) == 0x000020, "Member 'FCATimedMovementPreset::M_BlinkFraction' has a wrong offset!");

// ScriptStruct keaton.CATransition
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FCATransition final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_ActivationDuration;                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_DeactivationDuration;                            // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ActivationEaseIn;                                // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ActivationEaseOut;                               // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_DeactivationEaseIn;                              // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_DeactivationEaseOut;                             // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_AllowInterrupt;                                  // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_ManualUpdate;                                    // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0xE];                                       // 0x003A(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCATransition) == 0x000008, "Wrong alignment on FCATransition");
static_assert(sizeof(FCATransition) == 0x000048, "Wrong size on FCATransition");
static_assert(offsetof(FCATransition, M_ActivationDuration) == 0x000020, "Member 'FCATransition::M_ActivationDuration' has a wrong offset!");
static_assert(offsetof(FCATransition, M_DeactivationDuration) == 0x000024, "Member 'FCATransition::M_DeactivationDuration' has a wrong offset!");
static_assert(offsetof(FCATransition, M_ActivationEaseIn) == 0x000028, "Member 'FCATransition::M_ActivationEaseIn' has a wrong offset!");
static_assert(offsetof(FCATransition, M_ActivationEaseOut) == 0x00002C, "Member 'FCATransition::M_ActivationEaseOut' has a wrong offset!");
static_assert(offsetof(FCATransition, M_DeactivationEaseIn) == 0x000030, "Member 'FCATransition::M_DeactivationEaseIn' has a wrong offset!");
static_assert(offsetof(FCATransition, M_DeactivationEaseOut) == 0x000034, "Member 'FCATransition::M_DeactivationEaseOut' has a wrong offset!");
static_assert(offsetof(FCATransition, M_AllowInterrupt) == 0x000038, "Member 'FCATransition::M_AllowInterrupt' has a wrong offset!");
static_assert(offsetof(FCATransition, M_ManualUpdate) == 0x000039, "Member 'FCATransition::M_ManualUpdate' has a wrong offset!");

// ScriptStruct keaton.CACustomUIItem
// 0x0040 (0x0040 - 0x0000)
struct FCACustomUIItem final
{
public:
	TSoftClassPtr<class UClass>                   M_widget_class;                                    // 0x0000(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tag;                                             // 0x0030(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCACustomUIItem) == 0x000008, "Wrong alignment on FCACustomUIItem");
static_assert(sizeof(FCACustomUIItem) == 0x000040, "Wrong size on FCACustomUIItem");
static_assert(offsetof(FCACustomUIItem, M_widget_class) == 0x000000, "Member 'FCACustomUIItem::M_widget_class' has a wrong offset!");
static_assert(offsetof(FCACustomUIItem, M_tag) == 0x000030, "Member 'FCACustomUIItem::M_tag' has a wrong offset!");

// ScriptStruct keaton.CAUIOptionNames
// 0x0001 (0x0001 - 0x0000)
struct FCAUIOptionNames final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAUIOptionNames) == 0x000001, "Wrong alignment on FCAUIOptionNames");
static_assert(sizeof(FCAUIOptionNames) == 0x000001, "Wrong size on FCAUIOptionNames");

// ScriptStruct keaton.CAUIOptionPlatformSpecificText
// 0x0068 (0x0068 - 0x0000)
struct FCAUIOptionPlatformSpecificText final
{
public:
	struct FCAUIFlags                             M_option_flags;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAText                                M_label;                                           // 0x0008(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCAText                                M_tool_tip;                                        // 0x0038(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAUIOptionPlatformSpecificText) == 0x000008, "Wrong alignment on FCAUIOptionPlatformSpecificText");
static_assert(sizeof(FCAUIOptionPlatformSpecificText) == 0x000068, "Wrong size on FCAUIOptionPlatformSpecificText");
static_assert(offsetof(FCAUIOptionPlatformSpecificText, M_option_flags) == 0x000000, "Member 'FCAUIOptionPlatformSpecificText::M_option_flags' has a wrong offset!");
static_assert(offsetof(FCAUIOptionPlatformSpecificText, M_label) == 0x000008, "Member 'FCAUIOptionPlatformSpecificText::M_label' has a wrong offset!");
static_assert(offsetof(FCAUIOptionPlatformSpecificText, M_tool_tip) == 0x000038, "Member 'FCAUIOptionPlatformSpecificText::M_tool_tip' has a wrong offset!");

// ScriptStruct keaton.CAUIOptionDefaultValue
// 0x0048 (0x0048 - 0x0000)
struct FCAUIOptionDefaultValue final
{
public:
	int32                                         M_valid_platforms;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_default_value;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_default_value_initializer;                       // 0x0018(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAUIOptionDefaultValue) == 0x000008, "Wrong alignment on FCAUIOptionDefaultValue");
static_assert(sizeof(FCAUIOptionDefaultValue) == 0x000048, "Wrong size on FCAUIOptionDefaultValue");
static_assert(offsetof(FCAUIOptionDefaultValue, M_valid_platforms) == 0x000000, "Member 'FCAUIOptionDefaultValue::M_valid_platforms' has a wrong offset!");
static_assert(offsetof(FCAUIOptionDefaultValue, M_default_value) == 0x000008, "Member 'FCAUIOptionDefaultValue::M_default_value' has a wrong offset!");
static_assert(offsetof(FCAUIOptionDefaultValue, M_default_value_initializer) == 0x000018, "Member 'FCAUIOptionDefaultValue::M_default_value_initializer' has a wrong offset!");

// ScriptStruct keaton.CAUIStateCallbackPair
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x04) FCAUIStateCallbackPair final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAUIStateCallbackPair) == 0x000004, "Wrong alignment on FCAUIStateCallbackPair");
static_assert(sizeof(FCAUIStateCallbackPair) == 0x000028, "Wrong size on FCAUIStateCallbackPair");

// ScriptStruct keaton.TestTeamMemberConfig
// 0x0028 (0x0028 - 0x0000)
struct FTestTeamMemberConfig final
{
public:
	struct FCATeamID                              M_team_id;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_username;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_score;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_expected_currency;                               // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_expected_xp;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_extracted;                                       // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTestTeamMemberConfig) == 0x000008, "Wrong alignment on FTestTeamMemberConfig");
static_assert(sizeof(FTestTeamMemberConfig) == 0x000028, "Wrong size on FTestTeamMemberConfig");
static_assert(offsetof(FTestTeamMemberConfig, M_team_id) == 0x000000, "Member 'FTestTeamMemberConfig::M_team_id' has a wrong offset!");
static_assert(offsetof(FTestTeamMemberConfig, M_username) == 0x000008, "Member 'FTestTeamMemberConfig::M_username' has a wrong offset!");
static_assert(offsetof(FTestTeamMemberConfig, M_score) == 0x000018, "Member 'FTestTeamMemberConfig::M_score' has a wrong offset!");
static_assert(offsetof(FTestTeamMemberConfig, M_expected_currency) == 0x00001C, "Member 'FTestTeamMemberConfig::M_expected_currency' has a wrong offset!");
static_assert(offsetof(FTestTeamMemberConfig, M_expected_xp) == 0x000020, "Member 'FTestTeamMemberConfig::M_expected_xp' has a wrong offset!");
static_assert(offsetof(FTestTeamMemberConfig, M_extracted) == 0x000024, "Member 'FTestTeamMemberConfig::M_extracted' has a wrong offset!");

// ScriptStruct keaton.CAServicesNotificationState
// 0x0038 (0x0038 - 0x0000)
struct FCAServicesNotificationState final
{
public:
	class FString                                 M_GUID;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAServicesNotificationType                   M_type;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         M_creation_timestamp;                              // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_payload;                                         // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_state;                                           // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAServicesNotificationState) == 0x000008, "Wrong alignment on FCAServicesNotificationState");
static_assert(sizeof(FCAServicesNotificationState) == 0x000038, "Wrong size on FCAServicesNotificationState");
static_assert(offsetof(FCAServicesNotificationState, M_GUID) == 0x000000, "Member 'FCAServicesNotificationState::M_GUID' has a wrong offset!");
static_assert(offsetof(FCAServicesNotificationState, M_type) == 0x000010, "Member 'FCAServicesNotificationState::M_type' has a wrong offset!");
static_assert(offsetof(FCAServicesNotificationState, M_creation_timestamp) == 0x000018, "Member 'FCAServicesNotificationState::M_creation_timestamp' has a wrong offset!");
static_assert(offsetof(FCAServicesNotificationState, M_payload) == 0x000020, "Member 'FCAServicesNotificationState::M_payload' has a wrong offset!");
static_assert(offsetof(FCAServicesNotificationState, M_state) == 0x000030, "Member 'FCAServicesNotificationState::M_state' has a wrong offset!");

// ScriptStruct keaton.CASettingsState
// 0x0160 (0x0160 - 0x0000)
struct FCASettingsState final
{
public:
	TArray<struct FCAKeyRebindData>               M_key_rebinding_data;                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, bool>                       M_boolean_options;                                 // 0x0010(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      M_int_options;                                     // 0x0060(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, float>                      M_float_options;                                   // 0x00B0(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, class FString>              M_string_options;                                  // 0x0100(0x0050)(NativeAccessSpecifierPublic)
	class FName                                   M_last_chosen_game_mode;                           // 0x0150(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCASettingsState) == 0x000008, "Wrong alignment on FCASettingsState");
static_assert(sizeof(FCASettingsState) == 0x000160, "Wrong size on FCASettingsState");
static_assert(offsetof(FCASettingsState, M_key_rebinding_data) == 0x000000, "Member 'FCASettingsState::M_key_rebinding_data' has a wrong offset!");
static_assert(offsetof(FCASettingsState, M_boolean_options) == 0x000010, "Member 'FCASettingsState::M_boolean_options' has a wrong offset!");
static_assert(offsetof(FCASettingsState, M_int_options) == 0x000060, "Member 'FCASettingsState::M_int_options' has a wrong offset!");
static_assert(offsetof(FCASettingsState, M_float_options) == 0x0000B0, "Member 'FCASettingsState::M_float_options' has a wrong offset!");
static_assert(offsetof(FCASettingsState, M_string_options) == 0x000100, "Member 'FCASettingsState::M_string_options' has a wrong offset!");
static_assert(offsetof(FCASettingsState, M_last_chosen_game_mode) == 0x000150, "Member 'FCASettingsState::M_last_chosen_game_mode' has a wrong offset!");

// ScriptStruct keaton.CAUserBlobStorageItem
// 0x0218 (0x0218 - 0x0000)
struct FCAUserBlobStorageItem final
{
public:
	int32                                         M_version;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAFTUEState                           M_ftue_state;                                      // 0x0008(0x0060)(NativeAccessSpecifierPublic)
	struct FCARadialStorage                       M_emote_radial_storage;                            // 0x0068(0x0018)(NativeAccessSpecifierPublic)
	struct FCARadialStorage                       M_spray_radial_storage;                            // 0x0080(0x0018)(NativeAccessSpecifierPublic)
	TArray<struct FCAServicesNotificationState>   M_server_notification_states;                      // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCASettingsState                       M_settings;                                        // 0x00A8(0x0160)(NativeAccessSpecifierPublic)
	TArray<struct FCARecentPlayer>                M_recent_players;                                  // 0x0208(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAUserBlobStorageItem) == 0x000008, "Wrong alignment on FCAUserBlobStorageItem");
static_assert(sizeof(FCAUserBlobStorageItem) == 0x000218, "Wrong size on FCAUserBlobStorageItem");
static_assert(offsetof(FCAUserBlobStorageItem, M_version) == 0x000000, "Member 'FCAUserBlobStorageItem::M_version' has a wrong offset!");
static_assert(offsetof(FCAUserBlobStorageItem, M_ftue_state) == 0x000008, "Member 'FCAUserBlobStorageItem::M_ftue_state' has a wrong offset!");
static_assert(offsetof(FCAUserBlobStorageItem, M_emote_radial_storage) == 0x000068, "Member 'FCAUserBlobStorageItem::M_emote_radial_storage' has a wrong offset!");
static_assert(offsetof(FCAUserBlobStorageItem, M_spray_radial_storage) == 0x000080, "Member 'FCAUserBlobStorageItem::M_spray_radial_storage' has a wrong offset!");
static_assert(offsetof(FCAUserBlobStorageItem, M_server_notification_states) == 0x000098, "Member 'FCAUserBlobStorageItem::M_server_notification_states' has a wrong offset!");
static_assert(offsetof(FCAUserBlobStorageItem, M_settings) == 0x0000A8, "Member 'FCAUserBlobStorageItem::M_settings' has a wrong offset!");
static_assert(offsetof(FCAUserBlobStorageItem, M_recent_players) == 0x000208, "Member 'FCAUserBlobStorageItem::M_recent_players' has a wrong offset!");

// ScriptStruct keaton.CANonPersistentStorage
// 0x00F0 (0x00F0 - 0x0000)
struct FCANonPersistentStorage final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_flow_tracking_state;                             // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UTexture2DDynamic*> M_image_cache;                                     // 0x0098(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCANonPersistentStorage) == 0x000008, "Wrong alignment on FCANonPersistentStorage");
static_assert(sizeof(FCANonPersistentStorage) == 0x0000F0, "Wrong size on FCANonPersistentStorage");
static_assert(offsetof(FCANonPersistentStorage, M_flow_tracking_state) == 0x000090, "Member 'FCANonPersistentStorage::M_flow_tracking_state' has a wrong offset!");
static_assert(offsetof(FCANonPersistentStorage, M_image_cache) == 0x000098, "Member 'FCANonPersistentStorage::M_image_cache' has a wrong offset!");

// ScriptStruct keaton.VaultHeroLoot
// 0x0010 (0x0010 - 0x0000)
struct FVaultHeroLoot final
{
public:
	class UCAInventoryItem*                       M_loot_item;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACAPickUp*                              M_loot_pickup;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVaultHeroLoot) == 0x000008, "Wrong alignment on FVaultHeroLoot");
static_assert(sizeof(FVaultHeroLoot) == 0x000010, "Wrong size on FVaultHeroLoot");
static_assert(offsetof(FVaultHeroLoot, M_loot_item) == 0x000000, "Member 'FVaultHeroLoot::M_loot_item' has a wrong offset!");
static_assert(offsetof(FVaultHeroLoot, M_loot_pickup) == 0x000008, "Member 'FVaultHeroLoot::M_loot_pickup' has a wrong offset!");

// ScriptStruct keaton.CAVOIPSettings
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FCAVOIPSettings final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAVOIPSettings) == 0x000008, "Wrong alignment on FCAVOIPSettings");
static_assert(sizeof(FCAVOIPSettings) == 0x000050, "Wrong size on FCAVOIPSettings");

// ScriptStruct keaton.CAGameplayAbilityTargetData_GameplayTag
// 0x0010 (0x0018 - 0x0008)
struct FCAGameplayAbilityTargetData_GameplayTag final : public FGameplayAbilityTargetData
{
public:
	struct FGameplayTag                           M_gameplay_tag;                                    // 0x0008(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAGameplayAbilityTargetData_GameplayTag) == 0x000008, "Wrong alignment on FCAGameplayAbilityTargetData_GameplayTag");
static_assert(sizeof(FCAGameplayAbilityTargetData_GameplayTag) == 0x000018, "Wrong size on FCAGameplayAbilityTargetData_GameplayTag");
static_assert(offsetof(FCAGameplayAbilityTargetData_GameplayTag, M_gameplay_tag) == 0x000008, "Member 'FCAGameplayAbilityTargetData_GameplayTag::M_gameplay_tag' has a wrong offset!");

// ScriptStruct keaton.CAGameplayCueTargetData_TacticalGrenade
// 0x0008 (0x0010 - 0x0008)
struct FCAGameplayCueTargetData_TacticalGrenade final : public FGameplayCueTargetData
{
public:
	uint8                                         M_tactical_level;                                  // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_bounce_num;                                      // 0x0009(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAGameplayCueTargetData_TacticalGrenade) == 0x000008, "Wrong alignment on FCAGameplayCueTargetData_TacticalGrenade");
static_assert(sizeof(FCAGameplayCueTargetData_TacticalGrenade) == 0x000010, "Wrong size on FCAGameplayCueTargetData_TacticalGrenade");
static_assert(offsetof(FCAGameplayCueTargetData_TacticalGrenade, M_tactical_level) == 0x000008, "Member 'FCAGameplayCueTargetData_TacticalGrenade::M_tactical_level' has a wrong offset!");
static_assert(offsetof(FCAGameplayCueTargetData_TacticalGrenade, M_bounce_num) == 0x000009, "Member 'FCAGameplayCueTargetData_TacticalGrenade::M_bounce_num' has a wrong offset!");

// ScriptStruct keaton.CAGameplayAbilityTargetDataTacticalGrenade
// 0x0008 (0x0010 - 0x0008)
struct FCAGameplayAbilityTargetDataTacticalGrenade final : public FGameplayAbilityTargetData
{
public:
	uint8                                         M_tactical_level;                                  // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_bounce_num;                                      // 0x0009(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAGameplayAbilityTargetDataTacticalGrenade) == 0x000008, "Wrong alignment on FCAGameplayAbilityTargetDataTacticalGrenade");
static_assert(sizeof(FCAGameplayAbilityTargetDataTacticalGrenade) == 0x000010, "Wrong size on FCAGameplayAbilityTargetDataTacticalGrenade");
static_assert(offsetof(FCAGameplayAbilityTargetDataTacticalGrenade, M_tactical_level) == 0x000008, "Member 'FCAGameplayAbilityTargetDataTacticalGrenade::M_tactical_level' has a wrong offset!");
static_assert(offsetof(FCAGameplayAbilityTargetDataTacticalGrenade, M_bounce_num) == 0x000009, "Member 'FCAGameplayAbilityTargetDataTacticalGrenade::M_bounce_num' has a wrong offset!");

// ScriptStruct keaton.DualWieldConfiguration
// 0x0020 (0x0020 - 0x0000)
struct FDualWieldConfiguration final
{
public:
	TSubclassOf<class ACAWeaponSlave>             M_slaved_actor_class;                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_can_use_dual_wield;                              // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_mounting_point_label;                            // 0x000C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEquipmentSlotPriority                        M_slot_priority;                                   // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDualWieldConfiguration) == 0x000008, "Wrong alignment on FDualWieldConfiguration");
static_assert(sizeof(FDualWieldConfiguration) == 0x000020, "Wrong size on FDualWieldConfiguration");
static_assert(offsetof(FDualWieldConfiguration, M_slaved_actor_class) == 0x000000, "Member 'FDualWieldConfiguration::M_slaved_actor_class' has a wrong offset!");
static_assert(offsetof(FDualWieldConfiguration, M_can_use_dual_wield) == 0x000008, "Member 'FDualWieldConfiguration::M_can_use_dual_wield' has a wrong offset!");
static_assert(offsetof(FDualWieldConfiguration, M_mounting_point_label) == 0x00000C, "Member 'FDualWieldConfiguration::M_mounting_point_label' has a wrong offset!");
static_assert(offsetof(FDualWieldConfiguration, M_slot_priority) == 0x000018, "Member 'FDualWieldConfiguration::M_slot_priority' has a wrong offset!");

// ScriptStruct keaton.CAInstantWeaponData
// 0x0010 (0x0010 - 0x0000)
struct FCAInstantWeaponData final
{
public:
	float                                         M_proportion_max_health_damage;                    // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_impulse_applied_to_physics;                      // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_client_side_hit_leeway;                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_allowed_view_dot_hit_dir;                        // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAInstantWeaponData) == 0x000004, "Wrong alignment on FCAInstantWeaponData");
static_assert(sizeof(FCAInstantWeaponData) == 0x000010, "Wrong size on FCAInstantWeaponData");
static_assert(offsetof(FCAInstantWeaponData, M_proportion_max_health_damage) == 0x000000, "Member 'FCAInstantWeaponData::M_proportion_max_health_damage' has a wrong offset!");
static_assert(offsetof(FCAInstantWeaponData, M_impulse_applied_to_physics) == 0x000004, "Member 'FCAInstantWeaponData::M_impulse_applied_to_physics' has a wrong offset!");
static_assert(offsetof(FCAInstantWeaponData, M_client_side_hit_leeway) == 0x000008, "Member 'FCAInstantWeaponData::M_client_side_hit_leeway' has a wrong offset!");
static_assert(offsetof(FCAInstantWeaponData, M_allowed_view_dot_hit_dir) == 0x00000C, "Member 'FCAInstantWeaponData::M_allowed_view_dot_hit_dir' has a wrong offset!");

// ScriptStruct keaton.CAWeaponFireModeEffectsData
// 0x0030 (0x0038 - 0x0008)
struct FCAWeaponFireModeEffectsData final : public FTableRowBase
{
public:
	class FName                                   M_muzzle_attach_point;                             // 0x0008(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMatineeCameraShake>        M_fire_camera_shake;                               // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fire_camera_shake_scale_hip_fire;                // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fire_camera_shake_scale_ads;                     // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   M_fire_force_feedback;                             // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_physics_prop_momentum;                           // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_zero_g_physics_prop_momentum;                    // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAWeaponFireModeEffectsData) == 0x000008, "Wrong alignment on FCAWeaponFireModeEffectsData");
static_assert(sizeof(FCAWeaponFireModeEffectsData) == 0x000038, "Wrong size on FCAWeaponFireModeEffectsData");
static_assert(offsetof(FCAWeaponFireModeEffectsData, M_muzzle_attach_point) == 0x000008, "Member 'FCAWeaponFireModeEffectsData::M_muzzle_attach_point' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeEffectsData, M_fire_camera_shake) == 0x000018, "Member 'FCAWeaponFireModeEffectsData::M_fire_camera_shake' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeEffectsData, M_fire_camera_shake_scale_hip_fire) == 0x000020, "Member 'FCAWeaponFireModeEffectsData::M_fire_camera_shake_scale_hip_fire' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeEffectsData, M_fire_camera_shake_scale_ads) == 0x000024, "Member 'FCAWeaponFireModeEffectsData::M_fire_camera_shake_scale_ads' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeEffectsData, M_fire_force_feedback) == 0x000028, "Member 'FCAWeaponFireModeEffectsData::M_fire_force_feedback' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeEffectsData, M_physics_prop_momentum) == 0x000030, "Member 'FCAWeaponFireModeEffectsData::M_physics_prop_momentum' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeEffectsData, M_zero_g_physics_prop_momentum) == 0x000034, "Member 'FCAWeaponFireModeEffectsData::M_zero_g_physics_prop_momentum' has a wrong offset!");

// ScriptStruct keaton.CAWeaponFireModeAudioData
// 0x00E8 (0x00F0 - 0x0008)
struct FCAWeaponFireModeAudioData final : public FTableRowBase
{
public:
	uint8                                         M_looped_fire_sound : 1;                           // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCAWeaponFireModeAdditionalAudioData   M_fp_audio_data;                                   // 0x0010(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAWeaponFireModeAdditionalAudioData   M_tp_audio_data;                                   // 0x0070(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_whizzby_event;                                   // 0x00D0(0x0004)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_whizzby_trigger_radius;                          // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_whizzby_travel_radius;                           // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_whizzby_min_delay;                               // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_whizzby_max_delay;                               // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_whizzby_centre_point;                            // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_whizzby_end_point;                               // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAWeaponFireModeAudioData) == 0x000008, "Wrong alignment on FCAWeaponFireModeAudioData");
static_assert(sizeof(FCAWeaponFireModeAudioData) == 0x0000F0, "Wrong size on FCAWeaponFireModeAudioData");
static_assert(offsetof(FCAWeaponFireModeAudioData, M_fp_audio_data) == 0x000010, "Member 'FCAWeaponFireModeAudioData::M_fp_audio_data' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAudioData, M_tp_audio_data) == 0x000070, "Member 'FCAWeaponFireModeAudioData::M_tp_audio_data' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAudioData, M_whizzby_event) == 0x0000D0, "Member 'FCAWeaponFireModeAudioData::M_whizzby_event' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAudioData, M_whizzby_trigger_radius) == 0x0000D4, "Member 'FCAWeaponFireModeAudioData::M_whizzby_trigger_radius' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAudioData, M_whizzby_travel_radius) == 0x0000D8, "Member 'FCAWeaponFireModeAudioData::M_whizzby_travel_radius' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAudioData, M_whizzby_min_delay) == 0x0000DC, "Member 'FCAWeaponFireModeAudioData::M_whizzby_min_delay' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAudioData, M_whizzby_max_delay) == 0x0000E0, "Member 'FCAWeaponFireModeAudioData::M_whizzby_max_delay' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAudioData, M_whizzby_centre_point) == 0x0000E4, "Member 'FCAWeaponFireModeAudioData::M_whizzby_centre_point' has a wrong offset!");
static_assert(offsetof(FCAWeaponFireModeAudioData, M_whizzby_end_point) == 0x0000E8, "Member 'FCAWeaponFireModeAudioData::M_whizzby_end_point' has a wrong offset!");

// ScriptStruct keaton.CAWeaponStatsInstanceInterface
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FCAWeaponStatsInstanceInterface final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAWeaponStatsInstanceInterface) == 0x000008, "Wrong alignment on FCAWeaponStatsInstanceInterface");
static_assert(sizeof(FCAWeaponStatsInstanceInterface) == 0x000008, "Wrong size on FCAWeaponStatsInstanceInterface");

// ScriptStruct keaton.CAWeaponMode
// 0x0048 (0x0048 - 0x0000)
struct FCAWeaponMode final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCAWeaponMuzzleComponent*               M_weapon_muzzle_component;                         // 0x0010(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAWeaponStatsInstanceInterface        M_weapon_stats_interface;                          // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class UCAWeaponStatsInstance*                 M_weapon_stats;                                    // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCAShotPatternStatsInstance*            M_shot_pattern_stats;                              // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCABulletStatsInstance*                 M_bullet_stats;                                    // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAWeaponMode) == 0x000008, "Wrong alignment on FCAWeaponMode");
static_assert(sizeof(FCAWeaponMode) == 0x000048, "Wrong size on FCAWeaponMode");
static_assert(offsetof(FCAWeaponMode, M_weapon_muzzle_component) == 0x000010, "Member 'FCAWeaponMode::M_weapon_muzzle_component' has a wrong offset!");
static_assert(offsetof(FCAWeaponMode, M_weapon_stats_interface) == 0x000018, "Member 'FCAWeaponMode::M_weapon_stats_interface' has a wrong offset!");
static_assert(offsetof(FCAWeaponMode, M_weapon_stats) == 0x000020, "Member 'FCAWeaponMode::M_weapon_stats' has a wrong offset!");
static_assert(offsetof(FCAWeaponMode, M_shot_pattern_stats) == 0x000038, "Member 'FCAWeaponMode::M_shot_pattern_stats' has a wrong offset!");
static_assert(offsetof(FCAWeaponMode, M_bullet_stats) == 0x000040, "Member 'FCAWeaponMode::M_bullet_stats' has a wrong offset!");

// ScriptStruct keaton.CAWeaponRecoilCurveData
// 0x0020 (0x0020 - 0x0000)
struct FCAWeaponRecoilCurveData final
{
public:
	class UCurveFloat*                            M_recoil_decay_curve;                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            M_recoil_decay_curve_lateral;                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            M_recoil_decay_0g_curve;                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            M_recoil_decay_0g_curve_lateral;                   // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAWeaponRecoilCurveData) == 0x000008, "Wrong alignment on FCAWeaponRecoilCurveData");
static_assert(sizeof(FCAWeaponRecoilCurveData) == 0x000020, "Wrong size on FCAWeaponRecoilCurveData");
static_assert(offsetof(FCAWeaponRecoilCurveData, M_recoil_decay_curve) == 0x000000, "Member 'FCAWeaponRecoilCurveData::M_recoil_decay_curve' has a wrong offset!");
static_assert(offsetof(FCAWeaponRecoilCurveData, M_recoil_decay_curve_lateral) == 0x000008, "Member 'FCAWeaponRecoilCurveData::M_recoil_decay_curve_lateral' has a wrong offset!");
static_assert(offsetof(FCAWeaponRecoilCurveData, M_recoil_decay_0g_curve) == 0x000010, "Member 'FCAWeaponRecoilCurveData::M_recoil_decay_0g_curve' has a wrong offset!");
static_assert(offsetof(FCAWeaponRecoilCurveData, M_recoil_decay_0g_curve_lateral) == 0x000018, "Member 'FCAWeaponRecoilCurveData::M_recoil_decay_0g_curve_lateral' has a wrong offset!");

// ScriptStruct keaton.CAMuzzlesNode
// 0x0018 (0x0018 - 0x0000)
struct FCAMuzzlesNode final
{
public:
	class UCAWeaponMuzzleStatsDataAsset*          M_muzzle_data;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAFireModeNode>                M_fire_modes;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMuzzlesNode) == 0x000008, "Wrong alignment on FCAMuzzlesNode");
static_assert(sizeof(FCAMuzzlesNode) == 0x000018, "Wrong size on FCAMuzzlesNode");
static_assert(offsetof(FCAMuzzlesNode, M_muzzle_data) == 0x000000, "Member 'FCAMuzzlesNode::M_muzzle_data' has a wrong offset!");
static_assert(offsetof(FCAMuzzlesNode, M_fire_modes) == 0x000008, "Member 'FCAMuzzlesNode::M_fire_modes' has a wrong offset!");

// ScriptStruct keaton.CAShotPatternStatsTableData
// 0x0098 (0x0098 - 0x0000)
struct FCAShotPatternStatsTableData final
{
public:
	struct FFeatureKeyItem                        M_feature;                                         // 0x0000(0x0004)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              M_shot_pattern_data_table_asset;                   // 0x0008(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_shot_pattern_hold_time;                          // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_camera_recoil_proportion;                        // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_anchor_point_recoil_proportion;                  // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_spread_anchor_shift_proportion;                  // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_recoil_camera_attack;                            // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_recoil_camera_hold;                              // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_recoil_camera_decay;                             // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_recoil_camera_cutoff_angle;                      // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_repeated_last_indicies;                          // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_shot_pattern_distance;                           // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              M_shot_pattern_gamepad_scale;                      // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAWeaponRecoilCurveData               M_recoil_camera_decay_curves;                      // 0x0068(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_use_recoil_decay_range;                          // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              M_recoil_decay_range;                              // 0x008C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAShotPatternStatsTableData) == 0x000008, "Wrong alignment on FCAShotPatternStatsTableData");
static_assert(sizeof(FCAShotPatternStatsTableData) == 0x000098, "Wrong size on FCAShotPatternStatsTableData");
static_assert(offsetof(FCAShotPatternStatsTableData, M_feature) == 0x000000, "Member 'FCAShotPatternStatsTableData::M_feature' has a wrong offset!");
static_assert(offsetof(FCAShotPatternStatsTableData, M_shot_pattern_data_table_asset) == 0x000008, "Member 'FCAShotPatternStatsTableData::M_shot_pattern_data_table_asset' has a wrong offset!");
static_assert(offsetof(FCAShotPatternStatsTableData, M_shot_pattern_hold_time) == 0x000038, "Member 'FCAShotPatternStatsTableData::M_shot_pattern_hold_time' has a wrong offset!");
static_assert(offsetof(FCAShotPatternStatsTableData, M_camera_recoil_proportion) == 0x00003C, "Member 'FCAShotPatternStatsTableData::M_camera_recoil_proportion' has a wrong offset!");
static_assert(offsetof(FCAShotPatternStatsTableData, M_anchor_point_recoil_proportion) == 0x000040, "Member 'FCAShotPatternStatsTableData::M_anchor_point_recoil_proportion' has a wrong offset!");
static_assert(offsetof(FCAShotPatternStatsTableData, M_spread_anchor_shift_proportion) == 0x000044, "Member 'FCAShotPatternStatsTableData::M_spread_anchor_shift_proportion' has a wrong offset!");
static_assert(offsetof(FCAShotPatternStatsTableData, M_recoil_camera_attack) == 0x000048, "Member 'FCAShotPatternStatsTableData::M_recoil_camera_attack' has a wrong offset!");
static_assert(offsetof(FCAShotPatternStatsTableData, M_recoil_camera_hold) == 0x00004C, "Member 'FCAShotPatternStatsTableData::M_recoil_camera_hold' has a wrong offset!");
static_assert(offsetof(FCAShotPatternStatsTableData, M_recoil_camera_decay) == 0x000050, "Member 'FCAShotPatternStatsTableData::M_recoil_camera_decay' has a wrong offset!");
static_assert(offsetof(FCAShotPatternStatsTableData, M_recoil_camera_cutoff_angle) == 0x000054, "Member 'FCAShotPatternStatsTableData::M_recoil_camera_cutoff_angle' has a wrong offset!");
static_assert(offsetof(FCAShotPatternStatsTableData, M_repeated_last_indicies) == 0x000058, "Member 'FCAShotPatternStatsTableData::M_repeated_last_indicies' has a wrong offset!");
static_assert(offsetof(FCAShotPatternStatsTableData, M_shot_pattern_distance) == 0x00005C, "Member 'FCAShotPatternStatsTableData::M_shot_pattern_distance' has a wrong offset!");
static_assert(offsetof(FCAShotPatternStatsTableData, M_shot_pattern_gamepad_scale) == 0x000060, "Member 'FCAShotPatternStatsTableData::M_shot_pattern_gamepad_scale' has a wrong offset!");
static_assert(offsetof(FCAShotPatternStatsTableData, M_recoil_camera_decay_curves) == 0x000068, "Member 'FCAShotPatternStatsTableData::M_recoil_camera_decay_curves' has a wrong offset!");
static_assert(offsetof(FCAShotPatternStatsTableData, M_use_recoil_decay_range) == 0x000088, "Member 'FCAShotPatternStatsTableData::M_use_recoil_decay_range' has a wrong offset!");
static_assert(offsetof(FCAShotPatternStatsTableData, M_recoil_decay_range) == 0x00008C, "Member 'FCAShotPatternStatsTableData::M_recoil_decay_range' has a wrong offset!");

// ScriptStruct keaton.CAFireTypeStatsTableDataBase
// 0x0000 (0x0000 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x01) FCAFireTypeStatsTableDataBase
{
};
#pragma pack(pop)
static_assert(alignof(FCAFireTypeStatsTableDataBase) == 0x000001, "Wrong alignment on FCAFireTypeStatsTableDataBase");
static_assert(sizeof(FCAFireTypeStatsTableDataBase) == 0x000001, "Wrong size on FCAFireTypeStatsTableDataBase");

// ScriptStruct keaton.CABulletStatsTableData
// 0x0188 (0x0188 - 0x0000)
struct FCABulletStatsTableData final : public FCAFireTypeStatsTableDataBase
{
public:
	struct FFeatureKeyItem                        M_bullet_feature;                                  // 0x0000(0x0004)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             M_damage_curve;                                    // 0x0008(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFeatureObjectPtr                      M_proj_damage_curve;                               // 0x0038(0x0068)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_range;                                           // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_damage;                                          // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_aoe_damage;                                      // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_head_damage_multiplier;                          // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_body_damage_multiplier;                          // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_extremeties_damage_multiplier;                   // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_rear_damage_multiplier;                          // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_npc_damage_multiplier;                           // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_npc_component_damage_multiplier;                 // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_foam_damage_multiplier;                          // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_device_damage_multiplier;                        // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_additional_damage_type;                          // 0x00D0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_armour_piercing_ratio;                           // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_head_damage_ratio;                               // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_body_damage_ratio;                               // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_extremeties_damage_ratio;                        // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_max_health_damage_multiplier;                    // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_proj_lifetime;                                   // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_proj_initial_speed;                              // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_proj_initial_angle;                              // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_proj_use_launch_config;                          // 0x0110(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_proj_socket_fire_offset_socket;                  // 0x0114(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFeatureClassPtr                       M_proj_class;                                      // 0x0120(0x0068)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCABulletStatsTableData) == 0x000008, "Wrong alignment on FCABulletStatsTableData");
static_assert(sizeof(FCABulletStatsTableData) == 0x000188, "Wrong size on FCABulletStatsTableData");
static_assert(offsetof(FCABulletStatsTableData, M_bullet_feature) == 0x000000, "Member 'FCABulletStatsTableData::M_bullet_feature' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_damage_curve) == 0x000008, "Member 'FCABulletStatsTableData::M_damage_curve' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_proj_damage_curve) == 0x000038, "Member 'FCABulletStatsTableData::M_proj_damage_curve' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_range) == 0x0000A0, "Member 'FCABulletStatsTableData::M_range' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_damage) == 0x0000A4, "Member 'FCABulletStatsTableData::M_damage' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_aoe_damage) == 0x0000A8, "Member 'FCABulletStatsTableData::M_aoe_damage' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_head_damage_multiplier) == 0x0000AC, "Member 'FCABulletStatsTableData::M_head_damage_multiplier' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_body_damage_multiplier) == 0x0000B0, "Member 'FCABulletStatsTableData::M_body_damage_multiplier' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_extremeties_damage_multiplier) == 0x0000B4, "Member 'FCABulletStatsTableData::M_extremeties_damage_multiplier' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_rear_damage_multiplier) == 0x0000B8, "Member 'FCABulletStatsTableData::M_rear_damage_multiplier' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_npc_damage_multiplier) == 0x0000BC, "Member 'FCABulletStatsTableData::M_npc_damage_multiplier' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_npc_component_damage_multiplier) == 0x0000C0, "Member 'FCABulletStatsTableData::M_npc_component_damage_multiplier' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_foam_damage_multiplier) == 0x0000C4, "Member 'FCABulletStatsTableData::M_foam_damage_multiplier' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_device_damage_multiplier) == 0x0000C8, "Member 'FCABulletStatsTableData::M_device_damage_multiplier' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_additional_damage_type) == 0x0000D0, "Member 'FCABulletStatsTableData::M_additional_damage_type' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_armour_piercing_ratio) == 0x0000F0, "Member 'FCABulletStatsTableData::M_armour_piercing_ratio' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_head_damage_ratio) == 0x0000F4, "Member 'FCABulletStatsTableData::M_head_damage_ratio' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_body_damage_ratio) == 0x0000F8, "Member 'FCABulletStatsTableData::M_body_damage_ratio' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_extremeties_damage_ratio) == 0x0000FC, "Member 'FCABulletStatsTableData::M_extremeties_damage_ratio' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_max_health_damage_multiplier) == 0x000100, "Member 'FCABulletStatsTableData::M_max_health_damage_multiplier' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_proj_lifetime) == 0x000104, "Member 'FCABulletStatsTableData::M_proj_lifetime' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_proj_initial_speed) == 0x000108, "Member 'FCABulletStatsTableData::M_proj_initial_speed' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_proj_initial_angle) == 0x00010C, "Member 'FCABulletStatsTableData::M_proj_initial_angle' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_proj_use_launch_config) == 0x000110, "Member 'FCABulletStatsTableData::M_proj_use_launch_config' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_proj_socket_fire_offset_socket) == 0x000114, "Member 'FCABulletStatsTableData::M_proj_socket_fire_offset_socket' has a wrong offset!");
static_assert(offsetof(FCABulletStatsTableData, M_proj_class) == 0x000120, "Member 'FCABulletStatsTableData::M_proj_class' has a wrong offset!");

// ScriptStruct keaton.CAFireModeStatsInstance
// 0x0078 (0x0078 - 0x0000)
struct FCAFireModeStatsInstance final
{
public:
	class UCAFireTypeStatsInstanceBase*           M_fire_type_stats_instance;                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCAShotPatternStatsInstance*            M_shot_pattern_stats_instance;                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x68];                                      // 0x0010(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAFireModeStatsInstance) == 0x000008, "Wrong alignment on FCAFireModeStatsInstance");
static_assert(sizeof(FCAFireModeStatsInstance) == 0x000078, "Wrong size on FCAFireModeStatsInstance");
static_assert(offsetof(FCAFireModeStatsInstance, M_fire_type_stats_instance) == 0x000000, "Member 'FCAFireModeStatsInstance::M_fire_type_stats_instance' has a wrong offset!");
static_assert(offsetof(FCAFireModeStatsInstance, M_shot_pattern_stats_instance) == 0x000008, "Member 'FCAFireModeStatsInstance::M_shot_pattern_stats_instance' has a wrong offset!");

// ScriptStruct keaton.CAMuzzleStatsInstance
// 0x0858 (0x0858 - 0x0000)
struct FCAMuzzleStatsInstance final
{
public:
	TArray<struct FCAFireModeStatsInstance>       M_fire_mode_stats_instance_array;                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x848];                                     // 0x0010(0x0848)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAMuzzleStatsInstance) == 0x000008, "Wrong alignment on FCAMuzzleStatsInstance");
static_assert(sizeof(FCAMuzzleStatsInstance) == 0x000858, "Wrong size on FCAMuzzleStatsInstance");
static_assert(offsetof(FCAMuzzleStatsInstance, M_fire_mode_stats_instance_array) == 0x000000, "Member 'FCAMuzzleStatsInstance::M_fire_mode_stats_instance_array' has a wrong offset!");

// ScriptStruct keaton.CADialoguePingMappingRow
// 0x0010 (0x0018 - 0x0008)
struct FCADialoguePingMappingRow final : public FTableRowBase
{
public:
	ECAUIHUDEntityId                              EntityID;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PingDialogueName;                                  // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADialoguePingMappingRow) == 0x000008, "Wrong alignment on FCADialoguePingMappingRow");
static_assert(sizeof(FCADialoguePingMappingRow) == 0x000018, "Wrong size on FCADialoguePingMappingRow");
static_assert(offsetof(FCADialoguePingMappingRow, EntityID) == 0x000008, "Member 'FCADialoguePingMappingRow::EntityID' has a wrong offset!");
static_assert(offsetof(FCADialoguePingMappingRow, PingDialogueName) == 0x00000C, "Member 'FCADialoguePingMappingRow::PingDialogueName' has a wrong offset!");

// ScriptStruct keaton.CADialogueCooldownOverride
// 0x0008 (0x0008 - 0x0000)
struct FCADialogueCooldownOverride final
{
public:
	struct FFeatureKeyItem                        Feature;                                           // 0x0000(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Cooldown;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADialogueCooldownOverride) == 0x000004, "Wrong alignment on FCADialogueCooldownOverride");
static_assert(sizeof(FCADialogueCooldownOverride) == 0x000008, "Wrong size on FCADialogueCooldownOverride");
static_assert(offsetof(FCADialogueCooldownOverride, Feature) == 0x000000, "Member 'FCADialogueCooldownOverride::Feature' has a wrong offset!");
static_assert(offsetof(FCADialogueCooldownOverride, Cooldown) == 0x000004, "Member 'FCADialogueCooldownOverride::Cooldown' has a wrong offset!");

// ScriptStruct keaton.CADialogueDTBase
// 0x0138 (0x0140 - 0x0008)
struct FCADialogueDTBase final : public FTableRowBase
{
public:
	class FString                                 Trigger;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCAVariableValue>               Conditions;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          PlayOnFP;                                          // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayOnTP;                                          // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayOnComms;                                       // 0x002A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayOnRivals;                                      // 0x002B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSfx;                                             // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultCooldown;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FCADialogueCooldownOverride>      CooldownOverrides;                                 // 0x0038(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         GlobalCooldown;                                    // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<struct FCADialogueCooldownOverride>      DelayOverrides;                                    // 0x0090(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FCAFollowup                            Followup;                                          // 0x00E0(0x0030)(Edit, NativeAccessSpecifierPublic)
	ECAAudioDialoguePriority                      Priority;                                          // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAAudioDialoguePriority                      StreamPriority;                                    // 0x0111(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InterruptsEqualsPriority;                          // 0x0112(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_113[0x1];                                      // 0x0113(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QueueLifeTime;                                     // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ECADialogueTargetActorType>            TargetActorType;                                   // 0x0118(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          DiscardIfNoTargetActor;                            // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStaggered;                                       // 0x0129(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreDoppelganger;                                // 0x012A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12B[0x5];                                      // 0x012B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCAAudioStateValueType>         GamemodesToPlayIn;                                 // 0x0130(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCADialogueDTBase) == 0x000008, "Wrong alignment on FCADialogueDTBase");
static_assert(sizeof(FCADialogueDTBase) == 0x000140, "Wrong size on FCADialogueDTBase");
static_assert(offsetof(FCADialogueDTBase, Trigger) == 0x000008, "Member 'FCADialogueDTBase::Trigger' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, Conditions) == 0x000018, "Member 'FCADialogueDTBase::Conditions' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, PlayOnFP) == 0x000028, "Member 'FCADialogueDTBase::PlayOnFP' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, PlayOnTP) == 0x000029, "Member 'FCADialogueDTBase::PlayOnTP' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, PlayOnComms) == 0x00002A, "Member 'FCADialogueDTBase::PlayOnComms' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, PlayOnRivals) == 0x00002B, "Member 'FCADialogueDTBase::PlayOnRivals' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, IsSfx) == 0x00002C, "Member 'FCADialogueDTBase::IsSfx' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, DefaultCooldown) == 0x000030, "Member 'FCADialogueDTBase::DefaultCooldown' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, CooldownOverrides) == 0x000038, "Member 'FCADialogueDTBase::CooldownOverrides' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, GlobalCooldown) == 0x000088, "Member 'FCADialogueDTBase::GlobalCooldown' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, Delay) == 0x00008C, "Member 'FCADialogueDTBase::Delay' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, DelayOverrides) == 0x000090, "Member 'FCADialogueDTBase::DelayOverrides' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, Followup) == 0x0000E0, "Member 'FCADialogueDTBase::Followup' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, Priority) == 0x000110, "Member 'FCADialogueDTBase::Priority' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, StreamPriority) == 0x000111, "Member 'FCADialogueDTBase::StreamPriority' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, InterruptsEqualsPriority) == 0x000112, "Member 'FCADialogueDTBase::InterruptsEqualsPriority' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, QueueLifeTime) == 0x000114, "Member 'FCADialogueDTBase::QueueLifeTime' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, TargetActorType) == 0x000118, "Member 'FCADialogueDTBase::TargetActorType' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, DiscardIfNoTargetActor) == 0x000128, "Member 'FCADialogueDTBase::DiscardIfNoTargetActor' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, IsStaggered) == 0x000129, "Member 'FCADialogueDTBase::IsStaggered' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, IgnoreDoppelganger) == 0x00012A, "Member 'FCADialogueDTBase::IgnoreDoppelganger' has a wrong offset!");
static_assert(offsetof(FCADialogueDTBase, GamemodesToPlayIn) == 0x000130, "Member 'FCADialogueDTBase::GamemodesToPlayIn' has a wrong offset!");

// ScriptStruct keaton.CAProfileLevelProgressionData
// 0x001C (0x001C - 0x0000)
struct FCAProfileLevelProgressionData final
{
public:
	int32                                         M_starting_xp;                                     // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_target_xp;                                       // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_level;                                           // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_maximum_xp;                                      // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_starting_normalized_rank;                        // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_target_normalized_rank;                          // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_has_leveled_up;                                  // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAProfileLevelProgressionData) == 0x000004, "Wrong alignment on FCAProfileLevelProgressionData");
static_assert(sizeof(FCAProfileLevelProgressionData) == 0x00001C, "Wrong size on FCAProfileLevelProgressionData");
static_assert(offsetof(FCAProfileLevelProgressionData, M_starting_xp) == 0x000000, "Member 'FCAProfileLevelProgressionData::M_starting_xp' has a wrong offset!");
static_assert(offsetof(FCAProfileLevelProgressionData, M_target_xp) == 0x000004, "Member 'FCAProfileLevelProgressionData::M_target_xp' has a wrong offset!");
static_assert(offsetof(FCAProfileLevelProgressionData, M_level) == 0x000008, "Member 'FCAProfileLevelProgressionData::M_level' has a wrong offset!");
static_assert(offsetof(FCAProfileLevelProgressionData, M_maximum_xp) == 0x00000C, "Member 'FCAProfileLevelProgressionData::M_maximum_xp' has a wrong offset!");
static_assert(offsetof(FCAProfileLevelProgressionData, M_starting_normalized_rank) == 0x000010, "Member 'FCAProfileLevelProgressionData::M_starting_normalized_rank' has a wrong offset!");
static_assert(offsetof(FCAProfileLevelProgressionData, M_target_normalized_rank) == 0x000014, "Member 'FCAProfileLevelProgressionData::M_target_normalized_rank' has a wrong offset!");
static_assert(offsetof(FCAProfileLevelProgressionData, M_has_leveled_up) == 0x000018, "Member 'FCAProfileLevelProgressionData::M_has_leveled_up' has a wrong offset!");

// ScriptStruct keaton.CAEndOfMatchLevelProgressData
// 0x0014 (0x0014 - 0x0000)
struct FCAEndOfMatchLevelProgressData final
{
public:
	int32                                         M_level;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_base_xp;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_maximum_xp;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_rank_progress_normalized;                        // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_max_level;                                    // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAEndOfMatchLevelProgressData) == 0x000004, "Wrong alignment on FCAEndOfMatchLevelProgressData");
static_assert(sizeof(FCAEndOfMatchLevelProgressData) == 0x000014, "Wrong size on FCAEndOfMatchLevelProgressData");
static_assert(offsetof(FCAEndOfMatchLevelProgressData, M_level) == 0x000000, "Member 'FCAEndOfMatchLevelProgressData::M_level' has a wrong offset!");
static_assert(offsetof(FCAEndOfMatchLevelProgressData, M_base_xp) == 0x000004, "Member 'FCAEndOfMatchLevelProgressData::M_base_xp' has a wrong offset!");
static_assert(offsetof(FCAEndOfMatchLevelProgressData, M_maximum_xp) == 0x000008, "Member 'FCAEndOfMatchLevelProgressData::M_maximum_xp' has a wrong offset!");
static_assert(offsetof(FCAEndOfMatchLevelProgressData, M_rank_progress_normalized) == 0x00000C, "Member 'FCAEndOfMatchLevelProgressData::M_rank_progress_normalized' has a wrong offset!");
static_assert(offsetof(FCAEndOfMatchLevelProgressData, M_is_max_level) == 0x000010, "Member 'FCAEndOfMatchLevelProgressData::M_is_max_level' has a wrong offset!");

// ScriptStruct keaton.CAMapWidgetEntry
// 0x0010 (0x0010 - 0x0000)
struct FCAMapWidgetEntry final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCAHUDMapIconBase*                      M_widget;                                          // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAMapWidgetEntry) == 0x000008, "Wrong alignment on FCAMapWidgetEntry");
static_assert(sizeof(FCAMapWidgetEntry) == 0x000010, "Wrong size on FCAMapWidgetEntry");
static_assert(offsetof(FCAMapWidgetEntry, M_widget) == 0x000008, "Member 'FCAMapWidgetEntry::M_widget' has a wrong offset!");

// ScriptStruct keaton.CAFrontendPersistentState
// 0x0003 (0x0003 - 0x0000)
struct FCAFrontendPersistentState final
{
public:
	ECAPostGameState                              M_post_game_state;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECAFrontendContext                            M_frontend_context;                                // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_ftue;                                         // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAFrontendPersistentState) == 0x000001, "Wrong alignment on FCAFrontendPersistentState");
static_assert(sizeof(FCAFrontendPersistentState) == 0x000003, "Wrong size on FCAFrontendPersistentState");
static_assert(offsetof(FCAFrontendPersistentState, M_post_game_state) == 0x000000, "Member 'FCAFrontendPersistentState::M_post_game_state' has a wrong offset!");
static_assert(offsetof(FCAFrontendPersistentState, M_frontend_context) == 0x000001, "Member 'FCAFrontendPersistentState::M_frontend_context' has a wrong offset!");
static_assert(offsetof(FCAFrontendPersistentState, M_is_ftue) == 0x000002, "Member 'FCAFrontendPersistentState::M_is_ftue' has a wrong offset!");

// ScriptStruct keaton.CAHUDInteractionLabelsRow
// 0x0090 (0x0098 - 0x0008)
struct FCAHUDInteractionLabelsRow final : public FTableRowBase
{
public:
	ECAUseInteractableType                        M_type;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCAHUDInteractionListEntry> M_interaction_widget_class;                        // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAText                                M_prompt;                                          // 0x0018(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCAText                                M_prompt_when_unavailable;                         // 0x0048(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          M_non_interactable;                                // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_held_interaction;                                // 0x0079(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_unavailable;                                     // 0x007A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B[0x1];                                       // 0x007B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_action_name;                                     // 0x007C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_interaction_started_audio_event;                 // 0x0088(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_interaction_success_audio_event;                 // 0x008C(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCAAudioEventType                      M_interaction_fail_audio_event;                    // 0x0090(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCAHUDInteractionLabelsRow) == 0x000008, "Wrong alignment on FCAHUDInteractionLabelsRow");
static_assert(sizeof(FCAHUDInteractionLabelsRow) == 0x000098, "Wrong size on FCAHUDInteractionLabelsRow");
static_assert(offsetof(FCAHUDInteractionLabelsRow, M_type) == 0x000008, "Member 'FCAHUDInteractionLabelsRow::M_type' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionLabelsRow, M_interaction_widget_class) == 0x000010, "Member 'FCAHUDInteractionLabelsRow::M_interaction_widget_class' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionLabelsRow, M_prompt) == 0x000018, "Member 'FCAHUDInteractionLabelsRow::M_prompt' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionLabelsRow, M_prompt_when_unavailable) == 0x000048, "Member 'FCAHUDInteractionLabelsRow::M_prompt_when_unavailable' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionLabelsRow, M_non_interactable) == 0x000078, "Member 'FCAHUDInteractionLabelsRow::M_non_interactable' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionLabelsRow, M_held_interaction) == 0x000079, "Member 'FCAHUDInteractionLabelsRow::M_held_interaction' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionLabelsRow, M_unavailable) == 0x00007A, "Member 'FCAHUDInteractionLabelsRow::M_unavailable' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionLabelsRow, M_action_name) == 0x00007C, "Member 'FCAHUDInteractionLabelsRow::M_action_name' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionLabelsRow, M_interaction_started_audio_event) == 0x000088, "Member 'FCAHUDInteractionLabelsRow::M_interaction_started_audio_event' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionLabelsRow, M_interaction_success_audio_event) == 0x00008C, "Member 'FCAHUDInteractionLabelsRow::M_interaction_success_audio_event' has a wrong offset!");
static_assert(offsetof(FCAHUDInteractionLabelsRow, M_interaction_fail_audio_event) == 0x000090, "Member 'FCAHUDInteractionLabelsRow::M_interaction_fail_audio_event' has a wrong offset!");

// ScriptStruct keaton.CAOnHitInfo
// 0x0010 (0x0010 - 0x0000)
struct FCAOnHitInfo final
{
public:
	TArray<TSubclassOf<class UGameplayEffect>>    M_gameplay_effects;                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCAOnHitInfo) == 0x000008, "Wrong alignment on FCAOnHitInfo");
static_assert(sizeof(FCAOnHitInfo) == 0x000010, "Wrong size on FCAOnHitInfo");
static_assert(offsetof(FCAOnHitInfo, M_gameplay_effects) == 0x000000, "Member 'FCAOnHitInfo::M_gameplay_effects' has a wrong offset!");

}

