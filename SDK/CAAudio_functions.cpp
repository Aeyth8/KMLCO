#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CAAudio

#include "Basic.hpp"

#include "CAAudio_classes.hpp"
#include "CAAudio_parameters.hpp"


namespace SDK
{

// Function CAAudio.CAAudioAmbientComponent.StartAmbientComponent
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)

void UCAAudioAmbientComponent::StartAmbientComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CAAudioAmbientComponent", "StartAmbientComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioAmbientComponent.StopAmbientComponent
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)

void UCAAudioAmbientComponent::StopAmbientComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CAAudioAmbientComponent", "StopAmbientComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBank.Load
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// ECAAudioBankScope                       Scope                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBank::Load(ECAAudioBankScope Scope)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CAAudioBank", "Load");

	Params::CAAudioBank_Load Parms{};

	Parms.Scope = Scope;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBank.UnLoad
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)

void UCAAudioBank::UnLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CAAudioBank", "UnLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBeamComponent.SetRTPC
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// struct FCAAudioRTPCNameType             Rtpc_name                                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Change_duration                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Threshold                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBeamComponent::SetRTPC(const struct FCAAudioRTPCNameType& Rtpc_name, const float Value, const float Change_duration, const float Threshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CAAudioBeamComponent", "SetRTPC");

	Params::CAAudioBeamComponent_SetRTPC Parms{};

	Parms.Rtpc_name = std::move(Rtpc_name);
	Parms.Value = Value;
	Parms.Change_duration = Change_duration;
	Parms.Threshold = Threshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBeamComponent.SetSwitch
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// struct FCAAudioSwitchNameType           Switch_name                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FCAAudioSwitchValueType          Switch_value                                           (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCAAudioBeamComponent::SetSwitch(const struct FCAAudioSwitchNameType& Switch_name, const struct FCAAudioSwitchValueType& Switch_value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CAAudioBeamComponent", "SetSwitch");

	Params::CAAudioBeamComponent_SetSwitch Parms{};

	Parms.Switch_name = std::move(Switch_name);
	Parms.Switch_value = std::move(Switch_value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBeamComponent.Start
// (Final, BlueprintCosmetic, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Start_0                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBeamComponent::Start(const struct FVector& Start_0, const struct FVector& End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CAAudioBeamComponent", "Start");

	Params::CAAudioBeamComponent_Start Parms{};

	Parms.Start_0 = std::move(Start_0);
	Parms.End = std::move(End);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBeamComponent.Stop
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Fade_out_ms                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBeamComponent::Stop(int32 Fade_out_ms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CAAudioBeamComponent", "Stop");

	Params::CAAudioBeamComponent_Stop Parms{};

	Parms.Fade_out_ms = Fade_out_ms;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBeamComponent.UpdateBeamPosition
// (Final, BlueprintCosmetic, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Start                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBeamComponent::UpdateBeamPosition(const struct FVector& Start, const struct FVector& End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CAAudioBeamComponent", "UpdateBeamPosition");

	Params::CAAudioBeamComponent_UpdateBeamPosition Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBeamComponent.UpdateSourcePosition
// (Final, BlueprintCosmetic, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Source                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBeamComponent::UpdateSourcePosition(const struct FVector& Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CAAudioBeamComponent", "UpdateSourcePosition");

	Params::CAAudioBeamComponent_UpdateSourcePosition Parms{};

	Parms.Source = std::move(Source);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.BeginTrackingRTPC
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCAAudioRTPCNameType             Rtpc_name                                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FCAAudioPlaybackInstance         Instance                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCAAudioBlueprintFunctionLibrary::BeginTrackingRTPC(const struct FCAAudioRTPCNameType& Rtpc_name, const struct FCAAudioPlaybackInstance& Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "BeginTrackingRTPC");

	Params::CAAudioBlueprintFunctionLibrary_BeginTrackingRTPC Parms{};

	Parms.Rtpc_name = std::move(Rtpc_name);
	Parms.Instance = std::move(Instance);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.CompareHashIsEqual
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FCAAudioHashBase                 A                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FCAAudioHashBase                 b                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCAAudioBlueprintFunctionLibrary::CompareHashIsEqual(const struct FCAAudioHashBase& A, const struct FCAAudioHashBase& b)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "CompareHashIsEqual");

	Params::CAAudioBlueprintFunctionLibrary_CompareHashIsEqual Parms{};

	Parms.A = std::move(A);
	Parms.b = std::move(b);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.EndTrackingRTPC
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Tracking_id                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::EndTrackingRTPC(const int32 Tracking_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "EndTrackingRTPC");

	Params::CAAudioBlueprintFunctionLibrary_EndTrackingRTPC Parms{};

	Parms.Tracking_id = Tracking_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.GetEventInfo
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCAAudioEventType                Event                                                  (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Max_attenuation                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max_duration                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Is_3D                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Is_localised                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::GetEventInfo(const struct FCAAudioEventType& Event, float* Max_attenuation, float* Max_duration, bool* Is_3D, bool* Is_localised)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "GetEventInfo");

	Params::CAAudioBlueprintFunctionLibrary_GetEventInfo Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Max_attenuation != nullptr)
		*Max_attenuation = Parms.Max_attenuation;

	if (Max_duration != nullptr)
		*Max_duration = Parms.Max_duration;

	if (Is_3D != nullptr)
		*Is_3D = Parms.Is_3D;

	if (Is_localised != nullptr)
		*Is_localised = Parms.Is_localised;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.GetMaterialAudio
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EPhysicalSurface                        Surface                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioSwitchValueType          Switch_value                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FCAAudioBankNameType             Footstep_bank_name                                     (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::GetMaterialAudio(const EPhysicalSurface Surface, struct FCAAudioSwitchValueType* Switch_value, struct FCAAudioBankNameType* Footstep_bank_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "GetMaterialAudio");

	Params::CAAudioBlueprintFunctionLibrary_GetMaterialAudio Parms{};

	Parms.Surface = Surface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Switch_value != nullptr)
		*Switch_value = std::move(Parms.Switch_value);

	if (Footstep_bank_name != nullptr)
		*Footstep_bank_name = std::move(Parms.Footstep_bank_name);
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.GetObjectInfo
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UCAAudioComponent*                Component                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Is_playing                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Is_audible                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Is_3D                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance_to_listener                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::GetObjectInfo(const class UCAAudioComponent* Component, const class AActor* Actor, bool* Is_playing, bool* Is_audible, bool* Is_3D, float* Radius, float* Distance_to_listener)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "GetObjectInfo");

	Params::CAAudioBlueprintFunctionLibrary_GetObjectInfo Parms{};

	Parms.Component = Component;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Is_playing != nullptr)
		*Is_playing = Parms.Is_playing;

	if (Is_audible != nullptr)
		*Is_audible = Parms.Is_audible;

	if (Is_3D != nullptr)
		*Is_3D = Parms.Is_3D;

	if (Radius != nullptr)
		*Radius = Parms.Radius;

	if (Distance_to_listener != nullptr)
		*Distance_to_listener = Parms.Distance_to_listener;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.GetTrackedRTPC
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Tracking_id                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCAAudioBlueprintFunctionLibrary::GetTrackedRTPC(const int32 Tracking_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "GetTrackedRTPC");

	Params::CAAudioBlueprintFunctionLibrary_GetTrackedRTPC Parms{};

	Parms.Tracking_id = Tracking_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.HandleFootstep
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioSwitchValueType          Material_switch                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FCAAudioBankNameType             Material_bank                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Max_distance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::HandleFootstep(class AActor* Actor, const struct FCAAudioSwitchValueType& Material_switch, const struct FCAAudioBankNameType& Material_bank, float Max_distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "HandleFootstep");

	Params::CAAudioBlueprintFunctionLibrary_HandleFootstep Parms{};

	Parms.Actor = Actor;
	Parms.Material_switch = std::move(Material_switch);
	Parms.Material_bank = std::move(Material_bank);
	Parms.Max_distance = Max_distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.IsBankLoaded
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCAAudioBankNameType             bank_name                                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    Loaded                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Loading                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::IsBankLoaded(const struct FCAAudioBankNameType& bank_name, bool* Loaded, bool* Loading)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "IsBankLoaded");

	Params::CAAudioBlueprintFunctionLibrary_IsBankLoaded Parms{};

	Parms.bank_name = std::move(bank_name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Loaded != nullptr)
		*Loaded = Parms.Loaded;

	if (Loading != nullptr)
		*Loading = Parms.Loading;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.IsInAudibleRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max_distance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCAAudioBlueprintFunctionLibrary::IsInAudibleRange(class AActor* Actor, float Max_distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "IsInAudibleRange");

	Params::CAAudioBlueprintFunctionLibrary_IsInAudibleRange Parms{};

	Parms.Actor = Actor;
	Parms.Max_distance = Max_distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.IsPlaybackFinished
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCAAudioPlaybackInstance         Playback_instance                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::IsPlaybackFinished(const struct FCAAudioPlaybackInstance& Playback_instance, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "IsPlaybackFinished");

	Params::CAAudioBlueprintFunctionLibrary_IsPlaybackFinished Parms{};

	Parms.Playback_instance = std::move(Playback_instance);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.LoadBank
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FCAAudioBankNameType             bank_name                                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// ECAAudioMemoryPool                      Memory_pool                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Async_load                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::LoadBank(const struct FCAAudioBankNameType& bank_name, const ECAAudioMemoryPool Memory_pool, bool Async_load)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "LoadBank");

	Params::CAAudioBlueprintFunctionLibrary_LoadBank Parms{};

	Parms.bank_name = std::move(bank_name);
	Parms.Memory_pool = Memory_pool;
	Parms.Async_load = Async_load;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.PlayAmbientGroup
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Group_name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::PlayAmbientGroup(const class FString& Group_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "PlayAmbientGroup");

	Params::CAAudioBlueprintFunctionLibrary_PlayAmbientGroup Parms{};

	Parms.Group_name = std::move(Group_name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.PlayDynamicEvent
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCAAudioEventType                Event                                                  (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class FString>                   Arguments                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UCAAudioComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FCAAudioEventType& Event_name)>On_finished                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FCAAudioPlaybackInstance         Playback_instance                                      (Parm, OutParm, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    Play_success                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Stop_when_destroyed                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Ignore_out_of_range_oneshot                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Manage_loop                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Ignore_errors                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::PlayDynamicEvent(const struct FCAAudioEventType& Event, const TArray<class FString>& Arguments, class UCAAudioComponent* Component, class AActor* Actor, const TDelegate<void(const struct FCAAudioEventType& Event_name)>& On_finished, struct FCAAudioPlaybackInstance* Playback_instance, bool* Play_success, const bool Stop_when_destroyed, const bool Ignore_out_of_range_oneshot, const bool Manage_loop, const bool Ignore_errors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "PlayDynamicEvent");

	Params::CAAudioBlueprintFunctionLibrary_PlayDynamicEvent Parms{};

	Parms.Event = std::move(Event);
	Parms.Arguments = std::move(Arguments);
	Parms.Component = Component;
	Parms.Actor = Actor;
	Parms.On_finished = On_finished;
	Parms.Stop_when_destroyed = Stop_when_destroyed;
	Parms.Ignore_out_of_range_oneshot = Ignore_out_of_range_oneshot;
	Parms.Manage_loop = Manage_loop;
	Parms.Ignore_errors = Ignore_errors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Playback_instance != nullptr)
		*Playback_instance = std::move(Parms.Playback_instance);

	if (Play_success != nullptr)
		*Play_success = Parms.Play_success;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.PlayEvent
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCAAudioEventType                Event                                                  (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UCAAudioComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FCAAudioEventType& Event_name)>On_finished                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FCAAudioPlaybackInstance         Playback_instance                                      (Parm, OutParm, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    Play_success                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Stop_when_destroyed                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Ignore_out_of_range_oneshot                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Manage_loop                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Ignore_errors                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Single_instance                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::PlayEvent(const struct FCAAudioEventType& Event, class UCAAudioComponent* Component, class AActor* Actor, const TDelegate<void(const struct FCAAudioEventType& Event_name)>& On_finished, struct FCAAudioPlaybackInstance* Playback_instance, bool* Play_success, const bool Stop_when_destroyed, const bool Ignore_out_of_range_oneshot, const bool Manage_loop, const bool Ignore_errors, const bool Single_instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "PlayEvent");

	Params::CAAudioBlueprintFunctionLibrary_PlayEvent Parms{};

	Parms.Event = std::move(Event);
	Parms.Component = Component;
	Parms.Actor = Actor;
	Parms.On_finished = On_finished;
	Parms.Stop_when_destroyed = Stop_when_destroyed;
	Parms.Ignore_out_of_range_oneshot = Ignore_out_of_range_oneshot;
	Parms.Manage_loop = Manage_loop;
	Parms.Ignore_errors = Ignore_errors;
	Parms.Single_instance = Single_instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Playback_instance != nullptr)
		*Playback_instance = std::move(Parms.Playback_instance);

	if (Play_success != nullptr)
		*Play_success = Parms.Play_success;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.PlayEventInWorld
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FCAAudioEventType                Event                                                  (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioSwitchNameType           Switch_name                                            (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FCAAudioSwitchValueType          Switch_value                                           (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FCAAudioRTPCNameType             Rtpc_name                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                                   Rtpc_value                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioPlaybackInstance         Playback_instance                                      (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    Play_success                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Ignore_out_of_range_oneshot                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::PlayEventInWorld(const struct FCAAudioEventType& Event, const struct FVector& Location, const struct FCAAudioSwitchNameType& Switch_name, const struct FCAAudioSwitchValueType& Switch_value, const struct FCAAudioRTPCNameType& Rtpc_name, const float Rtpc_value, struct FCAAudioPlaybackInstance* Playback_instance, bool* Play_success, const bool Ignore_out_of_range_oneshot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "PlayEventInWorld");

	Params::CAAudioBlueprintFunctionLibrary_PlayEventInWorld Parms{};

	Parms.Event = std::move(Event);
	Parms.Location = std::move(Location);
	Parms.Switch_name = std::move(Switch_name);
	Parms.Switch_value = std::move(Switch_value);
	Parms.Rtpc_name = std::move(Rtpc_name);
	Parms.Rtpc_value = Rtpc_value;
	Parms.Ignore_out_of_range_oneshot = Ignore_out_of_range_oneshot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Playback_instance != nullptr)
		*Playback_instance = std::move(Parms.Playback_instance);

	if (Play_success != nullptr)
		*Play_success = Parms.Play_success;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.PlayPortalledEventInWorld
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FCAAudioEventType                Event                                                  (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioSwitchNameType           Switch_name                                            (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FCAAudioSwitchValueType          Switch_value                                           (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FCAAudioRTPCNameType             Rtpc_name                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                                   Rtpc_value                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioPlaybackInstance         Playback_instance                                      (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    Play_success                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Ignore_out_of_range_oneshot                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Use_occluded_source                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::PlayPortalledEventInWorld(const struct FCAAudioEventType& Event, const struct FVector& Location, const struct FCAAudioSwitchNameType& Switch_name, const struct FCAAudioSwitchValueType& Switch_value, const struct FCAAudioRTPCNameType& Rtpc_name, const float Rtpc_value, struct FCAAudioPlaybackInstance* Playback_instance, bool* Play_success, const bool Ignore_out_of_range_oneshot, const bool Use_occluded_source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "PlayPortalledEventInWorld");

	Params::CAAudioBlueprintFunctionLibrary_PlayPortalledEventInWorld Parms{};

	Parms.Event = std::move(Event);
	Parms.Location = std::move(Location);
	Parms.Switch_name = std::move(Switch_name);
	Parms.Switch_value = std::move(Switch_value);
	Parms.Rtpc_name = std::move(Rtpc_name);
	Parms.Rtpc_value = Rtpc_value;
	Parms.Ignore_out_of_range_oneshot = Ignore_out_of_range_oneshot;
	Parms.Use_occluded_source = Use_occluded_source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Playback_instance != nullptr)
		*Playback_instance = std::move(Parms.Playback_instance);

	if (Play_success != nullptr)
		*Play_success = Parms.Play_success;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.PlayWhizzBy
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FCAAudioEventType                Event                                                  (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Projectile_start                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Projectile_end                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max_end_distance                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Trigger_distance                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Ignore_distance                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::PlayWhizzBy(const struct FCAAudioEventType& Event, const struct FVector& Projectile_start, const struct FVector& Projectile_end, const float Max_end_distance, const float Trigger_distance, const float Ignore_distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "PlayWhizzBy");

	Params::CAAudioBlueprintFunctionLibrary_PlayWhizzBy Parms{};

	Parms.Event = std::move(Event);
	Parms.Projectile_start = std::move(Projectile_start);
	Parms.Projectile_end = std::move(Projectile_end);
	Parms.Max_end_distance = Max_end_distance;
	Parms.Trigger_distance = Trigger_distance;
	Parms.Ignore_distance = Ignore_distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.RequestDynamicDialogue
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FCAAudioEventType                Event                                                  (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class FString>                   Arguments                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UCAAudioComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FCAAudioEventType& Event_name)>On_finished                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    Is_streamed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max_queue_time                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECAAudioDialoguePriority                Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Interrupt_equal_priority                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::RequestDynamicDialogue(const struct FCAAudioEventType& Event, const TArray<class FString>& Arguments, class UCAAudioComponent* Component, class AActor* Actor, const struct FVector& Position, const TDelegate<void(const struct FCAAudioEventType& Event_name)>& On_finished, bool Is_streamed, float Max_queue_time, ECAAudioDialoguePriority Priority, bool Interrupt_equal_priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "RequestDynamicDialogue");

	Params::CAAudioBlueprintFunctionLibrary_RequestDynamicDialogue Parms{};

	Parms.Event = std::move(Event);
	Parms.Arguments = std::move(Arguments);
	Parms.Component = Component;
	Parms.Actor = Actor;
	Parms.Position = std::move(Position);
	Parms.On_finished = On_finished;
	Parms.Is_streamed = Is_streamed;
	Parms.Max_queue_time = Max_queue_time;
	Parms.Priority = Priority;
	Parms.Interrupt_equal_priority = Interrupt_equal_priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.RequestExternalDialogue
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FCAAudioEventType                Event                                                  (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioSwitchValueType          Projection                                             (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UCAAudioComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FCAAudioEventType& Event_name)>On_finished                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// class FString                           Target                                                 (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Is_streamed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max_queue_time                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECAAudioDialoguePriority                Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Interrupt_equal_priority                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::RequestExternalDialogue(const struct FCAAudioEventType& Event, const class FString& Filename, const struct FCAAudioSwitchValueType& Projection, class UCAAudioComponent* Component, class AActor* Actor, const struct FVector& Position, const TDelegate<void(const struct FCAAudioEventType& Event_name)>& On_finished, const class FString& Target, bool Is_streamed, float Max_queue_time, ECAAudioDialoguePriority Priority, bool Interrupt_equal_priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "RequestExternalDialogue");

	Params::CAAudioBlueprintFunctionLibrary_RequestExternalDialogue Parms{};

	Parms.Event = std::move(Event);
	Parms.Filename = std::move(Filename);
	Parms.Projection = std::move(Projection);
	Parms.Component = Component;
	Parms.Actor = Actor;
	Parms.Position = std::move(Position);
	Parms.On_finished = On_finished;
	Parms.Target = std::move(Target);
	Parms.Is_streamed = Is_streamed;
	Parms.Max_queue_time = Max_queue_time;
	Parms.Priority = Priority;
	Parms.Interrupt_equal_priority = Interrupt_equal_priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.RequestSingleDialogue
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCAAudioEventType                Event                                                  (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UCAAudioComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FCAAudioEventType& Event_name)>On_finished                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    Is_streamed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max_queue_time                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECAAudioDialoguePriority                Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Interrupt_equal_priority                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::RequestSingleDialogue(const struct FCAAudioEventType& Event, class UCAAudioComponent* Component, class AActor* Actor, const TDelegate<void(const struct FCAAudioEventType& Event_name)>& On_finished, bool Is_streamed, float Max_queue_time, ECAAudioDialoguePriority Priority, bool Interrupt_equal_priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "RequestSingleDialogue");

	Params::CAAudioBlueprintFunctionLibrary_RequestSingleDialogue Parms{};

	Parms.Event = std::move(Event);
	Parms.Component = Component;
	Parms.Actor = Actor;
	Parms.On_finished = On_finished;
	Parms.Is_streamed = Is_streamed;
	Parms.Max_queue_time = Max_queue_time;
	Parms.Priority = Priority;
	Parms.Interrupt_equal_priority = Interrupt_equal_priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.SetPlaybackWorldPosition
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FCAAudioPlaybackInstance         Playback_instance                                      (Parm, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::SetPlaybackWorldPosition(const struct FCAAudioPlaybackInstance& Playback_instance, const struct FVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "SetPlaybackWorldPosition");

	Params::CAAudioBlueprintFunctionLibrary_SetPlaybackWorldPosition Parms{};

	Parms.Playback_instance = std::move(Playback_instance);
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.SetRTPC
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UCAAudioComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioRTPCNameType             Rtpc_name                                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Global                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Change_duration                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Threshold                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::SetRTPC(class UCAAudioComponent* Component, class AActor* Actor, const struct FCAAudioRTPCNameType& Rtpc_name, const float Value, bool Global, const float Change_duration, const float Threshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "SetRTPC");

	Params::CAAudioBlueprintFunctionLibrary_SetRTPC Parms{};

	Parms.Component = Component;
	Parms.Actor = Actor;
	Parms.Rtpc_name = std::move(Rtpc_name);
	Parms.Value = Value;
	Parms.Global = Global;
	Parms.Change_duration = Change_duration;
	Parms.Threshold = Threshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.SetState
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FCAAudioStateNameType            State_name                                             (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FCAAudioStateValueType           State_value                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::SetState(const struct FCAAudioStateNameType& State_name, const struct FCAAudioStateValueType& State_value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "SetState");

	Params::CAAudioBlueprintFunctionLibrary_SetState Parms{};

	Parms.State_name = std::move(State_name);
	Parms.State_value = std::move(State_value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.SetSwitch
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UCAAudioComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioSwitchNameType           Switch_name                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FCAAudioSwitchValueType          Switch_value                                           (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::SetSwitch(class UCAAudioComponent* Component, class AActor* Actor, const struct FCAAudioSwitchNameType& Switch_name, const struct FCAAudioSwitchValueType& Switch_value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "SetSwitch");

	Params::CAAudioBlueprintFunctionLibrary_SetSwitch Parms{};

	Parms.Component = Component;
	Parms.Actor = Actor;
	Parms.Switch_name = std::move(Switch_name);
	Parms.Switch_value = std::move(Switch_value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.SimplePlayEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FCAAudioEventType                Event                                                  (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Stop_when_destroyed                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Ignore_out_of_range_oneshot                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::SimplePlayEvent(const struct FCAAudioEventType& Event, class AActor* Actor, const bool Stop_when_destroyed, const bool Ignore_out_of_range_oneshot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "SimplePlayEvent");

	Params::CAAudioBlueprintFunctionLibrary_SimplePlayEvent Parms{};

	Parms.Event = std::move(Event);
	Parms.Actor = Actor;
	Parms.Stop_when_destroyed = Stop_when_destroyed;
	Parms.Ignore_out_of_range_oneshot = Ignore_out_of_range_oneshot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.StopAmbientGroup
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Group_name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Fade_out_ms                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::StopAmbientGroup(const class FString& Group_name, const int32 Fade_out_ms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "StopAmbientGroup");

	Params::CAAudioBlueprintFunctionLibrary_StopAmbientGroup Parms{};

	Parms.Group_name = std::move(Group_name);
	Parms.Fade_out_ms = Fade_out_ms;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.StopEventByInstance
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCAAudioPlaybackInstance         Playback_instance                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Fade_out_ms                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::StopEventByInstance(const struct FCAAudioPlaybackInstance& Playback_instance, const int32 Fade_out_ms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "StopEventByInstance");

	Params::CAAudioBlueprintFunctionLibrary_StopEventByInstance Parms{};

	Parms.Playback_instance = std::move(Playback_instance);
	Parms.Fade_out_ms = Fade_out_ms;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.StopEventByName
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FCAAudioEventType                Event                                                  (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UCAAudioComponent*                Component                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Fade_out_ms                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::StopEventByName(const struct FCAAudioEventType& Event, const class UCAAudioComponent* Component, const class AActor* Actor, const int32 Fade_out_ms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "StopEventByName");

	Params::CAAudioBlueprintFunctionLibrary_StopEventByName Parms{};

	Parms.Event = std::move(Event);
	Parms.Component = Component;
	Parms.Actor = Actor;
	Parms.Fade_out_ms = Fade_out_ms;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.StopObject
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UCAAudioComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Fade_out_ms                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::StopObject(class UCAAudioComponent* Component, class AActor* Actor, const int32 Fade_out_ms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "StopObject");

	Params::CAAudioBlueprintFunctionLibrary_StopObject Parms{};

	Parms.Component = Component;
	Parms.Actor = Actor;
	Parms.Fade_out_ms = Fade_out_ms;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.StringToEvent
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioEventType                Event                                                  (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::StringToEvent(const class FString& String, struct FCAAudioEventType* Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "StringToEvent");

	Params::CAAudioBlueprintFunctionLibrary_StringToEvent Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Event != nullptr)
		*Event = std::move(Parms.Event);
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.StringToRTPCName
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioRTPCNameType             Rtpc_name                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::StringToRTPCName(const class FString& String, struct FCAAudioRTPCNameType* Rtpc_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "StringToRTPCName");

	Params::CAAudioBlueprintFunctionLibrary_StringToRTPCName Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Rtpc_name != nullptr)
		*Rtpc_name = std::move(Parms.Rtpc_name);
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.StringToStateName
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioStateNameType            State_name                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::StringToStateName(const class FString& String, struct FCAAudioStateNameType* State_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "StringToStateName");

	Params::CAAudioBlueprintFunctionLibrary_StringToStateName Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (State_name != nullptr)
		*State_name = std::move(Parms.State_name);
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.StringToStateValue
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioStateValueType           State_value                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::StringToStateValue(const class FString& String, struct FCAAudioStateValueType* State_value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "StringToStateValue");

	Params::CAAudioBlueprintFunctionLibrary_StringToStateValue Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (State_value != nullptr)
		*State_value = std::move(Parms.State_value);
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.StringToSwitchName
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioSwitchNameType           Switch_name                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::StringToSwitchName(const class FString& String, struct FCAAudioSwitchNameType* Switch_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "StringToSwitchName");

	Params::CAAudioBlueprintFunctionLibrary_StringToSwitchName Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Switch_name != nullptr)
		*Switch_name = std::move(Parms.Switch_name);
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.StringToSwitchValue
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioSwitchValueType          Switch_value                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::StringToSwitchValue(const class FString& String, struct FCAAudioSwitchValueType* Switch_value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "StringToSwitchValue");

	Params::CAAudioBlueprintFunctionLibrary_StringToSwitchValue Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Switch_value != nullptr)
		*Switch_value = std::move(Parms.Switch_value);
}


// Function CAAudio.CAAudioBlueprintFunctionLibrary.UnloadBank
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FCAAudioBankNameType             bank_name                                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    Force_unload                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::UnloadBank(const struct FCAAudioBankNameType& bank_name, const bool Force_unload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioBlueprintFunctionLibrary", "UnloadBank");

	Params::CAAudioBlueprintFunctionLibrary_UnloadBank Parms{};

	Parms.bank_name = std::move(bank_name);
	Parms.Force_unload = Force_unload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction CAAudio.CAAudioBlueprintFunctionLibrary.CompletionDelegate__DelegateSignature
// (Public, Delegate)
// Parameters:
// struct FCAAudioEventType                Event_name                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCAAudioBlueprintFunctionLibrary::CompletionDelegate__DelegateSignature(const struct FCAAudioEventType& Event_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CAAudioBlueprintFunctionLibrary", "CompletionDelegate__DelegateSignature");

	Params::CAAudioBlueprintFunctionLibrary_CompletionDelegate__DelegateSignature Parms{};

	Parms.Event_name = std::move(Event_name);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CAAudio.CAAudioMultiObjectComponent.RegisterEmitter
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)

void UCAAudioMultiObjectComponent::RegisterEmitter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CAAudioMultiObjectComponent", "RegisterEmitter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioMultiObjectBlueprintFunctionLibrary.AddMultiObjectArea
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Area                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Area_name                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioMultiObjectBlueprintFunctionLibrary::AddMultiObjectArea(class AActor* Area, const class FString& Area_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioMultiObjectBlueprintFunctionLibrary", "AddMultiObjectArea");

	Params::CAAudioMultiObjectBlueprintFunctionLibrary_AddMultiObjectArea Parms{};

	Parms.Area = Area;
	Parms.Area_name = std::move(Area_name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioMultiObjectBlueprintFunctionLibrary.PlayOnMultiObject
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCAAudioEventType                Event                                                  (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Emitter_name                                           (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Group_name                                             (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioPlaybackInstance         Playback_instance                                      (Parm, OutParm, NativeAccessSpecifierPublic)

void UCAAudioMultiObjectBlueprintFunctionLibrary::PlayOnMultiObject(const struct FCAAudioEventType& Event, const class FString& Emitter_name, const class FString& Group_name, struct FCAAudioPlaybackInstance* Playback_instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioMultiObjectBlueprintFunctionLibrary", "PlayOnMultiObject");

	Params::CAAudioMultiObjectBlueprintFunctionLibrary_PlayOnMultiObject Parms{};

	Parms.Event = std::move(Event);
	Parms.Emitter_name = std::move(Emitter_name);
	Parms.Group_name = std::move(Group_name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Playback_instance != nullptr)
		*Playback_instance = std::move(Parms.Playback_instance);
}


// Function CAAudio.CAAudioMultiObjectBlueprintFunctionLibrary.SetRTPCOnMultiObject
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FCAAudioSwitchNameType           Rtpc_name                                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Rtpc_value                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Emitter_name                                           (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Group_name                                             (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioMultiObjectBlueprintFunctionLibrary::SetRTPCOnMultiObject(const struct FCAAudioSwitchNameType& Rtpc_name, float Rtpc_value, const class FString& Emitter_name, const class FString& Group_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioMultiObjectBlueprintFunctionLibrary", "SetRTPCOnMultiObject");

	Params::CAAudioMultiObjectBlueprintFunctionLibrary_SetRTPCOnMultiObject Parms{};

	Parms.Rtpc_name = std::move(Rtpc_name);
	Parms.Rtpc_value = Rtpc_value;
	Parms.Emitter_name = std::move(Emitter_name);
	Parms.Group_name = std::move(Group_name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioMultiObjectBlueprintFunctionLibrary.SetSwitchOnMultiObject
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FCAAudioSwitchNameType           Switch_name                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FCAAudioSwitchValueType          Switch_value                                           (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Emitter_name                                           (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Group_name                                             (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioMultiObjectBlueprintFunctionLibrary::SetSwitchOnMultiObject(const struct FCAAudioSwitchNameType& Switch_name, const struct FCAAudioSwitchValueType& Switch_value, const class FString& Emitter_name, const class FString& Group_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioMultiObjectBlueprintFunctionLibrary", "SetSwitchOnMultiObject");

	Params::CAAudioMultiObjectBlueprintFunctionLibrary_SetSwitchOnMultiObject Parms{};

	Parms.Switch_name = std::move(Switch_name);
	Parms.Switch_value = std::move(Switch_value);
	Parms.Emitter_name = std::move(Emitter_name);
	Parms.Group_name = std::move(Group_name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioMultiObjectBlueprintFunctionLibrary.StopMultiObject
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Emitter_name                                           (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Group_name                                             (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioMultiObjectBlueprintFunctionLibrary::StopMultiObject(const class FString& Emitter_name, const class FString& Group_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CAAudioMultiObjectBlueprintFunctionLibrary", "StopMultiObject");

	Params::CAAudioMultiObjectBlueprintFunctionLibrary_StopMultiObject Parms{};

	Parms.Emitter_name = std::move(Emitter_name);
	Parms.Group_name = std::move(Group_name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CAAudioSpatialLinkComponent.GetOpenAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCAAudioSpatialLinkComponent::GetOpenAmount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CAAudioSpatialLinkComponent", "GetOpenAmount");

	Params::CAAudioSpatialLinkComponent_GetOpenAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CAAudio.CAAudioSpatialLinkComponent.SetOpenAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCAAudioSpatialLinkComponent::SetOpenAmount(float Amount, float Min, float Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CAAudioSpatialLinkComponent", "SetOpenAmount");

	Params::CAAudioSpatialLinkComponent_SetOpenAmount Parms{};

	Parms.Amount = Amount;
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CASPrPointDataInterface.GetNext
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Point                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Weight                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Zone_id                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCASPrPointDataInterface::GetNext(struct FVector* Point, float* Weight, int32* Zone_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CASPrPointDataInterface", "GetNext");

	Params::CASPrPointDataInterface_GetNext Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Point != nullptr)
		*Point = std::move(Parms.Point);

	if (Weight != nullptr)
		*Weight = Parms.Weight;

	if (Zone_id != nullptr)
		*Zone_id = Parms.Zone_id;

	return Parms.ReturnValue;
}


// Function CAAudio.CASPrPointDataInterface.GetZoneInfo
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Zone_id                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           Connected_zones                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCASPrPointDataInterface::GetZoneInfo(const struct FVector& Position, int32* Zone_id, TArray<int32>* Connected_zones)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CASPrPointDataInterface", "GetZoneInfo");

	Params::CASPrPointDataInterface_GetZoneInfo Parms{};

	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Zone_id != nullptr)
		*Zone_id = Parms.Zone_id;

	if (Connected_zones != nullptr)
		*Connected_zones = std::move(Parms.Connected_zones);

	return Parms.ReturnValue;
}


// Function CAAudio.CASPrPointDataInterface.PrepareIterator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECASPrPointType                         Position_type                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Voxel_step                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Sample_step                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UCASPrPointDataInterface::PrepareIterator(ECASPrPointType Position_type, int32 Voxel_step, int32 Sample_step)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CASPrPointDataInterface", "PrepareIterator");

	Params::CASPrPointDataInterface_PrepareIterator Parms{};

	Parms.Position_type = Position_type;
	Parms.Voxel_step = Voxel_step;
	Parms.Sample_step = Sample_step;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CAAudio.CASPrPointDataInterface.ResetNext
// (Final, Native, Public, BlueprintCallable)

void UCASPrPointDataInterface::ResetNext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CASPrPointDataInterface", "ResetNext");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CAAudio.CASPrBlueprintFunctionLibrary.AreInSameCASPrZone
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          First                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Second                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCASPrBlueprintFunctionLibrary::AreInSameCASPrZone(const struct FVector& First, const struct FVector& Second)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CASPrBlueprintFunctionLibrary", "AreInSameCASPrZone");

	Params::CASPrBlueprintFunctionLibrary_AreInSameCASPrZone Parms{};

	Parms.First = std::move(First);
	Parms.Second = std::move(Second);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CAAudio.CASPrBlueprintFunctionLibrary.GetCASPrZoneInfo
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Object                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Id                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EZoneType                               Type                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioStateValueType           Size                                                   (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Volume                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCASPrBlueprintFunctionLibrary::GetCASPrZoneInfo(const class AActor* Object, int32* Id, EZoneType* Type, struct FCAAudioStateValueType* Size, float* Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CASPrBlueprintFunctionLibrary", "GetCASPrZoneInfo");

	Params::CASPrBlueprintFunctionLibrary_GetCASPrZoneInfo Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Id != nullptr)
		*Id = Parms.Id;

	if (Type != nullptr)
		*Type = Parms.Type;

	if (Size != nullptr)
		*Size = std::move(Parms.Size);

	if (Volume != nullptr)
		*Volume = Parms.Volume;

	return Parms.ReturnValue;
}


// Function CAAudio.CASPrBlueprintFunctionLibrary.GetCASPrZoneInfoFromID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Id                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EZoneType                               Type                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioStateValueType           Size                                                   (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Volume                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCASPrBlueprintFunctionLibrary::GetCASPrZoneInfoFromID(int32 Id, EZoneType* Type, struct FCAAudioStateValueType* Size, float* Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CASPrBlueprintFunctionLibrary", "GetCASPrZoneInfoFromID");

	Params::CASPrBlueprintFunctionLibrary_GetCASPrZoneInfoFromID Parms{};

	Parms.Id = Id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Type != nullptr)
		*Type = Parms.Type;

	if (Size != nullptr)
		*Size = std::move(Parms.Size);

	if (Volume != nullptr)
		*Volume = Parms.Volume;

	return Parms.ReturnValue;
}


// Function CAAudio.CASPrBlueprintFunctionLibrary.GetCASPrZoneInfoFromLocation
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Pos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Id                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EZoneType                               Type                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCAAudioStateValueType           Size                                                   (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Volume                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCASPrBlueprintFunctionLibrary::GetCASPrZoneInfoFromLocation(const struct FVector& Pos, int32* Id, EZoneType* Type, struct FCAAudioStateValueType* Size, float* Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CASPrBlueprintFunctionLibrary", "GetCASPrZoneInfoFromLocation");

	Params::CASPrBlueprintFunctionLibrary_GetCASPrZoneInfoFromLocation Parms{};

	Parms.Pos = std::move(Pos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Id != nullptr)
		*Id = Parms.Id;

	if (Type != nullptr)
		*Type = Parms.Type;

	if (Size != nullptr)
		*Size = std::move(Parms.Size);

	if (Volume != nullptr)
		*Volume = Parms.Volume;

	return Parms.ReturnValue;
}

}

