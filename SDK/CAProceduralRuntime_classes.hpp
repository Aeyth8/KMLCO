#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CAProceduralRuntime

#include "Basic.hpp"

#include "CAKitBuilderRuntime_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "CAProceduralRuntime_structs.hpp"


namespace SDK
{

// Class CAProceduralRuntime.CAAggregatedCollisionActor
// 0x0010 (0x0278 - 0x0268)
class ACAAggregatedCollisionActor final : public AStaticMeshActor
{
public:
	TArray<class UStaticMesh*>                    M_room_caps;                                       // 0x0268(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAAggregatedCollisionActor">();
	}
	static class ACAAggregatedCollisionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACAAggregatedCollisionActor>();
	}
};
static_assert(alignof(ACAAggregatedCollisionActor) == 0x000008, "Wrong alignment on ACAAggregatedCollisionActor");
static_assert(sizeof(ACAAggregatedCollisionActor) == 0x000278, "Wrong size on ACAAggregatedCollisionActor");
static_assert(offsetof(ACAAggregatedCollisionActor, M_room_caps) == 0x000268, "Member 'ACAAggregatedCollisionActor::M_room_caps' has a wrong offset!");

// Class CAProceduralRuntime.CACapperNode
// 0x0038 (0x0068 - 0x0030)
class UCACapperNode final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UCARoomNode>             M_room_node;                                       // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UWallBreak>              M_room_feature;                                    // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_position;                                        // 0x0058(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CACapperNode">();
	}
	static class UCACapperNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCACapperNode>();
	}
};
static_assert(alignof(UCACapperNode) == 0x000008, "Wrong alignment on UCACapperNode");
static_assert(sizeof(UCACapperNode) == 0x000068, "Wrong size on UCACapperNode");
static_assert(offsetof(UCACapperNode, M_room_node) == 0x000048, "Member 'UCACapperNode::M_room_node' has a wrong offset!");
static_assert(offsetof(UCACapperNode, M_room_feature) == 0x000050, "Member 'UCACapperNode::M_room_feature' has a wrong offset!");
static_assert(offsetof(UCACapperNode, M_position) == 0x000058, "Member 'UCACapperNode::M_position' has a wrong offset!");

// Class CAProceduralRuntime.CACapperRegion
// 0x0098 (0x00C8 - 0x0030)
class UCACapperRegion final : public UObject
{
public:
	TArray<class UCACapperWallSeg*>               M_shape;                                           // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCACapperNode*>                  M_ordered_nodes;                                   // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x1];                                       // 0x0050(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	ECapperRegionType                             M_capper_region_type;                              // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UCACapperConnection>     M_aligned_connection;                              // 0x0054(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_template;                                        // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_template_folder;                                 // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_baked_material_slot_name;                        // 0x0080(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        M_vertex_buffer;                                   // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint32>                                M_index_buffer;                                    // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   M_material_type;                                   // 0x00B0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_material_group;                                  // 0x00BC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CACapperRegion">();
	}
	static class UCACapperRegion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCACapperRegion>();
	}
};
static_assert(alignof(UCACapperRegion) == 0x000008, "Wrong alignment on UCACapperRegion");
static_assert(sizeof(UCACapperRegion) == 0x0000C8, "Wrong size on UCACapperRegion");
static_assert(offsetof(UCACapperRegion, M_shape) == 0x000030, "Member 'UCACapperRegion::M_shape' has a wrong offset!");
static_assert(offsetof(UCACapperRegion, M_ordered_nodes) == 0x000040, "Member 'UCACapperRegion::M_ordered_nodes' has a wrong offset!");
static_assert(offsetof(UCACapperRegion, M_capper_region_type) == 0x000051, "Member 'UCACapperRegion::M_capper_region_type' has a wrong offset!");
static_assert(offsetof(UCACapperRegion, M_aligned_connection) == 0x000054, "Member 'UCACapperRegion::M_aligned_connection' has a wrong offset!");
static_assert(offsetof(UCACapperRegion, M_template) == 0x000060, "Member 'UCACapperRegion::M_template' has a wrong offset!");
static_assert(offsetof(UCACapperRegion, M_template_folder) == 0x000070, "Member 'UCACapperRegion::M_template_folder' has a wrong offset!");
static_assert(offsetof(UCACapperRegion, M_baked_material_slot_name) == 0x000080, "Member 'UCACapperRegion::M_baked_material_slot_name' has a wrong offset!");
static_assert(offsetof(UCACapperRegion, M_vertex_buffer) == 0x000090, "Member 'UCACapperRegion::M_vertex_buffer' has a wrong offset!");
static_assert(offsetof(UCACapperRegion, M_index_buffer) == 0x0000A0, "Member 'UCACapperRegion::M_index_buffer' has a wrong offset!");
static_assert(offsetof(UCACapperRegion, M_material_type) == 0x0000B0, "Member 'UCACapperRegion::M_material_type' has a wrong offset!");
static_assert(offsetof(UCACapperRegion, M_material_group) == 0x0000BC, "Member 'UCACapperRegion::M_material_group' has a wrong offset!");

// Class CAProceduralRuntime.CACapperConnectionRegion
// 0x0018 (0x0048 - 0x0030)
class UCACapperConnectionRegion final : public UObject
{
public:
	TArray<struct FCAConnectionShapeData>         M_shape;                                           // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	ECapperConnectionType                         M_connection_region_type;                          // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CACapperConnectionRegion">();
	}
	static class UCACapperConnectionRegion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCACapperConnectionRegion>();
	}
};
static_assert(alignof(UCACapperConnectionRegion) == 0x000008, "Wrong alignment on UCACapperConnectionRegion");
static_assert(sizeof(UCACapperConnectionRegion) == 0x000048, "Wrong size on UCACapperConnectionRegion");
static_assert(offsetof(UCACapperConnectionRegion, M_shape) == 0x000030, "Member 'UCACapperConnectionRegion::M_shape' has a wrong offset!");
static_assert(offsetof(UCACapperConnectionRegion, M_connection_region_type) == 0x000040, "Member 'UCACapperConnectionRegion::M_connection_region_type' has a wrong offset!");

// Class CAProceduralRuntime.CACapperWallSeg
// 0x0038 (0x0068 - 0x0030)
class UCACapperWallSeg final : public UObject
{
public:
	class UCACapperRegion*                        M_capper_region;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCACapperConnectionRegion> M_connection_region;                               // 0x0038(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CACapperWallSeg">();
	}
	static class UCACapperWallSeg* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCACapperWallSeg>();
	}
};
static_assert(alignof(UCACapperWallSeg) == 0x000008, "Wrong alignment on UCACapperWallSeg");
static_assert(sizeof(UCACapperWallSeg) == 0x000068, "Wrong size on UCACapperWallSeg");
static_assert(offsetof(UCACapperWallSeg, M_capper_region) == 0x000030, "Member 'UCACapperWallSeg::M_capper_region' has a wrong offset!");
static_assert(offsetof(UCACapperWallSeg, M_connection_region) == 0x000038, "Member 'UCACapperWallSeg::M_connection_region' has a wrong offset!");

// Class CAProceduralRuntime.CACapperConnection
// 0x0100 (0x0130 - 0x0030)
class UCACapperConnection final : public UObject
{
public:
	class UCACapperNode*                          M_from_node;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCACapperNode*                          M_to_node;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCACapperWallSeg*                       M_wall_seg_left;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCACapperWallSeg*                       M_wall_seg_right;                                  // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECapperConnectionType                         M_type;                                            // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELength                                       M_path_width;                                      // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_inner_start;                                     // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_inner_end;                                       // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCAWallOffsets                         M_offsets_from;                                    // 0x005C(0x0040)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCAWallOffsets                         M_offsets_to;                                      // 0x009C(0x0040)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_stretch_factor;                                  // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UCARoomConnection>       M_room_connection;                                 // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UCAWallSegment>          M_room_wall_seg;                                   // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_baked_material_slot_name;                        // 0x00F0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_template;                                        // 0x0100(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_template_folder;                                 // 0x0110(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_material_group;                                  // 0x0120(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CACapperConnection">();
	}
	static class UCACapperConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCACapperConnection>();
	}
};
static_assert(alignof(UCACapperConnection) == 0x000008, "Wrong alignment on UCACapperConnection");
static_assert(sizeof(UCACapperConnection) == 0x000130, "Wrong size on UCACapperConnection");
static_assert(offsetof(UCACapperConnection, M_from_node) == 0x000030, "Member 'UCACapperConnection::M_from_node' has a wrong offset!");
static_assert(offsetof(UCACapperConnection, M_to_node) == 0x000038, "Member 'UCACapperConnection::M_to_node' has a wrong offset!");
static_assert(offsetof(UCACapperConnection, M_wall_seg_left) == 0x000040, "Member 'UCACapperConnection::M_wall_seg_left' has a wrong offset!");
static_assert(offsetof(UCACapperConnection, M_wall_seg_right) == 0x000048, "Member 'UCACapperConnection::M_wall_seg_right' has a wrong offset!");
static_assert(offsetof(UCACapperConnection, M_type) == 0x000050, "Member 'UCACapperConnection::M_type' has a wrong offset!");
static_assert(offsetof(UCACapperConnection, M_path_width) == 0x000051, "Member 'UCACapperConnection::M_path_width' has a wrong offset!");
static_assert(offsetof(UCACapperConnection, M_inner_start) == 0x000054, "Member 'UCACapperConnection::M_inner_start' has a wrong offset!");
static_assert(offsetof(UCACapperConnection, M_inner_end) == 0x000058, "Member 'UCACapperConnection::M_inner_end' has a wrong offset!");
static_assert(offsetof(UCACapperConnection, M_offsets_from) == 0x00005C, "Member 'UCACapperConnection::M_offsets_from' has a wrong offset!");
static_assert(offsetof(UCACapperConnection, M_offsets_to) == 0x00009C, "Member 'UCACapperConnection::M_offsets_to' has a wrong offset!");
static_assert(offsetof(UCACapperConnection, M_stretch_factor) == 0x0000DC, "Member 'UCACapperConnection::M_stretch_factor' has a wrong offset!");
static_assert(offsetof(UCACapperConnection, M_room_connection) == 0x0000E0, "Member 'UCACapperConnection::M_room_connection' has a wrong offset!");
static_assert(offsetof(UCACapperConnection, M_room_wall_seg) == 0x0000E8, "Member 'UCACapperConnection::M_room_wall_seg' has a wrong offset!");
static_assert(offsetof(UCACapperConnection, M_baked_material_slot_name) == 0x0000F0, "Member 'UCACapperConnection::M_baked_material_slot_name' has a wrong offset!");
static_assert(offsetof(UCACapperConnection, M_template) == 0x000100, "Member 'UCACapperConnection::M_template' has a wrong offset!");
static_assert(offsetof(UCACapperConnection, M_template_folder) == 0x000110, "Member 'UCACapperConnection::M_template_folder' has a wrong offset!");
static_assert(offsetof(UCACapperConnection, M_material_group) == 0x000120, "Member 'UCACapperConnection::M_material_group' has a wrong offset!");

// Class CAProceduralRuntime.CACapperDataComponent
// 0x0050 (0x02A0 - 0x0250)
class UCACapperDataComponent final : public USceneComponent
{
public:
	TArray<class UCACapperNode*>                  M_nodes;                                           // 0x0248(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCACapperConnection*>            M_connections;                                     // 0x0258(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_need_check_add_remove_cappers;                   // 0x0268(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCACapperRegion*>                M_capper_regions;                                  // 0x0270(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCACapperConnectionRegion*>      M_capper_connection_regions;                       // 0x0280(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CACapperDataComponent">();
	}
	static class UCACapperDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCACapperDataComponent>();
	}
};
static_assert(alignof(UCACapperDataComponent) == 0x000010, "Wrong alignment on UCACapperDataComponent");
static_assert(sizeof(UCACapperDataComponent) == 0x0002A0, "Wrong size on UCACapperDataComponent");
static_assert(offsetof(UCACapperDataComponent, M_nodes) == 0x000248, "Member 'UCACapperDataComponent::M_nodes' has a wrong offset!");
static_assert(offsetof(UCACapperDataComponent, M_connections) == 0x000258, "Member 'UCACapperDataComponent::M_connections' has a wrong offset!");
static_assert(offsetof(UCACapperDataComponent, M_need_check_add_remove_cappers) == 0x000268, "Member 'UCACapperDataComponent::M_need_check_add_remove_cappers' has a wrong offset!");
static_assert(offsetof(UCACapperDataComponent, M_capper_regions) == 0x000270, "Member 'UCACapperDataComponent::M_capper_regions' has a wrong offset!");
static_assert(offsetof(UCACapperDataComponent, M_capper_connection_regions) == 0x000280, "Member 'UCACapperDataComponent::M_capper_connection_regions' has a wrong offset!");

// Class CAProceduralRuntime.CARoomCapperBaseActor
// 0x0010 (0x0268 - 0x0258)
class ACARoomCapperBaseActor : public AActor
{
public:
	class UStaticMesh*                            M_generated_mesh;                                  // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            M_collision_mesh;                                  // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CARoomCapperBaseActor">();
	}
	static class ACARoomCapperBaseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACARoomCapperBaseActor>();
	}
};
static_assert(alignof(ACARoomCapperBaseActor) == 0x000008, "Wrong alignment on ACARoomCapperBaseActor");
static_assert(sizeof(ACARoomCapperBaseActor) == 0x000268, "Wrong size on ACARoomCapperBaseActor");
static_assert(offsetof(ACARoomCapperBaseActor, M_generated_mesh) == 0x000258, "Member 'ACARoomCapperBaseActor::M_generated_mesh' has a wrong offset!");
static_assert(offsetof(ACARoomCapperBaseActor, M_collision_mesh) == 0x000260, "Member 'ACARoomCapperBaseActor::M_collision_mesh' has a wrong offset!");

// Class CAProceduralRuntime.CARoomCapperToolActor
// 0x0018 (0x0280 - 0x0268)
class ACARoomCapperToolActor : public ACARoomCapperBaseActor
{
public:
	class UProceduralMeshComponent*               M_proc_mesh_component;                             // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   M_static_mesh_component;                           // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   M_collision_mesh_component;                        // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CARoomCapperToolActor">();
	}
	static class ACARoomCapperToolActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACARoomCapperToolActor>();
	}
};
static_assert(alignof(ACARoomCapperToolActor) == 0x000008, "Wrong alignment on ACARoomCapperToolActor");
static_assert(sizeof(ACARoomCapperToolActor) == 0x000280, "Wrong size on ACARoomCapperToolActor");
static_assert(offsetof(ACARoomCapperToolActor, M_proc_mesh_component) == 0x000268, "Member 'ACARoomCapperToolActor::M_proc_mesh_component' has a wrong offset!");
static_assert(offsetof(ACARoomCapperToolActor, M_static_mesh_component) == 0x000270, "Member 'ACARoomCapperToolActor::M_static_mesh_component' has a wrong offset!");
static_assert(offsetof(ACARoomCapperToolActor, M_collision_mesh_component) == 0x000278, "Member 'ACARoomCapperToolActor::M_collision_mesh_component' has a wrong offset!");

// Class CAProceduralRuntime.CACeilingToolProceduralActor
// 0x0000 (0x0280 - 0x0280)
class ACACeilingToolProceduralActor final : public ACARoomCapperToolActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CACeilingToolProceduralActor">();
	}
	static class ACACeilingToolProceduralActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACACeilingToolProceduralActor>();
	}
};
static_assert(alignof(ACACeilingToolProceduralActor) == 0x000008, "Wrong alignment on ACACeilingToolProceduralActor");
static_assert(sizeof(ACACeilingToolProceduralActor) == 0x000280, "Wrong size on ACACeilingToolProceduralActor");

// Class CAProceduralRuntime.CACollisionSockActor
// 0x0018 (0x0280 - 0x0268)
class ACACollisionSockActor final : public AStaticMeshActor
{
public:
	class UStaticMeshComponent*                   M_monolithic_mesh_component;                       // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    M_room_caps;                                       // 0x0270(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CACollisionSockActor">();
	}
	static class ACACollisionSockActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACACollisionSockActor>();
	}
};
static_assert(alignof(ACACollisionSockActor) == 0x000008, "Wrong alignment on ACACollisionSockActor");
static_assert(sizeof(ACACollisionSockActor) == 0x000280, "Wrong size on ACACollisionSockActor");
static_assert(offsetof(ACACollisionSockActor, M_monolithic_mesh_component) == 0x000268, "Member 'ACACollisionSockActor::M_monolithic_mesh_component' has a wrong offset!");
static_assert(offsetof(ACACollisionSockActor, M_room_caps) == 0x000270, "Member 'ACACollisionSockActor::M_room_caps' has a wrong offset!");

// Class CAProceduralRuntime.CADecalComponent
// 0x0018 (0x0108 - 0x00F0)
class UCADecalComponent final : public UActorComponent
{
public:
	struct FVector                                MaxBounds;                                         // 0x00F0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MinBounds;                                         // 0x00FC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CADecalComponent">();
	}
	static class UCADecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCADecalComponent>();
	}
};
static_assert(alignof(UCADecalComponent) == 0x000008, "Wrong alignment on UCADecalComponent");
static_assert(sizeof(UCADecalComponent) == 0x000108, "Wrong size on UCADecalComponent");
static_assert(offsetof(UCADecalComponent, MaxBounds) == 0x0000F0, "Member 'UCADecalComponent::MaxBounds' has a wrong offset!");
static_assert(offsetof(UCADecalComponent, MinBounds) == 0x0000FC, "Member 'UCADecalComponent::MinBounds' has a wrong offset!");

// Class CAProceduralRuntime.CADecalActor
// 0x0010 (0x0268 - 0x0258)
class ACADecalActor final : public AActor
{
public:
	class UStaticMeshComponent*                   M_static_mesh_component;                           // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            M_generated_mesh;                                  // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CADecalActor">();
	}
	static class ACADecalActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACADecalActor>();
	}
};
static_assert(alignof(ACADecalActor) == 0x000008, "Wrong alignment on ACADecalActor");
static_assert(sizeof(ACADecalActor) == 0x000268, "Wrong size on ACADecalActor");
static_assert(offsetof(ACADecalActor, M_static_mesh_component) == 0x000258, "Member 'ACADecalActor::M_static_mesh_component' has a wrong offset!");
static_assert(offsetof(ACADecalActor, M_generated_mesh) == 0x000260, "Member 'ACADecalActor::M_generated_mesh' has a wrong offset!");

// Class CAProceduralRuntime.CAFloorToolProceduralActor
// 0x0000 (0x0280 - 0x0280)
class ACAFloorToolProceduralActor final : public ACARoomCapperToolActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAFloorToolProceduralActor">();
	}
	static class ACAFloorToolProceduralActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACAFloorToolProceduralActor>();
	}
};
static_assert(alignof(ACAFloorToolProceduralActor) == 0x000008, "Wrong alignment on ACAFloorToolProceduralActor");
static_assert(sizeof(ACAFloorToolProceduralActor) == 0x000280, "Wrong size on ACAFloorToolProceduralActor");

// Class CAProceduralRuntime.CAGeneratedCornerAssetUserData
// 0x0100 (0x0130 - 0x0030)
class UCAGeneratedCornerAssetUserData final : public UAssetUserData
{
public:
	struct FCAGeneratedCornerProperties           M_corner_properties;                               // 0x0030(0x00B0)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FCAGeneratedCornerConstructionProperties M_construction_properties;                         // 0x00E0(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAGeneratedCornerAssetUserData">();
	}
	static class UCAGeneratedCornerAssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAGeneratedCornerAssetUserData>();
	}
};
static_assert(alignof(UCAGeneratedCornerAssetUserData) == 0x000008, "Wrong alignment on UCAGeneratedCornerAssetUserData");
static_assert(sizeof(UCAGeneratedCornerAssetUserData) == 0x000130, "Wrong size on UCAGeneratedCornerAssetUserData");
static_assert(offsetof(UCAGeneratedCornerAssetUserData, M_corner_properties) == 0x000030, "Member 'UCAGeneratedCornerAssetUserData::M_corner_properties' has a wrong offset!");
static_assert(offsetof(UCAGeneratedCornerAssetUserData, M_construction_properties) == 0x0000E0, "Member 'UCAGeneratedCornerAssetUserData::M_construction_properties' has a wrong offset!");

// Class CAProceduralRuntime.CAGeneratedCornerActor
// 0x0000 (0x0258 - 0x0258)
class ACAGeneratedCornerActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAGeneratedCornerActor">();
	}
	static class ACAGeneratedCornerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACAGeneratedCornerActor>();
	}
};
static_assert(alignof(ACAGeneratedCornerActor) == 0x000008, "Wrong alignment on ACAGeneratedCornerActor");
static_assert(sizeof(ACAGeneratedCornerActor) == 0x000258, "Wrong size on ACAGeneratedCornerActor");

// Class CAProceduralRuntime.CAGeneratedMeshActor
// 0x0010 (0x0268 - 0x0258)
class ACAGeneratedMeshActor final : public AActor
{
public:
	class UStaticMeshComponent*                   M_generated_mesh;                                  // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   M_collision_mesh;                                  // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAGeneratedMeshActor">();
	}
	static class ACAGeneratedMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACAGeneratedMeshActor>();
	}
};
static_assert(alignof(ACAGeneratedMeshActor) == 0x000008, "Wrong alignment on ACAGeneratedMeshActor");
static_assert(sizeof(ACAGeneratedMeshActor) == 0x000268, "Wrong size on ACAGeneratedMeshActor");
static_assert(offsetof(ACAGeneratedMeshActor, M_generated_mesh) == 0x000258, "Member 'ACAGeneratedMeshActor::M_generated_mesh' has a wrong offset!");
static_assert(offsetof(ACAGeneratedMeshActor, M_collision_mesh) == 0x000260, "Member 'ACAGeneratedMeshActor::M_collision_mesh' has a wrong offset!");

// Class CAProceduralRuntime.CAMapGenerationActor
// 0x0000 (0x0268 - 0x0268)
class ACAMapGenerationActor final : public AStaticMeshActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAMapGenerationActor">();
	}
	static class ACAMapGenerationActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACAMapGenerationActor>();
	}
};
static_assert(alignof(ACAMapGenerationActor) == 0x000008, "Wrong alignment on ACAMapGenerationActor");
static_assert(sizeof(ACAMapGenerationActor) == 0x000268, "Wrong size on ACAMapGenerationActor");

// Class CAProceduralRuntime.CAMergedWallSegment
// 0x0028 (0x0058 - 0x0030)
class UCAMergedWallSegment final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCAWallSegment*>                 M_wall_segs;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UCARoomConnection*                      M_connection;                                      // 0x0048(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_used;                                         // 0x0050(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAMergedWallSegment">();
	}
	static class UCAMergedWallSegment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAMergedWallSegment>();
	}
};
static_assert(alignof(UCAMergedWallSegment) == 0x000008, "Wrong alignment on UCAMergedWallSegment");
static_assert(sizeof(UCAMergedWallSegment) == 0x000058, "Wrong size on UCAMergedWallSegment");
static_assert(offsetof(UCAMergedWallSegment, M_wall_segs) == 0x000038, "Member 'UCAMergedWallSegment::M_wall_segs' has a wrong offset!");
static_assert(offsetof(UCAMergedWallSegment, M_connection) == 0x000048, "Member 'UCAMergedWallSegment::M_connection' has a wrong offset!");
static_assert(offsetof(UCAMergedWallSegment, M_is_used) == 0x000050, "Member 'UCAMergedWallSegment::M_is_used' has a wrong offset!");

// Class CAProceduralRuntime.CAPipeFeature
// 0x0000 (0x0030 - 0x0030)
class UCAPipeFeature final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAPipeFeature">();
	}
	static class UCAPipeFeature* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAPipeFeature>();
	}
};
static_assert(alignof(UCAPipeFeature) == 0x000008, "Wrong alignment on UCAPipeFeature");
static_assert(sizeof(UCAPipeFeature) == 0x000030, "Wrong size on UCAPipeFeature");

// Class CAProceduralRuntime.CAPipeNode
// 0x0040 (0x0070 - 0x0030)
class UCAPipeNode final : public UObject
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_position;                                        // 0x0058(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCAPipeFeature*                         M_pipe_feature;                                    // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAPipeNode">();
	}
	static class UCAPipeNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAPipeNode>();
	}
};
static_assert(alignof(UCAPipeNode) == 0x000008, "Wrong alignment on UCAPipeNode");
static_assert(sizeof(UCAPipeNode) == 0x000070, "Wrong size on UCAPipeNode");
static_assert(offsetof(UCAPipeNode, M_position) == 0x000058, "Member 'UCAPipeNode::M_position' has a wrong offset!");
static_assert(offsetof(UCAPipeNode, M_pipe_feature) == 0x000068, "Member 'UCAPipeNode::M_pipe_feature' has a wrong offset!");

// Class CAProceduralRuntime.CAPipeSection
// 0x0030 (0x0060 - 0x0030)
class UCAPipeSection final : public UObject
{
public:
	class UCAPipeNode*                            M_from_node;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAPipeNode*                            M_to_node;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UCAPipeFeature*>                 M_features;                                        // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_pipe_width_override;                             // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_is_traversable;                                  // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_traversable_surface_rotation;                    // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAPipeSection">();
	}
	static class UCAPipeSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAPipeSection>();
	}
};
static_assert(alignof(UCAPipeSection) == 0x000008, "Wrong alignment on UCAPipeSection");
static_assert(sizeof(UCAPipeSection) == 0x000060, "Wrong size on UCAPipeSection");
static_assert(offsetof(UCAPipeSection, M_from_node) == 0x000030, "Member 'UCAPipeSection::M_from_node' has a wrong offset!");
static_assert(offsetof(UCAPipeSection, M_to_node) == 0x000038, "Member 'UCAPipeSection::M_to_node' has a wrong offset!");
static_assert(offsetof(UCAPipeSection, M_features) == 0x000040, "Member 'UCAPipeSection::M_features' has a wrong offset!");
static_assert(offsetof(UCAPipeSection, M_pipe_width_override) == 0x000050, "Member 'UCAPipeSection::M_pipe_width_override' has a wrong offset!");
static_assert(offsetof(UCAPipeSection, M_is_traversable) == 0x000054, "Member 'UCAPipeSection::M_is_traversable' has a wrong offset!");
static_assert(offsetof(UCAPipeSection, M_traversable_surface_rotation) == 0x000058, "Member 'UCAPipeSection::M_traversable_surface_rotation' has a wrong offset!");

// Class CAProceduralRuntime.CAPipeComponent
// 0x0000 (0x00F0 - 0x00F0)
class UCAPipeComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAPipeComponent">();
	}
	static class UCAPipeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAPipeComponent>();
	}
};
static_assert(alignof(UCAPipeComponent) == 0x000008, "Wrong alignment on UCAPipeComponent");
static_assert(sizeof(UCAPipeComponent) == 0x0000F0, "Wrong size on UCAPipeComponent");

// Class CAProceduralRuntime.CAPipeActor
// 0x0030 (0x0288 - 0x0258)
class ACAPipeActor final : public AActor
{
public:
	class UStaticMeshComponent*                   M_display_mesh;                                    // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInstancedStaticMeshComponent*          M_pre_vis_mesh_pipe;                               // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInstancedStaticMeshComponent*          M_pre_vis_mesh_traversable_pipe;                   // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInstancedStaticMeshComponent*          M_pre_vis_mesh_junction;                           // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInstancedStaticMeshComponent*          M_pre_vis_mesh_traversable_junction;               // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInstancedStaticMeshComponent*          M_pre_vis_brackets;                                // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAPipeActor">();
	}
	static class ACAPipeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACAPipeActor>();
	}
};
static_assert(alignof(ACAPipeActor) == 0x000008, "Wrong alignment on ACAPipeActor");
static_assert(sizeof(ACAPipeActor) == 0x000288, "Wrong size on ACAPipeActor");
static_assert(offsetof(ACAPipeActor, M_display_mesh) == 0x000258, "Member 'ACAPipeActor::M_display_mesh' has a wrong offset!");
static_assert(offsetof(ACAPipeActor, M_pre_vis_mesh_pipe) == 0x000260, "Member 'ACAPipeActor::M_pre_vis_mesh_pipe' has a wrong offset!");
static_assert(offsetof(ACAPipeActor, M_pre_vis_mesh_traversable_pipe) == 0x000268, "Member 'ACAPipeActor::M_pre_vis_mesh_traversable_pipe' has a wrong offset!");
static_assert(offsetof(ACAPipeActor, M_pre_vis_mesh_junction) == 0x000270, "Member 'ACAPipeActor::M_pre_vis_mesh_junction' has a wrong offset!");
static_assert(offsetof(ACAPipeActor, M_pre_vis_mesh_traversable_junction) == 0x000278, "Member 'ACAPipeActor::M_pre_vis_mesh_traversable_junction' has a wrong offset!");
static_assert(offsetof(ACAPipeActor, M_pre_vis_brackets) == 0x000280, "Member 'ACAPipeActor::M_pre_vis_brackets' has a wrong offset!");

// Class CAProceduralRuntime.CAProceduralError
// 0x0000 (0x0030 - 0x0030)
class UCAProceduralError final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAProceduralError">();
	}
	static class UCAProceduralError* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAProceduralError>();
	}
};
static_assert(alignof(UCAProceduralError) == 0x000008, "Wrong alignment on UCAProceduralError");
static_assert(sizeof(UCAProceduralError) == 0x000030, "Wrong size on UCAProceduralError");

// Class CAProceduralRuntime.CAProceduralErrors
// 0x0000 (0x0030 - 0x0030)
class ICAProceduralErrors final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAProceduralErrors">();
	}
	static class ICAProceduralErrors* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICAProceduralErrors>();
	}
};
static_assert(alignof(ICAProceduralErrors) == 0x000008, "Wrong alignment on ICAProceduralErrors");
static_assert(sizeof(ICAProceduralErrors) == 0x000030, "Wrong size on ICAProceduralErrors");

// Class CAProceduralRuntime.CAProceduralPathComponent
// 0x0010 (0x0260 - 0x0250)
class UCAProceduralPathComponent final : public USceneComponent
{
public:
	TArray<struct FPathPointData>                 M_path_points;                                     // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAProceduralPathComponent">();
	}
	static class UCAProceduralPathComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAProceduralPathComponent>();
	}
};
static_assert(alignof(UCAProceduralPathComponent) == 0x000010, "Wrong alignment on UCAProceduralPathComponent");
static_assert(sizeof(UCAProceduralPathComponent) == 0x000260, "Wrong size on UCAProceduralPathComponent");
static_assert(offsetof(UCAProceduralPathComponent, M_path_points) == 0x000248, "Member 'UCAProceduralPathComponent::M_path_points' has a wrong offset!");

// Class CAProceduralRuntime.CAProceduralSettings
// 0x0008 (0x0038 - 0x0030)
class UCAProceduralSettings final : public UObject
{
public:
	bool                                          M_production_assets_generate_per_map;              // 0x0030(0x0001)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAProceduralSettings">();
	}
	static class UCAProceduralSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAProceduralSettings>();
	}
};
static_assert(alignof(UCAProceduralSettings) == 0x000008, "Wrong alignment on UCAProceduralSettings");
static_assert(sizeof(UCAProceduralSettings) == 0x000038, "Wrong size on UCAProceduralSettings");
static_assert(offsetof(UCAProceduralSettings, M_production_assets_generate_per_map) == 0x000030, "Member 'UCAProceduralSettings::M_production_assets_generate_per_map' has a wrong offset!");

// Class CAProceduralRuntime.CARoomComponent
// 0x0000 (0x00F0 - 0x00F0)
class UCARoomComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CARoomComponent">();
	}
	static class UCARoomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCARoomComponent>();
	}
};
static_assert(alignof(UCARoomComponent) == 0x000008, "Wrong alignment on UCARoomComponent");
static_assert(sizeof(UCARoomComponent) == 0x0000F0, "Wrong size on UCARoomComponent");

// Class CAProceduralRuntime.CARoomActor
// 0x0018 (0x0270 - 0x0258)
class ACARoomActor final : public AActor
{
public:
	uint8                                         Pad_258[0x10];                                     // 0x0258(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCARoomComponent*                       M_room_component;                                  // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CARoomActor">();
	}
	static class ACARoomActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACARoomActor>();
	}
};
static_assert(alignof(ACARoomActor) == 0x000008, "Wrong alignment on ACARoomActor");
static_assert(sizeof(ACARoomActor) == 0x000270, "Wrong size on ACARoomActor");
static_assert(offsetof(ACARoomActor, M_room_component) == 0x000268, "Member 'ACARoomActor::M_room_component' has a wrong offset!");

// Class CAProceduralRuntime.CARoomCapperActor
// 0x0010 (0x0278 - 0x0268)
class ACARoomCapperActor final : public ACARoomCapperBaseActor
{
public:
	class UProceduralMeshComponent*               M_proc_mesh_component;                             // 0x0268(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   M_static_mesh_component;                           // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CARoomCapperActor">();
	}
	static class ACARoomCapperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACARoomCapperActor>();
	}
};
static_assert(alignof(ACARoomCapperActor) == 0x000008, "Wrong alignment on ACARoomCapperActor");
static_assert(sizeof(ACARoomCapperActor) == 0x000278, "Wrong size on ACARoomCapperActor");
static_assert(offsetof(ACARoomCapperActor, M_proc_mesh_component) == 0x000268, "Member 'ACARoomCapperActor::M_proc_mesh_component' has a wrong offset!");
static_assert(offsetof(ACARoomCapperActor, M_static_mesh_component) == 0x000270, "Member 'ACARoomCapperActor::M_static_mesh_component' has a wrong offset!");

// Class CAProceduralRuntime.CARoomConnection
// 0x0058 (0x0088 - 0x0030)
class UCARoomConnection final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCARoomNode*                            M_from_node;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCARoomNode*                            M_to_node;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAWallSegment*                         M_wall_seg_left;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCAWallSegment*                         M_wall_seg_right;                                  // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_use_squidgies;                                   // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWallBreak*>                     M_breaks;                                          // 0x0060(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	EWallConstructionPattern                      M_wall_construction_pattern;                       // 0x0070(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELength                                       M_max_wall_section_length;                         // 0x0071(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         M_error_list;                                      // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	bool GetIsFromNode(const class UCARoomNode* Node) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CARoomConnection">();
	}
	static class UCARoomConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCARoomConnection>();
	}
};
static_assert(alignof(UCARoomConnection) == 0x000008, "Wrong alignment on UCARoomConnection");
static_assert(sizeof(UCARoomConnection) == 0x000088, "Wrong size on UCARoomConnection");
static_assert(offsetof(UCARoomConnection, M_from_node) == 0x000038, "Member 'UCARoomConnection::M_from_node' has a wrong offset!");
static_assert(offsetof(UCARoomConnection, M_to_node) == 0x000040, "Member 'UCARoomConnection::M_to_node' has a wrong offset!");
static_assert(offsetof(UCARoomConnection, M_wall_seg_left) == 0x000048, "Member 'UCARoomConnection::M_wall_seg_left' has a wrong offset!");
static_assert(offsetof(UCARoomConnection, M_wall_seg_right) == 0x000050, "Member 'UCARoomConnection::M_wall_seg_right' has a wrong offset!");
static_assert(offsetof(UCARoomConnection, M_use_squidgies) == 0x000058, "Member 'UCARoomConnection::M_use_squidgies' has a wrong offset!");
static_assert(offsetof(UCARoomConnection, M_breaks) == 0x000060, "Member 'UCARoomConnection::M_breaks' has a wrong offset!");
static_assert(offsetof(UCARoomConnection, M_wall_construction_pattern) == 0x000070, "Member 'UCARoomConnection::M_wall_construction_pattern' has a wrong offset!");
static_assert(offsetof(UCARoomConnection, M_max_wall_section_length) == 0x000071, "Member 'UCARoomConnection::M_max_wall_section_length' has a wrong offset!");
static_assert(offsetof(UCARoomConnection, M_error_list) == 0x000078, "Member 'UCARoomConnection::M_error_list' has a wrong offset!");

// Class CAProceduralRuntime.WallBreak
// 0x0008 (0x0038 - 0x0030)
class UWallBreak final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WallBreak">();
	}
	static class UWallBreak* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWallBreak>();
	}
};
static_assert(alignof(UWallBreak) == 0x000008, "Wrong alignment on UWallBreak");
static_assert(sizeof(UWallBreak) == 0x000038, "Wrong size on UWallBreak");

// Class CAProceduralRuntime.CARoomNode
// 0x0098 (0x00C8 - 0x0030)
class UCARoomNode final : public UObject
{
public:
	uint8                                         Pad_30[0x70];                                      // 0x0030(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_errors;                                          // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_position;                                        // 0x00B0(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_floor_level;                                     // 0x00BC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWallBreak*                             M_wall_break;                                      // 0x00C0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UWallBreak* GetFeature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CARoomNode">();
	}
	static class UCARoomNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCARoomNode>();
	}
};
static_assert(alignof(UCARoomNode) == 0x000008, "Wrong alignment on UCARoomNode");
static_assert(sizeof(UCARoomNode) == 0x0000C8, "Wrong size on UCARoomNode");
static_assert(offsetof(UCARoomNode, M_errors) == 0x0000A0, "Member 'UCARoomNode::M_errors' has a wrong offset!");
static_assert(offsetof(UCARoomNode, M_position) == 0x0000B0, "Member 'UCARoomNode::M_position' has a wrong offset!");
static_assert(offsetof(UCARoomNode, M_floor_level) == 0x0000BC, "Member 'UCARoomNode::M_floor_level' has a wrong offset!");
static_assert(offsetof(UCARoomNode, M_wall_break) == 0x0000C0, "Member 'UCARoomNode::M_wall_break' has a wrong offset!");

// Class CAProceduralRuntime.CARoomObject
// 0x0000 (0x0030 - 0x0030)
class ICARoomObject final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CARoomObject">();
	}
	static class ICARoomObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICARoomObject>();
	}
};
static_assert(alignof(ICARoomObject) == 0x000008, "Wrong alignment on ICARoomObject");
static_assert(sizeof(ICARoomObject) == 0x000030, "Wrong size on ICARoomObject");

// Class CAProceduralRuntime.CAWallSegment
// 0x0008 (0x0038 - 0x0030)
class UCAWallSegment final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CAWallSegment">();
	}
	static class UCAWallSegment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCAWallSegment>();
	}
};
static_assert(alignof(UCAWallSegment) == 0x000008, "Wrong alignment on UCAWallSegment");
static_assert(sizeof(UCAWallSegment) == 0x000038, "Wrong size on UCAWallSegment");

}

